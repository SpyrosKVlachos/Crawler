[
    {
        "id": 1,
        "url": "https://en.wikipedia.org/wiki/Python_(programming_language)",
        "title": "Python (programming language)",
        "content": "General-purpose programming language This article is about the Python programming language. For the animal, see Python (genus). PythonParadigmMulti-paradigm: object-oriented, procedural (imperative), functional, structured, reflectiveDesigned byGuido van RossumDeveloperPython Software FoundationFirst appeared20 February 1991; 33 years ago (1991-02-20)Stable release3.13.1 / 3 December 2024; 40 days ago (3 December 2024) Typing disciplineduck, dynamic, strong; optional type annotations (since 3.5, but those hints are ignored, except with unofficial tools)OS Tier 1: 64-bit Linux, macOS; 64- and 32-bit Windows 10+ Tier 2: E.g. 32-bit WebAssembly (WASI) Tier 3: 64-bit Android, iOS, FreeBSD, and (32-bit) Raspberry Pi OSUnofficial (or has been known to work): Other Unix-like/BSD variants) and a few other platforms LicensePython Software Foundation LicenseFilename extensions.py, .pyw, .pyz, .pyi, .pyc, .pydWebsitepython.orgMajor implementationsCPython, PyPy, Stackless Python, MicroPython, CircuitPython, IronPython, JythonDialectsCython, RPython, StarlarkInfluenced byABC, Ada, ALGOL 68, APL, C, C++, CLU, Dylan, Haskell, Icon, Lisp, Modula-3, Perl, Standard MLInfluencedApache Groovy, Boo, Cobra, CoffeeScript, D, F#, GDScript, Go, JavaScript, Julia, Mojo, Nim, Ring, Ruby, Swift, V Python Programming at Wikibooks Python is a high-level, general-purpose programming language. Its design philosophy emphasizes code readability with the use of significant indentation. Python is dynamically type-checked and garbage-collected. It supports multiple programming paradigms, including structured (particularly procedural), object-oriented and functional programming. It is often described as a \"batteries included\" language due to its comprehensive standard library. Guido van Rossum began working on Python in the late 1980s as a successor to the ABC programming language and first released it in 1991 as Python 0.9.0. Python 2.0 was released in 2000. Python 3.0, released in 2008, was a major revision not completely backward-compatible with earlier versions. Python 2.7.18, released in 2020, was the last release of Python 2. Python consistently ranks as one of the most popular programming languages, and has gained widespread use in the machine learning community. History[edit] Main article: History of Python The designer of Python, Guido van Rossum, at PyCon US 2024 Python was conceived in the late 1980s by Guido van Rossum at Centrum Wiskunde & Informatica (CWI) in the Netherlands as a successor to the ABC programming language, which was inspired by SETL, capable of exception handling and interfacing with the Amoeba operating system. Its implementation began in December 1989. Van Rossum shouldered sole responsibility for the project, as the lead developer, until 12 July 2018, when he announced his \"permanent vacation\" from his responsibilities as Python's \"benevolent dictator for life\" (BDFL), a title the Python community bestowed upon him to reflect his long-term commitment as the project's chief decision-maker (he has since come out of retirement and is self-titled \"BDFL-emeritus\"). In January 2019, active Python core developers elected a five-member Steering Council to lead the project. The name Python is said to come from the British comedy series Monty Python's Flying Circus. Python 2.0 was released on 16 October 2000, with many major new features such as list comprehensions, cycle-detecting garbage collection, reference counting, and Unicode support. Python 2.7's end-of-life was initially set for 2015, then postponed to 2020 out of concern that a large body of existing code could not easily be forward-ported to Python 3. No further security patches or other improvements will be released for it. While Python 2.7 and older versions are officially unsupported, a different unofficial Python implementation, PyPy, continues to support Python 2, i.e. \"2.7.18+\" (plus 3.10), with the plus meaning (at least some) \"backported security updates\". Python 3.0 was released on 3 December 2008, with some new semantics and changed syntax. At least every Python release since (now unsupported) 3.5 has added some syntax to the language, and a few later releases have dropped outdated modules, or changed semantics, at least in a minor way. Since 7 October 2024[update], Python 3.13 is the latest stable release, and it and, for few more months, 3.12 are the only releases with active support including for bug fixes (as opposed to just for security) and Python 3.9, is the oldest supported version of Python (albeit in the 'security support' phase), due to Python 3.8 reaching end-of-life. Starting with 3.13, it and later versions have 2 years of full support (up from one and a half), followed by 3 years of security support (for same total support as before). Security updates were expedited in 2021 (and again twice in 2022, and more fixed in 2023 and in September 2024 for Python 3.12.6 down to 3.8.20), since all Python versions were insecure (including 2.7) because of security issues leading to possible remote code execution and web-cache poisoning. Python 3.10 added the | union type operator and the match and case keywords (for structural pattern matching statements). 3.11 expanded exception handling functionality. Python 3.12 added the new keyword type. Notable changes in 3.11 from 3.10 include increased program execution speed and improved error reporting. Python 3.11 claims to be between 10 and 60% faster than Python 3.10, and Python 3.12 adds another 5% on top of that. It also has improved error messages (again improved in 3.14), and many other changes. Python 3.13 introduces more syntax for types, a new and improved interactive interpreter (REPL), featuring multi-line editing and color support; an incremental garbage collector (producing shorter pauses for collection in programs with a lot of objects, and addition to the improved speed in 3.11 and 3.12), and an experimental just-in-time (JIT) compiler (such features, can/needs to be enabled specifically for the increase in speed), and an experimental free-threaded build mode, which disables the global interpreter lock (GIL), allowing threads to run more concurrently, that latter feature enabled with python3.13t or python3.13t.exe. Python 3.13 introduces some change in behavior, i.e. new \"well-defined semantics\", fixing bugs (plus many removals of deprecated classes, functions and methods, and removed some of the C API and outdated modules): \"The [old] implementation of locals() and frame.f_locals is slow, inconsistent and buggy [and it] has many corner cases and oddities. Code that works around those may need to be changed. Code that uses locals() for simple templating, or print debugging, will continue to work correctly.\" Some (more) standard library modules and many deprecated classes, functions and methods, will be removed in Python 3.15 or 3.16. Python 3.11 adds Sigstore digital verification signatures for all CPython artifacts (in addition to PGP). Since use of PGP has been criticized by security practitioners Python is moving to Sigstore exclusively and dropping PGP from 3.14. Python 3.14 is now in alpha 3; regarding possible change to annotations: \"In Python 3.14, from __future__ import annotations will continue to work as it did before, converting annotations into strings.\" PEP 711 proposes PyBI: a standard format for distributing Python Binaries. Python 3.15 will \"Make UTF-8 mode default\", the mode exists in all current Python versions, but currently needs to be opted into. UTF-8 is already used, by default, on Windows (and elsewhere), for most things, but e.g. to open files it's not and enabling also makes code fully cross-platform, i.e. use UTF-8 for everything on all platforms. Design philosophy and features[edit] Python is a multi-paradigm programming language. Object-oriented programming and structured programming are fully supported, and many of their features support functional programming and aspect-oriented programming (including metaprogramming and metaobjects). Many other paradigms are supported via extensions, including design by contract and logic programming. Python is known as a glue language, able to work very well with many other languages with ease of access. Python uses dynamic typing and a combination of reference counting and a cycle-detecting garbage collector for memory management. It uses dynamic name resolution (late binding), which binds method and variable names during program execution. Its design offers some support for functional programming in the Lisp tradition. It has filter,mapandreduce functions; list comprehensions, dictionaries, sets, and generator expressions. The standard library has two modules (itertools and functools) that implement functional tools borrowed from Haskell and Standard ML. Its core philosophy is summarized in the Zen of Python (PEP 20), which includes aphorisms such as: Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Readability counts. However, Python features regularly violate these principles and have received criticism for adding unnecessary language bloat. Responses to these criticisms are that the Zen of Python is a guideline rather than a rule. The addition of some new features had been so controversial that Guido van Rossum resigned as Benevolent Dictator for Life following vitriol over the addition of the assignment expression operator in Python 3.8. Nevertheless, rather than building all of its functionality into its core, Python was designed to be highly extensible via modules. This compact modularity has made it particularly popular as a means of adding programmable interfaces to existing applications. Van Rossum's vision of a small core language with a large standard library and easily extensible interpreter stemmed from his frustrations with ABC, which espoused the opposite approach. Python claims to strive for a simpler, less-cluttered syntax and grammar while giving developers a choice in their coding methodology. In contrast to Perl's \"there is more than one way to do it\" motto, Python embraces a \"there should be one—and preferably only one—obvious way to do it.\" philosophy. In practice, however, Python provides many ways to achieve the same task. There are, for example, at least three ways to format a string literal, with no certainty as to which one a programmer should use. Alex Martelli, a Fellow at the Python Software Foundation and Python book author, wrote: \"To describe something as 'clever' is not considered a compliment in the Python culture.\" Python's developers usually strive to avoid premature optimization and reject patches to non-critical parts of the CPython reference implementation that would offer marginal increases in speed at the cost of clarity. Execution speed can be improved by moving speed-critical functions to extension modules written in languages such as C, or by using a just-in-time compiler like PyPy. It is also possible to cross-compile to other languages, but it either doesn't provide the full speed-up that might be expected, since Python is a very dynamic language, or a restricted subset of Python is compiled, and possibly semantics are slightly changed. Python's developers aim for it to be fun to use. This is reflected in its name—a tribute to the British comedy group Monty Python—and in occasionally playful approaches to tutorials and reference materials, such as the use of the terms \"spam\" and \"eggs\" (a reference to a Monty Python sketch) in examples, instead of the often-used \"foo\" and \"bar\". A common neologism in the Python community is pythonic, which has a wide range of meanings related to program style. \"Pythonic\" code may use Python idioms well, be natural or show fluency in the language, or conform with Python's minimalist philosophy and emphasis on readability. Code that is difficult to understand or reads like a rough transcription from another programming language is called unpythonic. Syntax and semantics[edit] Main article: Python syntax and semantics An example of Python code and indentation Example of C# code with curly braces and semicolons Python is meant to be an easily readable language. Its formatting is visually uncluttered and often uses English keywords where other languages use punctuation. Unlike many other languages, it does not use curly brackets to delimit blocks, and semicolons after statements are allowed but rarely used. It has fewer syntactic exceptions and special cases than C or Pascal. Indentation[edit] Main article: Python syntax and semantics § Indentation Python uses whitespace indentation, rather than curly brackets or keywords, to delimit blocks. An increase in indentation comes after certain statements; a decrease in indentation signifies the end of the current block. Thus, the program's visual structure accurately represents its semantic structure. This feature is sometimes termed the off-side rule. Some other languages use indentation this way; but in most, indentation has no semantic meaning. The recommended indent size is four spaces. Statements and control flow[edit] Python's statements include: The assignment statement, using a single equals sign = The if statement, which conditionally executes a block of code, along with else and elif (a contraction of else-if) The for statement, which iterates over an iterable object, capturing each element to a local variable for use by the attached block The while statement, which executes a block of code as long as its condition is true The try statement, which allows exceptions raised in its attached code block to be caught and handled by except clauses (or new syntax except* in Python 3.11 for exception groups); it also ensures that clean-up code in a finally block is always run regardless of how the block exits The raise statement, used to raise a specified exception or re-raise a caught exception The class statement, which executes a block of code and attaches its local namespace to a class, for use in object-oriented programming The def statement, which defines a function or method The with statement, which encloses a code block within a context manager (for example, acquiring a lock before it is run, then releasing the lock; or opening and closing a file), allowing resource-acquisition-is-initialization (RAII)-like behavior and replacing a common try/finally idiom The break statement, which exits a loop The continue statement, which skips the rest of the current iteration and continues with the next The del statement, which removes a variable—deleting the reference from the name to the value, and producing an error if the variable is referred to before it is redefined The pass statement, serving as a NOP, syntactically needed to create an empty code block The assert statement, used in debugging to check for conditions that should apply The yield statement, which returns a value from a generator function (and also an operator); used to implement coroutines The return statement, used to return a value from a function The import and from statements, used to import modules whose functions or variables can be used in the current program The match and case statements, an analog of the switch statement construct, that compares an expression against one or more cases as a control-of-flow measure. The assignment statement (=) binds a name as a reference to a separate, dynamically allocated object. Variables may subsequently be rebound at any time to any object. In Python, a variable name is a generic reference holder without a fixed data type; however, it always refers to some object with a type. This is called dynamic typing—in contrast to statically-typed languages, where each variable may contain only a value of a certain type. Python does not support tail call optimization or first-class continuations, and, according to Van Rossum, it never will. However, better support for coroutine-like functionality is provided by extending Python's generators. Before 2.5, generators were lazy iterators; data was passed unidirectionally out of the generator. From Python 2.5 on, it is possible to pass data back into a generator function; and from version 3.3, it can be passed through multiple stack levels. Expressions[edit] Python's expressions include: The +, -, and * operators for mathematical addition, subtraction, and multiplication are similar to other languages, but the behavior of division differs. There are two types of divisions in Python: floor division (or integer division) // and floating-point/division. Python uses the ** operator for exponentiation. Python uses the + operator for string concatenation. Python uses the * operator for duplicating a string a specified number of times. The @ infix operator is intended to be used by libraries such as NumPy for matrix multiplication. The syntax :=, called the \"walrus operator\", was introduced in Python 3.8. It assigns values to variables as part of a larger expression. In Python, == compares by value. Python's is operator may be used to compare object identities (comparison by reference), and comparisons may be chained—for example, a <= b <= c. Python uses and, or, and not as Boolean operators. Python has a type of expression named a list comprehension, and a more general expression named a generator expression. Anonymous functions are implemented using lambda expressions; however, there may be only one expression in each body. Conditional expressions are written as x if c else y (different in order of operands from the c ? x : y operator common to many other languages). Python makes a distinction between lists and tuples. Lists are written as [1, 2, 3], are mutable, and cannot be used as the keys of dictionaries (dictionary keys must be immutable in Python). Tuples, written as (1, 2, 3), are immutable and thus can be used as keys of dictionaries, provided all of the tuple's elements are immutable. The + operator can be used to concatenate two tuples, which does not directly modify their contents, but produces a new tuple containing the elements of both. Thus, given the variable t initially equal to (1, 2, 3), executing t = t + (4, 5) first evaluates t + (4, 5), which yields (1, 2, 3, 4, 5), which is then assigned back to t—thereby effectively \"modifying the contents\" of t while conforming to the immutable nature of tuple objects. Parentheses are optional for tuples in unambiguous contexts. Python features sequence unpacking where multiple expressions, each evaluating to anything that can be assigned (to a variable, writable property, etc.) are associated in an identical manner to that forming tuple literals—and, as a whole, are put on the left-hand side of the equal sign in an assignment statement. The statement expects an iterable object on the right-hand side of the equal sign that produces the same number of values as the provided writable expressions; when iterated through them, it assigns each of the produced values to the corresponding expression on the left. Python has a \"string format\" operator % that functions analogously to printf format strings in C—e.g. \"spam=%s eggs=%d\" % (\"blah\", 2) evaluates to \"spam=blah eggs=2\". In Python 2.6+ and 3+, this was supplemented by the format() method of the str class, e.g. \"spam={0} eggs={1}\".format(\"blah\", 2). Python 3.6 added \"f-strings\": spam = \"blah\"; eggs = 2; f'spam={spam} eggs={eggs}'. Strings in Python can be concatenated by \"adding\" them (with the same operator as for adding integers and floats), e.g. \"spam\" + \"eggs\" returns \"spameggs\". If strings contain numbers, they are added as strings rather than integers, e.g. \"2\" + \"2\" returns \"22\". Python has various string literals: Delimited by single or double quotes; unlike in Unix shells, Perl, and Perl-influenced languages, single and double quotes work the same. Both use the backslash (\\) as an escape character. String interpolation became available in Python 3.6 as \"formatted string literals\". Triple-quoted (beginning and ending with three single or double quotes), which may span multiple lines and function like here documents in shells, Perl, and Ruby. Raw string varieties, denoted by prefixing the string literal with r. Escape sequences are not interpreted; hence raw strings are useful where literal backslashes are common, such as regular expressions and Windows-style paths. (Compare \"@-quoting\" in C#.) Python has array index and array slicing expressions in lists, denoted as a[key], a[start:stop] or a[start:stop:step]. Indexes are zero-based, and negative indexes are relative to the end. Slices take elements from the start index up to, but not including, the stop index. The third slice parameter, called step or stride, allows elements to be skipped and reversed. Slice indexes may be omitted—for example, a[:] returns a copy of the entire list. Each element of a slice is a shallow copy. In Python, a distinction between expressions and statements is rigidly enforced, in contrast to languages such as Common Lisp, Scheme, or Ruby. This leads to duplicating some functionality. For example: List comprehensions vs. for-loops Conditional expressions vs. if blocks The eval() vs. exec() built-in functions (in Python 2, exec is a statement); the former is for expressions, the latter is for statements Statements cannot be a part of an expression—so list and other comprehensions or lambda expressions, all being expressions, cannot contain statements. A particular case is that an assignment statement such as a = 1 cannot form part of the conditional expression of a conditional statement. Methods[edit] Methods on objects are functions attached to the object's class; the syntax instance.method(argument) is, for normal methods and functions, syntactic sugar for Class.method(instance, argument). Python methods have an explicit self parameter to access instance data, in contrast to the implicit self (or this) in some other object-oriented programming languages (e.g., C++, Java, Objective-C, Ruby). Python also provides methods, often called dunder methods (due to their names beginning and ending with double-underscores), to allow user-defined classes to modify how they are handled by native operations including length, comparison, in arithmetic operations and type conversion. Typing[edit] The standard type hierarchy in Python 3 Python uses duck typing and has typed objects but untyped variable names. Type constraints are not checked at compile time; rather, operations on an object may fail, signifying that it is not of a suitable type. Despite being dynamically typed, Python is strongly typed, forbidding operations that are not well-defined (for example, adding a number to a string) rather than silently attempting to make sense of them. Python allows programmers to define their own types using classes, most often used for object-oriented programming. New instances of classes are constructed by calling the class (for example, SpamClass() or EggsClass()), and the classes are instances of the metaclass type (itself an instance of itself), allowing metaprogramming and reflection. Before version 3.0, Python had two kinds of classes (both using the same syntax): old-style and new-style; current Python versions only support the semantics of the new style. Python supports optional type annotations. These annotations are not enforced by the language, but may be used by external tools such as mypy to catch errors. Mypy also supports a Python compiler called mypyc, which leverages type annotations for optimization. Summary of Python 3's built-in types Type Mutability Description Syntax examples bool immutable Boolean value TrueFalse bytearray mutable Sequence of bytes bytearray(b'Some ASCII')bytearray(b\"Some ASCII\")bytearray([119, 105, 107, 105]) bytes immutable Sequence of bytes b'Some ASCII'b\"Some ASCII\"bytes([119, 105, 107, 105]) complex immutable Complex number with real and imaginary parts 3+2.7j3 + 2.7j dict mutable Associative array (or dictionary) of key and value pairs; can contain mixed types (keys and values), keys must be a hashable type {'key1': 1.0, 3: False}{} types.EllipsisType immutable An ellipsis placeholder to be used as an index in NumPy arrays ...Ellipsis float immutable Double-precision floating-point number. The precision is machine-dependent but in practice is generally implemented as a 64-bit IEEE 754 number with 53 bits of precision. 1.33333 frozenset immutable Unordered set, contains no duplicates; can contain mixed types, if hashable frozenset([4.0, 'string', True]) int immutable Integer of unlimited magnitude 42 list mutable List, can contain mixed types [4.0, 'string', True][] types.NoneType immutable An object representing the absence of a value, often called null in other languages None types.NotImplementedType immutable A placeholder that can be returned from overloaded operators to indicate unsupported operand types. NotImplemented range immutable An immutable sequence of numbers commonly used for looping a specific number of times in for loops range(−1, 10)range(10, −5, −2) set mutable Unordered set, contains no duplicates; can contain mixed types, if hashable {4.0, 'string', True}set() str immutable A character string: sequence of Unicode codepoints 'Wikipedia'\"Wikipedia\"\"\"\"Spanning multiple lines\"\"\" Spanning multiple lines tuple immutable Can contain mixed types (4.0, 'string', True)('single element',)() Arithmetic operations[edit] Python has the usual symbols for arithmetic operators (+, -, *, /), the floor division operator // and the modulo operation % (where the remainder can be negative, e.g. 4 % -3 == -2). It also has ** for exponentiation, e.g. 5**3 == 125 and 9**0.5 == 3.0, and a matrix‑multiplication operator @ . These operators work like in traditional math; with the same precedence rules, the operators infix (+ and - can also be unary to represent positive and negative numbers respectively). The division between integers produces floating-point results. The behavior of division has changed significantly over time: Current Python (i.e. since 3.0) changed / to always be floating-point division, e.g. 5/2 == 2.5. The floor division // operator was introduced. So 7//3 == 2, -7//3 == -3, 7.5//3 == 2.0 and -7.5//3 == -3.0. Adding from __future__ import division causes a module used in Python 2.7 to use Python 3.0 rules for division (see above). In Python terms, / is true division (or simply division), and // is floor division. / before version 3.0 is classic division. Rounding towards negative infinity, though different from most languages, adds consistency. For instance, it means that the equation (a + b)//b == a//b + 1 is always true. It also means that the equation b*(a//b) + a%b == a is valid for both positive and negative values of a. However, maintaining the validity of this equation means that while the result of a%b is, as expected, in the half-open interval [0, b), where b is a positive integer, it has to lie in the interval (b, 0] when b is negative. Python provides a round function for rounding a float to the nearest integer. For tie-breaking, Python 3 uses round to even: round(1.5) and round(2.5) both produce 2. Versions before 3 used round-away-from-zero: round(0.5) is 1.0, round(-0.5) is −1.0. Python allows Boolean expressions with multiple equality relations in a manner that is consistent with general use in mathematics. For example, the expression a < b < c tests whether a is less than b and b is less than c. C-derived languages interpret this expression differently: in C, the expression would first evaluate a < b, resulting in 0 or 1, and that result would then be compared with c. Python uses arbitrary-precision arithmetic for all integer operations. The Decimal type/class in the decimal module provides decimal floating-point numbers to a pre-defined arbitrary precision and several rounding modes. The Fraction class in the fractions module provides arbitrary precision for rational numbers. Due to Python's extensive mathematics library, and the third-party library NumPy that further extends the native capabilities, it is frequently used as a scientific scripting language to aid in problems such as numerical data processing and manipulation. Function syntax[edit] Functions are created in Python using the def keyword. In Python, you define the function as if you were calling it, by typing the function name and then the attributes required. Here is an example of a function that will print whatever is given:def printer(input1, input2=\"already there\"): print(input1) print(input2) printer(\"hello\") # Example output: # hello # already there If you want the attribute to have a set value if no value is given, use the variable-defining syntax inside the function definition. Programming examples[edit] \"Hello, World!\" program: print('Hello, world!') Program to calculate the factorial of a positive integer: n = int(input('Type a number, and its factorial will be printed: ')) if n < 0: raise ValueError('You must enter a non-negative integer') factorial = 1 for i in range(2, n + 1): factorial *= i print(factorial) Libraries[edit] Python's large standard library provides tools suited to many tasks and is commonly cited as one of its greatest strengths. For Internet-facing applications, many standard formats and protocols such as MIME and HTTP are supported. It includes modules for creating graphical user interfaces, connecting to relational databases, generating pseudorandom numbers, arithmetic with arbitrary-precision decimals, manipulating regular expressions, and unit testing. Some parts of the standard library are covered by specifications—for example, the Web Server Gateway Interface (WSGI) implementation wsgiref follows PEP 333—but most are specified by their code, internal documentation, and test suites. However, because most of the standard library is cross-platform Python code, only a few modules need altering or rewriting for variant implementations. As of 17 March 2024,[update] the Python Package Index (PyPI), the official repository for third-party Python software, contains over 523,000 packages with a wide range of functionality, including: Automation Data analytics Databases Documentation Graphical user interfaces Image processing Machine learning Mobile apps Multimedia Computer networking Scientific computing System administration Test frameworks Text processing Web frameworks Web scraping Development environments[edit] See also: Comparison of integrated development environments § Python Most Python implementations (including CPython) include a read–eval–print loop (REPL), permitting them to function as a command line interpreter for which users enter statements sequentially and receive results immediately. Python also comes with an Integrated development environment (IDE) called IDLE, which is more beginner-oriented. Other shells, including IDLE and IPython, add further abilities such as improved auto-completion, session state retention, and syntax highlighting. As well as standard desktop integrated development environments including PyCharm, IntelliJ Idea, Visual Studio Code etc, there are web browser-based IDEs, including SageMath, for developing science- and math-related programs; PythonAnywhere, a browser-based IDE and hosting environment; and Canopy IDE, a commercial IDE emphasizing scientific computing. Implementations[edit] See also: List of Python software § Python implementations Reference implementation[edit] CPython is the reference implementation of Python. It is written in C, meeting the C89 standard (Python 3.11 uses C11) with several select C99 features. CPython includes its own C extensions, but third-party extensions are not limited to older C versions—e.g. they can be implemented with C11 or C++. CPython compiles Python programs into an intermediate bytecode which is then executed by its virtual machine. CPython is distributed with a large standard library written in a mixture of C and native Python, and is available for many platforms, including Windows (starting with Python 3.9, the Python installer deliberately fails to install on Windows 7 and 8; Windows XP was supported until Python 3.5) and most modern Unix-like systems, including macOS (and Apple M1 Macs, since Python 3.9.1, with experimental installer), with unofficial support for VMS. Platform portability was one of its earliest priorities. (During Python 1 and 2 development, even OS/2 and Solaris were supported, but support has since been dropped for many platforms.) All current Python versions (i.e. since 3.7) only support operating systems with multi-threading support. Other implementations[edit] All alternative implementations have at least slightly different semantics (e.g. may have unordered dictionaries, unlike all current Python versions), e.g. with the larger Python ecosystem, such as with supporting the C Python API of with PyPy: PyPy is a fast, compliant interpreter of Python 2.7 and 3.10. Its just-in-time compiler often brings a significant speed improvement over CPython, but some libraries written in C cannot be used with it. It has e.g. RISC-V support. Codon is a language with an ahead-of-time (AOT) compiler, that (AOT) compiles a statically-typed Python-like language with \"syntax and semantics are nearly identical to Python's, there are some notable differences\" e.g. it uses 64-bit machine integers, for speed, not arbitrary like Python, and it claims speedups over CPython are usually on the order of 10–100x. It compiles to machine code (via LLVM) and supports native multithreading. Codon can also compile to Python extension modules that can be imported and used from Python. Stackless Python is a significant fork of CPython that implements microthreads; it does not use the call stack in the same way, thus allowing massively concurrent programs. PyPy also has a stackless version. MicroPython and CircuitPython are Python 3 variants optimized for microcontrollers, including Lego Mindstorms EV3. Pyston is a variant of the Python runtime that uses just-in-time compilation to speed up the execution of Python programs. Cinder is a performance-oriented fork of CPython 3.8 that contains a number of optimizations, including bytecode inline caching, eager evaluation of coroutines, a method-at-a-time JIT, and an experimental bytecode compiler. Snek Embedded Computing Language (compatible with e.g. 8-bit AVR microcontrollers such as ATmega 328P-based Arduino, as well as larger ones compatible with MicroPython) \"is Python-inspired, but it is not Python. It is possible to write Snek programs that run under a full Python system, but most Python programs will not run under Snek.\" It is an imperative language not including OOP / classes, unlike Python, and simplifying to one number type with 32-bit single-precision (similar to JavaScript, except smaller). No longer supported implementations[edit] Other just-in-time Python compilers have been developed, but are now unsupported: Google began a project named Unladen Swallow in 2009, with the aim of speeding up the Python interpreter five-fold by using the LLVM, and of improving its multithreading ability to scale to thousands of cores, while ordinary implementations suffer from the global interpreter lock. Psyco is a discontinued just-in-time specializing compiler that integrates with CPython and transforms bytecode to machine code at runtime. The emitted code is specialized for certain data types and is faster than the standard Python code. Psyco does not support Python 2.7 or later. PyS60 was a Python 2 interpreter for Series 60 mobile phones released by Nokia in 2005. It implemented many of the modules from the standard library and some additional modules for integrating with the Symbian operating system. The Nokia N900 also supports Python with GTK widget libraries, enabling programs to be written and run on the target device. Cross-compilers to other languages[edit] There are several compilers/transpilers to high-level object languages, with either unrestricted Python, a restricted subset of Python, or a language similar to Python as the source language: Brython, Transcrypt and Pyjs (latest release in 2012) compile Python to JavaScript. Cython compiles (a superset of) Python to C. The resulting code is also usable with Python via direct C-level API calls into the Python interpreter. PyJL compiles/transpiles a subset of Python to \"human-readable, maintainable, and high-performance Julia source code\". Despite claiming high performance, no tool can claim to do that for arbitrary Python code; i.e. it's known not possible to compile to a faster language or machine code. Unless semantics of Python are changed, but in many cases speedup is possible with few or no changes in the Python code. The faster Julia source code can then be used from Python, or compiled to machine code, and based that way. Nuitka compiles Python into C. It works with Python 3.4 to 3.12 (and 2.6 and 2.7), for Python's main supported platforms (and Windows 7 or even Windows XP) and for Android. It claims complete support for Python 3.10, some support for 3.11 and 3.12 and experimental support for Python 3.13. It supports macOS including Apple Silicon-based. It's a free compiler, though it also has commercial add-ons (e.g. for hiding source code). Numba is used from Python, as a tool (enabled by adding a decorator to relevant Python code), a JIT compiler that translates a subset of Python and NumPy code into fast machine code. Pythran compiles a subset of Python 3 to C++ (C++11). RPython can be compiled to C, and is used to build the PyPy interpreter of Python. The Python → 11l → C++ transpiler compiles a subset of Python 3 to C++ (C++17). Specialized: MyHDL is a Python-based hardware description language (HDL), that converts MyHDL code to Verilog or VHDL code. Older projects (or not to be used with Python 3.x and latest syntax): Google's Grumpy (latest release in 2017) transpiles Python 2 to Go. IronPython allows running Python 2.7 programs (and an alpha, released in 2021, is also available for \"Python 3.4, although features and behaviors from later versions may be included\") on the .NET Common Language Runtime. Jython compiles Python 2.7 to Java bytecode, allowing the use of the Java libraries from a Python program. Pyrex (latest release in 2010) and Shed Skin (latest release in 2013) compile to C and C++ respectively. Performance[edit] Performance comparison of various Python implementations on a non-numerical (combinatorial) workload was presented at EuroSciPy '13. Python's performance compared to other programming languages is also benchmarked by The Computer Language Benchmarks Game. Development[edit] Python's development is conducted largely through the Python Enhancement Proposal (PEP) process, the primary mechanism for proposing major new features, collecting community input on issues, and documenting Python design decisions. Python coding style is covered in PEP 8. Outstanding PEPs are reviewed and commented on by the Python community and the steering council. Enhancement of the language corresponds with the development of the CPython reference implementation. The mailing list python-dev is the primary forum for the language's development. Specific issues were originally discussed in the Roundup bug tracker hosted at by the foundation. In 2022, all issues and discussions were migrated to GitHub. Development originally took place on a self-hosted source-code repository running Mercurial, until Python moved to GitHub in January 2017. CPython's public releases come in three types, distinguished by which part of the version number is incremented: Backward-incompatible versions, where code is expected to break and needs to be manually ported. The first part of the version number is incremented. These releases happen infrequently—version 3.0 was released 8 years after 2.0. According to Guido van Rossum, a version 4.0 is very unlikely to ever happen. Major or \"feature\" releases are largely compatible with the previous version but introduce new features. The second part of the version number is incremented. Starting with Python 3.9, these releases are expected to happen annually. Each major version is supported by bug fixes for several years after its release. Bug fix releases, which introduce no new features, occur about every 3 months and are made when a sufficient number of bugs have been fixed upstream since the last release. Security vulnerabilities are also patched in these releases. The third and final part of the version number is incremented. Many alpha, beta, and release-candidates are also released as previews and for testing before final releases. Although there is a rough schedule for each release, they are often delayed if the code is not ready. Python's development team monitors the state of the code by running the large unit test suite during development. The major academic conference on Python is PyCon. There are also special Python mentoring programs, such as PyLadies. Python 3.12 removed wstr meaning Python extensions need to be modified, and 3.10 added pattern matching to the language. Python 3.12 dropped some outdated modules, and more will be dropped in the future, deprecated as of 3.13; already deprecated array 'u' format code will emit DeprecationWarning since 3.13 and will be removed in Python 3.16. The 'w' format code should be used instead. Part of ctypes is also deprecated and http.server.CGIHTTPRequestHandler will emit a DeprecationWarning, and will be removed in 3.15. Using that code already has a high potential for both security and functionality bugs. Parts of the typing module are deprecated, e.g. creating a typing.NamedTuple class using keyword arguments to denote the fields and such (and more) will be disallowed in Python 3.15. API documentation generators[edit] Tools that can generate documentation for Python API include pydoc (available as part of the standard library), Sphinx, Pdoc and its forks, Doxygen and Graphviz, among others. Naming[edit] Python's name is derived from the British comedy group Monty Python, whom Python creator Guido van Rossum enjoyed while developing the language. Monty Python references appear frequently in Python code and culture; for example, the metasyntactic variables often used in Python literature are spam and eggs instead of the traditional foo and bar. The official Python documentation also contains various references to Monty Python routines. Users of Python are sometimes referred to as \"Pythonistas\". The prefix Py- is used to show that something is related to Python. Examples of the use of this prefix in names of Python applications or libraries include Pygame, a binding of Simple DirectMedia Layer to Python (commonly used to create games); PyQt and PyGTK, which bind Qt and GTK to Python respectively; and PyPy, a Python implementation originally written in Python. Popularity[edit] Since 2003, Python has consistently ranked in the top ten most popular programming languages in the TIOBE Programming Community Index where as of December 2022[update] it was the most popular language (ahead of C, C++, and Java). It was selected as Programming Language of the Year (for \"the highest rise in ratings in a year\") in 2007, 2010, 2018, and 2020 (the only language to have done so four times as of 2020[update]). Large organizations that use Python include Wikipedia, Google, Yahoo!, CERN, NASA, Facebook, Amazon, Instagram, Spotify, and some smaller entities like Industrial Light & Magic and ITA. The social news networking site Reddit was written mostly in Python. Organizations that partially use Python include Discord and Baidu. Uses[edit] Main article: List of Python software Python Powered Python can serve as a scripting language for web applications, e.g. via mod_wsgi for the Apache webserver. With Web Server Gateway Interface, a standard API has evolved to facilitate these applications. Web frameworks like Django, Pylons, Pyramid, TurboGears, web2py, Tornado, Flask, Bottle, and Zope support developers in the design and maintenance of complex applications. Pyjs and IronPython can be used to develop the client-side of Ajax-based applications. SQLAlchemy can be used as a data mapper to a relational database. Twisted is a framework to program communications between computers, and is used (for example) by Dropbox. Libraries such as NumPy, SciPy and Matplotlib allow the effective use of Python in scientific computing, with specialized libraries such as Biopython and Astropy providing domain-specific functionality. SageMath is a computer algebra system with a notebook interface programmable in Python: its library covers many aspects of mathematics, including algebra, combinatorics, numerical mathematics, number theory, and calculus. OpenCV has Python bindings with a rich set of features for computer vision and image processing. Python is commonly used in artificial intelligence projects and machine learning projects with the help of libraries like TensorFlow, Keras, Pytorch, scikit-learn and the Logic language ProbLog. As a scripting language with a modular architecture, simple syntax, and rich text processing tools, Python is often used for natural language processing. The combination of Python and Prolog has proved to be particularly useful for AI applications, with Prolog providing knowledge representation and reasoning capabilities. The Janus system, in particular, exploits the similarities between these two languages, in part because of their use of dynamic typing, and the simple recursive nature of their data structures. Typical applications of this combination include natural language processing, visual query answering, geospatial reasoning, and handling of semantic web data. The Natlog system, implemented in Python, uses Definite Clause Grammars (DCGs) as prompt generators for text-to-text generators like GPT3 and text-to-image generators like DALL-E or Stable Diffusion. Python can also be used for graphical user interface (GUI) by using libraries like Tkinter. Python has been successfully embedded in many software products as a scripting language, including in finite element method software such as Abaqus, 3D parametric modelers like FreeCAD, 3D animation packages such as 3ds Max, Blender, Cinema 4D, Lightwave, Houdini, Maya, modo, MotionBuilder, Softimage, the visual effects compositor Nuke, 2D imaging programs like GIMP, Inkscape, Scribus and Paint Shop Pro, and musical notation programs like scorewriter and capella. GNU Debugger uses Python as a pretty printer to show complex structures such as C++ containers. Esri promotes Python as the best choice for writing scripts in ArcGIS. It has also been used in several video games, and has been adopted as first of the three available programming languages in Google App Engine, the other two being Java and Go. Many operating systems include Python as a standard component. It ships with most Linux distributions, AmigaOS 4 (using Python 2.7), FreeBSD (as a package), NetBSD, and OpenBSD (as a package) and can be used from the command line (terminal). Many Linux distributions use installers written in Python: Ubuntu uses the Ubiquity installer, while Red Hat Linux and Fedora Linux use the Anaconda installer. Gentoo Linux uses Python in its package management system, Portage. Python is used extensively in the information security industry, including in exploit development. Most of the Sugar software for the One Laptop per Child XO, developed at Sugar Labs as of 2008[update], is written in Python. The Raspberry Pi single-board computer project has adopted Python as its main user-programming language. LibreOffice includes Python and intends to replace Java with Python. Its Python Scripting Provider is a core feature since Version 4.0 from 7 February 2013. Languages influenced by Python[edit] Python's design and philosophy have influenced many other programming languages: Boo uses indentation, a similar syntax, and a similar object model. Cobra uses indentation and a similar syntax, and its Acknowledgements document lists Python first among languages that influenced it. CoffeeScript, a programming language that cross-compiles to JavaScript, has Python-inspired syntax. ECMAScript–JavaScript borrowed iterators and generators from Python. GDScript, a scripting language very similar to Python, built-in to the Godot game engine. Go is designed for the \"speed of working in a dynamic language like Python\" and shares the same syntax for slicing arrays. Groovy was motivated by the desire to bring the Python design philosophy to Java. Julia was designed to be \"as usable for general programming as Python\". Mojo is a non-strict superset of Python (e.g. still missing classes, and adding e.g. struct). Nim uses indentation and similar syntax. Ruby's creator, Yukihiro Matsumoto, has said: \"I wanted a scripting language that was more powerful than Perl, and more object-oriented than Python. That's why I decided to design my own language.\" Swift, a programming language developed by Apple, has some Python-inspired syntax. Kotlin blends Python and Java features, minimizing boilerplate code for enhanced developer efficiency. Python's development practices have also been emulated by other languages. For example, the practice of requiring a document describing the rationale for, and issues surrounding, a change to the language (in Python, a PEP) is also used in Tcl, Erlang, and Swift. See also[edit] Computer programming portalFree and open-source software portal Python syntax and semantics pip (package manager) List of programming languages History of programming languages Comparison of programming languages References[edit] ^ \"General Python FAQ – Python 3 documentation\". docs.python.org. Retrieved 7 July 2024. ^ \"Python 0.9.1 part 01/21\". alt.sources archives. Archived from the original on 11 August 2021. Retrieved 11 August 2021. ^ \"Why is Python a dynamic language and also a strongly typed language\". Python Wiki. Archived from the original on 14 March 2021. Retrieved 27 January 2021. ^ a b \"PEP 483 – The Theory of Type Hints\". Python.org. Archived from the original on 14 June 2020. Retrieved 14 June 2018. ^ \"PEP 11 – CPython platform support | peps.python.org\". Python Enhancement Proposals (PEPs). Retrieved 22 April 2024. ^ \"PEP 738 – Adding Android as a supported platform | peps.python.org\". Python Enhancement Proposals (PEPs). Retrieved 19 May 2024. ^ \"Download Python for Other Platforms\". Python.org. Archived from the original on 27 November 2020. Retrieved 18 August 2023. ^ \"test – Regression tests package for Python – Python 3.7.13 documentation\". docs.python.org. Archived from the original on 17 May 2022. Retrieved 17 May 2022. ^ \"platform – Access to underlying platform's identifying data – Python 3.10.4 documentation\". docs.python.org. Archived from the original on 17 May 2022. Retrieved 17 May 2022. ^ Holth, Moore (30 March 2014). \"PEP 0441 – Improving Python ZIP Application Support\". Archived from the original on 26 December 2018. Retrieved 12 November 2015. ^ \"Starlark Language\". Archived from the original on 15 June 2020. Retrieved 25 May 2019. ^ a b \"Why was Python created in the first place?\". General Python FAQ. Python Software Foundation. Archived from the original on 24 October 2012. Retrieved 22 March 2007. I had extensive experience with implementing an interpreted language in the ABC group at CWI, and from working with this group I had learned a lot about language design. This is the origin of many Python features, including the use of indentation for statement grouping and the inclusion of very high-level data types (although the details are all different in Python). ^ \"Ada 83 Reference Manual (raise statement)\". Archived from the original on 22 October 2019. Retrieved 7 January 2020. ^ a b Kuchling, Andrew M. (22 December 2006). \"Interview with Guido van Rossum (July 1998)\". amk.ca. Archived from the original on 1 May 2007. Retrieved 12 March 2012. I'd spent a summer at DEC's Systems Research Center, which introduced me to Modula-2+; the Modula-3 final report was being written there at about the same time. What I learned there later showed up in Python's exception handling, modules, and the fact that methods explicitly contain 'self' in their parameter list. String slicing came from Algol-68 and Icon. ^ a b c \"itertools – Functions creating iterators for efficient looping – Python 3.7.1 documentation\". docs.python.org. Archived from the original on 14 June 2020. Retrieved 22 November 2016. This module implements a number of iterator building blocks inspired by constructs from APL, Haskell, and SML. ^ van Rossum, Guido (1993). \"An Introduction to Python for UNIX/C Programmers\". Proceedings of the NLUUG Najaarsconferentie (Dutch UNIX Users Group). CiteSeerX 10.1.1.38.2023. even though the design of C is far from ideal, its influence on Python is considerable. ^ a b \"Classes\". The Python Tutorial. Python Software Foundation. Archived from the original on 23 October 2012. Retrieved 20 February 2012. It is a mixture of the class mechanisms found in C++ and Modula-3 ^ Lundh, Fredrik. \"Call By Object\". effbot.org. Archived from the original on 23 November 2019. Retrieved 21 November 2017. replace \"CLU\" with \"Python\", \"record\" with \"instance\", and \"procedure\" with \"function or method\", and you get a pretty accurate description of Python's object model. ^ Simionato, Michele. \"The Python 2.3 Method Resolution Order\". Python Software Foundation. Archived from the original on 20 August 2020. Retrieved 29 July 2014. The C3 method itself has nothing to do with Python, since it was invented by people working on Dylan and it is described in a paper intended for lispers ^ Kuchling, A. M. \"Functional Programming HOWTO\". Python v2.7.2 documentation. Python Software Foundation. Archived from the original on 24 October 2012. Retrieved 9 February 2012. List comprehensions and generator expressions [...] are a concise notation for such operations, borrowed from the functional programming language Haskell. ^ Schemenauer, Neil; Peters, Tim; Hetland, Magnus Lie (18 May 2001). \"PEP 255 – Simple Generators\". Python Enhancement Proposals. Python Software Foundation. Archived from the original on 5 June 2020. Retrieved 9 February 2012. ^ \"More Control Flow Tools\". Python 3 documentation. Python Software Foundation. Archived from the original on 4 June 2016. Retrieved 24 July 2015. By popular demand, a few features commonly found in functional programming languages like Lisp have been added to Python. With the lambda keyword, small anonymous functions can be created. ^ \"re – Regular expression operations – Python 3.10.6 documentation\". docs.python.org. Archived from the original on 18 July 2018. Retrieved 6 September 2022. This module provides regular expression matching operations similar to those found in Perl. ^ \"CoffeeScript\". coffeescript.org. Archived from the original on 12 June 2020. Retrieved 3 July 2018. ^ \"Perl and Python influences in JavaScript\". www.2ality.com. 24 February 2013. Archived from the original on 26 December 2018. Retrieved 15 May 2015. ^ Rauschmayer, Axel. \"Chapter 3: The Nature of JavaScript; Influences\". O'Reilly, Speaking JavaScript. Archived from the original on 26 December 2018. Retrieved 15 May 2015. ^ a b \"Why We Created Julia\". Julia website. February 2012. Archived from the original on 2 May 2020. Retrieved 5 June 2014. We want something as usable for general programming as Python [...] ^ a b Krill, Paul (4 May 2023). \"Mojo language marries Python and MLIR for AI development\". InfoWorld. Archived from the original on 5 May 2023. Retrieved 5 May 2023. ^ Ring Team (4 December 2017). \"Ring and other languages\". ring-lang.net. ring-lang. Archived from the original on 25 December 2018. Retrieved 4 December 2017. ^ Bini, Ola (2007). Practical JRuby on Rails Web 2.0 Projects: bringing Ruby on Rails to the Java platform. Berkeley: APress. p. 3. ISBN 978-1-59059-881-8. ^ Lattner, Chris (3 June 2014). \"Chris Lattner's Homepage\". Chris Lattner. Archived from the original on 25 December 2018. Retrieved 3 June 2014. The Swift language is the product of tireless effort from a team of language experts, documentation gurus, compiler optimization ninjas, and an incredibly important internal dogfooding group who provided feedback to help refine and battle-test ideas. Of course, it also greatly benefited from the experiences hard-won by many other languages in the field, drawing ideas from Objective-C, Rust, Haskell, Ruby, Python, C#, CLU, and far too many others to list. ^ \"V documentation (Introduction)\". GitHub. Retrieved 24 December 2024. ^ Kuhlman, Dave. \"A Python Book: Beginning Python, Advanced Python, and Python Exercises\". Section 1.1. Archived from the original (PDF) on 23 June 2012. ^ \"About Python\". Python Software Foundation. Archived from the original on 20 April 2012. Retrieved 24 April 2012., second section \"Fans of Python use the phrase \"batteries included\" to describe the standard library, which covers everything from asynchronous processing to zip files.\" ^ \"PEP 206 – Python Advanced Library\". Python.org. Archived from the original on 5 May 2021. Retrieved 11 October 2021. ^ Rossum, Guido Van (20 January 2009). \"The History of Python: A Brief Timeline of Python\". The History of Python. Archived from the original on 5 June 2020. Retrieved 5 March 2021. ^ Peterson, Benjamin (20 April 2020). \"Python 2.7.18, the last release of Python 2\". Python Insider. Archived from the original on 26 April 2020. Retrieved 27 April 2020. ^ \"Stack Overflow Developer Survey 2022\". Stack Overflow. Archived from the original on 27 June 2022. Retrieved 12 August 2022. ^ \"The State of Developer Ecosystem in 2020 Infographic\". JetBrains: Developer Tools for Professionals and Teams. Archived from the original on 1 March 2021. Retrieved 5 March 2021. ^ a b \"TIOBE Index\". TIOBE. Archived from the original on 25 February 2018. Retrieved 3 January 2023. The TIOBE Programming Community index is an indicator of the popularity of programming languages Updated as required. ^ \"PYPL PopularitY of Programming Language index\". pypl.github.io. Archived from the original on 14 March 2017. Retrieved 26 March 2021. ^ a b Venners, Bill (13 January 2003). \"The Making of Python\". Artima Developer. Artima. Archived from the original on 1 September 2016. Retrieved 22 March 2007. ^ van Rossum, Guido (29 August 2000). \"SETL (was: Lukewarm about range literals)\". Python-Dev (Mailing list). Archived from the original on 14 July 2018. Retrieved 13 March 2011. ^ van Rossum, Guido (20 January 2009). \"A Brief Timeline of Python\". The History of Python. Archived from the original on 5 June 2020. Retrieved 20 January 2009. ^ Fairchild, Carlie (12 July 2018). \"Guido van Rossum Stepping Down from Role as Python's Benevolent Dictator For Life\". Linux Journal. Archived from the original on 13 July 2018. Retrieved 13 July 2018. ^ \"PEP 8100\". Python Software Foundation. Archived from the original on 4 June 2020. Retrieved 4 May 2019. ^ \"PEP 13 – Python Language Governance\". Python.org. Archived from the original on 27 May 2021. Retrieved 25 August 2021. ^ Briggs, Jason R.; Lipovača, Miran (2013). Python for kids: a playful introduction to programming. San Francisco, Calif: No Starch Press. ISBN 978-1-59327-407-8. ^ Kuchling, A. M.; Zadka, Moshe (16 October 2000). \"What's New in Python 2.0\". Python Software Foundation. Archived from the original on 23 October 2012. Retrieved 11 February 2012. ^ \"PEP 373 – Python 2.7 Release Schedule\". python.org. Archived from the original on 19 May 2020. Retrieved 9 January 2017. ^ \"PEP 466 – Network Security Enhancements for Python 2.7.x\". python.org. Archived from the original on 4 June 2020. Retrieved 9 January 2017. ^ \"Sunsetting Python 2\". Python.org. Archived from the original on 12 January 2020. Retrieved 22 September 2019. ^ \"PEP 373 – Python 2.7 Release Schedule\". Python.org. Archived from the original on 13 January 2020. Retrieved 22 September 2019. ^ mattip (25 December 2023). \"PyPy v7.3.14 release\". PyPy. Archived from the original on 5 January 2024. Retrieved 5 January 2024. ^ Langa, Łukasz (17 May 2022). \"Python 3.9.13 is now available\". Python Insider. Archived from the original on 17 May 2022. Retrieved 21 May 2022. ^ \"Status of Python versions\". Python Developer's Guide. Retrieved 7 October 2024. ^ \"Python\". endoflife.date. 8 October 2024. Retrieved 20 November 2024. ^ \"CVE-2021-3177\". Red Hat Customer Portal. Archived from the original on 6 March 2021. Retrieved 26 February 2021. ^ \"CVE-2021-3177\". CVE. Archived from the original on 27 February 2021. Retrieved 26 February 2021. ^ \"CVE-2021-23336\". CVE. Archived from the original on 24 February 2021. Retrieved 26 February 2021. ^ \"Built-in Types\". ^ corbet (24 October 2022). \"Python 3.11 released [LWN.net]\". lwn.net. Retrieved 15 November 2022. ^ \"What's New In Python 3.13\". Python documentation. Retrieved 30 April 2024. ^ \"PEP 667 – Consistent views of namespaces | peps.python.org\". Python Enhancement Proposals (PEPs). Retrieved 7 October 2024. ^ Wouters, Thomas (9 April 2024). \"Python Insider: Python 3.12.3 and 3.13.0a6 released\". Python Insider. Retrieved 29 April 2024. ^ \"PEP 594 – Removing dead batteries from the standard library\". Python Enhancement Proposals. Python Softtware Foundation. 20 May 2019. ^ \"PEP 761 – Deprecating PGP signatures for CPython artifacts | peps.python.org\". Python Enhancement Proposals (PEPs). Retrieved 6 January 2025. ^ \"PEP 749 – Implementing PEP 649 | peps.python.org\". Python Enhancement Proposals (PEPs). Retrieved 20 November 2024. ^ \"PEP 711: PyBI: a standard format for distributing Python Binaries\". Discussions on Python.org. 7 April 2023. Retrieved 20 November 2024. ^ \"PEP 686 – Make UTF-8 mode default | peps.python.org\". Python Enhancement Proposals (PEPs). Retrieved 20 November 2024. ^ The Cain Gang Ltd. \"Python Metaclasses: Who? Why? When?\" (PDF). Archived from the original (PDF) on 30 May 2009. Retrieved 27 June 2009. ^ \"3.3. Special method names\". The Python Language Reference. Python Software Foundation. Archived from the original on 15 December 2018. Retrieved 27 June 2009. ^ \"PyDBC: method preconditions, method postconditions and class invariants for Python\". Archived from the original on 23 November 2019. Retrieved 24 September 2011. ^ \"Contracts for Python\". Archived from the original on 15 June 2020. Retrieved 24 September 2011. ^ \"PyDatalog\". Archived from the original on 13 June 2020. Retrieved 22 July 2012. ^ \"Glue It All Together With Python\". Python.org. Retrieved 30 September 2024. ^ \"Extending and Embedding the Python Interpreter: Reference Counts\". Docs.python.org. Archived from the original on 18 October 2012. Retrieved 5 June 2020. Since Python makes heavy use of malloc() and free(), it needs a strategy to avoid memory leaks as well as the use of freed memory. The chosen method is called reference counting. ^ a b Hettinger, Raymond (30 January 2002). \"PEP 289 – Generator Expressions\". Python Enhancement Proposals. Python Software Foundation. Archived from the original on 14 June 2020. Retrieved 19 February 2012. ^ \"6.5 itertools – Functions creating iterators for efficient looping\". Docs.python.org. Archived from the original on 14 June 2020. Retrieved 22 November 2016. ^ a b Peters, Tim (19 August 2004). \"PEP 20 – The Zen of Python\". Python Enhancement Proposals. Python Software Foundation. Archived from the original on 26 December 2018. Retrieved 24 November 2008. ^ Lutz, Mark (January 2022). \"Python Changes 2014+\". Learning Python. Archived from the original on 15 March 2024. Retrieved 25 February 2024. ^ \"Confusion regarding a rule in The Zen of Python\". Python Help - Discussions on Python.org. 3 May 2022. Archived from the original on 25 February 2024. Retrieved 25 February 2024. ^ Ambi, Chetan (4 July 2021). \"The Most Controversial Python Walrus Operator\". Python Simplified. Archived from the original on 27 August 2023. Retrieved 5 February 2024. ^ Grifski, Jeremy (24 May 2020). \"The Controversy Behind The Walrus Operator in Python\". The Renegade Coder. Archived from the original on 28 December 2023. Retrieved 25 February 2024. ^ Bader, Dan. \"Python String Formatting Best Practices\". Real Python. Archived from the original on 18 February 2024. Retrieved 25 February 2024. ^ Martelli, Alex; Ravenscroft, Anna; Ascher, David (2005). Python Cookbook, 2nd Edition. O'Reilly Media. p. 230. ISBN 978-0-596-00797-3. Archived from the original on 23 February 2020. Retrieved 14 November 2015. ^ \"Python Culture\". ebeab. 21 January 2014. Archived from the original on 30 January 2014. ^ a b \"Transpiling Python to Julia using PyJL\" (PDF). Archived (PDF) from the original on 19 November 2023. Retrieved 20 September 2023. After manually modifying one line of code by specifying the necessary type information, we obtained a speedup of 52.6×, making the translated Julia code 19.5× faster than the original Python code. ^ \"Why is it called Python?\". General Python FAQ. Docs.python.org. Archived from the original on 24 October 2012. Retrieved 3 January 2023. ^ \"15 Ways Python Is a Powerful Force on the Web\". Archived from the original on 11 May 2019. Retrieved 3 July 2018. ^ \"pprint – Data pretty printer – Python 3.11.0 documentation\". docs.python.org. Archived from the original on 22 January 2021. Retrieved 5 November 2022. stuff=['spam', 'eggs', 'lumberjack', 'knights', 'ni'] ^ \"Code Style – The Hitchhiker's Guide to Python\". docs.python-guide.org. Archived from the original on 27 January 2021. Retrieved 20 January 2021. ^ \"Is Python a good language for beginning programmers?\". General Python FAQ. Python Software Foundation. Archived from the original on 24 October 2012. Retrieved 21 March 2007. ^ \"Myths about indentation in Python\". Secnetix.de. Archived from the original on 18 February 2018. Retrieved 19 April 2011. ^ Guttag, John V. (12 August 2016). Introduction to Computation and Programming Using Python: With Application to Understanding Data. MIT Press. ISBN 978-0-262-52962-4. ^ \"PEP 8 – Style Guide for Python Code\". Python.org. Archived from the original on 17 April 2019. Retrieved 26 March 2019. ^ \"8. Errors and Exceptions – Python 3.12.0a0 documentation\". docs.python.org. Archived from the original on 9 May 2022. Retrieved 9 May 2022. ^ \"Highlights: Python 2.5\". Python.org. Archived from the original on 4 August 2019. Retrieved 20 March 2018. ^ van Rossum, Guido (22 April 2009). \"Tail Recursion Elimination\". Neopythonic.blogspot.be. Archived from the original on 19 May 2018. Retrieved 3 December 2012. ^ van Rossum, Guido (9 February 2006). \"Language Design Is Not Just Solving Puzzles\". Artima forums. Artima. Archived from the original on 17 January 2020. Retrieved 21 March 2007. ^ van Rossum, Guido; Eby, Phillip J. (10 May 2005). \"PEP 342 – Coroutines via Enhanced Generators\". Python Enhancement Proposals. Python Software Foundation. Archived from the original on 29 May 2020. Retrieved 19 February 2012. ^ \"PEP 380\". Python.org. Archived from the original on 4 June 2020. Retrieved 3 December 2012. ^ \"division\". python.org. Archived from the original on 20 July 2006. Retrieved 30 July 2014. ^ \"PEP 0465 – A dedicated infix operator for matrix multiplication\". python.org. Archived from the original on 4 June 2020. Retrieved 1 January 2016. ^ \"Python 3.5.1 Release and Changelog\". python.org. Archived from the original on 14 May 2020. Retrieved 1 January 2016. ^ \"What's New in Python 3.8\". Archived from the original on 8 June 2020. Retrieved 14 October 2019. ^ van Rossum, Guido; Hettinger, Raymond (7 February 2003). \"PEP 308 – Conditional Expressions\". Python Enhancement Proposals. Python Software Foundation. Archived from the original on 13 March 2016. Retrieved 13 July 2011. ^ \"4. Built-in Types – Python 3.6.3rc1 documentation\". python.org. Archived from the original on 14 June 2020. Retrieved 1 October 2017. ^ \"5.3. Tuples and Sequences – Python 3.7.1rc2 documentation\". python.org. Archived from the original on 10 June 2020. Retrieved 17 October 2018. ^ a b \"PEP 498 – Literal String Interpolation\". python.org. Archived from the original on 15 June 2020. Retrieved 8 March 2017. ^ \"Why must 'self' be used explicitly in method definitions and calls?\". Design and History FAQ. Python Software Foundation. Archived from the original on 24 October 2012. Retrieved 19 February 2012. ^ Sweigart, Al (2020). Beyond the Basic Stuff with Python: Best Practices for Writing Clean Code. No Starch Press. p. 322. ISBN 978-1-59327-966-0. Archived from the original on 13 August 2021. Retrieved 7 July 2021. ^ \"The Python Language Reference, section 3.3. New-style and classic classes, for release 2.7.1\". Archived from the original on 26 October 2012. Retrieved 12 January 2011. ^ \"PEP 484 – Type Hints | peps.python.org\". peps.python.org. Archived from the original on 27 November 2023. Retrieved 29 November 2023. ^ \"typing — Support for type hints\". Python documentation. Python Software Foundation. Archived from the original on 21 February 2020. Retrieved 22 December 2023. ^ \"mypy – Optional Static Typing for Python\". Archived from the original on 6 June 2020. Retrieved 28 January 2017. ^ \"Introduction\". mypyc.readthedocs.io. Archived from the original on 22 December 2023. Retrieved 22 December 2023. ^ \"15. Floating Point Arithmetic: Issues and Limitations – Python 3.8.3 documentation\". docs.python.org. Archived from the original on 6 June 2020. Retrieved 6 June 2020. Almost all machines today (November 2000) use IEEE-754 floating point arithmetic, and almost all platforms map Python floats to IEEE-754 \"double precision\". ^ Zadka, Moshe; van Rossum, Guido (11 March 2001). \"PEP 237 – Unifying Long Integers and Integers\". Python Enhancement Proposals. Python Software Foundation. Archived from the original on 28 May 2020. Retrieved 24 September 2011. ^ \"Built-in Types\". Archived from the original on 14 June 2020. Retrieved 3 October 2019. ^ \"PEP 465 – A dedicated infix operator for matrix multiplication\". python.org. Archived from the original on 29 May 2020. Retrieved 3 July 2018. ^ a b Zadka, Moshe; van Rossum, Guido (11 March 2001). \"PEP 238 – Changing the Division Operator\". Python Enhancement Proposals. Python Software Foundation. Archived from the original on 28 May 2020. Retrieved 23 October 2013. ^ \"Why Python's Integer Division Floors\". 24 August 2010. Archived from the original on 5 June 2020. Retrieved 25 August 2010. ^ \"round\", The Python standard library, release 3.2, §2: Built-in functions, archived from the original on 25 October 2012, retrieved 14 August 2011 ^ \"round\", The Python standard library, release 2.7, §2: Built-in functions, archived from the original on 27 October 2012, retrieved 14 August 2011 ^ Beazley, David M. (2009). Python Essential Reference (4th ed.). Addison-Wesley Professional. p. 66. ISBN 9780672329784. ^ Kernighan, Brian W.; Ritchie, Dennis M. (1988). The C Programming Language (2nd ed.). p. 206. ^ a b Batista, Facundo (17 October 2003). \"PEP 327 – Decimal Data Type\". Python Enhancement Proposals. Python Software Foundation. Archived from the original on 4 June 2020. Retrieved 24 November 2008. ^ \"What's New in Python 2.6\". Python v2.6.9 documentation. 29 October 2013. Archived from the original on 23 December 2019. Retrieved 26 September 2015. ^ \"10 Reasons Python Rocks for Research (And a Few Reasons it Doesn't) – Hoyt Koepke\". University of Washington Department of Statistics. Archived from the original on 31 May 2020. Retrieved 3 February 2019. ^ Shell, Scott (17 June 2014). \"An introduction to Python for scientific computing\" (PDF). Archived (PDF) from the original on 4 February 2019. Retrieved 3 February 2019. ^ Piotrowski, Przemyslaw (July 2006). \"Build a Rapid Web Development Environment for Python Server Pages and Oracle\". Oracle Technology Network. Oracle. Archived from the original on 2 April 2019. Retrieved 12 March 2012. ^ Eby, Phillip J. (7 December 2003). \"PEP 333 – Python Web Server Gateway Interface v1.0\". Python Enhancement Proposals. Python Software Foundation. Archived from the original on 14 June 2020. Retrieved 19 February 2012. ^ \"PyPI\". PyPI. 17 March 2024. Archived from the original on 17 March 2024. ^ Enthought, Canopy. \"Canopy\". www.enthought.com. Archived from the original on 15 July 2017. Retrieved 20 August 2016. ^ \"PEP 7 – Style Guide for C Code | peps.python.org\". peps.python.org. Archived from the original on 24 April 2022. Retrieved 28 April 2022. ^ \"4. Building C and C++ Extensions – Python 3.9.2 documentation\". docs.python.org. Archived from the original on 3 March 2021. Retrieved 1 March 2021. ^ van Rossum, Guido (5 June 2001). \"PEP 7 – Style Guide for C Code\". Python Enhancement Proposals. Python Software Foundation. Archived from the original on 1 June 2020. Retrieved 24 November 2008. ^ \"CPython byte code\". Docs.python.org. Archived from the original on 5 June 2020. Retrieved 16 February 2016. ^ \"Python 2.5 internals\" (PDF). Archived (PDF) from the original on 6 August 2012. Retrieved 19 April 2011. ^ \"Changelog – Python 3.9.0 documentation\". docs.python.org. Archived from the original on 7 February 2021. Retrieved 8 February 2021. ^ \"Download Python\". Python.org. Archived from the original on 8 December 2020. Retrieved 13 December 2020. ^ \"history [vmspython]\". www.vmspython.org. Archived from the original on 2 December 2020. Retrieved 4 December 2020. ^ \"An Interview with Guido van Rossum\". Oreilly.com. Archived from the original on 16 July 2014. Retrieved 24 November 2008. ^ \"Download Python for Other Platforms\". Python.org. Archived from the original on 27 November 2020. Retrieved 4 December 2020. ^ \"PyPy compatibility\". Pypy.org. Archived from the original on 6 June 2020. Retrieved 3 December 2012. ^ Team, The PyPy (28 December 2019). \"Download and Install\". PyPy. Archived from the original on 8 January 2022. Retrieved 8 January 2022. ^ \"speed comparison between CPython and Pypy\". Speed.pypy.org. Archived from the original on 10 May 2021. Retrieved 3 December 2012. ^ \"Codon: Differences with Python\". Archived from the original on 25 May 2023. Retrieved 28 August 2023. ^ Lawson, Loraine (14 March 2023). \"MIT-Created Compiler Speeds up Python Code\". The New Stack. Archived from the original on 6 April 2023. Retrieved 28 August 2023. ^ \"Application-level Stackless features – PyPy 2.0.2 documentation\". Doc.pypy.org. Archived from the original on 4 June 2020. Retrieved 17 July 2013. ^ \"Python-for-EV3\". LEGO Education. Archived from the original on 7 June 2020. Retrieved 17 April 2019. ^ Yegulalp, Serdar (29 October 2020). \"Pyston returns from the dead to speed Python\". InfoWorld. Archived from the original on 27 January 2021. Retrieved 26 January 2021. ^ \"cinder: Instagram's performance-oriented fork of CPython\". GitHub. Archived from the original on 4 May 2021. Retrieved 4 May 2021. ^ Aroca, Rafael (7 August 2021). \"Snek Lang: feels like Python on Arduinos\". Yet Another Technology Blog. Archived from the original on 5 January 2024. Retrieved 4 January 2024. ^ Aufranc (CNXSoft), Jean-Luc (16 January 2020). \"Snekboard Controls LEGO Power Functions with CircuitPython or Snek Programming Languages (Crowdfunding) – CNX Software\". CNX Software – Embedded Systems News. Archived from the original on 5 January 2024. Retrieved 4 January 2024. ^ Kennedy (@mkennedy), Michael. \"Ready to find out if you're git famous?\". pythonbytes.fm. Archived from the original on 5 January 2024. Retrieved 4 January 2024. ^ Packard, Keith (20 December 2022). \"The Snek Programming Language: A Python-inspired Embedded Computing Language\" (PDF). Archived (PDF) from the original on 4 January 2024. Retrieved 4 January 2024. ^ \"Plans for optimizing Python\". Google Project Hosting. 15 December 2009. Archived from the original on 11 April 2016. Retrieved 24 September 2011. ^ \"Python on the Nokia N900\". Stochastic Geometry. 29 April 2010. Archived from the original on 20 June 2019. Retrieved 9 July 2015. ^ \"Brython\". brython.info. Archived from the original on 3 August 2018. Retrieved 21 January 2021. ^ \"Transcrypt – Python in the browser\". transcrypt.org. Archived from the original on 19 August 2018. Retrieved 22 December 2020. ^ \"Transcrypt: Anatomy of a Python to JavaScript Compiler\". InfoQ. Archived from the original on 5 December 2020. Retrieved 20 January 2021. ^ \"Nuitka Home | Nuitka Home\". nuitka.net. Archived from the original on 30 May 2020. Retrieved 18 August 2017. ^ Guelton, Serge; Brunet, Pierrick; Amini, Mehdi; Merlini, Adrien; Corbillon, Xavier; Raynaud, Alan (16 March 2015). \"Pythran: enabling static optimization of scientific Python programs\". Computational Science & Discovery. 8 (1). IOP Publishing: 014001. Bibcode:2015CS&D....8a4001G. doi:10.1088/1749-4680/8/1/014001. ISSN 1749-4699. ^ \"The Python → 11l → C++ transpiler\". Archived from the original on 24 September 2022. Retrieved 17 July 2022. ^ \"google/grumpy\". 10 April 2020. Archived from the original on 15 April 2020. Retrieved 25 March 2020 – via GitHub. ^ \"Projects\". opensource.google. Archived from the original on 24 April 2020. Retrieved 25 March 2020. ^ Francisco, Thomas Claburn in San. \"Google's Grumpy code makes Python Go\". www.theregister.com. Archived from the original on 7 March 2021. Retrieved 20 January 2021. ^ \"GitHub – IronLanguages/ironpython3: Implementation of Python 3.x for .NET Framework that is built on top of the Dynamic Language Runtime\". GitHub. Archived from the original on 28 September 2021. ^ \"IronPython.net /\". ironpython.net. Archived from the original on 17 April 2021. ^ \"Jython FAQ\". www.jython.org. Archived from the original on 22 April 2021. Retrieved 22 April 2021. ^ Murri, Riccardo (2013). Performance of Python runtimes on a non-numeric scientific code. European Conference on Python in Science (EuroSciPy). arXiv:1404.6388. Bibcode:2014arXiv1404.6388M. ^ \"The Computer Language Benchmarks Game\". Archived from the original on 14 June 2020. Retrieved 30 April 2020. ^ a b Warsaw, Barry; Hylton, Jeremy; Goodger, David (13 June 2000). \"PEP 1 – PEP Purpose and Guidelines\". Python Enhancement Proposals. Python Software Foundation. Archived from the original on 6 June 2020. Retrieved 19 April 2011. ^ \"PEP 8 – Style Guide for Python Code\". Python.org. Archived from the original on 17 April 2019. Retrieved 26 March 2019. ^ Cannon, Brett. \"Guido, Some Guys, and a Mailing List: How Python is Developed\". python.org. Python Software Foundation. Archived from the original on 1 June 2009. Retrieved 27 June 2009. ^ \"Moving Python's bugs to GitHub [LWN.net]\". Archived from the original on 2 October 2022. Retrieved 2 October 2022. ^ \"Python Developer's Guide – Python Developer's Guide\". devguide.python.org. Archived from the original on 9 November 2020. Retrieved 17 December 2019. ^ Hughes, Owen (24 May 2021). \"Programming languages: Why Python 4.0 might never arrive, according to its creator\". TechRepublic. Archived from the original on 14 July 2022. Retrieved 16 May 2022. ^ \"PEP 602 – Annual Release Cycle for Python\". Python.org. Archived from the original on 14 June 2020. Retrieved 6 November 2019. ^ \"Changing the Python release cadence [LWN.net]\". lwn.net. Archived from the original on 6 November 2019. Retrieved 6 November 2019. ^ Norwitz, Neal (8 April 2002). \"[Python-Dev] Release Schedules (was Stability & change)\". Archived from the original on 15 December 2018. Retrieved 27 June 2009. ^ a b Aahz; Baxter, Anthony (15 March 2001). \"PEP 6 – Bug Fix Releases\". Python Enhancement Proposals. Python Software Foundation. Archived from the original on 5 June 2020. Retrieved 27 June 2009. ^ \"Python Buildbot\". Python Developer's Guide. Python Software Foundation. Archived from the original on 5 June 2020. Retrieved 24 September 2011. ^ \"1. Extending Python with C or C++ – Python 3.9.1 documentation\". docs.python.org. Archived from the original on 23 June 2020. Retrieved 14 February 2021. ^ \"PEP 623 – Remove wstr from Unicode\". Python.org. Archived from the original on 5 March 2021. Retrieved 14 February 2021. ^ \"PEP 634 – Structural Pattern Matching: Specification\". Python.org. Archived from the original on 6 May 2021. Retrieved 14 February 2021. ^ \"Documentation Tools\". Python.org. Archived from the original on 11 November 2020. Retrieved 22 March 2021. ^ a b \"Whetting Your Appetite\". The Python Tutorial. Python Software Foundation. Archived from the original on 26 October 2012. Retrieved 20 February 2012. ^ \"In Python, should I use else after a return in an if block?\". Stack Overflow. Stack Exchange. 17 February 2011. Archived from the original on 20 June 2019. Retrieved 6 May 2011. ^ Lutz, Mark (2009). Learning Python: Powerful Object-Oriented Programming. O'Reilly Media, Inc. p. 17. ISBN 9781449379322. Archived from the original on 17 July 2017. Retrieved 9 May 2017. ^ Fehily, Chris (2002). Python. Peachpit Press. p. xv. ISBN 9780201748840. Archived from the original on 17 July 2017. Retrieved 9 May 2017. ^ Lubanovic, Bill (2014). Introducing Python. Sebastopol, CA : O'Reilly Media. p. 305. ISBN 978-1-4493-5936-2. Retrieved 31 July 2023. ^ Blake, Troy (18 January 2021). \"TIOBE Index for January 2021\". Technology News and Information by SeniorDBA. Archived from the original on 21 March 2021. Retrieved 26 February 2021. ^ \"Quotes about Python\". Python Software Foundation. Archived from the original on 3 June 2020. Retrieved 8 January 2012. ^ \"Organizations Using Python\". Python Software Foundation. Archived from the original on 21 August 2018. Retrieved 15 January 2009. ^ \"Python : the holy grail of programming\". CERN Bulletin (31/2006). CERN Publications. 31 July 2006. Archived from the original on 15 January 2013. Retrieved 11 February 2012. ^ Shafer, Daniel G. (17 January 2003). \"Python Streamlines Space Shuttle Mission Design\". Python Software Foundation. Archived from the original on 5 June 2020. Retrieved 24 November 2008. ^ \"Tornado: Facebook's Real-Time Web Framework for Python – Facebook for Developers\". Facebook for Developers. Archived from the original on 19 February 2019. Retrieved 19 June 2018. ^ \"What Powers Instagram: Hundreds of Instances, Dozens of Technologies\". Instagram Engineering. 11 December 2016. Archived from the original on 15 June 2020. Retrieved 27 May 2019. ^ \"How we use Python at Spotify\". Spotify Labs. 20 March 2013. Archived from the original on 10 June 2020. Retrieved 25 July 2018. ^ Fortenberry, Tim (17 January 2003). \"Industrial Light & Magic Runs on Python\". Python Software Foundation. Archived from the original on 6 June 2020. Retrieved 11 February 2012. ^ Taft, Darryl K. (5 March 2007). \"Python Slithers into Systems\". eWeek.com. Ziff Davis Holdings. Archived from the original on 13 August 2021. Retrieved 24 September 2011. ^ GitHub – reddit-archive/reddit: historical code from reddit.com., The Reddit Archives, archived from the original on 1 June 2020, retrieved 20 March 2019 ^ \"Real time communication at scale with Elixir at Discord\". 8 October 2020. ^ \"What Programming Language is Baidu Built In?\". 5 July 2018. ^ \"Usage statistics and market share of Python for websites\". 2012. Archived from the original on 13 August 2021. Retrieved 18 December 2012. ^ Oliphant, Travis (2007). \"Python for Scientific Computing\". Computing in Science and Engineering. 9 (3): 10–20. Bibcode:2007CSE.....9c..10O. CiteSeerX 10.1.1.474.6460. doi:10.1109/MCSE.2007.58. ISSN 1521-9615. S2CID 206457124. Archived from the original on 15 June 2020. Retrieved 10 April 2015. ^ Millman, K. Jarrod; Aivazis, Michael (2011). \"Python for Scientists and Engineers\". Computing in Science and Engineering. 13 (2): 9–12. Bibcode:2011CSE....13b...9M. doi:10.1109/MCSE.2011.36. Archived from the original on 19 February 2019. Retrieved 7 July 2014. ^ Science education with SageMath, Innovative Computing in Science Education, archived from the original on 15 June 2020, retrieved 22 April 2019 ^ \"OpenCV: OpenCV-Python Tutorials\". docs.opencv.org. Archived from the original on 23 September 2020. Retrieved 14 September 2020. ^ Dean, Jeff; Monga, Rajat; et al. (9 November 2015). \"TensorFlow: Large-scale machine learning on heterogeneous systems\" (PDF). TensorFlow.org. Google Research. Archived (PDF) from the original on 20 November 2015. Retrieved 10 November 2015. ^ Piatetsky, Gregory. \"Python eats away at R: Top Software for Analytics, Data Science, Machine Learning in 2018: Trends and Analysis\". KDnuggets. Archived from the original on 15 November 2019. Retrieved 30 May 2018. ^ \"Who is using scikit-learn? – scikit-learn 0.20.1 documentation\". scikit-learn.org. Archived from the original on 6 May 2020. Retrieved 30 November 2018. ^ Jouppi, Norm. \"Google supercharges machine learning tasks with TPU custom chip\". Google Cloud Platform Blog. Archived from the original on 18 May 2016. Retrieved 19 May 2016. ^ De Raedt, Luc; Kimmig, Angelika (2015). \"Probabilistic (logic) programming concepts\". Machine Learning. 100 (1): 5–47. doi:10.1007/s10994-015-5494-z. S2CID 3166992. ^ \"Natural Language Toolkit – NLTK 3.5b1 documentation\". www.nltk.org. Archived from the original on 13 June 2020. Retrieved 10 April 2020. ^ Andersen, C. and Swift, T., 2023. The Janus System: a bridge to new prolog applications. In Prolog: The Next 50 Years (pp. 93–104). Cham: Springer Nature Switzerland. ^ \"SWI-Prolog Python interface\". Archived from the original on 15 March 2024. Retrieved 15 March 2024. ^ Tarau, P., 2023. Reflections on automation, learnability and expressiveness in logic-based programming languages. In Prolog: The Next 50 Years (pp. 359–371). Cham: Springer Nature Switzerland. ^ \"Tkinter — Python interface to TCL/Tk\". Archived from the original on 18 October 2012. Retrieved 9 June 2023. ^ \"Python Tkinter Tutorial\". 3 June 2020. Archived from the original on 9 June 2023. Retrieved 9 June 2023. ^ \"Installers for GIMP for Windows – Frequently Asked Questions\". 26 July 2013. Archived from the original on 17 July 2013. Retrieved 26 July 2013. ^ \"jasc psp9components\". Archived from the original on 19 March 2008. ^ \"About getting started with writing geoprocessing scripts\". ArcGIS Desktop Help 9.2. Environmental Systems Research Institute. 17 November 2006. Archived from the original on 5 June 2020. Retrieved 11 February 2012. ^ CCP porkbelly (24 August 2010). \"Stackless Python 2.7\". EVE Community Dev Blogs. CCP Games. Archived from the original on 11 January 2014. Retrieved 11 January 2014. As you may know, EVE has at its core the programming language known as Stackless Python. ^ Caudill, Barry (20 September 2005). \"Modding Sid Meier's Civilization IV\". Sid Meier's Civilization IV Developer Blog. Firaxis Games. Archived from the original on 2 December 2010. we created three levels of tools ... The next level offers Python and XML support, letting modders with more experience manipulate the game world and everything in it. ^ \"Python Language Guide (v1.0)\". Google Documents List Data API v1.0. Archived from the original on 15 July 2010. ^ \"Python Setup and Usage\". Python Software Foundation. Archived from the original on 17 June 2020. Retrieved 10 January 2020. ^ \"Immunity: Knowing You're Secure\". Archived from the original on 16 February 2009. ^ \"Core Security\". Core Security. Archived from the original on 9 June 2020. Retrieved 10 April 2020. ^ \"What is Sugar?\". Sugar Labs. Archived from the original on 9 January 2009. Retrieved 11 February 2012. ^ \"4.0 New Features and Fixes\". LibreOffice.org. The Document Foundation. 2013. Archived from the original on 9 February 2014. Retrieved 25 February 2013. ^ \"Gotchas for Python Users\". boo.codehaus.org. Codehaus Foundation. Archived from the original on 11 December 2008. Retrieved 24 November 2008. ^ Esterbrook, Charles. \"Acknowledgements\". cobra-language.com. Cobra Language. Archived from the original on 8 February 2008. Retrieved 7 April 2010. ^ \"Proposals: iterators and generators [ES4 Wiki]\". wiki.ecmascript.org. Archived from the original on 20 October 2007. Retrieved 24 November 2008. ^ \"Frequently asked questions\". Godot Engine documentation. Archived from the original on 28 April 2021. Retrieved 10 May 2021. ^ Kincaid, Jason (10 November 2009). \"Google's Go: A New Programming Language That's Python Meets C++\". TechCrunch. Archived from the original on 18 January 2010. Retrieved 29 January 2010. ^ Strachan, James (29 August 2003). \"Groovy – the birth of a new dynamic language for the Java platform\". Archived from the original on 5 April 2007. Retrieved 11 June 2007. ^ \"Modular Docs – Why Mojo\". docs.modular.com. Archived from the original on 5 May 2023. Retrieved 5 May 2023. Mojo as a member of the Python family [..] Embracing Python massively simplifies our design efforts, because most of the syntax is already specified. [..] we decided that the right long-term goal for Mojo is to provide a superset of Python (i.e. be compatible with existing programs) and to embrace the CPython immediately for long-tail ecosystem enablement. To a Python programmer, we expect and hope that Mojo will be immediately familiar, while also providing new tools for developing systems-level code that enable you to do things that Python falls back to C and C++ for. ^ Spencer, Michael (4 May 2023). \"What is Mojo Programming Language?\". datasciencelearningcenter.substack.com. Archived from the original on 5 May 2023. Retrieved 5 May 2023. ^ Yegulalp, Serdar (16 January 2017). \"Nim language draws from best of Python, Rust, Go, and Lisp\". InfoWorld. Archived from the original on 13 October 2018. Retrieved 7 June 2020. Nim's syntax is strongly reminiscent of Python's, as it uses indented code blocks and some of the same syntax (such as the way if/elif/then/else blocks are constructed). ^ \"An Interview with the Creator of Ruby\". Linuxdevcenter.com. Archived from the original on 28 April 2018. Retrieved 3 December 2012. ^ Lattner, Chris (3 June 2014). \"Chris Lattner's Homepage\". Chris Lattner. Archived from the original on 22 December 2015. Retrieved 3 June 2014. I started work on the Swift Programming Language in July of 2010. I implemented much of the basic language structure, with only a few people knowing of its existence. A few other (amazing) people started contributing in earnest late in 2011, and it became a major focus for the Apple Developer Tools group in July 2013 [...] drawing ideas from Objective-C, Rust, Haskell, Ruby, Python, C#, CLU, and far too many others to list. ^ Jalan, Nishant Aanjaney (10 November 2022). \"Programming in Kotlin\". CodeX. Retrieved 29 April 2024. ^ Kupries, Andreas; Fellows, Donal K. (14 September 2000). \"TIP #3: TIP Format\". tcl.tk. Tcl Developer Xchange. Archived from the original on 13 July 2017. Retrieved 24 November 2008. ^ Gustafsson, Per; Niskanen, Raimo (29 January 2007). \"EEP 1: EEP Purpose and Guidelines\". erlang.org. Archived from the original on 15 June 2020. Retrieved 19 April 2011. ^ \"Swift Evolution Process\". Swift Programming Language Evolution repository on GitHub. 18 February 2020. Archived from the original on 27 April 2020. Retrieved 27 April 2020. Sources[edit] \"Python for Artificial Intelligence\". Python Wiki. 19 July 2012. Archived from the original on 1 November 2012. Retrieved 3 December 2012. Paine, Jocelyn, ed. (August 2005). \"AI in Python\". AI Expert Newsletter. Amzi!. Archived from the original on 26 March 2012. Retrieved 11 February 2012. \"PyAIML 0.8.5 : Python Package Index\". Pypi.python.org. Retrieved 17 July 2013. Russell, Stuart J. & Norvig, Peter (2009). Artificial Intelligence: A Modern Approach (3rd ed.). Upper Saddle River, NJ: Prentice Hall. ISBN 978-0-13-604259-4. Further reading[edit] Downey, Allen (July 2024). Think Python: How to Think Like a Computer Scientist (3rd ed.). O'Reilly Media. ISBN 978-1098155438. Lutz, Mark (2013). Learning Python (5th ed.). O'Reilly Media. ISBN 978-0-596-15806-4. Summerfield, Mark (2009). Programming in Python 3 (2nd ed.). Addison-Wesley Professional. ISBN 978-0-321-68056-3. Ramalho, Luciano (May 2022). Fluent Python. O'Reilly Media. ISBN 978-1-4920-5632-4. External links[edit] Python at Wikipedia's sister projects Media from CommonsQuotations from WikiquoteTextbooks from WikibooksResources from WikiversityData from Wikidata Official website The Python Tutorial vtePythonImplementations CircuitPython CLPython CPython Cython MicroPython Numba IronPython Jython Psyco PyPy Python for S60 Shed Skin Stackless Python Unladen Swallow more... IDEs eric IDLE Ninja-IDE PyCharm PyDev Spyder more... Topics WSGI ASGI Designer Guido van Rossum Software (list) Python Software Foundation Python Conference (PyCon) vteProgramming languages Comparison Timeline History Ada ALGOL Simula APL Assembly BASIC Visual Basic classic .NET C C++ C# COBOL Erlang Forth Fortran Go Haskell Java JavaScript Julia Kotlin Lisp Lua MATLAB ML Pascal Object Pascal Perl PHP Prolog Python R Ruby Rust SQL Scratch Shell Smalltalk Swift more... Lists: Alphabetical Categorical Generational Non-English-based Category vtePython web frameworks Bottle CherryPy CubicWeb Django FastAPI Flask Grok Nevow Pylons Pyramid Quixote Tornado TurboGears TwistedWeb web2py Zope 2 more... Comparison vteDifferentiable computingGeneral Differentiable programming Information geometry Statistical manifold Automatic differentiation Neuromorphic computing Pattern recognition Ricci calculus Computational learning theory Inductive bias Hardware IPU TPU VPU Memristor SpiNNaker Software libraries TensorFlow PyTorch Keras scikit-learn Theano JAX Flux.jl MindSpore Portals Computer programming Technology vteFree and open-source softwareGeneral Alternative terms for free software Comparison of open-source and closed-source software Comparison of source-code-hosting facilities Free software Free software project directories Gratis versus libre Long-term support Open-source software Open-source software development Outline Timeline Softwarepackages Audio Bioinformatics Codecs Configuration management Drivers Graphics Wireless Health Mathematics Office suites Operating systems Routing Television Video games Web applications E-commerce Android apps iOS apps Commercial Formerly proprietary Formerly open-source Community Free software movement History Open-source-software movement Events Advocacy Organisations Free Software Movement of India Free Software Foundation Licenses AFL Apache APSL Artistic Beerware BSD Creative Commons CDDL EPL Free Software Foundation GNU GPL GNU AGPL GNU LGPL ISC MIT MPL Python Python Software Foundation License Shared Source Initiative Sleepycat Unlicense WTFPL zlib Types and standards Comparison of licenses Contributor License Agreement Copyleft Debian Free Software Guidelines Definition of Free Cultural Works Free license The Free Software Definition The Open Source Definition Open-source license Permissive software license Public domain Challenges Digital rights management License proliferation Mozilla software rebranding Proprietary device drivers Proprietary firmware Proprietary software SCO/Linux controversies Software patents Software security Tivoization Trusted Computing Related topics Forking GNU Manifesto Microsoft Open Specification Promise Open-core model Open-source hardware Shared Source Initiative Source-available software The Cathedral and the Bazaar Revolution OS Portal Category vteStatistical softwarePublic domain Dataplot Epi Info CSPro X-12-ARIMA Open-source ADMB DAP gretl jamovi JASP JAGS JMulTi Julia Jupyter (Julia, Python, R) GNU Octave OpenBUGS Orange PSPP Python (statsmodels, PyMC3, IPython, IDLE) R (RStudio) SageMath SimFiT SOFA Statistics Stan XLispStat Freeware BV4.1 CumFreq SegReg XploRe WinBUGS CommercialCross-platform Data Desk GAUSS GraphPad InStat GraphPad Prism IBM SPSS Statistics IBM SPSS Modeler JMP Maple Mathcad Mathematica MATLAB OxMetrics RATS Revolution Analytics SAS SmartPLS Stata StatView SUDAAN S-PLUS TSP World Programming System (WPS) Windows only BMDP EViews GenStat LIMDEP LISREL MedCalc Microfit Minitab MLwiN NCSS SHAZAM SigmaStat Statistica StatsDirect StatXact SYSTAT The Unscrambler UNISTAT Excel add-ons Analyse-it UNISTAT for Excel XLfit RExcel Category Comparison vteNumerical-analysis softwareFree Advanced Simulation Library ADMB Chapel Euler Mathematical Toolbox FreeFem++ FreeMat Genius Gmsh GNU Octave gretl Julia Jupyter (Julia, Python, R; IPython) MFEM OpenFOAM Python R SageMath Salome ScicosLab Scilab X10 Weka Discontinued Fortress Proprietary DADiSP FEATool Multiphysics GAUSS LabVIEW Maple Mathcad Mathematica MATLAB Speakeasy VisSim Comparison Authority control databases InternationalFASTNationalGermanyUnited StatesFranceBnF dataCzech RepublicIsraelOtherIdRef"
    },
    {
        "id": 2,
        "url": "https://en.wikipedia.org/wiki/Main_Page",
        "title": "Main Page",
        "content": "Welcome to Wikipedia, the free encyclopedia that anyone can edit. 116,790 active editors6,938,951 articles in English From today's featured article Smash Hit is a 2014 rail-shooter video game developed and published by the Swedish indie game studio Mediocre. Through the game's twelve levels, the player takes a first-person perspective, shooting metal balls to destroy glass obstacles. The player can also shoot up to five balls at once by smashing a consecutive sequence of crystals and gather power-ups that are activated for a limited amount of time. The game also features a one-time in-game purchase that allows the player to start from any unlocked checkpoint. The game's development team consisted of Dennis Gustafsson, Henrik Johansson, and Douglas Holmquist. A virtual reality adaptation of the game was released for platforms in 2015 and 2018. Smash Hit received positive acclaim from reviewers, who praised its physics engine, graphics, music, and sound effects. CNET and Apple listed it as one of the best mobile games of 2014. Gustafsson and Holmquist later worked on Teardown after Mediocre closed in 2017. (Full article...) Recently featured: Tomb of Kha and Merit Ferrari FF Title (album) Archive By email More featured articles About Did you know ... Adrien Nunez ... that Adrien Nunez (pictured), despite limited playing time, was more highly paid than a projected NBA draft lottery pick while in college? ... that specimens of Aquilegia daingolica were collected in 1906 and 1909, but it was first described as a new species in 2013? ... that Yanou Collart helped Rock Hudson get medical treatment when Nancy Reagan would not? ... that when Alexander McQueen, following years of criticism for over-reliance on runway spectacles, presented The Man Who Knew Too Much, it was criticised for its lack of theatrics? ... that Lars Chemnitz was one of the first recipients of Nersornaat, the highest honor in Greenland? ... that the principal songwriter of a song on Always Happy to Explode asked listeners to \"love it for me, for I cannot\"? ... that Daniel Hermann wrote poems on the inclusion of a lizard and a frog in a piece of amber, the eagle in the coat of arms of Poland, and a child suffering from Fraser syndrome? ... that the harsh treatment of Allied prisoners of war in Japan is well known in the West but mostly ignored or glossed over in Japan itself? ... that a cable TV channel in the UK was still broadcasting primarily in black and white as late as 1979? Archive Start a new article Nominate an article In the news Joseph Aoun Joseph Aoun (pictured) is elected president of Lebanon after a two-year vacancy. An attack on the presidential palace in N'Djamena, Chad, results in 20 deaths. A series of wildfires in Southern California, United States, leaves at least 16 people dead and forces the evacuation of nearly 180,000 others. A 7.1-magnitude earthquake hits Tingri County in the Tibet Autonomous Region, China, leaving at least 126 people dead. Ongoing: Israel–Hamas war Russian invasion of Ukraine timeline Sudanese civil war timeline Recent deaths: Mike Rinder Peter Yarrow Ayla Erduran Claude Allègre Joseph Bendounga Al MacNeil Nominate an article On this day January 12: Zanzibar Revolution Day in Tanzania (1964) Comet McNaught 1659 – The fort at Allahabad was surrendered to the forces of Mughal emperor Aurangzeb. 1879 – Anglo-Zulu War: Natal Native Contingent and British troops defeated Zulu forces in the Action at Sihayo's Kraal. 1899 – During a storm, the crew of Lynmouth Lifeboat Station transported their 10-ton lifeboat 15 mi (24 km) overland in order to rescue a damaged schooner. 1967 – Seventy-three-year-old psychology professor James Bedford became the first person to be cryonically preserved with intent of future resuscitation. 2007 – Comet McNaught (pictured) reached perihelion, becoming the brightest comet in over 40 years, with an apparent magnitude of −5.5. John Singer Sargent (b. 1856)Laura Adams Armer (b. 1874)Princess Patricia of Connaught (d. 1974) More anniversaries: January 11 January 12 January 13 Archive By email List of days of the year About Today's featured picture John Henry Turpin (1876–1962) was a sailor in the United States Navy in the late 19th and early 20th centuries. He was one of the first African-American chief petty officers in the U.S. Navy, becoming a chief gunner's mate on the cruiser Marblehead in 1917. He was transferred to the Fleet Reserve in 1919 and retired in 1925. He is also notable for surviving the catastrophic explosions of two U.S. Navy ships: USS Maine in 1898, and USS Bennington in 1905. Photograph credit: unknown photographer; restored by Adam Cuerden Recently featured: Tocopilla railway Colias croceus Michael William Balfe Archive More featured pictures Other areas of Wikipedia Community portal – The central hub for editors, with resources, links, tasks, and announcements. Village pump – Forum for discussions about Wikipedia itself, including policies and technical issues. Site news – Sources of news about Wikipedia and the broader Wikimedia movement. Teahouse – Ask basic questions about using or editing Wikipedia. Help desk – Ask questions about using or editing Wikipedia. Reference desk – Ask research questions about encyclopedic topics. Content portals – A unique way to navigate the encyclopedia. Wikipedia's sister projects Wikipedia is written by volunteer editors and hosted by the Wikimedia Foundation, a non-profit organization that also hosts a range of other volunteer projects: CommonsFree media repository MediaWikiWiki software development Meta-WikiWikimedia project coordination WikibooksFree textbooks and manuals WikidataFree knowledge base WikinewsFree-content news WikiquoteCollection of quotations WikisourceFree-content library WikispeciesDirectory of species WikiversityFree learning tools WikivoyageFree travel guide WiktionaryDictionary and thesaurus Wikipedia languages This Wikipedia is written in English. Many other Wikipedias are available; some of the largest are listed below. 1,000,000+ articles العربية Deutsch Español فارسی‎ Français Italiano Nederlands 日本語 Polski Português Русский Svenska Українська Tiếng Việt 中文 250,000+ articles Bahasa Indonesia Bahasa Melayu 閩南語 Български Català Čeština Dansk Esperanto Euskara עברית Հայերեն 한국어 Magyar Norsk bokmål Română Simple English Slovenčina Srpski Srpskohrvatski Suomi Türkçe Oʻzbekcha 50,000+ articles Asturianu Azərbaycanca বাংলা Bosanski کوردی Eesti Ελληνικά Frysk Gaeilge Galego Hrvatski ქართული Kurdî Latviešu Lietuvių മലയാളം Македонски မြန်မာဘာသာ Norsk nynorsk ਪੰਜਾਬੀ Shqip Slovenščina ไทย తెలుగు اردو"
    },
    {
        "id": 3,
        "url": "https://en.wikipedia.org/wiki/Python_(genus)",
        "title": "Python (genus)",
        "content": "Genus of snakes PythonTemporal range: Miocene–Present PreꞒ Ꞓ O S D C P T J K Pg N Burmese python (Python bivittatus) Scientific classification Domain: Eukaryota Kingdom: Animalia Phylum: Chordata Class: Reptilia Order: Squamata Suborder: Serpentes Family: Pythonidae Genus: PythonDaudin, 1803 Type species Boa molura[citation needed]Linnaeus, 1758 Synonyms List Python Daudin, 1803Constrictor Wagler, 1830Enygrus Wagler, 1830Engyrus Gray, 1831Enygris Gray, 1842Heleionomus Gray, 1842Morelia Gray, 1842Hortulia Gray, 1842Asterophis Fitzinger, 1843Liasis Duméril & Bibron, 1844Simalia Gray, 1849Aspidopython Meyer, 1874Aspidoboa Sauvage, 1884Hypaspistes Ogilby, 1891 Python is a genus of constricting snakes in the Pythonidae family native to the tropics and subtropics of the Eastern Hemisphere. The name python was proposed by François Marie Daudin in 1803 for non-venomous flecked snakes. Currently, 10 python species are recognized as valid taxa. Three formerly considered python subspecies have been promoted, and a new species recognized.[when?] Taxonomy[edit] The generic name Python was proposed by François Marie Daudin in 1803 for non-venomous snakes with a flecked skin and a long split tongue. In 1993, seven python species were recognized as valid taxa. On the basis of phylogenetic analyses, between seven and 13 python species are recognized. Species Image IUCN Red List and geographic range Indian python (P. molurus; Linnaeus, 1758) NT Central African rock python (P. sebae; Gmelin, 1788) NTRange shown in green Ball python (P. regius; Shaw, 1802) NT Burmese python (P. bivittatus; Kuhl, 1820) VU Southern African rock python (P. natalensis; Smith, 1833) LCRange shown in orange Sumatran short-tailed python (P. curtus; Schlegel, 1872) LCRange shown in yellow Bornean python (P. breitensteini; Steindachner, 1881) LCRange shown in green Angolan python (P. anchietae; Bocage, 1887) LC Blood python (P. brongersmai; Stull, 1938) (formerly P. curtus brongersmai) LCRange shown in red Myanmar short-tailed python (P. kyaiktiyo; Zug, Gotte & Jacobs, 2011) VUWest of the Tenasserim Hills, Myanmar † European python (Python europaeus; Szyndlar & Rage, 2003) EX Extinct species known from the discovery of a trunk vertebrae dated to the Miocene epoch, found in Vieux-Collonges and La Grive-Saint-Alban, France. Distribution and habitat[edit] Python anchietae In Africa, pythons are native to the tropics south of the Sahara, but not in the extreme south-western tip of southern Africa (Western Cape) or in Madagascar. In Asia, they occur from Bangladesh, Nepal, India, Pakistan, and Sri Lanka, including the Nicobar Islands, through Myanmar, east to Indochina, southern China, Hong Kong and Hainan, as well as in the Malayan region of Indonesia and the Philippines. Invasive[edit] Some suggest that P. bivittatus and P. sebae have the potential to be problematic invasive species in South Florida. In early 2016, after a culling operation yielded 106 pythons, Everglades National Park officials suggested that \"thousands\" may live within the park, and that the species has been breeding there for some years. More recent data suggest that these pythons would not withstand winter climates north of Florida, contradicting previous research suggesting a more significant geographic potential range. Uses[edit] Ball pythons commonly exhibit mutations, such as this \"Spider\" morph, and are popular among snake keepers. Python skin is used to make clothing, such as vests, belts, boots and shoes, or fashion accessories such as handbags. It may also be stretched and formed as the sound board of some string musical instruments, such as the erhu spike-fiddle, sanxian and the sanshin lutes. With a high demand of snake skin in the current fashion industry, countries in Africa and Southern Asia partake in the legal and illegal selling of python skin. Providing an extremely low pay for the hunters with an extremely high selling product for the consumers, there is an enormous gap between the beginning and end of the snake skin trade. As pets[edit] Many Python species, such as P. regius, P. brongersmai, P. bivittatus and M. reticulatus, are popular to keep as pets due to their ease of care, docile temperament, and vibrant colors, with some rare mutations having been sold for several thousands of dollars. Pythons in the pet trade are sourced from the wild, or from captive females that were taken from the wild ('captive-born'), or from parents that themselves were born in a captive setting ('captive-bred') Despite controversy that has arisen from media reports, with proper safety procedures pet pythons are relatively safe to own. Etymology[edit] The word 'Python' is derived from the Latin word 'pȳthon' and the Greek word 'πύθων', both referring to the \"serpent slain, who was fabled to have been called Pythius in commemoration of his victory near Delphi by Apollo according to the myth\". References[edit] ^ a b McDiarmid, R. W.; Campbell, J. A.; Touré, T. (1999). \"Python\". Snake Species of the World: A Taxonomic and Geographic Reference. Volume 1. Washington, DC: Herpetologists' League. ISBN 1893777014. ^ a b Daudin, F. M. (1803). \"Python\". Histoire naturelle, générale et particulière, des reptiles. Tome 8. Paris: De l'Imprimerie de F. Dufart. p. 384. ^ Barker, D. G.; Barker, T. M.; Davis, M. A.; Schuett, G. W. (2015). \"A review of the systematics and taxonomy of Pythonidae: an ancient serpent lineage\". Zoological Journal of the Linnean Society. 175 (1): 1−19. doi:10.1111/zoj.12267. ^ Kluge, A. G. (1993). \"Aspidites and the phylogeny of pythonine snakes\". Records of the Australian Museum (Supplement 19): 1–77. ^ Lawson, R.; Slowinski, J. B.; Burbrink, F. T. (2004). \"A molecular approach to discerning the phylogenetic placement of the enigmatic snake Xenophidion schaeferi among the Alethinophidia\". Journal of Zoology. 263 (3): 285–294. doi:10.1017/s0952836904005278. ^ Reynolds, R. G.; Niemiller, M. L.; Revell, L. J. (2014). \"Toward a tree-of-life for the boas and pythons: multilocus species-level phylogeny with unprecedented taxon sampling\". Molecular Phylogenetics and Evolution. 71 (71): 201–213. doi:10.1016/j.ympev.2013.11.011. PMID 24315866. ^ Linnaeus, C. (1758). \"Coluber molurus\". Systema naturae per regna tria naturae: secundum classes, ordines, genera, species, cum characteribus, differentiis, synonymis, locis. Vol. 1 (Tenth reformed ed.). Holmiae: Laurentii Salvii. p. 225. ^ Aengals, A.; Das, A.; Mohapatra, P.; Srinivasulu, C.; Srinivasulu, B.; Shankar, G. & Murthy, B.H.C. (2021). \"Python molurus\". IUCN Red List of Threatened Species. 2021: e.T58894358A1945283. Retrieved 2 December 2021. ^ Gmelin, J. F. (1788). \"Coluber sebae\". Caroli a Linné. Systema naturae per regna tria naturae: secundum classes, ordines, genera, species, cum characteribus, differentiis, synonymis, locis. Vol. I, Part III (13., aucta, reformata ed.). Lipsiae: Georg Emanuel Beer. p. 1118. ^ Alexander, G.J.; Tolley, K.A.; Penner, J.; Luiselli, L.; Jallow, M.; Segniagbeto, G.; Niagate, B.; Howell, K.; Beraduccii, J.; Msuya, C.A. & Ngalason, W. (2021). \"Python sebae\". IUCN Red List of Threatened Species. 2021: e.T13300572A13300582. Retrieved 2 December 2021. ^ Shaw, G. (1802). \"Royal Boa\". General zoology, or Systematic natural history. Volume III, Part II. London: G. Kearsley. pp. 347–348. ^ D'Cruze, N.; Wilms, T.; Penner, J.; Luiselli, L.; Jallow, M.; Segniagbeto, G.; Niagate, B. & Schmitz, A. (2021). \"Python regius\". IUCN Red List of Threatened Species. 2021: e.T177562A15340592. Retrieved 2 December 2021. ^ Kuhl, H. (1820). \"Python bivittatus mihi\". Beiträge zur Zoologie und vergleichenden Anatomie. Frankfurt am Main: Verlag der Hermannschen Buchhandlung. p. 94. ^ Stuart, B.; Nguyen, T.Q.; Thy, N.; Grismer, L.; Chan-Ard, T.; Iskandar, D.; Golynsky, E. & Lau, M.W. (2019) [errata version of 2019 assessment]. \"Python bivittatus\". IUCN Red List of Threatened Species. 2019: e.T193451A151341916. Retrieved 6 April 2021. ^ Smith, A. (1849). \"Python natalensis\". Illustrations of the zoology of South Africa : consisting chiefly of figures and descriptions of the objects of natural history collected during an expedition into the interior of South Africa, in the years 1834, 1835, and 1836; fitted out by \"the Cape of Good Hope Association for exploring Central Africa\" : together with a summary of African zoology, and an inquiry into the geographical ranges of species in that quarter of the globe. London: Smith, Elder and Co. pp. 42–44. ^ Alexander, G.J. & Tolley, K.A. (2021). \"Python natalensis\". IUCN Red List of Threatened Species. 2021: e.T13300560A13300564. Retrieved 19 April 2022. ^ Schlegel, H. (1872). \"De Pythons\". In Witkamp, P. H. (ed.). De Diergaarde van het Koninklijk Zoölogisch Genootschap Natura Artis Magistra te Amsterdam: De Kruipende Dieren. Amsterdam: Van Es. pp. 53–54. ^ Inger, R.F.; Iskandar, D.; Lilley, R.; Jenkins, H. & Das, I. (2014). \"Python curtus\". IUCN Red List of Threatened Species. 2014: e.T192244A2060581. Retrieved 2 December 2021. ^ Steindachner, F. (1880). \"Über eine neue Pythonart (Python breitensteini) aus Borneo\". Sitzungsberichte der Kaiserlichen Akademie der Wissenschaften Wien. 82: 267−280. ^ Inger, R.F.; Iskandar, D.; Lilley, R.; Jenkins, H.; Das, I. (2012). \"Python breitensteini\". IUCN Red List of Threatened Species. 2012: e.T192013A2028005. Retrieved 2 December 2021. ^ a b Baptista, N.; Becker, F.; Conradie, W.; Bauer, A.M. & Ceríaco, L.M.P. (2021). \"Python anchietae\". IUCN Red List of Threatened Species. 2021: e.T177539A120594491. Retrieved 2 December 2021. ^ Grismer, L. & Chan-Ard, T. (2012). \"Python brongersmai\". IUCN Red List of Threatened Species. 2012: e.T192169A2050353. doi:10.2305/IUCN.UK.2012-1.RLTS.T192169A2050353.en. Retrieved 13 March 2018. ^ Zug, G. R.; Gotte, S. W.; Jacobs, J. F. (2011). \"Pythons in Burma: Short-tailed python (Reptilia: Squamata)\". Proceedings of the Biological Society of Washington. 124 (2): 112−136. doi:10.2988/10-34.1. S2CID 86424371. ^ a b Wogan, G. & Chan-Ard, T. (2012). \"Python kyaiktiyo\". IUCN Red List of Threatened Species. 2012: e.T199854A2614411. doi:10.2305/IUCN.UK.2012-1.RLTS.T199854A2614411.en. Retrieved 13 March 2018. ^ a b Szyndlar, Z.; Rage, J. C. (2003). \"Python europaeus\". Non-erycine Booidea from the Oligocene and Miocene of Europe. Kraków: Institute of Systematics and Evolution of Animals. pp. 68−72. ^ \"Python Snakes, An Invasive Species In Florida, Could Spread To One Third Of US\". ScienceDaily. 2008. Retrieved 2017-08-01. ^ Avery, M. L.; Engeman, R. M.; Keacher, K. L.; Humphrey, J. S.; Bruce, W. E.; Mathies, T. C.; Mauldin, R. E. (2010). \"Cold weather and the potential range of invasive Burmese pythons\". Biological Invasions. 12 (11): 3649−3652. doi:10.1007/s10530-010-9761-4. S2CID 2060365. ^ \"About Sanshin: Introduction to the asian banjo - the Okinawan sanshin\". Archived from the original on 2016-08-21. Retrieved 2015-04-08. ^ Wahab; Maulany, R. I.; Nasri & Nirsyawita (2020). \"Hunting and trading activities of reticulated python (Python reticulatus) in South Sulawesi, Indonesia: A report from the field\". IOP Conference Series: Earth and Environmental Science. 486 (1): 12029–. Bibcode:2020E&ES..486a2029W. doi:10.1088/1755-1315/486/1/012029. S2CID 219739375. ^ Nijman, Vincent (2022-11-05). \"Harvest quotas, free markets and the sustainable trade in pythons\". Nature Conservation. 48: 99–121. doi:10.3897/natureconservation.48.80988. ISSN 1314-3301. S2CID 248733239. ^ \"Malayopython reticulatus\". ^ \"Playing with the Big Boys: Handling Large Constrictors\". www.anapsid.org. Retrieved 2017-08-01. ^ Lewis, C. T.; Short, C. (1879). \"Pȳthon\". A Latin Dictionary. Oxford: Clarendon Press. External links[edit] Wikispecies has information related to Python (genus). Wikimedia Commons has media related to: Python (genus) (category) Wikisource has the text of a 1920 Encyclopedia Americana article about Python (genus). Python at the Reptarium.cz Reptile Database. Accessed 11 September 2007. vteFamily PythonidaeAntaresia Antaresia childreni Antaresia maculosa Antaresia perthensis Apodora Apodora papuana Aspidites Aspidites melanocephalus Aspidites ramsayi Bothrochilus Bothrochilus boa Leiopython Leiopython albertisii Leiopython biakensis Leiopython fredparkeri Liasis Liasis fuscus Liasis mackloti Liasis olivaceus Malayopython Malayopython reticulatus Malayopython timoriensis Morelia Morelia azurea Morelia bredli Morelia carinata Morelia imbricata Morelia spilota Morelia viridis Nyctophilopython Nyctophilopython oenpelliensis Python Python anchietae Python bivittatus Python breitensteini Python brongersmai Python curtus Python kyaiktiyo Python molurus Python natalensis Python regius Python sebae Simalia Simalia amethistina Simalia boeleni Simalia clastolepis Simalia kinghorni Simalia nauta Simalia tracyae Taxon identifiersPython Wikidata: Q271218 Wikispecies: Python CoL: CDXHH EoL: 35510 EPPO: 1PYTNG GBIF: 2454645 iNaturalist: 32149 IRMNG: 1031494 ITIS: 202186 NCBI: 37579 Open Tree of Life: 675102 Paleobiology Database: 38114 Authority control databases: National Czech RepublicLatvia"
    },
    {
        "id": 4,
        "url": "https://en.wikipedia.org/wiki/Programming_paradigm",
        "title": "Programming paradigm",
        "content": "High-level computer programming conceptualization This article is about classification of programming languages. For definition of the term \"programming model\", see Programming model. A programming paradigm is a relatively high-level way to conceptualize and structure the implementation of a computer program. A programming language can be classified as supporting one or more paradigms. Paradigms are separated along and described by different dimensions of programming. Some paradigms are about implications of the execution model, such as allowing side effects, or whether the sequence of operations is defined by the execution model. Other paradigms are about the way code is organized, such as grouping into units that include both state and behavior. Yet others are about syntax and grammar. Some common programming paradigms include (shown in hierarchical relationship): Imperative – code directly controls execution flow and state change, explicit statements that change a program state procedural – organized as procedures that call each other object-oriented – organized as objects that contain both data structure and associated behavior, uses data structures consisting of data fields and methods together with their interactions (objects) to design programs Class-based – object-oriented programming in which inheritance is achieved by defining classes of objects, versus the objects themselves Prototype-based – object-oriented programming that avoids classes and implements inheritance via cloning of instances Declarative – code declares properties of the desired result, but not how to compute it, describes what computation should perform, without specifying detailed state changes functional – a desired result is declared as the value of a series of function evaluations, uses evaluation of mathematical functions and avoids state and mutable data logic – a desired result is declared as the answer to a question about a system of facts and rules, uses explicit mathematical logic for programming reactive – a desired result is declared with data streams and the propagation of change Concurrent programming – has language constructs for concurrency, these may involve multi-threading, support for distributed computing, message passing, shared resources (including shared memory), or futures Actor programming – concurrent computation with actors that make local decisions in response to the environment (capable of selfish or competitive behaviour) Constraint programming – relations between variables are expressed as constraints (or constraint networks), directing allowable solutions (uses constraint satisfaction or simplex algorithm) Dataflow programming – forced recalculation of formulas when data values change (e.g. spreadsheets) Distributed programming – has support for multiple autonomous computers that communicate via computer networks Generic programming – uses algorithms written in terms of to-be-specified-later types that are then instantiated as needed for specific types provided as parameters Metaprogramming – writing programs that write or manipulate other programs (or themselves) as their data, or that do part of the work at compile time that would otherwise be done at runtime Template metaprogramming – metaprogramming methods in which a compiler uses templates to generate temporary source code, which is merged by the compiler with the rest of the source code and then compiled Reflective programming – metaprogramming methods in which a program modifies or extends itself Pipeline programming – a simple syntax change to add syntax to nest function calls to language originally designed with none Rule-based programming – a network of rules of thumb that comprise a knowledge base and can be used for expert systems and problem deduction & resolution Visual programming – manipulating program elements graphically rather than by specifying them textually (e.g. Simulink); also termed diagrammatic programming Overview[edit] Overview of the various programming paradigms according to Peter Van Roy: 5 Programming paradigms come from computer science research into existing practices of software development. The findings allow for describing and comparing programming practices and the languages used to code programs. For perspective, other fields of research study software engineering processes and describe various methodologies to describe and compare them. A programming language can be described in terms of paradigms. Some languages support only one paradigm. For example, Smalltalk supports object-oriented and Haskell supports functional. Most languages support multiple paradigms. For example, a program written in C++, Object Pascal, or PHP can be purely procedural, purely object-oriented, or can contain aspects of both paradigms, or others. When using a language that supports multiple paradigms, the developer chooses which paradigm elements to use. But, this choice may not involve considering paradigms per se. The developer often uses the features of a language as the language provides them and to the extent that the developer knows them. Categorizing the resulting code by paradigm is often an academic activity done in retrospect. Languages categorized as imperative paradigm have two main features: they state the order in which operations occur, with constructs that explicitly control that order, and they allow side effects, in which state can be modified at one point in time, within one unit of code, and then later read at a different point in time inside a different unit of code. The communication between the units of code is not explicit. In contrast, languages in the declarative paradigm do not state the order in which to execute operations. Instead, they supply a number of available operations in the system, along with the conditions under which each is allowed to execute. The implementation of the language's execution model tracks which operations are free to execute and chooses the order independently. More at Comparison of multi-paradigm programming languages. In object-oriented programming, code is organized into objects that contain state that is owned by and (usually) controlled by the code of the object. Most object-oriented languages are also imperative languages. In object-oriented programming, programs are treated as a set of interacting objects. In functional programming, programs are treated as a sequence of stateless function evaluations. When programming computers or systems with many processors, in process-oriented programming, programs are treated as sets of concurrent processes that act on a logical shared data structures. Many programming paradigms are as well known for the techniques they forbid as for those they support. For instance, pure functional programming disallows side-effects, while structured programming disallows the goto construct. Partly for this reason, new paradigms are often regarded as doctrinaire or overly rigid by those accustomed to older ones. Yet, avoiding certain techniques can make it easier to understand program behavior, and to prove theorems about program correctness. Programming paradigms can also be compared with programming models, which allows invoking an execution model by using only an API. Programming models can also be classified into paradigms based on features of the execution model. For parallel computing, using a programming model instead of a language is common. The reason is that details of the parallel hardware leak into the abstractions used to program the hardware. This causes the programmer to have to map patterns in the algorithm onto patterns in the execution model (which have been inserted due to leakage of hardware into the abstraction). As a consequence, no one parallel programming language maps well to all computation problems. Thus, it is more convenient to use a base sequential language and insert API calls to parallel execution models via a programming model. Such parallel programming models can be classified according to abstractions that reflect the hardware, such as shared memory, distributed memory with message passing, notions of place visible in the code, and so forth. These can be considered flavors of programming paradigm that apply to only parallel languages and programming models. Criticism[edit] Some programming language researchers criticise the notion of paradigms as a classification of programming languages, e.g. Harper, and Krishnamurthi. They argue that many programming languages cannot be strictly classified into one paradigm, but rather include features from several paradigms. See Comparison of multi-paradigm programming languages. History[edit] Different approaches to programming have developed over time. Classification of each approach was either described at the time the approach was first developed, but often not until some time later, retrospectively. An early approach consciously identified as such is structured programming, advocated since the mid 1960s. The concept of a programming paradigm as such dates at least to 1978, in the Turing Award lecture of Robert W. Floyd, entitled The Paradigms of Programming, which cites the notion of paradigm as used by Thomas Kuhn in his The Structure of Scientific Revolutions (1962). Early programming languages did not have clearly defined programming paradigms and sometimes programs made extensive use of goto statements. Liberal use of which lead to spaghetti code which is difficult to understand and maintain. This led to the development of structured programming paradigms that disallowed the use of goto statements; only allowing the use of more structured programming constructs. Languages and paradigms[edit] Machine code[edit] Machine code is the lowest-level of computer programming as it is machine instructions that define behavior at the lowest level of abstract possible for a computer. As it is the most prescriptive way to code it is classified as imperative. It is sometimes called the first-generation programming language. Assembly[edit] Assembly language introduced mnemonics for machine instructions and memory addresses. Assembly is classified as imperative and is sometimes called the second-generation programming language. In the 1960s, assembly languages were developed to support library COPY and quite sophisticated conditional macro generation and preprocessing abilities, CALL to subroutine, external variables and common sections (globals), enabling significant code re-use and isolation from hardware specifics via the use of logical operators such as READ/WRITE/GET/PUT. Assembly was, and still is, used for time-critical systems and often in embedded systems as it gives the most control of what the machine does. Procedural languages[edit] Procedural languages, also called the third-generation programming languages are the first described as high-level languages. They support vocabulary related to the problem being solved. For example, COmmon Business Oriented Language (COBOL) – uses terms like file, move and copy. FORmula TRANslation (FORTRAN) – using mathematical language terminology, it was developed mainly for scientific and engineering problems. ALGOrithmic Language (ALGOL) – focused on being an appropriate language to define algorithms, while using mathematical language terminology, targeting scientific and engineering problems, just like FORTRAN. Programming Language One (PL/I) – a hybrid commercial-scientific general purpose language supporting pointers. Beginners All purpose Symbolic Instruction Code (BASIC) – it was developed to enable more people to write programs. C – a general-purpose programming language, initially developed by Dennis Ritchie between 1969 and 1973 at AT&T Bell Labs. These languages are classified as procedural paradigm. They directly control the step by step process that a computer program follows. The efficacy and efficiency of such a program is therefore highly dependent on the programmer's skill. Object-oriented programming[edit] Main article: Object-oriented programming In attempt to improve on procedural languages, object-oriented programming (OOP) languages were created, such as Simula, Smalltalk, C++, Eiffel, Python, PHP, Java, and C#. In these languages, data and methods to manipulate the data are in the same code unit called an object. This encapsulation ensures that the only way that an object can access data is via methods of the object that contains the data. Thus, an object's inner workings may be changed without affecting code that uses the object. There is controversy raised by Alexander Stepanov, Richard Stallman and other programmers, concerning the efficacy of the OOP paradigm versus the procedural paradigm. The need for every object to have associative methods leads some skeptics to associate OOP with software bloat; an attempt to resolve this dilemma came through polymorphism. Although most OOP languages are third-generation, it is possible to create an object-oriented assembler language. High Level Assembly (HLA) is an example of this that fully supports advanced data types and object-oriented assembly language programming – despite its early origins. Thus, differing programming paradigms can be seen rather like motivational memes of their advocates, rather than necessarily representing progress from one level to the next.[citation needed] Precise comparisons of competing paradigms' efficacy are frequently made more difficult because of new and differing terminology applied to similar entities and processes together with numerous implementation distinctions across languages. Declarative languages[edit] A declarative programming program describes what the problem is, not how to solve it. The program is structured as a set of properties to find in the expected result, not as a procedure to follow. Given a database or a set of rules, the computer tries to find a solution matching all the desired properties. An archetype of a declarative language is the fourth generation language SQL, and the family of functional languages and logic programming. Functional programming is a subset of declarative programming. Programs written using this paradigm use functions, blocks of code intended to behave like mathematical functions. Functional languages discourage changes in the value of variables through assignment, making a great deal of use of recursion instead. The logic programming paradigm views computation as automated reasoning over a body of knowledge. Facts about the problem domain are expressed as logic formulas, and programs are executed by applying inference rules over them until an answer to the problem is found, or the set of formulas is proved inconsistent. Other paradigms[edit] Symbolic programming is a paradigm that describes programs able to manipulate formulas and program components as data. Programs can thus effectively modify themselves, and appear to \"learn\", making them suited for applications such as artificial intelligence, expert systems, natural-language processing and computer games. Languages that support this paradigm include Lisp and Prolog. Differentiable programming structures programs so that they can be differentiated throughout, usually via automatic differentiation. Literate programming, as a form of imperative programming, structures programs as a human-centered web, as in a hypertext essay: documentation is integral to the program, and the program is structured following the logic of prose exposition, rather than compiler convenience. Symbolic programming techniques such as reflective programming (reflection), which allow a program to refer to itself, might also be considered as a programming paradigm. However, this is compatible with the major paradigms and thus is not a real paradigm in its own right. See also[edit] Computer programming portal Domain-specific language Flow-based programming Modeling language Programming domain Turing completeness Von Neumann programming languages References[edit] ^ \"Multi-Paradigm Programming Language\". Mozilla Developer Network. Mozilla Foundation. Jun 21, 2013. Archived from the original on 21 August 2013. ^ Nørmark, Kurt. Overview of the four main programming paradigms. Aalborg University, 9 May 2011. Retrieved 22 September 2012. ^ Frans Coenen (1999-10-11). \"Characteristics of declarative programming languages\". cgi.csc.liv.ac.uk. Archived from the original on 2014-02-27. Retrieved 2014-02-20. ^ a b Michael A. Covington (2010-08-23). \"CSCI/ARTI 4540/6540: First Lecture on Symbolic Programming and LISP\" (PDF). University of Georgia. Archived from the original (PDF) on 2012-03-07. Retrieved 2013-11-20. ^ Peter Van Roy (2009-05-12). \"Programming Paradigms: What Every Programmer Should Know\" (PDF). info.ucl.ac.be. Retrieved 2014-01-27. ^ Peter Van-Roy; Seif Haridi (2004). Concepts, Techniques, and Models of Computer Programming. MIT Press. ISBN 978-0-262-22069-9. ^ \"Programming paradigms: What are the principles of programming?\". IONOS Digitalguide. 20 April 2020. Archived from the original on Jun 29, 2022. Retrieved 2022-05-03. ^ Frank Rubin (March 1987). \"'GOTO Considered Harmful' Considered Harmful\" (PDF). Communications of the ACM. 30 (3): 195–196. doi:10.1145/214748.315722. S2CID 6853038. Archived from the original (PDF) on March 20, 2009. ^ Harper, Robert (1 May 2017). \"What, if anything, is a programming-paradigm?\". FifteenEightyFour. Cambridge University Press. ^ Krishnamurthi, Shriram (November 2008). \"Teaching programming languages in a post-linnaean age\". ACM SIGPLAN Notices. 43 (11). ACM: 81–83. doi:10.1145/1480828.1480846. S2CID 35714982.. ^ Floyd, R. W. (1979). \"The paradigms of programming\". Communications of the ACM. 22 (8): 455–460. doi:10.1145/359138.359140. ^ Soroka, Barry I. (2006). Java 5: Objects First. Jones & Bartlett Learning. ISBN 9780763737207. ^ \"Mode inheritance, cloning, hooks & OOP (Google Groups Discussion)\". ^ \"Business glossary: Symbolic programming definition\". allbusiness.com. Retrieved 2014-07-30. ^ Wang, Fei; Decker, James; Wu, Xilun; Essertel, Gregory; Rompf, Tiark (2018), Bengio, S.; Wallach, H.; Larochelle, H.; Grauman, K. (eds.), \"Backpropagation with Callbacks: Foundations for Efficient and Expressive Differentiable Programming\" (PDF), Advances in Neural Information Processing Systems 31, Curran Associates, Inc., pp. 10201–10212, retrieved 2019-02-13 ^ Innes, Mike (2018). \"On Machine Learning and Programming Languages\" (PDF). SysML Conference 2018. Archived from the original (PDF) on 2018-09-20. Retrieved 2019-02-13. External links[edit] Wikimedia Commons has media related to Programming language by paradigm. Classification of the principal programming paradigms How programming paradigms evolve and get adopted? Software engineering vteTypes of computer languageTypes Architecture description Data exchange Hardware description Knowledge representation Markup Modeling Programming language Query Shading Specification Stylesheet Transformation See also Category:Lists of computer languages Category:Lists of programming languages List of programming languages by type vteSoftware engineeringFields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction Component-based software engineering Software compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software verification and validation Software system Structured analysis Essential analysis CI/CD Orientations Agile Aspect-oriented Object orientation Ontology Service orientation SDLC ModelsDevelopmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD UP Scrum Spiral model V-model Waterfall model XP Model-driven engineering Round-trip engineering Other SPICE CMMI Data model ER model Function model Information model Metamodeling Object model Systems model View model Languages IDEF UML USL SysML Related fields Computer science Computer engineering Information science Project management Risk management Systems engineering Commons Category vteComputer scienceNote: This template roughly follows the 2012 ACM Computing Classification System.Hardware Printed circuit board Peripheral Integrated circuit Very Large Scale Integration Systems on Chip (SoCs) Energy consumption (Green computing) Electronic design automation Hardware acceleration Processor Size / Form Computer systems organization Computer architecture Computational complexity Dependability Embedded system Real-time computing Networks Network architecture Network protocol Network components Network scheduler Network performance evaluation Network service Software organization Interpreter Middleware Virtual machine Operating system Software quality Software notations and tools Programming paradigm Programming language Compiler Domain-specific language Modeling language Software framework Integrated development environment Software configuration management Software library Software repository Software development Control variable Software development process Requirements analysis Software design Software construction Software deployment Software engineering Software maintenance Programming team Open-source model Theory of computation Model of computation Stochastic Formal language Automata theory Computability theory Computational complexity theory Logic Semantics Algorithms Algorithm design Analysis of algorithms Algorithmic efficiency Randomized algorithm Computational geometry Mathematics of computing Discrete mathematics Probability Statistics Mathematical software Information theory Mathematical analysis Numerical analysis Theoretical computer science Information systems Database management system Information storage systems Enterprise information system Social information systems Geographic information system Decision support system Process control system Multimedia information system Data mining Digital library Computing platform Digital marketing World Wide Web Information retrieval Security Cryptography Formal methods Security hacker Security services Intrusion detection system Hardware security Network security Information security Application security Human–computer interaction Interaction design Social computing Ubiquitous computing Visualization Accessibility Concurrency Concurrent computing Parallel computing Distributed computing Multithreading Multiprocessing Artificial intelligence Natural language processing Knowledge representation and reasoning Computer vision Automated planning and scheduling Search methodology Control method Philosophy of artificial intelligence Distributed artificial intelligence Machine learning Supervised learning Unsupervised learning Reinforcement learning Multi-task learning Cross-validation Graphics Animation Rendering Photograph manipulation Graphics processing unit Mixed reality Virtual reality Image compression Solid modeling Applied computing Quantum Computing E-commerce Enterprise software Computational mathematics Computational physics Computational chemistry Computational biology Computational social science Computational engineering Differentiable computing Computational healthcare Digital art Electronic publishing Cyberwarfare Electronic voting Video games Word processing Operations research Educational technology Document management Category Outline Glossaries Programming vteProgramming paradigms (Comparison by language)ImperativeStructured Jackson structures Block-structured Modular Non-structured Procedural Programming in the large and in the small Design by contract Invariant-based Nested function Object-oriented(comparison, list) Class-based, Prototype-based, Object-based Agent Immutable object Persistent Uniform Function Call Syntax DeclarativeFunctional(comparison) Recursive Anonymous function (Partial application) Higher-order Purely functional Total Strict GADTs Dependent types Functional logic Point-free style Expression-oriented Applicative, Concatenative Function-level, Value-level Dataflow Flow-based Reactive (Functional reactive) Signals Streams Synchronous Logic Abductive logic Answer set Constraint (Constraint logic) Inductive logic Nondeterministic Ontology Probabilistic logic Query DSL Algebraic modeling Array Automata-based (Action) Command (Spacecraft) Differentiable End-user Grammar-oriented Interface description Language-oriented List comprehension Low-code Modeling Natural language Non-English-based Page description Pipes and filters Probabilistic Quantum Scientific Scripting Set-theoretic Simulation Stack-based System Tactile Templating Transformation (Graph rewriting, Production, Pattern) Visual Concurrent,distributed,parallel Actor-based Automatic mutual exclusion Choreographic programming Concurrent logic (Concurrent constraint logic) Concurrent OO Macroprogramming Multitier programming Organic computing Parallel programming models Partitioned global address space Process-oriented Relativistic programming Service-oriented Structured concurrency Metaprogramming Attribute-oriented Automatic (Inductive) Dynamic Extensible Generic Homoiconicity Interactive Macro (Hygienic) Metalinguistic abstraction Multi-stage Program synthesis (Bayesian, Inferential, by demonstration, by example) Reflective Self-modifying code Symbolic Template Separationof concerns Aspects Components Data-driven Data-oriented Event-driven Features Intentional Literate Roles Subjects vteTypes of programming languagesLevel Machine Assembly Compiled Interpreted Low-level High-level Very high-level Esoteric Generation First Second Third Fourth Fifth vteProgramming languages Comparison Timeline History Ada ALGOL Simula APL Assembly BASIC Visual Basic classic .NET C C++ C# COBOL Erlang Forth Fortran Go Haskell Java JavaScript Julia Kotlin Lisp Lua MATLAB ML Pascal Object Pascal Perl PHP Prolog Python R Ruby Rust SQL Scratch Shell Smalltalk Swift more... Lists: Alphabetical Categorical Generational Non-English-based Category vteTypes of programming languagesLevel Machine Assembly Compiled Interpreted Low-level High-level Very high-level Esoteric Generation First Second Third Fourth Fifth vteComputer scienceNote: This template roughly follows the 2012 ACM Computing Classification System.Hardware Printed circuit board Peripheral Integrated circuit Very Large Scale Integration Systems on Chip (SoCs) Energy consumption (Green computing) Electronic design automation Hardware acceleration Processor Size / Form Computer systems organization Computer architecture Computational complexity Dependability Embedded system Real-time computing Networks Network architecture Network protocol Network components Network scheduler Network performance evaluation Network service Software organization Interpreter Middleware Virtual machine Operating system Software quality Software notations and tools Programming paradigm Programming language Compiler Domain-specific language Modeling language Software framework Integrated development environment Software configuration management Software library Software repository Software development Control variable Software development process Requirements analysis Software design Software construction Software deployment Software engineering Software maintenance Programming team Open-source model Theory of computation Model of computation Stochastic Formal language Automata theory Computability theory Computational complexity theory Logic Semantics Algorithms Algorithm design Analysis of algorithms Algorithmic efficiency Randomized algorithm Computational geometry Mathematics of computing Discrete mathematics Probability Statistics Mathematical software Information theory Mathematical analysis Numerical analysis Theoretical computer science Information systems Database management system Information storage systems Enterprise information system Social information systems Geographic information system Decision support system Process control system Multimedia information system Data mining Digital library Computing platform Digital marketing World Wide Web Information retrieval Security Cryptography Formal methods Security hacker Security services Intrusion detection system Hardware security Network security Information security Application security Human–computer interaction Interaction design Social computing Ubiquitous computing Visualization Accessibility Concurrency Concurrent computing Parallel computing Distributed computing Multithreading Multiprocessing Artificial intelligence Natural language processing Knowledge representation and reasoning Computer vision Automated planning and scheduling Search methodology Control method Philosophy of artificial intelligence Distributed artificial intelligence Machine learning Supervised learning Unsupervised learning Reinforcement learning Multi-task learning Cross-validation Graphics Animation Rendering Photograph manipulation Graphics processing unit Mixed reality Virtual reality Image compression Solid modeling Applied computing Quantum Computing E-commerce Enterprise software Computational mathematics Computational physics Computational chemistry Computational biology Computational social science Computational engineering Differentiable computing Computational healthcare Digital art Electronic publishing Cyberwarfare Electronic voting Video games Word processing Operations research Educational technology Document management Category Outline Glossaries Authority control databases: National Germany"
    },
    {
        "id": 5,
        "url": "https://en.wikipedia.org/wiki/Multi-paradigm",
        "title": "Comparison of multi-paradigm programming languages",
        "content": "This article possibly contains original research. Please improve it by verifying the claims made and adding inline citations. Statements consisting only of original research should be removed. (August 2009) (Learn how and when to remove this message) Programming languages can be grouped by the number and types of paradigms supported. Paradigm summaries[edit] A concise reference for the programming paradigms listed in this article. Concurrent programming – have language constructs for concurrency, these may involve multi-threading, support for distributed computing, message passing, shared resources (including shared memory), or futures Actor programming – concurrent computation with actors that make local decisions in response to the environment (capable of selfish or competitive behaviour) Constraint programming – relations between variables are expressed as constraints (or constraint networks), directing allowable solutions (uses constraint satisfaction or simplex algorithm) Dataflow programming – forced recalculation of formulas when data values change (e.g. spreadsheets) Declarative programming – describes what computation should perform, without specifying detailed state changes c.f. imperative programming (functional and logic programming are major subgroups of declarative programming) Distributed programming – have support for multiple autonomous computers that communicate via computer networks Functional programming – uses evaluation of mathematical functions and avoids state and mutable data Generic programming – uses algorithms written in terms of to-be-specified-later types that are then instantiated as needed for specific types provided as parameters Imperative programming – explicit statements that change a program state Logic programming – uses explicit mathematical logic for programming Metaprogramming – writing programs that write or manipulate other programs (or themselves) as their data, or that do part of the work at compile time that would otherwise be done at runtime Template metaprogramming – metaprogramming methods in which a compiler uses templates to generate temporary source code, which is merged by the compiler with the rest of the source code and then compiled Reflective programming – metaprogramming methods in which a program modifies or extends itself Object-oriented programming – uses data structures consisting of data fields and methods together with their interactions (objects) to design programs Class-based – object-oriented programming in which inheritance is achieved by defining classes of objects, versus the objects themselves Prototype-based – object-oriented programming that avoids classes and implements inheritance via cloning of instances Pipeline programming – a simple syntax change to add syntax to nest function calls to language originally designed with none Rule-based programming – a network of rules of thumb that comprise a knowledge base and can be used for expert systems and problem deduction & resolution Visual programming – manipulating program elements graphically rather than by specifying them textually (e.g. Simulink); also termed diagrammatic programming Language overview[edit] List of multi-paradigm programming languages Language Paradigm count Concurrent Constraints Dataflow Declarative Distributed Functional Metaprogramming Generic Imperative Logic Reflection Object-oriented Pipelines Visual Rule-based Other Ada 5 Yes[a 1] — — — Yes — — Yes Yes — — Yes[a 2] — — — — ALF 2 — — — — — Yes — — — Yes — — — — — — AmigaE[citation needed] 2 — — — — — — — — Yes — — Yes[a 2] — — — — APL 3 — — — — — Yes — — Yes — — — — — — Array (multi-dimensional) BETA[citation needed] 3 — — — — — Yes — — Yes — — Yes[a 2] — — — — C++ 7 (15) Yes Library Library Library Library Yes Yes Yes[a 3] Yes Library Library Yes[a 2] Yes — Library Array (multi-dimensional; using STL) C# 6 (7) Yes — Library[a 4] — — Yes[a 5] — Yes Yes — Yes Yes[a 2] — — — Reactive[a 6] ChucK[citation needed] 3 Yes — — — — — — — Yes — — Yes[a 2] — — — — Claire 2 — — — — — Yes — — — — — Yes[a 2] — — — — Clojure 5 Yes — — Yes — Yes Yes — — Library — — Yes Editor — Multiple dispatch, Agents Common Lisp 7 (14) Library Library Library Yes Library Yes Yes Yes Yes Library Yes Yes[a 7][a 2] Library Library Library Multiple dispatch, meta-OOP system, Language is extensible via metaprogramming. Curl 5 — — — — — Yes — Yes[a 3] Yes — Yes Yes[a 2] — — — — Curry 4 Yes Yes — — — Yes — — — Yes — — — — — — D (version 2.0) 7 Yes[a 8] — — — — Yes Yes[a 3] Yes[a 3] Yes — Yes Yes[a 2] — — — — Delphi 3 — — — — — — — Yes[a 3] Yes — — Yes[a 2] — — — — Dylan[citation needed] 3 — — — — — Yes — — — — Yes Yes[a 2] — — — — E 3 Yes — — — Yes — — — — — — Yes[a 2] — — — — ECMAScript (ActionScript, E4X, JavaScript, JScript) 4 (5) Partial[a 9][a 10] — — Library — Yes — — Yes — Yes Yes[a 11] Library Editor — Reactive,[a 12] event driven[a 13][a 14] Erlang 3 Yes — — Yes Yes Yes — — — — — — Yes — — — Elixir 4 Yes — — — Yes Yes Yes — — — — — Yes — — — Elm 6 Yes — Yes Yes — Yes (pure)[a 15] — Yes — — — — Yes — — Reactive F# 7 (8) Yes[a 8] — Library[a 4] Yes — Yes — Yes Yes — Yes Yes[a 2] — — — Reactive[a 6] Fortran 4 (5) Yes — — — — Yes[a 15] — Yes[a 16] — — — Yes[a 2] — — — Array (multi-dimensional) Go 4 Yes — — — — — — — Yes — Yes — Yes — — — Haskell 8 (15) Yes Library Library Yes Library Yes (lazy) (pure)[a 15] Yes Yes Yes Library — Partial[a 17] Yes Yes Library Literate, reactive, dependent types (partial) Io 4 Yes[a 8] — — — — Yes — — Yes — — Yes[a 11] — — — — J[citation needed] 3 — — — — — Yes — — Yes — — Yes[a 2] — — — — Java 6 Yes Library Library — — Yes — Yes Yes — Yes Yes[a 2] — — — — Julia 9 (17) Yes Library Library Library Yes Yes (eager) Yes Yes Yes Library Yes Yes[a 18] Yes — Library Multiple dispatch,Array (multi-dimensional); optionally lazy and reactive (with libraries) Kotlin 8 Yes — — — — Yes Yes Yes Yes — Yes Yes Yes — — — LabVIEW 4 Yes — Yes — — — — — — — — Yes — Yes — — Lava 2 — — — — — — — — — — — Yes[a 2] — Yes — — LispWorks (version 6.0 with support for symmetric multi-processing, rules, logic (Prolog), CORBA) 9 Yes — — — Yes Yes Yes — Yes Yes Yes Yes[a 2] — — Yes — Lua[citation needed] 3 — — — — — Yes — — Yes — — Yes[a 11] — — — — MATLAB 6 (10) Toolbox Toolbox Yes — Toolbox — Yes Yes — — Yes Yes — Yes — Array (multi-dimensional) Nemerle 7 Yes — — — — Yes Yes Yes Yes — Yes Yes[a 2] — — — — Object Pascal 4 Yes — — — — Yes — — Yes — — Yes[a 2] — — — — OCaml 4 — — — — — Yes — Yes Yes — — Yes[a 2] — — — — Oz 11 Yes Yes Yes Yes Yes Yes — — Yes Yes — Yes[a 2] Yes — Yes — Perl[citation needed] 8 (9) Yes — Yes — — Yes Yes — Yes — Yes[a 2] Yes[a 2] Yes — — — PHP 4 — — — — — Yes — — Yes — Yes Yes[a 2] — — — — Poplog 3 — — — — — Yes — — Yes Yes — — — — — — Prograph 3 — — Yes — — — — — — — — Yes[a 2] — Yes — — Python 5 (10) Library Library — — Library Yes Yes Yes Yes Library Yes Yes[a 2] — Editor — Structured R 4 (6) Library — — — Library Yes — — Yes — Yes Yes Yes — — Array (multi-dimensional) Racket 10 Yes Yes Yes — Yes Yes Yes — Yes Yes Yes Yes — — — Lazy Raku 10 Yes Library Yes — Library Yes Yes Yes Yes — Yes Yes Yes — — Multiple dispatch, lazy lists, reactive. ROOP 3 — — — — — — — — Yes Yes — — — — Yes — Ruby 5 — — — — — Yes Yes — Yes — Yes Yes[a 2] — — — — Rust (version 1.0.0-alpha) 6 Yes[a 8] — — — — Yes Yes Yes Yes — — Yes — — — Linear, affline, and ownership types Sather[citation needed] 2 — — — — — Yes — — — — — Yes[a 2] — — — — Scala 9 Yes[a 8] — Yes[a 19] Yes — Yes Yes Yes Yes — Yes Yes[a 2] — — — — Simula[citation needed] 2 — — — — — — — — Yes — — Yes[a 2] — — — — SISAL 3 Yes — Yes — — Yes — — — — — — — — — — Spreadsheets 2 — — — — — Yes — — — — — — — Yes — — Swift 7 Yes — — — — Yes Yes Yes Yes — Yes Yes[a 2] — — — Block-structured Tcl with Snit extension[citation needed] 3 — — — — — Yes — — Yes — — Yes[a 11] — — — — Visual Basic .NET 6 (7) Yes — Library[a 4] — — Yes — Yes Yes — Yes Yes[a 2] — — — Reactive[a 6] Windows PowerShell 6 — — — — — Yes — Yes Yes — Yes Yes[a 2] Yes — — — Wolfram Language & Mathematica 13 (14) Yes Yes Yes Yes Yes Yes Yes Yes Yes Yes Yes Yes Yes — Yes Knowledge Based See also[edit] Programming paradigm List of programming languages by type Domain-specific language Domain-specific multimodeling Notes[edit] ^ rendezvous and monitor-like based ^ a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae af ag ah ai class-based ^ a b c d e template metaprogramming ^ a b c using TPL Dataflow ^ only lambda support (lazy functional programming) ^ a b c using Reactive Extensions (Rx) ^ multiple dispatch, method combinations ^ a b c d e actor programming ^ promises, native extensions ^ using Node.js' cluster module or child_process.fork method, web workers in the browser, etc. ^ a b c d Prototype-based ^ using Reactive Extensions (RxJS) ^ in Node.js via their events module ^ in browsers via their native EventTarget API ^ a b c purely functional ^ parameterized classes ^ immutable ^ multiple dispatch, not traditional single ^ Akka Archived 2013-01-19 at the Wayback Machine Citations[edit] ^ Bragg, S.D.; Driskill, C.G. (20–22 September 1994). \"Diagrammatic-graphical programming languages and DoD-STD-2167A\". Proceedings of AUTOTESTCON '94 (IEEEXplore). Institute of Electrical and Electronics Engineers (IEEE). pp. 211–220. doi:10.1109/AUTEST.1994.381508. ISBN 978-0-7803-1910-3. S2CID 62509261. ^ Ada Reference Manual, ISO/IEC 8652:2005(E) Ed. 3, Section 9: Tasks and Synchronization ^ Ada Reference Manual, ISO/IEC 8652:2005(E) Ed. 3 Annex E: Distributed Systems ^ Ada Reference Manual, ISO/IEC 8652:2005(E) Ed. 3, Section 12: Generic Units ^ Ada Reference Manual, ISO/IEC 8652:2005(E) Ed. 3, Section 6: Subprograms ^ Ada Reference Manual, ISO/IEC 8652:2005(E) Ed. 3, 3.9 Tagged Types and Type Extensions ^ Thread support ^ Atomics support ^ Memory model ^ Gecode ^ SystemC ^ Boost.Iostreams ^ Boolinq ^ \"AraRat\" (PDF). Archived from the original (PDF) on 2019-08-19. Retrieved 2019-09-15. ^ OpenMPI ^ Boost.MPI ^ Boost.MPL ^ LC++ ^ Castor Archived 2013-01-25 at the Wayback Machine ^ Reflect Library ^ N3534 ^ Boost.Spirit ^ Clojure - Concurrent Programming ^ Clojure - core.async ^ Clojure - Functional Programming ^ Clojure - Macros ^ Clojure - core.logic ^ Clojure - Threading Macros Guide ^ \"Light Table\". 2019-04-08. ^ Multimethods and Hierarchies ^ Agents and Asynchronous Actions ^ \"concurrency\". CLiki. ^ constraint programming inside CL through extensions ^ dataflow extension ^ by creating DSLs using the built-in metaprogramming; also see note on functional, constraint and logic paradigms, which are part of declarative ^ MPI, etc via language extensions ^ template metaprogramming using macros (see C++) ^ Prolog implemented as a language extension ^ Common Lisp Object System see Wikipedia article on CLOS, the Common Lisp Object System. ^ implemented by the user via a short macro, example of implementation ^ - Visual programming tool based on Common Lisp ^ rule-based programming extension ^ Archived 2018-04-26 at the Wayback Machine through the Meta Object Protocol ^ D Language Feature Table ^ Phobos std.algorithm ^ D language String Mixins ^ The Little JavaScripter demonstrates fundamental commonality with Scheme, a functional language. ^ Object-Oriented Programming in JavaScript Archived 2019-02-10 at the Wayback Machine gives an overview of object-oriented programming techniques in JavaScript. ^ \"React – A JavaScript library for building user interfaces\". 2019-04-08. ^ \"TNG-Hooks\". GitHub. 2019-04-08. ^ \"Lodash documentation\". 2019-04-08. ^ \"mori\". 2019-04-08. ^ \"Light Table\". 2019-04-08. ^ \"TNG-Hooks\". GitHub. 2019-04-08. ^ \"Prolog embedding\". Haskell.org. ^ \"Functional Reactive Programming\". HaskellWiki. ^ Cloud Haskell ^ \"Template Haskell\". HaskellWiki. ^ \"Logict: A backtracking logic-programming monad\". Haskell.org. ^ Kollmansberger, Steve; Erwig, Martin (30 May 2006). \"Haskell Rules: Embedding Rule Systems in Haskell\" (PDF). Oregon State University. ^ https://jcp.org/en/jsr/detail?id=331 JSR 331: Constraint Programming API ^ https://github.com/GoogleCloudPlatform/DataflowJavaSDK Google Cloud Platform Dataflow SDK ^ \"JuliaOpt/JuMP.jl\". GitHub. JuliaOpt. 11 February 2020. Retrieved 12 February 2020. ^ \"GitHub - MikeInnes/DataFlow.jl\". GitHub. 2019-01-15. ^ \"GitHub - JuliaGizmos/Reactive.jl: Reactive programming primitives for Julia\". GitHub. 2018-12-28. ^ https://github.com/davidanthoff/Query.jl Query almost anything in julia ^ https://github.com/lilinjn/LilKanren.jl A collection of Kanren implementations in Julia ^ \"GitHub - abeschneider/PEGParser.jl: PEG Parser for Julia\". GitHub. 2018-12-03. ^ \"GitHub - gitfoxi/Parsimonious.jl: A PEG parser generator for Julia\". GitHub. 2017-08-03. ^ Lazy https://github.com/MikeInnes/Lazy.jl ^ \"Execute loop iterations in parallel\". mathworks.com. Retrieved 21 October 2016. ^ \"Write Constraints\". mathworks.com. Retrieved 21 October 2016. ^ \"Getting Started with SimEvents\". mathworks.com. Retrieved 21 October 2016. ^ \"Execute loop iterations in parallel\". mathworks.com. Retrieved 21 October 2016. ^ \"Execute MATLAB expression in text - MATLAB eval\". mathworks.com. Retrieved 21 October 2016. ^ \"Determine class of object\". mathworks.com. Retrieved 21 October 2016. ^ \"Class Metadata\". mathworks.com. Retrieved 21 October 2016. ^ \"Object-Oriented Programming\". mathworks.com. Retrieved 21 October 2016. ^ \"Simulink\". mathworks.com. Retrieved 21 October 2016. ^ interpreter based threads ^ Higher Order Perl ^ PHP Manual, Chapter 17. Functions ^ PHP Manual, Chapter 19. Classes and Objects (PHP 5) ^ PHP Manual, Anonymous functions ^ \"Parallel Processing and Multiprocessing in Python\". Python Wiki. Retrieved 21 October 2016. ^ \"threading — Higher-level threading interface\". docs.python.org. Retrieved 21 October 2016. ^ \"python-constraint\". pypi.python.org. Retrieved 21 October 2016. ^ \"DistributedProgramming\". Python Wiki. Retrieved 21 October 2016. ^ \"Chapter 9. Metaprogramming\". chimera.labs.oreilly.com. Archived from the original on 23 October 2016. Retrieved 22 October 2016. ^ \"Metaprogramming\". readthedocs.io. Retrieved 22 October 2016. ^ \"PEP 443 – Single-dispatch generic functions\". python.org. Retrieved 22 October 2016. ^ \"PEP 484 – Type Hints\". python.org. Retrieved 22 October 2016. ^ \"PyDatalog\". Retrieved 22 October 2016. ^ \"Light Table\". 2019-04-08. ^ \"Futureverse\". ^ \"future batchtools\". ^ \"Magrittr: A Forward Pipe Operator for R\". cran.r-project.org\\access-date=13 July 2017. 17 November 2020. ^ Racket Guide: Concurrency and Synchronization ^ The Rosette Guide ^ FrTime: A Language for Reactive Programs ^ Racket Guide: Distributed Places ^ Lazy Racket ^ Channels and other mechanisms ^ \"Problem Solver module\". ^ Feed operator ^ https://github.com/perl6/doc/issues/1744#issuecomment-360565196 Cro module ^ \"Meta-programming: What, why and how\". 2011-12-14. ^ https://perl6advent.wordpress.com/2009/12/18/day-18-roles/ Parametrized Roles ^ \"Meta-object protocol (MOP)\". ^ https://docs.perl6.org/language/classtut Classes and Roles ^ \"The Rust macros guide\". Rust. Retrieved 19 January 2015. ^ \"The Rust compiler plugins guide\". Rust. Retrieved 19 January 2015. ^ The Rust Reference §6.1.3.1 ^ An Overview of the Scala Programming Language ^ Scala Language Specification ^ \"Tcl Programming/Introduction\". en.wikibooks.org. Retrieved 22 October 2016. ^ \"TCLLIB - Tcl Standard Library: snitfaq\". sourceforge.net. Retrieved 22 October 2016. ^ Notes for Programming Language Experts, Wolfram Language Documentation. ^ External Programs, Wolfram Language Documentation. References[edit] Jim Coplien, Multiparadigm Design for C++, Addison-Wesley Professional, 1998. vteProgramming paradigms (Comparison by language)ImperativeStructured Jackson structures Block-structured Modular Non-structured Procedural Programming in the large and in the small Design by contract Invariant-based Nested function Object-oriented(comparison, list) Class-based, Prototype-based, Object-based Agent Immutable object Persistent Uniform Function Call Syntax DeclarativeFunctional(comparison) Recursive Anonymous function (Partial application) Higher-order Purely functional Total Strict GADTs Dependent types Functional logic Point-free style Expression-oriented Applicative, Concatenative Function-level, Value-level Dataflow Flow-based Reactive (Functional reactive) Signals Streams Synchronous Logic Abductive logic Answer set Constraint (Constraint logic) Inductive logic Nondeterministic Ontology Probabilistic logic Query DSL Algebraic modeling Array Automata-based (Action) Command (Spacecraft) Differentiable End-user Grammar-oriented Interface description Language-oriented List comprehension Low-code Modeling Natural language Non-English-based Page description Pipes and filters Probabilistic Quantum Scientific Scripting Set-theoretic Simulation Stack-based System Tactile Templating Transformation (Graph rewriting, Production, Pattern) Visual Concurrent,distributed,parallel Actor-based Automatic mutual exclusion Choreographic programming Concurrent logic (Concurrent constraint logic) Concurrent OO Macroprogramming Multitier programming Organic computing Parallel programming models Partitioned global address space Process-oriented Relativistic programming Service-oriented Structured concurrency Metaprogramming Attribute-oriented Automatic (Inductive) Dynamic Extensible Generic Homoiconicity Interactive Macro (Hygienic) Metalinguistic abstraction Multi-stage Program synthesis (Bayesian, Inferential, by demonstration, by example) Reflective Self-modifying code Symbolic Template Separationof concerns Aspects Components Data-driven Data-oriented Event-driven Features Intentional Literate Roles Subjects vteTypes of programming languagesLevel Machine Assembly Compiled Interpreted Low-level High-level Very high-level Esoteric Generation First Second Third Fourth Fifth"
    },
    {
        "id": 6,
        "url": "https://en.wikipedia.org/wiki/Object-oriented",
        "title": "Object-oriented programming",
        "content": "Programming paradigm based on the concept of objects \"Object-oriented\" redirects here. For other meanings of object-oriented, see Object-orientation. UML notation for a class. This Button class has variables for data, and functions. Through inheritance, a subclass can be created as a subset of the Button class. Objects are instances of a class. Object-oriented programming (OOP) is a programming paradigm based on the concept of objects, which can contain data and code: data in the form of fields (often known as attributes or properties), and code in the form of procedures (often known as methods). In OOP, computer programs are designed by making them out of objects that interact with one another. Many of the most widely used programming languages (such as C++, Java, and Python) are multi-paradigm and support object-oriented programming to a greater or lesser degree, typically in combination with imperative programming and declarative programming. Significant object-oriented languages include Ada, ActionScript, C++, Common Lisp, C#, Dart, Eiffel, Fortran 2003, Haxe, Java, JavaScript, Kotlin, Logo, MATLAB, Objective-C, Object Pascal, Perl, PHP, Python, R, Raku, Ruby, Scala, SIMSCRIPT, Simula, Smalltalk, Swift, Vala and Visual Basic.NET. History[edit] Terminology invoking \"objects\" in the modern sense of object-oriented programming made its first appearance at the artificial intelligence group at MIT in the late 1950s and early 1960s. \"Object\" referred to LISP atoms with identified properties (attributes). Another early MIT example was Sketchpad created by Ivan Sutherland in 1960–1961; in the glossary of the 1963 technical report based on his dissertation about Sketchpad, Sutherland defined notions of \"object\" and \"instance\" (with the class concept covered by \"master\" or \"definition\"), albeit specialized to graphical interaction. Also, in 1968, an MIT ALGOL version, AED-0, established a direct link between data structures (\"plexes\", in that dialect) and procedures, prefiguring what were later termed \"messages\", \"methods\", and \"member functions\". Topics such as data abstraction and modular programming were common points of discussion at this time. Independently of later MIT work such as AED, Simula was developed during the years 1961–1967. Simula introduced important concepts that are today an essential part of object-oriented programming, such as class and object, inheritance, and dynamic binding. The object-oriented Simula programming language was used mainly by researchers involved with physical modelling, such as models to study and improve the movement of ships and their content through cargo ports. I thought of objects being like biological cells and/or individual computers on a network, only able to communicate with messages (so messaging came at the very beginning – it took a while to see how to do messaging in a programming language efficiently enough to be useful). Alan Kay, Influenced by the work at MIT and the Simula language, in November 1966 Alan Kay began working on ideas that would eventually be incorporated into the Smalltalk programming language. Kay used the term \"object-oriented programming\" in conversation as early as 1967. Although sometimes called \"the father of object-oriented programming\", Alan Kay has differentiated his notion of OO from the more conventional abstract data type notion of object, and has implied that the computer science establishment did not adopt his notion. A 1976 MIT memo co-authored by Barbara Liskov lists Simula 67, CLU, and Alphard as object-oriented languages, but does not mention Smalltalk. In the 1970s, the first version of the Smalltalk programming language was developed at Xerox PARC by Alan Kay, Dan Ingalls and Adele Goldberg. Smalltalk-72 included a programming environment and was dynamically typed, and at first was interpreted, not compiled. Smalltalk became noted for its application of object orientation at the language-level and its graphical development environment. Smalltalk went through various versions and interest in the language grew. While Smalltalk was influenced by the ideas introduced in Simula 67 it was designed to be a fully dynamic system in which classes could be created and modified dynamically. During the late 1970s and 1980s, object-oriented programming rose to prominence. The Flavors object-oriented Lisp was developed starting 1979, introducing multiple inheritance and mixins. In 1981, Goldberg edited the August issue of Byte Magazine, introducing Smalltalk and object-oriented programming to a wide audience. LOOPS, the object system for Interlisp-D, was influenced by Smalltalk and Flavors, and a paper about it was published in 1982. In 1986, the Association for Computing Machinery organized the first Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), which was attended by 1,000 people. Among other developments was the Common Lisp Object System, which integrates functional programming and object-oriented programming and allows extension via a Meta-object protocol. In the 1980s, there were a few attempts to design processor architectures that included hardware support for objects in memory but these were not successful. Examples include the Intel iAPX 432 and the Linn Smart Rekursiv. In the mid-1980s Objective-C was developed by Brad Cox, who had used Smalltalk at ITT Inc.. Bjarne Stroustrup, who had used Simula for his PhD thesis, created the object-oriented C++. In 1985, Bertrand Meyer also produced the first design of the Eiffel language. Focused on software quality, Eiffel is a purely object-oriented programming language and a notation supporting the entire software lifecycle. Meyer described the Eiffel software development method, based on a small number of key ideas from software engineering and computer science, in Object-Oriented Software Construction. Essential to the quality focus of Eiffel is Meyer's reliability mechanism, design by contract, which is an integral part of both the method and language. In the early and mid-1990s object-oriented programming developed as the dominant programming paradigm when programming languages supporting the techniques became widely available. These included Visual FoxPro 3.0, C++, and Delphi[citation needed]. Its dominance was further enhanced by the rising popularity of graphical user interfaces, which rely heavily upon object-oriented programming techniques. An example of a closely related dynamic GUI library and OOP language can be found in the Cocoa frameworks on Mac OS X, written in Objective-C, an object-oriented, dynamic messaging extension to C based on Smalltalk. OOP toolkits also enhanced the popularity of event-driven programming (although this concept is not limited to OOP). At ETH Zürich, Niklaus Wirth and his colleagues investigated the concept of type checking across module boundaries. Modula-2 (1978) included this concept, and their succeeding design, Oberon (1987), included a distinctive approach to object orientation, classes, and such. Inheritance is not obvious in Wirth's design since his nomenclature looks in the opposite direction: It is called type extension and the viewpoint is from the parent down to the inheritor. Object-oriented features have been added to many previously existing languages, including Ada, BASIC, Fortran, Pascal, and COBOL. Adding these features to languages that were not initially designed for them often led to problems with compatibility and maintainability of code. More recently, some languages have emerged that are primarily object-oriented, but that are also compatible with procedural methodology. Two such languages are Python and Ruby. Probably the most commercially important recent object-oriented languages are Java, developed by Sun Microsystems, as well as C# and Visual Basic.NET (VB.NET), both designed for Microsoft's .NET platform. Each of these two frameworks shows, in its way, the benefit of using OOP by creating an abstraction from implementation. VB.NET and C# support cross-language inheritance, allowing classes defined in one language to subclass classes defined in the other language. Features[edit] See also: Comparison of programming languages (object-oriented programming) and List of object-oriented programming terms Object-oriented programming uses objects, but not all of the associated techniques and structures are supported directly in languages that claim to support OOP. The features listed below are common among languages considered to be strongly class- and object-oriented (or multi-paradigm with OOP support), with notable exceptions mentioned. Christopher J. Date stated that critical comparison of OOP to other technologies, relational in particular, is difficult because of lack of an agreed-upon and rigorous definition of OOP. Shared with non-OOP languages[edit] Variables that can store information formatted in a small number of built-in data types like integers and alphanumeric characters. This may include data structures like strings, lists, and hash tables that are either built-in or result from combining variables using memory pointers. Procedures – also known as functions, methods, routines, or subroutines – that take input, generate output, and manipulate data. Modern languages include structured programming constructs like loops and conditionals. Modular programming support provides the ability to group procedures into files and modules for organizational purposes. Modules are namespaced so identifiers in one module will not conflict with a procedure or variable sharing the same name in another file or module. Objects[edit] Main article: Object (computer science) An object is a data structure or abstract data type containing fields (state variables containing data) and methods (subroutines or procedures defining the object's behavior in code). Fields may also be known as members, attributes, or properties. Objects are typically stored as contiguous regions of memory. Objects are accessed somewhat like variables with complex internal structures, and in many languages are effectively pointers, serving as actual references to a single instance of said object in memory within a heap or stack. Objects sometimes correspond to things found in the real world. For example, a graphics program may have objects such as \"circle\", \"square\", and \"menu\". An online shopping system might have objects such as \"shopping cart\", \"customer\", and \"product\". Sometimes objects represent more abstract entities, like an object that represents an open file, or an object that provides the service of translating measurements from U.S. customary to metric. Objects can contain other objects in their instance variables; this is known as object composition. For example, an object in the Employee class might contain (either directly or through a pointer) an object in the Address class, in addition to its own instance variables like \"first_name\" and \"position\". Object composition is used to represent \"has-a\" relationships: every employee has an address, so every Employee object has access to a place to store an Address object (either directly embedded within itself or at a separate location addressed via a pointer). Date and Darwen have proposed a theoretical foundation that uses OOP as a kind of customizable type system to support RDBMS, but it forbids object pointers. The OOP paradigm has been criticized for overemphasizing the use of objects for software design and modeling at the expense of other important aspects (computation/algorithms). For example, Rob Pike has said that OOP languages frequently shift the focus from data structures and algorithms to types. Steve Yegge noted that, as opposed to functional programming: Object Oriented Programming puts the nouns first and foremost. Why would you go to such lengths to put one part of speech on a pedestal? Why should one kind of concept take precedence over another? It's not as if OOP has suddenly made verbs less important in the way we actually think. It's a strangely skewed perspective. Rich Hickey, creator of Clojure, described object systems as overly simplistic models of the real world. He emphasized the inability of OOP to model time properly, which is getting increasingly problematic as software systems become more concurrent. Alexander Stepanov compares object orientation unfavourably to generic programming: I find OOP technically unsound. It attempts to decompose the world in terms of interfaces that vary on a single type. To deal with the real problems you need multisorted algebras — families of interfaces that span multiple types. I find OOP philosophically unsound. It claims that everything is an object. Even if it is true it is not very interesting — saying that everything is an object is saying nothing at all. Inheritance[edit] OOP languages typically allow inheritance for code reuse and extensibility in the form of either classes or prototypes. These forms of inheritance are significantly different, but analogous terminology is used to define the concepts of object and instance. Class-based[edit] In class-based programming, the most popular style, each object is required to be an instance of a particular class. The class defines the data format or type (including member variables and their types) and available procedures (class methods or member functions) for a given type or class of object. Objects are created by calling a special type of method in the class known as a constructor. Classes may inherit from other classes, so they are arranged in a hierarchy that represents \"is-a-type-of\" relationships. For example, class Employee might inherit from class Person. All the data and methods available to the parent class also appear in the child class with the same names. For example, class Person might define variables \"first_name\" and \"last_name\" with method \"make_full_name()\". These will also be available in class Employee, which might add the variables \"position\" and \"salary\". It is guaranteed that all instances of class Employee will have the same variables, such as the name, position, and salary. Procedures and variables can be specific to either the class or the instance; this leads to the following terms: Class variables – belong to the class as a whole; there is only one copy of each variable, shared across all instances of the class Instance variables or attributes – data that belongs to individual objects; every object has its own copy of each one. All 4 variables mentioned above (first_name, position etc) are instance variables. Member variables – refers to both the class and instance variables that are defined by a particular class. Class methods – belong to the class as a whole and have access to only class variables and inputs from the procedure call Instance methods – belong to individual objects, and have access to instance variables for the specific object they are called on, inputs, and class variables Depending on the definition of the language, subclasses may or may not be able to override the methods defined by superclasses. Multiple inheritance is allowed in some languages, though this can make resolving overrides complicated. Some languages have special support for other concepts like traits and mixins, though, in any language with multiple inheritance, a mixin is simply a class that does not represent an is-a-type-of relationship. Mixins are typically used to add the same methods to multiple classes. For example, class UnicodeConversionMixin might provide a method unicode_to_ascii() when included in class FileReader and class WebPageScraper, which do not share a common parent. Abstract classes cannot be instantiated into objects; they exist only for inheritance into other \"concrete\" classes that can be instantiated. In Java, the final keyword can be used to prevent a class from being subclassed. Prototype-based[edit] In contrast, in prototype-based programming, objects are the primary entities. Generally, the concept of a \"class\" does not even exist. Rather, the prototype or parent of an object is just another object to which the object is linked. In Self, an object may have multiple or no parents, but in the most popular prototype-based language, Javascript, every object has one prototype link (and only one). New objects can be created based on already existing objects chosen as their prototype. You may call two different objects apple and orange a fruit if the object fruit exists, and both apple and orange have fruit as their prototype. The idea of the fruit class does not exist explicitly, but can be modeled as the equivalence class of the objects sharing the same prototype, or as the set of objects satisfying a certain interface (duck typing). Unlike class-based programming, it is typically possible in prototype-based languages to define attributes and methods not shared with other objects; for example, the attribute sugar_content may be defined in apple but not orange. Absence[edit] Some languages like Go do not support inheritance at all. Go states that it is object-oriented, and Bjarne Stroustrup, author of C++, has stated that it is possible to do OOP without inheritance. The doctrine of composition over inheritance advocates implementing has-a relationships using composition instead of inheritance. For example, instead of inheriting from class Person, class Employee could give each Employee object an internal Person object, which it then has the opportunity to hide from external code even if class Person has many public attributes or methods. Delegation is another language feature that can be used as an alternative to inheritance. Rob Pike has criticized the OO mindset for preferring a multilevel type hierarchy with layered abstractions to a three-line lookup table. He has called object-oriented programming \"the Roman numerals of computing\". Bob Martin states that because they are software, related classes do not necessarily share the relationships of the things they represent. Dynamic dispatch/message passing[edit] It is the responsibility of the object, not any external code, to select the procedural code to execute in response to a method call, typically by looking up the method at run time in a table associated with the object. This feature is known as dynamic dispatch. If the call variability relies on more than the single type of the object on which it is called (i.e. at least one other parameter object is involved in the method choice), one speaks of multiple dispatch. A method call is also known as message passing. It is conceptualized as a message (the name of the method and its input parameters) being passed to the object for dispatch. Dispatch interacts with inheritance; if a method is not present in a given object or class, the dispatch is delegated to its parent object or class, and so on, going up the chain of inheritance. Data abstraction and encapsulation[edit] Data abstraction is a design pattern in which data are visible only to semantically related functions, to prevent misuse. The success of data abstraction leads to frequent incorporation of data hiding as a design principle in object-oriented and pure functional programming. Similarly, encapsulation prevents external code from being concerned with the internal workings of an object. This facilitates code refactoring, for example allowing the author of the class to change how objects of that class represent their data internally without changing any external code (as long as \"public\" method calls work the same way). It also encourages programmers to put all the code that is concerned with a certain set of data in the same class, which organizes it for easy comprehension by other programmers. Encapsulation is a technique that encourages decoupling. In object oriented programming, objects provide a layer which can be used to separate internal from external code and implement abstraction and encapsulation. External code can only use an object by calling a specific instance method with a certain set of input parameters, reading an instance variable, or writing to an instance variable. A program may create many instances of objects as it runs, which operate independently. This technique, it is claimed, allows easy re-use of the same procedures and data definitions for different sets of data, in addition to potentially mirroring real-world relationships intuitively. Rather than utilizing database tables and programming subroutines, the developer utilizes objects the user may be more familiar with: objects from their application domain. These claims that the OOP paradigm enhances reusability and modularity have been criticized. The initial design is encouraged to use the most restrictive visibility possible, in order of local (or method) variables, private variables (in object oriented programming), and global (or public) variables, and only be expanded when and as much as necessary. This prevents changes to visibility from invalidating existing code. If a class does not allow calling code to access internal object data and permits access through methods only, this is also a form of information hiding. Some languages (Java, for example) let classes enforce access restrictions explicitly, for example, denoting internal data with the private keyword and designating methods intended for use by code outside the class with the public keyword. Methods may also be designed public, private, or intermediate levels such as protected (which allows access from the same class and its subclasses, but not objects of a different class). In other languages (like Python) this is enforced only by convention (for example, private methods may have names that start with an underscore). In C#, Swift & Kotlin languages, internal keyword permits access only to files present in the same assembly, package, or module as that of the class. In programming languages, particularly object-oriented ones, the emphasis on abstraction is vital. Object-oriented languages extend the notion of type to incorporate data abstraction, highlighting the significance of restricting access to internal data through methods. Eric S. Raymond has written that object-oriented programming languages tend to encourage thickly layered programs that destroy transparency. Raymond compares this unfavourably to the approach taken with Unix and the C programming language. The \"open/closed principle\" advocates that classes and functions \"should be open for extension, but closed for modification\". Luca Cardelli has claimed that OOP languages have \"extremely poor modularity properties with respect to class extension and modification\", and tend to be extremely complex. The latter point is reiterated by Joe Armstrong, the principal inventor of Erlang, who is quoted as saying: The problem with object-oriented languages is they've got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle. Leo Brodie has suggested a connection between the standalone nature of objects and a tendency to duplicate code in violation of the don't repeat yourself principle of software development. Polymorphism[edit] Subtyping – a form of polymorphism – is when calling code can be independent of which class in the supported hierarchy it is operating on – the parent class or one of its descendants. Meanwhile, the same operation name among objects in an inheritance hierarchy may behave differently. For example, objects of the type Circle and Square are derived from a common class called Shape. The Draw function for each type of Shape implements what is necessary to draw itself while calling code can remain indifferent to the particular type of Shape being drawn. This is another type of abstraction that simplifies code external to the class hierarchy and enables strong separation of concerns. Open recursion[edit] A common feature of objects is that methods are attached to them and can access and modify the object's data fields. In this brand of OOP, there is usually a special name such as this or self used to refer to the current object. In languages that support open recursion, object methods can call other methods on the same object (including themselves) using this name. This variable is late-bound; it allows a method defined in one class to invoke another method that is defined later, in some subclass thereof. OOP languages[edit] This section does not cite any sources. Please help improve this section by adding citations to reliable sources. Unsourced material may be challenged and removed. (August 2009) (Learn how and when to remove this message) See also: List of object-oriented programming languages Simula (1967) is generally accepted as being the first language with the primary features of an object-oriented language. It was created for making simulation programs, in which what came to be called objects were the most important information representation. Smalltalk (1972 to 1980) is another early example and the one with which much of the theory of OOP was developed. Concerning the degree of object orientation, the following distinctions can be made: Languages called \"pure\" OO languages, because everything in them is treated consistently as an object, from primitives such as characters and punctuation, all the way up to whole classes, prototypes, blocks, modules, etc. They were designed specifically to facilitate, even enforce, OO methods. Examples: Ruby, Scala, Smalltalk, Eiffel, Emerald, JADE, Self, Raku. Languages designed mainly for OO programming, but with some procedural elements. Examples: Java, Python, C++, C#, Delphi/Object Pascal, VB.NET. Languages that are historically procedural languages, but have been extended with some OO features. Examples: PHP, JavaScript, Perl, Visual Basic (derived from BASIC), MATLAB, COBOL 2002, Fortran 2003, ABAP, Ada 95, Pascal. Languages with most of the features of objects (classes, methods, inheritance), but in a distinctly original form. Examples: Oberon (Oberon-1 or Oberon-2). Languages with abstract data type support which may be used to resemble OO programming, but without all features of object-orientation. This includes object-based and prototype-based languages. Examples: JavaScript, Lua, Modula-2, CLU. Chameleon languages that support multiple paradigms, including OO. Tcl stands out among these for TclOO, a hybrid object system that supports both prototype-based programming and class-based OO. Popularity and reception[edit] The TIOBE programming language popularity index graph from 2002 to 2023. In the 2000s the object-oriented Java (orange) and the procedural C (dark blue) competed for the top position. Many widely used languages, such as C++, Java, and Python, provide object-oriented features. Although in the past object-oriented programming was widely accepted, more recently essays criticizing object-oriented programming and recommending the avoidance of these features (generally in favor of functional programming) have been very popular in the developer community. Paul Graham has suggested that OOP's popularity within large companies is due to \"large (and frequently changing) groups of mediocre programmers\". According to Graham, the discipline imposed by OOP prevents any one programmer from \"doing too much damage\". Eric S. Raymond, a Unix programmer and open-source software advocate, has been critical of claims that present object-oriented programming as the \"One True Solution\". Richard Feldman argues that these languages may have improved their modularity by adding OO features, but they became popular for reasons other than being object-oriented. In an article, Lawrence Krubner claimed that compared to other languages (LISP dialects, functional languages, etc.) OOP languages have no unique strengths, and inflict a heavy burden of unneeded complexity. A study by Potok et al. has shown no significant difference in productivity between OOP and procedural approaches. Luca Cardelli has claimed that OOP code is \"intrinsically less efficient\" than procedural code and that OOP can take longer to compile. OOP in dynamic languages[edit] In recent years, object-oriented programming has become especially popular in dynamic programming languages. Python, PowerShell, Ruby and Groovy are dynamic languages built on OOP principles, while Perl and PHP have been adding object-oriented features since Perl 5 and PHP 4, and ColdFusion since version 6. The Document Object Model of HTML, XHTML, and XML documents on the Internet has bindings to the popular JavaScript/ECMAScript language. JavaScript is perhaps the best known prototype-based programming language, which employs cloning from prototypes rather than inheriting from a class (contrast to class-based programming). Another scripting language that takes this approach is Lua. OOP in a network protocol[edit] The messages that flow between computers to request services in a client-server environment can be designed as the linearizations of objects defined by class objects known to both the client and the server. For example, a simple linearized object would consist of a length field, a code point identifying the class, and a data value. A more complex example would be a command consisting of the length and code point of the command and values consisting of linearized objects representing the command's parameters. Each such command must be directed by the server to an object whose class (or superclass) recognizes the command and can provide the requested service. Clients and servers are best modeled as complex object-oriented structures. Distributed Data Management Architecture (DDM) took this approach and used class objects to define objects at four levels of a formal hierarchy: Fields defining the data values that form messages, such as their length, code point and data values. Objects and collections of objects similar to what would be found in a Smalltalk program for messages and parameters. Managers similar to IBM i Objects, such as a directory to files and files consisting of metadata and records. Managers conceptually provide memory and processing resources for their contained objects. A client or server consisting of all the managers necessary to implement a full processing environment, supporting such aspects as directory services, security, and concurrency control. The initial version of DDM defined distributed file services. It was later extended to be the foundation of Distributed Relational Database Architecture (DRDA). Design patterns[edit] One way to address challenges of object-oriented design is via design patterns which are solution patterns to commonly occurring problems in software design. Some of these commonly occurring problems have implications and solutions particular to object-oriented development. Object patterns[edit] The following are notable software design patterns for OOP objects. Function object: with a single method (in C++, the function operator, operator()) it acts much like a function Immutable object: does not change state after creation First-class object: can be used without restriction Container object: contains other objects Factory object: creates other objects Metaobject: from which other objects can be created (compare with a class, which is not necessarily an object) Prototype object: a specialized metaobject from which other objects can be created by copying Singleton object: only instance of its class for the lifetime of the program Filter object: receives a stream of data as its input and transforms it into the object's output As an example of an object anti-pattern, the God object knows or does too much. Inheritance and behavioral subtyping[edit] See also: Object-oriented design It is intuitive to assume that inheritance creates a semantic \"is a\" relationship, and thus to infer that objects instantiated from subclasses can always be safely used instead of those instantiated from the superclass. This intuition is unfortunately false in most OOP languages, in particular in all those that allow mutable objects. Subtype polymorphism as enforced by the type checker in OOP languages (with mutable objects) cannot guarantee behavioral subtyping in any context. Behavioral subtyping is undecidable in general, so it cannot be implemented by a program (compiler). Class or object hierarchies must be carefully designed, considering possible incorrect uses that cannot be detected syntactically. This issue is known as the Liskov substitution principle. Gang of Four design patterns[edit] Main article: Design pattern (computer science) Design Patterns: Elements of Reusable Object-Oriented Software is an influential book published in 1994 by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, often referred to humorously as the \"Gang of Four\". Along with exploring the capabilities and pitfalls of object-oriented programming, it describes 23 common programming problems and patterns for solving them. The book describes the following patterns: Creational patterns (5): Factory method pattern, Abstract factory pattern, Singleton pattern, Builder pattern, Prototype pattern Structural patterns (7): Adapter pattern, Bridge pattern, Composite pattern, Decorator pattern, Facade pattern, Flyweight pattern, Proxy pattern Behavioral patterns (11): Chain-of-responsibility pattern, Command pattern, Interpreter pattern, Iterator pattern, Mediator pattern, Memento pattern, Observer pattern, State pattern, Strategy pattern, Template method pattern, Visitor pattern Object-orientation and databases[edit] Main articles: Object-relational impedance mismatch, Object-relational mapping, and Object database Both object-oriented programming and relational database management systems (RDBMSs) are extremely common in software today[update]. Since relational databases do not store objects directly (though some RDBMSs have object-oriented features to approximate this), there is a general need to bridge the two worlds. The problem of bridging object-oriented programming accesses and data patterns with relational databases is known as object-relational impedance mismatch. There are some approaches to cope with this problem, but no general solution without downsides. One of the most common approaches is object-relational mapping, as found in IDE languages such as Visual FoxPro and libraries such as Java Data Objects and Ruby on Rails' ActiveRecord. There are also object databases that can be used to replace RDBMSs, but these have not been as technically and commercially successful as RDBMSs. Real-world modeling and relationships[edit] OOP can be used to associate real-world objects and processes with digital counterparts. However, not everyone agrees that OOP facilitates direct real-world mapping or that real-world mapping is even a worthy goal; Bertrand Meyer argues in Object-Oriented Software Construction that a program is not a model of the world but a model of some part of the world; \"Reality is a cousin twice removed\". At the same time, some principal limitations of OOP have been noted. For example, the circle-ellipse problem is difficult to handle using OOP's concept of inheritance. However, Niklaus Wirth (who popularized the adage now known as Wirth's law: \"Software is getting slower more rapidly than hardware becomes faster\") said of OOP in his paper, \"Good Ideas through the Looking Glass\", \"This paradigm closely reflects the structure of systems in the real world and is therefore well suited to model complex systems with complex behavior\" (contrast KISS principle). Steve Yegge and others noted that natural languages lack the OOP approach of strictly prioritizing things (objects/nouns) before actions (methods/verbs). This problem may cause OOP to suffer more convoluted solutions than procedural programming. OOP and control flow[edit] OOP was developed to increase the reusability and maintainability of source code. Transparent representation of the control flow had no priority and was meant to be handled by a compiler. With the increasing relevance of parallel hardware and multithreaded coding, developing transparent control flow becomes more important, something hard to achieve with OOP. Responsibility- vs. data-driven design[edit] Responsibility-driven design defines classes in terms of a contract, that is, a class should be defined around a responsibility and the information that it shares. This is contrasted by Wirfs-Brock and Wilkerson with data-driven design, where classes are defined around the data-structures that must be held. The authors hold that responsibility-driven design is preferable. SOLID and GRASP guidelines[edit] SOLID is a mnemonic invented by Michael Feathers which spells out five software engineering design principles: Single responsibility principle Open/closed principle Liskov substitution principle Interface segregation principle Dependency inversion principle GRASP (General Responsibility Assignment Software Patterns) is another set of guidelines advocated by Craig Larman. Formal semantics[edit] See also: Formal semantics of programming languages Objects are the run-time entities in an object-oriented system. They may represent a person, a place, a bank account, a table of data, or any item that the program has to handle. There have been several attempts at formalizing the concepts used in object-oriented programming. The following concepts and constructs have been used as interpretations of OOP concepts: co algebraic data types recursive types encapsulated state inheritance records are the basis for understanding objects if function literals can be stored in fields (like in functional-programming languages), but the actual calculi need be considerably more complex to incorporate essential features of OOP. Several extensions of System F<: that deal with mutable objects have been studied; these allow both subtype polymorphism and parametric polymorphism (generics) Attempts to find a consensus definition or theory behind objects have not proven very successful (however, see Abadi & Cardelli, A Theory of Objects for formal definitions of many OOP concepts and constructs), and often diverge widely. For example, some definitions focus on mental activities, and some on program structuring. One of the simpler definitions is that OOP is the act of using \"map\" data structures or arrays that can contain functions and pointers to other maps, all with some syntactic and scoping sugar on top. Inheritance can be performed by cloning the maps (sometimes called \"prototyping\"). Systems[edit] CADES Common Object Request Broker Architecture (CORBA) Distributed Component Object Model Distributed Data Management Architecture Jeroo Modeling languages[edit] IDEF4 Interface description language UML See also[edit] Computer programming portal Comparison of programming languages (object-oriented programming) Component-based software engineering Object association Object modeling language Object-oriented analysis and design Object-oriented ontology References[edit] ^ a b c d \"Dr. Alan Kay on the Meaning of \"Object-Oriented Programming\"\". 2003. Retrieved 11 February 2010. ^ Kindler, E.; Krivy, I. (2011). \"Object-Oriented Simulation of systems with sophisticated control\". International Journal of General Systems. 40 (3): 313–343. doi:10.1080/03081079.2010.539975. ^ Lewis, John; Loftus, William (2008). Java Software Solutions Foundations of Programming Design 6th ed. Pearson Education Inc. ISBN 978-0-321-53205-3., section 1.6 \"Object-Oriented Programming\" ^ a b Bloch 2018, pp. xi–xii, Foreword. ^ McCarthy, J.; Brayton, R.; Edwards, D.; Fox, P.; Hodes, L.; Luckham, D.; Maling, K.; Park, D.; Russell, S. (March 1969). \"LISP I Programmers Manual\" (PDF). Computation Center and Research Laboratory of Electronics. Boston, Massachusetts: Artificial Intelligence Group, M.I.T. Computation Center and Research Laboratory: 88f. Archived from the original (PDF) on 17 July 2010. In the local M.I.T. patois, association lists [of atomic symbols] are also referred to as \"property lists\", and atomic symbols are sometimes called \"objects\". ^ McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart, swapnil d.; Levin, Michael I. (1962). LISP 1.5 Programmer's Manual. MIT Press. p. 105. ISBN 978-0-262-13011-0. Object — a synonym for atomic symbol ^ Ivan E. Sutherland (May 1963). Sketchpad: a man-machine graphical communication system. AFIPS '63 (Spring): Proceedings of the May 21–23, 1963 Spring Joint Computer Conference. AFIPS Press. pp. 329–346. doi:10.1145/1461551.1461591. ^ a b Kristen Nygaard; Ole-Johan Dahl (1 August 1978). \"The development of the SIMULA languages\". ACM SIGPLAN Notices. 13 (8): 245–272. doi:10.1145/960118.808391. ^ Ross, Doug. \"The first software engineering language\". LCS/AI Lab Timeline. MIT Computer Science and Artificial Intelligence Laboratory. Retrieved 13 May 2010. ^ a b Holmevik, Jan Rune (Winter 1994). \"Compiling Simula: A historical study of technological genesis\" (PDF). IEEE Annals of the History of Computing. 16 (4): 25–37. doi:10.1109/85.329756. S2CID 18148999. Archived from the original (PDF) on 30 August 2017. Retrieved 3 March 2018. ^ Butcher, Paul (30 June 2014). Seven Concurrency Models in Seven Weeks: When Threads Unravel. Pragmatic Bookshelf. p. 204. ISBN 978-1-68050-466-8. ^ Jones, Anita K.; Liskov, Barbara H. (April 1976). An Access Control Facility for Programming Languages (PDF) (Technical report). MIT. CSG Memo 137. ^ a b Bertrand Meyer (2009). Touch of Class: Learning to Program Well with Objects and Contracts. Springer Science & Business Media. p. 329. Bibcode:2009tclp.book.....M. ISBN 978-3-540-92144-8. ^ Alan C. Kay (March 1993). \"The early history of Smalltalk\". ACM SIGPLAN Notices. 28 (3): 69–95. doi:10.1145/155360.155364. ^ Moon, David A. (June 1986). \"Object-Oriented Programming with Flavors\" (PDF). Conference proceedings on Object-oriented Programming Systems Languages and Applications. OOPSLA '86. pp. 1–8. doi:10.1145/28697.28698. ISBN 978-0-89791-204-4. S2CID 17150741. Retrieved 17 March 2022. ^ \"Introducing the Smalltalk Zoo\". CHM. 17 December 2020. ^ Bobrow, D. G.; Stefik, M. J (1982). LOOPS: data and object oriented Programming for Interlisp (PDF). European AI Conference. ^ Meyer 1997. ^ 1995 (June) Visual FoxPro 3.0, FoxPro evolves from a procedural language to an object-oriented language. Visual FoxPro 3.0 introduces a database container, seamless client/server capabilities, support for ActiveX technologies, and OLE Automation and null support. Summary of Fox releases ^ 1995 Reviewers Guide to Visual FoxPro 3.0: DFpug.de ^ Khurana, Rohit (1 November 2009). Object Oriented Programming with C++, 1E. Vikas Publishing House Pvt Limited. ISBN 978-81-259-2532-3. ^ Deborah J. Armstrong. The Quarks of Object-Oriented Development. A survey of nearly 40 years of computing literature identified several fundamental concepts found in the large majority of definitions of OOP, in descending order of popularity: Inheritance, Object, Class, Encapsulation, Method, Message Passing, Polymorphism, and Abstraction. ^ John C. Mitchell, Concepts in programming languages, Cambridge University Press, 2003, ISBN 0-521-78098-5, p.278. Lists: Dynamic dispatch, abstraction, subtype polymorphism, and inheritance. ^ Michael Lee Scott, Programming language pragmatics, Edition 2, Morgan Kaufmann, 2006, ISBN 0-12-633951-1, p. 470. Lists encapsulation, inheritance, and dynamic dispatch. ^ Pierce, Benjamin (2002). Types and Programming Languages. MIT Press. ISBN 978-0-262-16209-8., section 18.1 \"What is Object-Oriented Programming?\" Lists: Dynamic dispatch, encapsulation or multi-methods (multiple dispatch), subtype polymorphism, inheritance or delegation, open recursion (\"this\"/\"self\") ^ C. J. Date, Introduction to Database Systems, 6th-ed., Page 650 ^ Booch, Grady (1986). Software Engineering with Ada. Addison Wesley. p. 220. ISBN 978-0-8053-0608-8. Perhaps the greatest strength of an object-oriented approach to development is that it offers a mechanism that captures a model of the real world. ^ C. J. Date, Hugh Darwen. Foundation for Future Database Systems: The Third Manifesto (2nd Edition) ^ a b Stepanov, Alexander. \"STLport: An Interview with A. Stepanov\". Retrieved 21 April 2010. ^ a b Rich Hickey, JVM Languages Summit 2009 keynote, Are We There Yet? November 2009. ^ Pike, Rob (25 June 2012). \"Less is exponentially more\". Retrieved 1 October 2016. ^ \"Stevey's Blog Rants: Execution in the Kingdom of Nouns\". Retrieved 20 May 2020. ^ Bloch 2018, p. 19, Chapter §2 Item 4 Enforce noninstantiability with a private constructor. ^ Dony, C; Malenfant, J; Bardon, D (1999). \"Classifying prototype-based programming languages\" (PDF). Prototype-based programming: concepts, languages and applications. Singapore Berlin Heidelberg: Springer. ISBN 9789814021258. ^ \"Is Go an object-oriented language?\". Retrieved 13 April 2019. Although Go has types and methods and allows an object-oriented style of programming, there is no type hierarchy. ^ Stroustrup, Bjarne (2015). Object-Oriented Programming without Inheritance (Invited Talk). 29th European Conference on Object-Oriented Programming (ECOOP 2015). 1:34. doi:10.4230/LIPIcs.ECOOP.2015.1. ^ Pike, Rob (14 November 2012). \"A few years ago I saw this page\". Archived from the original on 14 August 2018. Retrieved 1 October 2016. ^ Pike, Rob (2 March 2004). \"[9fans] Re: Threads: Sewing badges of honor onto a Kernel\". comp.os.plan9 (Mailing list). Retrieved 17 November 2016. ^ \"Uncle Bob SOLID principles\". YouTube. 2 August 2018. ^ Jacobsen, Ivar; Magnus Christerson; Patrik Jonsson; Gunnar Overgaard (1992). Object Oriented Software Engineering. Addison-Wesley ACM Press. pp. 43–69. ISBN 978-0-201-54435-0. ^ a b c Cardelli, Luca (1996). \"Bad Engineering Properties of Object-Oriented Languages\". ACM Comput. Surv. 28 (4es): 150–es. doi:10.1145/242224.242415. ISSN 0360-0300. S2CID 12105785. Retrieved 21 April 2010. ^ a b Armstrong, Joe. In Coders at Work: Reflections on the Craft of Programming. Peter Seibel, ed. Codersatwork.com Archived 5 March 2010 at the Wayback Machine, Accessed 13 November 2009. ^ McDonough, James E. (2017). \"Encapsulation\". Object-Oriented Design with ABAP: A Practical Approach. Apress. doi:10.1007/978-1-4842-2838-8. ISBN 978-1-4842-2837-1 – via O'Reilly.{{cite book}}: CS1 maint: date and year (link) ^ a b Bloch 2018, pp. 73–77, Chapter §4 Item15 Minimize the accessibility of classes and members. ^ \"What is Object Oriented Programming (OOP) In Simple Words? – Software Geek Bytes\". 5 January 2023. Retrieved 17 January 2023. ^ Cardelli, Luca; Wegner, Peter (10 December 1985). \"On understanding types, data abstraction, and polymorphism\". ACM Computing Surveys. 17 (4): 471–523. doi:10.1145/6041.6042. ISSN 0360-0300. ^ a b c Eric S. Raymond (2003). \"The Art of Unix Programming: Unix and Object-Oriented Languages\". Retrieved 6 August 2014. ^ Brodie, Leo (1984). Thinking Forth (PDF). pp. 92–93. Retrieved 4 May 2018. ^ Hunt, Andrew. \"Don't Repeat Yourself\". Category Extreme Programming. Retrieved 4 May 2018. ^ \"The Emerald Programming Language\". 26 February 2011. ^ Brucker, Achim D.; Wolff, Burkhart (2008). \"Extensible Universes for Object-Oriented Data Models\". ECOOP 2008 – Object-Oriented Programming. Lecture Notes in Computer Science. Vol. 5142. pp. 438–462. doi:10.1007/978-3-540-70592-5_19. ISBN 978-3-540-70591-8. object-oriented programming is a widely accepted programming paradigm ^ Cassel, David (21 August 2019). \"Why Are So Many Developers Hating on Object-Oriented Programming?\". The New Stack. ^ Graham, Paul. \"Why ARC isn't especially Object-Oriented\". PaulGraham.com. Retrieved 13 November 2009. ^ Feldman, Richard (30 September 2019). \"Why Isn't Functional Programming the Norm?\". YouTube. ^ Krubner, Lawrence. \"Object Oriented Programming is an expensive disaster which must end\". smashcompany.com. Archived from the original on 14 October 2014. Retrieved 14 October 2014. ^ Potok, Thomas; Mladen Vouk; Andy Rindos (1999). \"Productivity Analysis of Object-Oriented Software Developed in a Commercial Environment\" (PDF). Software: Practice and Experience. 29 (10): 833–847. doi:10.1002/(SICI)1097-024X(199908)29:10<833::AID-SPE258>3.0.CO;2-P. S2CID 57865731. Retrieved 21 April 2010. ^ Martin, Robert C. \"Design Principles and Design Patterns\" (PDF). Archived from the original (PDF) on 6 September 2015. Retrieved 28 April 2017. ^ Neward, Ted (26 June 2006). \"The Vietnam of Computer Science\". Interoperability Happens. Archived from the original on 4 July 2006. Retrieved 2 June 2010. ^ Meyer 1997, p. 230. ^ M.Trofimov, OOOP – The Third \"O\" Solution: Open OOP. First Class, OMG, 1993, Vol. 3, issue 3, p.14. ^ Niklaus Wirth (23 January 2006). \"Good ideas, through the looking glass\" (PDF). IEEE Computer. Cover Feature. 39 (1): 28–39. doi:10.1109/MC.2006.20. S2CID 6582369. Archived from the original (PDF) on 12 October 2016. ^ Yegge, Steve (30 March 2006). \"Execution in the Kingdom of Nouns\". steve-yegge.blogspot.com. Retrieved 3 July 2010. ^ Boronczyk, Timothy (11 June 2009). \"What's Wrong with OOP\". zaemis.blogspot.com. Retrieved 3 July 2010. ^ Ambler, Scott (1 January 1998). \"A Realistic Look at Object-Oriented Reuse\". drdobbs.com. Retrieved 4 July 2010. ^ Shelly, Asaf (22 August 2008). \"Flaws of Object Oriented Modeling\". Intel Software Network. Retrieved 4 July 2010. ^ James, Justin (1 October 2007). \"Multithreading is a verb not a noun\". techrepublic.com. Archived from the original on 10 October 2007. Retrieved 4 July 2010. ^ Shelly, Asaf (22 August 2008). \"HOW TO: Multicore Programming (Multiprocessing) Visual C++ Class Design Guidelines, Member Functions\". support.microsoft.com. Retrieved 4 July 2010. ^ Robert Harper (17 April 2011). \"Some thoughts on teaching FP\". Existential Type Blog. Retrieved 5 December 2011. ^ Poll, Erik. \"Subtyping and Inheritance for Categorical Datatypes\" (PDF). Retrieved 5 June 2011. ^ a b Abadi, Martin; Cardelli, Luca (1996). A Theory of Objects. Springer-Verlag New York, Inc. ISBN 978-0-387-94775-4. Retrieved 21 April 2010. Further reading[edit] Abadi, Martin; Luca Cardelli (1998). A Theory of Objects. Springer Verlag. ISBN 978-0-387-94775-4. Abelson, Harold; Gerald Jay Sussman (1997). Structure and Interpretation of Computer Programs. MIT Press. ISBN 978-0-262-01153-2. Archived from the original on 26 December 2017. Retrieved 22 January 2006. Armstrong, Deborah J. (February 2006). \"The Quarks of Object-Oriented Development\". Communications of the ACM. 49 (2): 123–128. doi:10.1145/1113034.1113040. ISSN 0001-0782. S2CID 11485502. Bloch, Joshua (2018). \"Effective Java: Programming Language Guide\" (third ed.). Addison-Wesley. ISBN 978-0134685991. Booch, Grady (1997). Object-Oriented Analysis and Design with Applications. Addison-Wesley. ISBN 978-0-8053-5340-2. Eeles, Peter; Oliver Sims (1998). Building Business Objects. John Wiley & Sons. ISBN 978-0-471-19176-6. Gamma, Erich; Richard Helm; Ralph Johnson; John Vlissides (1995). Design Patterns: Elements of Reusable Object Oriented Software. Addison-Wesley. Bibcode:1995dper.book.....G. ISBN 978-0-201-63361-0. Harmon, Paul; William Morrissey (1996). The Object Technology Casebook – Lessons from Award-Winning Business Applications. John Wiley & Sons. ISBN 978-0-471-14717-6. Jacobson, Ivar (1992). Object-Oriented Software Engineering: A Use Case-Driven Approach. Addison-Wesley. Bibcode:1992oose.book.....J. ISBN 978-0-201-54435-0. Kay, Alan. The Early History of Smalltalk. Archived from the original on 4 April 2005. Retrieved 18 April 2005. Meyer, Bertrand (1997). Object-Oriented Software Construction. Prentice Hall. ISBN 978-0-13-629155-8. Pecinovsky, Rudolf (2013). OOP – Learn Object Oriented Thinking & Programming. Bruckner Publishing. ISBN 978-80-904661-8-0. Rumbaugh, James; Michael Blaha; William Premerlani; Frederick Eddy; William Lorensen (1991). Object-Oriented Modeling and Design. Prentice Hall. ISBN 978-0-13-629841-0. Schach, Stephen (2006). Object-Oriented and Classical Software Engineering, Seventh Edition. McGraw-Hill. ISBN 978-0-07-319126-3. Schreiner, Axel-Tobias (1993). Object oriented programming with ANSI-C. Hanser. hdl:1850/8544. ISBN 978-3-446-17426-9. Taylor, David A. (1992). Object-Oriented Information Systems – Planning and Implementation. John Wiley & Sons. ISBN 978-0-471-54364-0. Weisfeld, Matt (2009). The Object-Oriented Thought Process, Third Edition. Addison-Wesley. ISBN 978-0-672-33016-2. West, David (2004). Object Thinking (Developer Reference). Microsoft Press. ISBN 978-0-7356-1965-4. External links[edit] Wikiquote has quotations related to Object-orientation. Wikiversity has learning resources about Object-oriented programming at Topic:Object-Oriented Programming Wikibooks has a book on the topic of: Object Oriented Programming Introduction to Object Oriented Programming Concepts (OOP) and More by L.W.C. Nirosh Discussion on Cons of OOP OOP Concepts (Java Tutorials) vteProgramming paradigms (Comparison by language)ImperativeStructured Jackson structures Block-structured Modular Non-structured Procedural Programming in the large and in the small Design by contract Invariant-based Nested function Object-oriented(comparison, list) Class-based, Prototype-based, Object-based Agent Immutable object Persistent Uniform Function Call Syntax DeclarativeFunctional(comparison) Recursive Anonymous function (Partial application) Higher-order Purely functional Total Strict GADTs Dependent types Functional logic Point-free style Expression-oriented Applicative, Concatenative Function-level, Value-level Dataflow Flow-based Reactive (Functional reactive) Signals Streams Synchronous Logic Abductive logic Answer set Constraint (Constraint logic) Inductive logic Nondeterministic Ontology Probabilistic logic Query DSL Algebraic modeling Array Automata-based (Action) Command (Spacecraft) Differentiable End-user Grammar-oriented Interface description Language-oriented List comprehension Low-code Modeling Natural language Non-English-based Page description Pipes and filters Probabilistic Quantum Scientific Scripting Set-theoretic Simulation Stack-based System Tactile Templating Transformation (Graph rewriting, Production, Pattern) Visual Concurrent,distributed,parallel Actor-based Automatic mutual exclusion Choreographic programming Concurrent logic (Concurrent constraint logic) Concurrent OO Macroprogramming Multitier programming Organic computing Parallel programming models Partitioned global address space Process-oriented Relativistic programming Service-oriented Structured concurrency Metaprogramming Attribute-oriented Automatic (Inductive) Dynamic Extensible Generic Homoiconicity Interactive Macro (Hygienic) Metalinguistic abstraction Multi-stage Program synthesis (Bayesian, Inferential, by demonstration, by example) Reflective Self-modifying code Symbolic Template Separationof concerns Aspects Components Data-driven Data-oriented Event-driven Features Intentional Literate Roles Subjects vteTypes of programming languagesLevel Machine Assembly Compiled Interpreted Low-level High-level Very high-level Esoteric Generation First Second Third Fourth Fifth vteSoftware engineeringFields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction Component-based software engineering Software compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software verification and validation Software system Structured analysis Essential analysis CI/CD Orientations Agile Aspect-oriented Object orientation Ontology Service orientation SDLC ModelsDevelopmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD UP Scrum Spiral model V-model Waterfall model XP Model-driven engineering Round-trip engineering Other SPICE CMMI Data model ER model Function model Information model Metamodeling Object model Systems model View model Languages IDEF UML USL SysML Related fields Computer science Computer engineering Information science Project management Risk management Systems engineering Commons Category Authority control databases InternationalFASTNationalGermanyUnited StatesFranceBnF dataJapanCzech RepublicSpainIsrael"
    },
    {
        "id": 7,
        "url": "https://en.wikipedia.org/wiki/Procedural_programming",
        "title": "Procedural programming",
        "content": "Programming paradigm This article is about the computer programming paradigm. For the method of algorithmic content creation, see Procedural generation. This article needs additional citations for verification. Please help improve this article by adding citations to reliable sources. Unsourced material may be challenged and removed.Find sources: \"Procedural programming\" – news · newspapers · books · scholar · JSTOR (April 2008) (Learn how and when to remove this message) Procedural programming is a programming paradigm, classified as imperative programming, that involves implementing the behavior of a computer program as procedures (a.k.a. functions, subroutines) that call each other. The resulting program is a series of steps that forms a hierarchy of calls to its constituent procedures. The first major procedural programming languages appeared c. 1957–1964, including Fortran, ALGOL, COBOL, PL/I and BASIC. Pascal and C were published c. 1970–1972. Computer processors provide hardware support for procedural programming through a stack register and instructions for calling procedures and returning from them. Hardware support for other types of programming is possible, like Lisp machines or Java processors, but no attempt was commercially successful.[contradictory] Development practices[edit] Certain software development practices are often employed with procedural programming in order to enhance quality and lower development and maintenance costs. Modularity and scoping[edit] Modularity is about organizing the procedures of a program into separate modules—each of which has a specific and understandable purpose. Minimizing the scope of variables and procedures can enhance software quality by reducing the cognitive load of procedures and modules. A program lacking modularity or wide scoping tends to have procedures that consume many variables that other procedures also consume. The resulting code is relatively hard to understand and to maintain. Sharing[edit] Since a procedure can specify a well-defined interface and be self-contained it supports code reuse—in particular via the software library. Comparison with other programming paradigms[edit] Imperative programming[edit] Procedural programming is classified as an imperative programming, because it involves direct command of execution. Procedural is a sub-class of imperative since procedural includes block and scope concepts, whereas imperative describes a more general concept that does not require such features. Procedural languages generally use reserved words that define blocks, such as if, while, and for, to implement control flow, whereas non-structured imperative languages (i.e. assembly language) use goto and branch tables for this purpose. Object-oriented programming[edit] Also classified as imperative, object-oriented programming (OOP) involves dividing a program implementation into objects that expose behavior (methods) and data (members) via a well-defined interface. In contrast, procedural programming is about dividing the program implementation into variables, data structures, and subroutines. An important distinction is that while procedural involves procedures to operate on data structures, OOP bundles the two together. An object is a data structure and the behavior associated with that data structure. Some OOP languages support the class concept which allows for creating an object based on a definition. Nomenclature varies between the two, although they have similar semantics: Procedural Object-oriented Procedure Method Record Object Module Class Procedure call Message Functional programming[edit] The principles of modularity and code reuse in functional languages are fundamentally the same as in procedural languages, since they both stem from structured programming. For example: Procedures correspond to functions. Both allow the reuse of the same code in various parts of the programs, and at various points of its execution. By the same token, procedure calls correspond to function application. Functions and their modularly separated from each other in the same manner, by the use of function arguments, return values and variable scopes. The main difference between the styles is that functional programming languages remove or at least deemphasize the imperative elements of procedural programming. The feature set of functional languages is therefore designed to support writing programs as much as possible in terms of pure functions: Whereas procedural languages model execution of the program as a sequence of imperative commands that may implicitly alter shared state, functional programming languages model execution as the evaluation of complex expressions that only depend on each other in terms of arguments and return values. For this reason, functional programs can have a free order of code execution, and the languages may offer little control over the order in which various parts of the program are executed; for example, the arguments to a procedure invocation in Scheme are evaluated in an arbitrary order. Functional programming languages support (and heavily use) first-class functions, anonymous functions and closures, although these concepts have also been included in procedural languages at least since Algol 68. Functional programming languages tend to rely on tail call optimization and higher-order functions instead of imperative looping constructs. Many functional languages, however, are in fact impurely functional and offer imperative/procedural constructs that allow the programmer to write programs in procedural style, or in a combination of both styles. It is common for input/output code in functional languages to be written in a procedural style. There do exist a few esoteric functional languages (like Unlambda) that eschew structured programming precepts for the sake of being difficult to program in (and therefore challenging). These languages are the exception to the common ground between procedural and functional languages. Logic programming[edit] In logic programming, a program is a set of premises, and computation is performed by attempting to prove candidate theorems. From this point of view, logic programs are declarative, focusing on what the problem is, rather than on how to solve it. However, the backward reasoning technique, implemented by SLD resolution, used to solve problems in logic programming languages such as Prolog, treats programs as goal-reduction procedures. Thus clauses of the form: H :- B1, …, Bn. have a dual interpretation, both as procedures to show/solve H, show/solve B1 and … and Bn and as logical implications: B1 and … and Bn implies H. A skilled logic programmer uses the procedural interpretation to write programs that are effective and efficient, and uses the declarative interpretation to help ensure that programs are correct. See also[edit] Declarative programming Functional programming (contrast) Imperative programming Logic programming Object-oriented programming Programming paradigms Programming language Structured programming SQL procedural extensions References[edit] ^ \"Programming Paradigms\". ^ \"Welcome to IEEE Xplore 2.0: Use of procedural programming languages for controlling production systems\". Proceedings. The Seventh IEEE Conference on Artificial Intelligence Application. IEEE. doi:10.1109/CAIA.1991.120848. S2CID 58175293. ^ Stevenson, Joseph (August 2013). \"Procedural programming vs object-oriented programming\". neonbrand.com. Retrieved 2013-08-19. External links[edit] vteProgramming paradigms (Comparison by language)ImperativeStructured Jackson structures Block-structured Modular Non-structured Procedural Programming in the large and in the small Design by contract Invariant-based Nested function Object-oriented(comparison, list) Class-based, Prototype-based, Object-based Agent Immutable object Persistent Uniform Function Call Syntax DeclarativeFunctional(comparison) Recursive Anonymous function (Partial application) Higher-order Purely functional Total Strict GADTs Dependent types Functional logic Point-free style Expression-oriented Applicative, Concatenative Function-level, Value-level Dataflow Flow-based Reactive (Functional reactive) Signals Streams Synchronous Logic Abductive logic Answer set Constraint (Constraint logic) Inductive logic Nondeterministic Ontology Probabilistic logic Query DSL Algebraic modeling Array Automata-based (Action) Command (Spacecraft) Differentiable End-user Grammar-oriented Interface description Language-oriented List comprehension Low-code Modeling Natural language Non-English-based Page description Pipes and filters Probabilistic Quantum Scientific Scripting Set-theoretic Simulation Stack-based System Tactile Templating Transformation (Graph rewriting, Production, Pattern) Visual Concurrent,distributed,parallel Actor-based Automatic mutual exclusion Choreographic programming Concurrent logic (Concurrent constraint logic) Concurrent OO Macroprogramming Multitier programming Organic computing Parallel programming models Partitioned global address space Process-oriented Relativistic programming Service-oriented Structured concurrency Metaprogramming Attribute-oriented Automatic (Inductive) Dynamic Extensible Generic Homoiconicity Interactive Macro (Hygienic) Metalinguistic abstraction Multi-stage Program synthesis (Bayesian, Inferential, by demonstration, by example) Reflective Self-modifying code Symbolic Template Separationof concerns Aspects Components Data-driven Data-oriented Event-driven Features Intentional Literate Roles Subjects vteTypes of programming languagesLevel Machine Assembly Compiled Interpreted Low-level High-level Very high-level Esoteric Generation First Second Third Fourth Fifth"
    },
    {
        "id": 8,
        "url": "https://en.wikipedia.org/wiki/Imperative_programming",
        "title": "Imperative programming",
        "content": "Type of programming paradigm in computer science This article needs additional citations for verification. Please help improve this article by adding citations to reliable sources. Unsourced material may be challenged and removed.Find sources: \"Imperative programming\" – news · newspapers · books · scholar · JSTOR (October 2011) (Learn how and when to remove this message) In computer science, imperative programming is a programming paradigm of software that uses statements that change a program's state. In much the same way that the imperative mood in natural languages expresses commands, an imperative program consists of commands for the computer to perform. Imperative programming focuses on describing how a program operates step by step (generally order of the steps being determined in source code by the placement of statements one below the other), rather than on high-level descriptions of its expected results. The term is often used in contrast to declarative programming, which focuses on what the program should accomplish without specifying all the details of how the program should achieve the result. Procedural programming[edit] Procedural programming is a type of imperative programming in which the program is built from one or more procedures (also termed subroutines or functions). The terms are often used as synonyms, but the use of procedures has a dramatic effect on how imperative programs appear and how they are constructed. Heavy procedural programming, in which state changes are localized to procedures or restricted to explicit arguments and returns from procedures, is a form of structured programming. Since the 1960s, structured programming and modular programming in general have been promoted as techniques to improve the maintainability and overall quality of imperative programs. The concepts behind object-oriented programming attempt to extend this approach. Procedural programming could be considered a step toward declarative programming. A programmer can often tell, simply by looking at the names, arguments, and return types of procedures (and related comments), what a particular procedure is supposed to do, without necessarily looking at the details of how it achieves its result. At the same time, a complete program is still imperative since it fixes the statements to be executed and their order of execution to a large extent. Rationale and foundations of imperative programming[edit] The programming paradigm used to build programs for almost all computers typically follows an imperative model.[note 1] Digital computer hardware is designed to execute machine code, which is native to the computer and is usually written in the imperative style, although low-level compilers and interpreters using other paradigms exist for some architectures such as lisp machines. From this low-level perspective, the program state is defined by the contents of memory, and the statements are instructions in the native machine language of the computer. Higher-level imperative languages use variables and more complex statements, but still follow the same paradigm. Recipes and process checklists, while not computer programs, are also familiar concepts that are similar in style to imperative programming; each step is an instruction, and the physical world holds the state. Since the basic ideas of imperative programming are both conceptually familiar and directly embodied in the hardware, most computer languages are in the imperative style. Assignment statements, in imperative paradigm, perform an operation on information located in memory and store the results in memory for later use. High-level imperative languages, in addition, permit the evaluation of complex expressions, which may consist of a combination of arithmetic operations and function evaluations, and the assignment of the resulting value to memory. Looping statements (as in while loops, do while loops, and for loops) allow a sequence of statements to be executed multiple times. Loops can either execute the statements they contain a predefined number of times, or they can execute them repeatedly until some condition is met. Conditional branching statements allow a sequence of statements to be executed only if some condition is met. Otherwise, the statements are skipped and the execution sequence continues from the statement following them. Unconditional branching statements allow an execution sequence to be transferred to another part of a program. These include the jump (called goto in many languages), switch, and the subprogram, subroutine, or procedure call (which usually returns to the next statement after the call). Early in the development of high-level programming languages, the introduction of the block enabled the construction of programs in which a group of statements and declarations could be treated as if they were one statement. This, alongside the introduction of subroutines, enabled complex structures to be expressed by hierarchical decomposition into simpler procedural structures. Many imperative programming languages (such as Fortran, BASIC, and C) are abstractions of assembly language. History of imperative and object-oriented languages[edit] The earliest imperative languages were the machine languages of the original computers. In these languages, instructions were very simple, which made hardware implementation easier but hindered the creation of complex programs. FORTRAN, developed by John Backus at International Business Machines (IBM) starting in 1954, was the first major programming language to remove the obstacles presented by machine code in the creation of complex programs. FORTRAN was a compiled language that allowed named variables, complex expressions, subprograms, and many other features now common in imperative languages. The next two decades saw the development of many other major high-level imperative programming languages. In the late 1950s and 1960s, ALGOL was developed in order to allow mathematical algorithms to be more easily expressed and even served as the operating system's target language for some computers. MUMPS (1966) carried the imperative paradigm to a logical extreme, by not having any statements at all, relying purely on commands, even to the extent of making the IF and ELSE commands independent of each other, connected only by an intrinsic variable named $TEST. COBOL (1960) and BASIC (1964) were both attempts to make programming syntax look more like English. In the 1970s, Pascal was developed by Niklaus Wirth, and C was created by Dennis Ritchie while he was working at Bell Laboratories. Wirth went on to design Modula-2 and Oberon. For the needs of the United States Department of Defense, Jean Ichbiah and a team at Honeywell began designing Ada in 1978, after a 4-year project to define the requirements for the language. The specification was first published in 1983, with revisions in 1995, 2005, and 2012. The 1980s saw a rapid growth in interest in object-oriented programming. These languages were imperative in style, but added features to support objects. The last two decades of the 20th century saw the development of many such languages. Smalltalk-80, originally conceived by Alan Kay in 1969, was released in 1980, by the Xerox Palo Alto Research Center (PARC). Drawing from concepts in another object-oriented language—Simula (which is considered the world's first object-oriented programming language, developed in the 1960s)—Bjarne Stroustrup designed C++, an object-oriented language based on C. Design of C++ began in 1979 and the first implementation was completed in 1983. In the late 1980s and 1990s, the notable imperative languages drawing on object-oriented concepts were Perl, released by Larry Wall in 1987; Python, released by Guido van Rossum in 1990; Visual Basic and Visual C++ (which included Microsoft Foundation Class Library (MFC) 2.0), released by Microsoft in 1991 and 1993 respectively; PHP, released by Rasmus Lerdorf in 1994; Java, by James Gosling (Sun Microsystems) in 1995, JavaScript, by Brendan Eich (Netscape), and Ruby, by Yukihiro \"Matz\" Matsumoto, both released in 1995. Microsoft's .NET Framework (2002) is imperative at its core, as are its main target languages, VB.NET and C# that run on it; however Microsoft's F#, a functional language, also runs on it. Examples[edit] Fortran[edit] FORTRAN (1958) was unveiled as \"The IBM Mathematical FORmula TRANslating system.\" It was designed for scientific calculations, without string handling facilities. Along with declarations, expressions, and statements, it supported: arrays subroutines \"do\" loops It succeeded because: programming and debugging costs were below computer running costs it was supported by IBM applications at the time were scientific. However, non IBM vendors also wrote Fortran compilers, but with a syntax that would likely fail IBM's compiler. The American National Standards Institute (ANSI) developed the first Fortran standard in 1966. In 1978, Fortran 77 became the standard until 1991. Fortran 90 supports: records pointers to arrays COBOL[edit] COBOL (1959) stands for \"COmmon Business Oriented Language.\" Fortran manipulated symbols. It was soon realized that symbols did not need to be numbers, so strings were introduced. The US Department of Defense influenced COBOL's development, with Grace Hopper being a major contributor. The statements were English-like and verbose. The goal was to design a language so managers could read the programs. However, the lack of structured statements hindered this goal. COBOL's development was tightly controlled, so dialects did not emerge to require ANSI standards. As a consequence, it was not changed for 15 years until 1974. The 1990s version did make consequential changes, like object-oriented programming. Algol[edit] ALGOL (1960) stands for \"ALGOrithmic Language.\" It had a profound influence on programming language design. Emerging from a committee of European and American programming language experts, it used standard mathematical notation and had a readable structured design. Algol was first to define its syntax using the Backus–Naur form. This led to syntax-directed compilers. It added features like: block structure, where variables were local to their block arrays with variable bounds \"for\" loops functions recursion Algol's direct descendants include Pascal, Modula-2, Ada, Delphi and Oberon on one branch. On another branch there's C, C++ and Java. Basic[edit] BASIC (1964) stands for \"Beginner's All Purpose Symbolic Instruction Code.\" It was developed at Dartmouth College for all of their students to learn. If a student did not go on to a more powerful language, the student would still remember Basic. A Basic interpreter was installed in the microcomputers manufactured in the late 1970s. As the microcomputer industry grew, so did the language. Basic pioneered the interactive session. It offered operating system commands within its environment: The 'new' command created an empty slate Statements evaluated immediately Statements could be programmed by preceding them with a line number The 'list' command displayed the program The 'run' command executed the program However, the Basic syntax was too simple for large programs. Recent dialects added structure and object-oriented extensions. Microsoft's Visual Basic is still widely used and produces a graphical user interface. C[edit] C programming language (1973) got its name because the language BCPL was replaced with B, and AT&T Bell Labs called the next version \"C.\" Its purpose was to write the UNIX operating system. C is a relatively small language -- making it easy to write compilers. Its growth mirrored the hardware growth in the 1980s. Its growth also was because it has the facilities of assembly language, but uses a high-level syntax. It added advanced features like: inline assembler arithmetic on pointers pointers to functions bit operations freely combining complex operators Computer memory map C allows the programmer to control in which region of memory data is to be stored. Global variables and static variables require the fewest clock cycles to store. The stack is automatically used for the standard variable declarations. Heap memory is returned to a pointer variable from the malloc() function. The global and static data region is located just above the program region. (The program region is technically called the text region. It's where machine instructions are stored.) The global and static data region is technically two regions. One region is called the initialized data segment, where variables declared with default values are stored. The other region is called the block started by segment, where variables declared without default values are stored. Variables stored in the global and static data region have their addresses set at compile-time. They retain their values throughout the life of the process. The global and static region stores the global variables that are declared on top of (outside) the main() function. Global variables are visible to main() and every other function in the source code. On the other hand, variable declarations inside of main(), other functions, or within { } block delimiters are local variables. Local variables also include formal parameter variables. Parameter variables are enclosed within the parenthesis of function definitions. They provide an interface to the function. Local variables declared using the static prefix are also stored in the global and static data region. Unlike global variables, static variables are only visible within the function or block. Static variables always retain their value. An example usage would be the function int increment_counter(){ static int counter = 0; counter++; return counter;} The stack region is a contiguous block of memory located near the top memory address. Variables placed in the stack are populated from top to bottom. A stack pointer is a special-purpose register that keeps track of the last memory address populated. Variables are placed into the stack via the assembly language PUSH instruction. Therefore, the addresses of these variables are set during runtime. The method for stack variables to lose their scope is via the POP instruction. Local variables declared without the static prefix, including formal parameter variables, are called automatic variables and are stored in the stack. They are visible inside the function or block and lose their scope upon exiting the function or block. The heap region is located below the stack. It is populated from the bottom to the top. The operating system manages the heap using a heap pointer and a list of allocated memory blocks. Like the stack, the addresses of heap variables are set during runtime. An out of memory error occurs when the heap pointer and the stack pointer meet. C provides the malloc() library function to allocate heap memory. Populating the heap with data is an additional copy function. Variables stored in the heap are economically passed to functions using pointers. Without pointers, the entire block of data would have to be passed to the function via the stack. C++[edit] In the 1970s, software engineers needed language support to break large projects down into modules. One obvious feature was to decompose large projects physically into separate files. A less obvious feature was to decompose large projects logically into abstract datatypes. At the time, languages supported concrete (scalar) datatypes like integer numbers, floating-point numbers, and strings of characters. Concrete datatypes have their representation as part of their name. Abstract datatypes are structures of concrete datatypes — with a new name assigned. For example, a list of integers could be called integer_list. In object-oriented jargon, abstract datatypes are called classes. However, a class is only a definition; no memory is allocated. When memory is allocated to a class, it's called an object. Object-oriented imperative languages developed by combining the need for classes and the need for safe functional programming. A function, in an object-oriented language, is assigned to a class. An assigned function is then referred to as a method, member function, or operation. Object-oriented programming is executing operations on objects. Object-oriented languages support a syntax to model subset/superset relationships. In set theory, an element of a subset inherits all the attributes contained in the superset. For example, a student is a person. Therefore, the set of students is a subset of the set of persons. As a result, students inherit all the attributes common to all persons. Additionally, students have unique attributes that other persons don't have. Object-oriented languages model subset/superset relationships using inheritance. Object-oriented programming became the dominant language paradigm by the late 1990s. C++ (1985) was originally called \"C with Classes.\" It was designed to expand C's capabilities by adding the object-oriented facilities of the language Simula. An object-oriented module is composed of two files. The definitions file is called the header file. Here is a C++ header file for the GRADE class in a simple school application: // grade.h // ------- // Used to allow multiple source files to include // this header file without duplication errors. // See: https://en.wikipedia.org/wiki/Include_guard // ---------------------------------------------- #ifndef GRADE_H #define GRADE_H class GRADE { public: // This is the constructor operation. // ---------------------------------- GRADE ( const char letter ); // This is a class variable. // ------------------------- char letter; // This is a member operation. // --------------------------- int grade_numeric( const char letter ); // This is a class variable. // ------------------------- int numeric; }; #endif A constructor operation is a function with the same name as the class name. It is executed when the calling operation executes the new statement. A module's other file is the source file. Here is a C++ source file for the GRADE class in a simple school application: // grade.cpp // --------- #include \"grade.h\" GRADE::GRADE( const char letter ) { // Reference the object using the keyword 'this'. // ---------------------------------------------- this->letter = letter; // This is Temporal Cohesion // ------------------------- this->numeric = grade_numeric( letter ); } int GRADE::grade_numeric( const char letter ) { if ( ( letter == 'A' || letter == 'a' ) ) return 4; else if ( ( letter == 'B' || letter == 'b' ) ) return 3; else if ( ( letter == 'C' || letter == 'c' ) ) return 2; else if ( ( letter == 'D' || letter == 'd' ) ) return 1; else if ( ( letter == 'F' || letter == 'f' ) ) return 0; else return -1; } Here is a C++ header file for the PERSON class in a simple school application: // person.h // -------- #ifndef PERSON_H #define PERSON_H class PERSON { public: PERSON ( const char *name ); const char *name; }; #endif Here is a C++ source file for the PERSON class in a simple school application: // person.cpp // ---------- #include \"person.h\" PERSON::PERSON ( const char *name ) { this->name = name; } Here is a C++ header file for the STUDENT class in a simple school application: // student.h // --------- #ifndef STUDENT_H #define STUDENT_H #include \"person.h\" #include \"grade.h\" // A STUDENT is a subset of PERSON. // -------------------------------- class STUDENT : public PERSON{ public: STUDENT ( const char *name ); ~STUDENT(); GRADE *grade; }; #endif Here is a C++ source file for the STUDENT class in a simple school application: // student.cpp // ----------- #include \"student.h\" #include \"person.h\" STUDENT::STUDENT ( const char *name ): // Execute the constructor of the PERSON superclass. // ------------------------------------------------- PERSON( name ) { // Nothing else to do. // ------------------- } STUDENT::~STUDENT() { // deallocate grade's memory // to avoid memory leaks. // ------------------------------------------------- delete this->grade; } Here is a driver program for demonstration: // student_dvr.cpp // --------------- #include <iostream> #include \"student.h\" int main( void ) { STUDENT *student = new STUDENT( \"The Student\" ); student->grade = new GRADE( 'a' ); std::cout // Notice student inherits PERSON's name << student->name << \": Numeric grade = \" << student->grade->numeric << \"\\n\"; // deallocate student's memory // to avoid memory leaks. // ------------------------------------------------- delete student; return 0; } Here is a makefile to compile everything: # makefile # -------- all: student_dvr clean: rm student_dvr *.o student_dvr: student_dvr.cpp grade.o student.o person.o c++ student_dvr.cpp grade.o student.o person.o -o student_dvr grade.o: grade.cpp grade.h c++ -c grade.cpp student.o: student.cpp student.h c++ -c student.cpp person.o: person.cpp person.h c++ -c person.cpp See also[edit] Functional programming Reactive programming History of programming languages List of imperative programming languages Notes[edit] ^ Reconfigurable computing is a notable exception. References[edit] ^ Jain, Anisha (2022-12-10). \"Javascript Promises— Is There a Better Approach?\". Medium. Archived from the original on 2022-12-20. Retrieved 2022-12-20. ^ \"Imperative programming: Overview of the oldest programming paradigm\". IONOS Digitalguide. 21 May 2021. Archived from the original on 2022-05-03. Retrieved 2022-05-03. ^ Bruce Eckel (2006). Thinking in Java. Pearson Education. p. 24. ISBN 978-0-13-187248-6. ^ a b Wilson, Leslie B. (2001). Comparative Programming Languages, Third Edition. Addison-Wesley. p. 16. ISBN 0-201-71012-9. ^ Wilson, Leslie B. (2001). Comparative Programming Languages, Third Edition. Addison-Wesley. p. 24. ISBN 0-201-71012-9. ^ a b Wilson, Leslie B. (2001). Comparative Programming Languages, Third Edition. Addison-Wesley. p. 25. ISBN 0-201-71012-9. ^ a b c d Wilson, Leslie B. (2001). Comparative Programming Languages, Third Edition. Addison-Wesley. p. 19. ISBN 0-201-71012-9. ^ a b c d e Wilson, Leslie B. (2001). Comparative Programming Languages, Third Edition. Addison-Wesley. p. 30. ISBN 0-201-71012-9. ^ Wilson, Leslie B. (2001). Comparative Programming Languages, Third Edition. Addison-Wesley. p. 31. ISBN 0-201-71012-9. ^ a b c Wilson, Leslie B. (2001). Comparative Programming Languages, Third Edition. Addison-Wesley. p. 37. ISBN 0-201-71012-9. ^ a b c d \"Memory Layout of C Programs\". 12 September 2011. Archived from the original on 6 November 2021. Retrieved 25 May 2022. ^ a b Kernighan, Brian W.; Ritchie, Dennis M. (1988). The C Programming Language Second Edition. Prentice Hall. p. 31. ISBN 0-13-110362-8. ^ Wilson, Leslie B. (2001). Comparative Programming Languages, Third Edition. Addison-Wesley. p. 128. ISBN 0-201-71012-9. ^ a b c Kerrisk, Michael (2010). The Linux Programming Interface. No Starch Press. p. 121. ISBN 978-1-59327-220-3. ^ Kerrisk, Michael (2010). The Linux Programming Interface. No Starch Press. p. 122. ISBN 978-1-59327-220-3. ^ Kernighan, Brian W.; Ritchie, Dennis M. (1988). The C Programming Language Second Edition. Prentice Hall. p. 185. ISBN 0-13-110362-8. ^ Kernighan, Brian W.; Ritchie, Dennis M. (1988). The C Programming Language Second Edition. Prentice Hall. p. 187. ISBN 0-13-110362-8. ^ a b c Wilson, Leslie B. (2001). Comparative Programming Languages, Third Edition. Addison-Wesley. p. 38. ISBN 0-201-71012-9. ^ Stroustrup, Bjarne (2013). The C++ Programming Language, Fourth Edition. Addison-Wesley. p. 65. ISBN 978-0-321-56384-2. ^ Wilson, Leslie B. (2001). Comparative Programming Languages, Third Edition. Addison-Wesley. p. 193. ISBN 0-201-71012-9. ^ Wilson, Leslie B. (2001). Comparative Programming Languages, Third Edition. Addison-Wesley. p. 39. ISBN 0-201-71012-9. ^ Wilson, Leslie B. (2001). Comparative Programming Languages, Third Edition. Addison-Wesley. p. 35. ISBN 0-201-71012-9. ^ Wilson, Leslie B. (2001). Comparative Programming Languages, Third Edition. Addison-Wesley. p. 192. ISBN 0-201-71012-9. ^ Stroustrup, Bjarne (2013). The C++ Programming Language, Fourth Edition. Addison-Wesley. p. 22. ISBN 978-0-321-56384-2. ^ Stroustrup, Bjarne (2013). The C++ Programming Language, Fourth Edition. Addison-Wesley. p. 21. ISBN 978-0-321-56384-2. ^ Stroustrup, Bjarne (2013). The C++ Programming Language, Fourth Edition. Addison-Wesley. p. 49. ISBN 978-0-321-56384-2. Pratt, Terrence W. and Marvin V. Zelkowitz. Programming Languages: Design and Implementation, 3rd ed. Englewood Cliffs, N.J.: Prentice Hall, 1996. Sebesta, Robert W. Concepts of Programming Languages, 3rd ed. Reading, Mass.: Addison-Wesley Publishing Company, 1996. Originally based on the article 'Imperative programming' by Stan Seibert, from Nupedia, licensed under the GNU Free Documentation License. vteProgramming paradigms (Comparison by language)ImperativeStructured Jackson structures Block-structured Modular Non-structured Procedural Programming in the large and in the small Design by contract Invariant-based Nested function Object-oriented(comparison, list) Class-based, Prototype-based, Object-based Agent Immutable object Persistent Uniform Function Call Syntax DeclarativeFunctional(comparison) Recursive Anonymous function (Partial application) Higher-order Purely functional Total Strict GADTs Dependent types Functional logic Point-free style Expression-oriented Applicative, Concatenative Function-level, Value-level Dataflow Flow-based Reactive (Functional reactive) Signals Streams Synchronous Logic Abductive logic Answer set Constraint (Constraint logic) Inductive logic Nondeterministic Ontology Probabilistic logic Query DSL Algebraic modeling Array Automata-based (Action) Command (Spacecraft) Differentiable End-user Grammar-oriented Interface description Language-oriented List comprehension Low-code Modeling Natural language Non-English-based Page description Pipes and filters Probabilistic Quantum Scientific Scripting Set-theoretic Simulation Stack-based System Tactile Templating Transformation (Graph rewriting, Production, Pattern) Visual Concurrent,distributed,parallel Actor-based Automatic mutual exclusion Choreographic programming Concurrent logic (Concurrent constraint logic) Concurrent OO Macroprogramming Multitier programming Organic computing Parallel programming models Partitioned global address space Process-oriented Relativistic programming Service-oriented Structured concurrency Metaprogramming Attribute-oriented Automatic (Inductive) Dynamic Extensible Generic Homoiconicity Interactive Macro (Hygienic) Metalinguistic abstraction Multi-stage Program synthesis (Bayesian, Inferential, by demonstration, by example) Reflective Self-modifying code Symbolic Template Separationof concerns Aspects Components Data-driven Data-oriented Event-driven Features Intentional Literate Roles Subjects vteTypes of programming languagesLevel Machine Assembly Compiled Interpreted Low-level High-level Very high-level Esoteric Generation First Second Third Fourth Fifth Authority control databases: National United StatesIsrael"
    },
    {
        "id": 9,
        "url": "https://en.wikipedia.org/wiki/Functional_programming",
        "title": "Functional programming",
        "content": ""
    },
    {
        "id": 10,
        "url": "https://en.wikipedia.org/wiki/Structured_programming",
        "title": "Structured programming",
        "content": "Programming paradigm based on control flowStructured programming is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by making specific disciplined use of the structured control flow constructs of selection (if/then/else) and repetition (while and for), block structures, and subroutines. It emerged in the late 1950s with the appearance of the ALGOL 58 and ALGOL 60 programming languages, with the latter including support for block structures. Contributing factors to its popularity and widespread acceptance, at first in academia and later among practitioners, include the discovery of what is now known as the structured program theorem in 1966, and the publication of the influential \"Go To Statement Considered Harmful\" open letter in 1968 by Dutch computer scientist Edsger W. Dijkstra, who coined the term \"structured programming\". Structured programming is most frequently used with deviations that allow for clearer programs in some particular cases, such as when exception handling has to be performed. Elements[edit] Control structures[edit] Following the structured program theorem, all programs are seen as composed of three control structures: \"Sequence\"; ordered statements or subroutines executed in sequence. \"Selection\"; one of a number of statements is executed depending on the state of the program. This is usually expressed with keywords such as if..then..else..endif. The conditional statement should have at least one true condition and each condition should have one exit point at max. \"Iteration\"; a statement or block is executed until the program reaches a certain state, or operations have been applied to every element of a collection. This is usually expressed with keywords such as while, repeat, for or do..until. Often it is recommended that each loop should only have one entry point (and in the original structural programming, also only one exit point, and a few languages enforce this). Graphical representation of the three basic patterns — sequence, selection, and repetition — using NS diagrams (blue) and flow charts (green). Subroutines[edit] Subroutines; callable units such as procedures, functions, methods, or subprograms are used to allow a sequence to be referred to by a single statement. Blocks[edit] Blocks are used to enable groups of statements to be treated as if they were one statement. Block-structured languages have a syntax for enclosing structures in some formal way, such as an if-statement bracketed by if..fi as in ALGOL 68, or a code section bracketed by BEGIN..END, as in PL/I and Pascal, whitespace indentation as in Python, or the curly braces {...} of C and many later languages. Structured programming languages[edit] It is possible to do structured programming in any programming language, though it is preferable to use something like a procedural programming language. Some of the languages initially used for structured programming include: ALGOL, Pascal, PL/I, Ada and RPL but most new procedural programming languages since that time have included features to encourage structured programming, and sometimes deliberately left out features – notably GOTO – in an effort to make unstructured programming more difficult. Structured programming (sometimes known as modular programming) enforces a logical structure on the program being written to make it more efficient and easier to understand and modify. History[edit] Theoretical foundation[edit] The structured program theorem provides the theoretical basis of structured programming. It states that three ways of combining programs—sequencing, selection, and iteration—are sufficient to express any computable function. This observation did not originate with the structured programming movement; these structures are sufficient to describe the instruction cycle of a central processing unit, as well as the operation of a Turing machine. Therefore, a processor is always executing a \"structured program\" in this sense, even if the instructions it reads from memory are not part of a structured program. However, authors usually credit the result to a 1966 paper by Böhm and Jacopini, possibly because Dijkstra cited this paper himself. The structured program theorem does not address how to write and analyze a usefully structured program. These issues were addressed during the late 1960s and early 1970s, with major contributions by Dijkstra, Robert W. Floyd, Tony Hoare, Ole-Johan Dahl, and David Gries. Debate[edit] P. J. Plauger, an early adopter of structured programming, described his reaction to the structured program theorem: Us converts waved this interesting bit of news under the noses of the unreconstructed assembly-language programmers who kept trotting forth twisty bits of logic and saying, 'I betcha can't structure this.' Neither the proof by Böhm and Jacopini nor our repeated successes at writing structured code brought them around one day sooner than they were ready to convince themselves. Donald Knuth accepted the principle that programs must be written with provability in mind, but he disagreed with abolishing the GOTO statement, and as of 2018[update] has continued to use it in his programs. In his 1974 paper, \"Structured Programming with Goto Statements\", he gave examples where he believed that a direct jump leads to clearer and more efficient code without sacrificing provability. Knuth proposed a looser structural constraint: It should be possible to draw a program's flow chart with all forward branches on the left, all backward branches on the right, and no branches crossing each other. Many of those knowledgeable in compilers and graph theory have advocated allowing only reducible flow graphs.[when defined as?][who?] Structured programming theorists gained a major ally in the 1970s after IBM researcher Harlan Mills applied his interpretation of structured programming theory to the development of an indexing system for The New York Times research file. The project was a great engineering success, and managers at other companies cited it in support of adopting structured programming, although Dijkstra criticized the ways that Mills's interpretation differed from the published work. As late as 1987 it was still possible to raise the question of structured programming in a computer science journal. Frank Rubin did so in that year with an open letter titled \"'GOTO Considered Harmful' Considered Harmful\". Numerous objections followed, including a response from Dijkstra that sharply criticized both Rubin and the concessions other writers made when responding to him. Outcome[edit] By the end of the 20th century, nearly all computer scientists were convinced that it is useful to learn and apply the concepts of structured programming. High-level programming languages that originally lacked programming structures, such as FORTRAN, COBOL, and BASIC, now have them. Common deviations[edit] While goto has now largely been replaced by the structured constructs of selection (if/then/else) and repetition (while and for), few languages are purely structured. The most common deviation, found in many languages, is the use of a return statement for early exit from a subroutine. This results in multiple exit points, instead of the single exit point required by structured programming. There are other constructions to handle cases that are awkward in purely structured programming. Early exit[edit] Further information: Return early The most common deviation from structured programming is early exit from a function or loop. At the level of functions, this is a return statement. At the level of loops, this is a break statement (terminate the loop) or continue statement (terminate the current iteration, proceed with next iteration). In structured programming, these can be replicated by adding additional branches or tests, but for returns from nested code this can add significant complexity. C is an early and prominent example of these constructs. Some newer languages also have \"labeled breaks\", which allow breaking out of more than just the innermost loop. Exceptions also allow early exit, but have further consequences, and thus are treated below. Multiple exits can arise for a variety of reasons, most often either that the subroutine has no more work to do (if returning a value, it has completed the calculation), or has encountered \"exceptional\" circumstances that prevent it from continuing, hence needing exception handling. The most common problem in early exit is that cleanup or final statements are not executed – for example, allocated memory is not deallocated, or open files are not closed, causing memory leaks or resource leaks. These must be done at each return site, which is brittle and can easily result in bugs. For instance, in later development, a return statement could be overlooked by a developer, and an action that should be performed at the end of a subroutine (e.g., a trace statement) might not be performed in all cases. Languages without a return statement, such as standard Pascal and Seed7, do not have this problem. Most modern languages provide language-level support to prevent such leaks; see detailed discussion at resource management. Most commonly this is done via unwind protection, which ensures that certain code is guaranteed to be run when execution exits a block; this is a structured alternative to having a cleanup block and a goto. This is most often known as try...finally, and considered a part of exception handling. In case of multiple return statements introducing try...finally, without exceptions might look strange. Various techniques exist to encapsulate resource management. An alternative approach, found primarily in C++, is Resource Acquisition Is Initialization, which uses normal stack unwinding (variable deallocation) at function exit to call destructors on local variables to deallocate resources. Kent Beck, Martin Fowler and co-authors have argued in their refactoring books that nested conditionals may be harder to understand than a certain type of flatter structure using multiple exits predicated by guard clauses. Their 2009 book flatly states that \"one exit point is really not a useful rule. Clarity is the key principle: If the method is clearer with one exit point, use one exit point; otherwise don’t\". They offer a cookbook solution for transforming a function consisting only of nested conditionals into a sequence of guarded return (or throw) statements, followed by a single unguarded block, which is intended to contain the code for the common case, while the guarded statements are supposed to deal with the less common ones (or with errors). Herb Sutter and Andrei Alexandrescu also argue in their 2004 C++ tips book that the single-exit point is an obsolete requirement. In his 2004 textbook, David Watt writes that \"single-entry multi-exit control flows are often desirable\". Using Tennent's framework notion of sequencer, Watt uniformly describes the control flow constructs found in contemporary programming languages and attempts to explain why certain types of sequencers are preferable to others in the context of multi-exit control flows. Watt writes that unrestricted gotos (jump sequencers) are bad because the destination of the jump is not self-explanatory to the reader of a program until the reader finds and examines the actual label or address that is the target of the jump. In contrast, Watt argues that the conceptual intent of a return sequencer is clear from its own context, without having to examine its destination. Watt writes that a class of sequencers known as escape sequencers, defined as a \"sequencer that terminates execution of a textually enclosing command or procedure\", encompasses both breaks from loops (including multi-level breaks) and return statements. Watt also notes that while jump sequencers (gotos) have been somewhat restricted in languages like C, where the target must be an inside the local block or an encompassing outer block, that restriction alone is not sufficient to make the intent of gotos in C self-describing and so they can still produce \"spaghetti code\". Watt also examines how exception sequencers differ from escape and jump sequencers; this is explained in the next section of this article. In contrast to the above, Bertrand Meyer wrote in his 2009 textbook that instructions like break and continue \"are just the old goto in sheep's clothing\" and strongly advised against their use. Exception handling[edit] Further information: Exception handling (programming) Based on the coding error from the Ariane 501 disaster, software developer Jim Bonang argues that any exceptions thrown from a function violate the single-exit paradigm, and proposes that all inter-procedural exceptions should be forbidden. Bonang proposes that all single-exit conforming C++ should be written along the lines of: bool MyCheck1() throw() { bool success = false; try { // Do something that may throw exceptions. if (!MyCheck2()) { throw SomeInternalException(); } // Other code similar to the above. success = true; } catch (...) { // All exceptions caught and logged. } return success; } Peter Ritchie also notes that, in principle, even a single throw right before the return in a function constitutes a violation of the single-exit principle, but argues that Dijkstra's rules were written in a time before exception handling became a paradigm in programming languages, so he proposes to allow any number of throw points in addition to a single return point. He notes that solutions that wrap exceptions for the sake of creating a single-exit have higher nesting depth and thus are more difficult to comprehend, and even accuses those who propose to apply such solutions to programming languages that support exceptions of engaging in cargo cult thinking. David Watt also analyzes exception handling in the framework of sequencers (introduced in this article in the previous section on early exits.) Watt notes that an abnormal situation (generally exemplified with arithmetic overflows or input/output failures like file not found) is a kind of error that \"is detected in some low-level program unit, but [for which] a handler is more naturally located in a high-level program unit\". For example, a program might contain several calls to read files, but the action to perform when a file is not found depends on the meaning (purpose) of the file in question to the program and thus a handling routine for this abnormal situation cannot be located in low-level system code. Watts further notes that introducing status flags testing in the caller, as single-exit structured programming or even (multi-exit) return sequencers would entail, results in a situation where \"the application code tends to get cluttered by tests of status flags\" and that \"the programmer might forgetfully or lazily omit to test a status flag. In fact, abnormal situations represented by status flags are by default ignored!\" He notes that in contrast to status flags testing, exceptions have the opposite default behavior, causing the program to terminate unless the programmer explicitly deals with the exception in some way, possibly by adding code to willfully ignore it. Based on these arguments, Watt concludes that jump sequencers or escape sequencers (discussed in the previous section) are not as suitable as a dedicated exception sequencer with the semantics discussed above. The textbook by Louden and Lambert emphasizes that exception handling differs from structured programming constructs like while loops because the transfer of control \"is set up at a different point in the program than that where the actual transfer takes place. At the point where the transfer actually occurs, there may be no syntactic indication that control will in fact be transferred.\" Computer science professor Arvind Kumar Bansal also notes that in languages which implement exception handling, even control structures like for, which have the single-exit property in absence of exceptions, no longer have it in presence of exceptions, because an exception can prematurely cause an early exit in any part of the control structure; for instance if init() throws an exception in for (init(); check(); increm()), then the usual exit point after check() is not reached. Citing multiple prior studies by others (1999–2004) and their own results, Westley Weimer and George Necula wrote that a significant problem with exceptions is that they \"create hidden control-flow paths that are difficult for programmers to reason about\". The necessity to limit code to single-exit points appears in some contemporary programming environments focused on parallel computing, such as OpenMP. The various parallel constructs from OpenMP, like parallel do, do not allow early exits from inside to the outside of the parallel construct; this restriction includes all manner of exits, from break to C++ exceptions, but all of these are permitted inside the parallel construct if the jump target is also inside it. Multiple entry[edit] Further information: Coroutine More rarely, subprograms allow multiple entry. This is most commonly only re-entry into a coroutine (or generator/semicoroutine), where a subprogram yields control (and possibly a value), but can then be resumed where it left off. There are a number of common uses of such programming, notably for streams (particularly input/output), state machines, and concurrency. From a code execution point of view, yielding from a coroutine is closer to structured programming than returning from a subroutine, as the subprogram has not actually terminated, and will continue when called again – it is not an early exit. However, coroutines mean that multiple subprograms have execution state – rather than a single call stack of subroutines – and thus introduce a different form of complexity. It is very rare for subprograms to allow entry to an arbitrary position in the subprogram, as in this case the program state (such as variable values) is uninitialized or ambiguous, and this is very similar to a goto. State machines[edit] Some programs, particularly parsers and communications protocols, have a number of states that follow each other in a way that is not easily reduced to the basic structures, and some programmers implement the state-changes with a jump to the new state. This type of state-switching is often used in the Linux kernel.[citation needed] However, it is possible to structure these systems by making each state-change a separate subprogram and using a variable to indicate the active state (see trampoline). Alternatively, these can be implemented via coroutines, which dispense with the trampoline. See also[edit] DRAKON Minimal evaluation Nassi–Shneiderman diagram Structure chart Structured concurrency Switch statement References[edit] Citations[edit] ^ Clark, Leslie B. Wilson, Robert G.; Robert, Clark (2000). Comparative programming languages (3rd ed.). Harlow, England: Addison-Wesley. p. 20. ISBN 9780201710120. Archived from the original on 26 November 2015. Retrieved 25 November 2015.{{cite book}}: CS1 maint: multiple names: authors list (link) ^ Böhm & Jacopini 1966. ^ Dijkstra 1968, p. 147, \"The unbridled use of the go to statement has as an immediate consequence that it becomes terribly hard to find a meaningful set of coordinates in which to describe the process progress. ... The go to statement as it stands is just too primitive, it is too much an invitation to make a mess of one's program.\" ^ a b \"What is Structured Programming?\". Software Quality. Retrieved 2024-04-09. ^ \"Reading: Structured Programming | ITE 115 Introduction to Computer Applications and Concepts\". courses.lumenlearning.com. Retrieved 2024-04-09. ^ Dijkstra 1968. ^ Plauger, P. J. (February 12, 1993). Programming on Purpose, Essays on Software Design (1st ed.). Prentice-Hall. p. 25. ISBN 978-0-13-721374-0. ^ DLS • Donald Knuth • All Questions Answered. YouTube. University of Waterloo. 15 Nov 2018. 48 minutes in. Retrieved 24 July 2022. ^ Donald E. Knuth (December 1974). \"Structured programming with go to statements\" (PDF). Computing Surveys. 6 (4): 261–301. doi:10.1145/356635.356640. S2CID 207630080. Archived from the original (PDF) on 2013-10-23. ^ In EWD1308, \"What led to \"Notes on Structured Programming\"\"., dated 10 June 2001, Dijkstra writes, \"Apparently, IBM did not like the popularity of my text; it stole the term \"Structured Programming\" and under its auspices Harlan D. Mills trivialized the original concept to the abolishment of the goto statement.\" ^ Frank Rubin (March 1987). \"\"GOTO Considered Harmful\" Considered Harmful\" (PDF). Communications of the ACM. 30 (3): 195–196. doi:10.1145/214748.315722. S2CID 6853038. Archived from the original (PDF) on 2009-03-20. ^ Elder, Matt; Jackson, Steve; Liblit, Ben (October 2008). Code Sandwiches (PDF) (Technical report). University of Wisconsin–Madison. 1647. ^ Jay Fields; Shane Harvie; Martin Fowler; Kent Beck (2009). Refactoring: Ruby Edition. Pearson Education. pp. 274–279. ISBN 978-0-321-60350-0. ^ Herb Sutter; Andrei Alexandrescu (2004). C++ Coding Standards: 101 Rules, Guidelines, and Best Practices. Pearson Education. ISBN 978-0-13-265442-5. Example 4: Single entry, single exit (\"SESE\"). Historically, some coding standards have required that each function have exactly one exit, meaning one return statement. Such a requirement is obsolete in languages that support exceptions and destructors, where functions typically have numerous implicit exits. ^ Watt & Findlay 2004, pp. 215–221. ^ Bertrand Meyer (2009). Touch of Class: Learning to Program Well with Objects and Contracts. Springer Science & Business Media. p. 189. ISBN 978-3-540-92144-8. ^ \"Single-Entry, Single-Exit, Should It Still be Applicable in Object-oriented Languages?\". Peter Ritchie's MVP Blog. 7 March 2008. Archived from the original on 2012-11-14. Retrieved 2014-07-15. ^ Watt & Findlay 2004, pp. 221–222. ^ Kenneth C. Louden; Kenneth A. Lambert (2011). Programming Languages: Principles and Practices (3rd ed.). Cengage Learning. p. 423. ISBN 978-1-111-52941-3. ^ Arvind Kumar Bansal (2013). Introduction to Programming Languages. CRC Press. p. 135. ISBN 978-1-4665-6514-2. ^ Weimer, W. & Necula, G.C. (2008). \"Exceptional Situations and Program Reliability\" (PDF). ACM Transactions on Programming Languages and Systems. 30 (2). 8:27. doi:10.1145/1330017.1330019. S2CID 3136431. Archived from the original (PDF) on 2015-09-23. ^ Rohit Chandra (2001). Parallel Programming in OpenMP. Morgan Kaufmann. p. 45. ISBN 978-1-55860-671-5. Sources[edit] Edsger Dijkstra, Notes on Structured Programming, p. 6. Böhm, Corrado; Jacopini, Giuseppe (May 1966). \"Flow Diagrams, Turing Machines and Languages with Only Two Formation Rules\" (PDF). Communications of the ACM. 9 (5): 366–371. CiteSeerX 10.1.1.119.9119. doi:10.1145/355592.365646. S2CID 10236439. Archived (PDF) from the original on 2015-09-23. Dijkstra, Edsger W. (March 1968). \"Letters to the editor: Go to statement considered harmful\" (PDF). Communications of the ACM. 11 (3): 147–148. doi:10.1145/362929.362947. ISSN 0001-0782. S2CID 17469809. Michael A. Jackson, Principles of Program Design, Academic Press, London, 1975. O.-J. Dahl, E. W. Dijkstra, C. A. R. Hoare Structured Programming, Academic Press, London, 1972. ISBN 0-12-200550-3. this volume includes an expanded version of the Notes on Structured Programming, above, including an extended example of using the structured approach to develop a backtracking algorithm to solve the 8 Queens problem. a pdf version is in the ACM Classic Books Series Note that the third chapter of this book, by Dahl, describes an approach that is easily recognized as Object Oriented Programming. It can be seen as another way to \"usefully structure\" a program to aid in showing that it is correct. Watt, David Anthony; Findlay, William (2004). Programming language design concepts. John Wiley & Sons. ISBN 978-0-470-85320-7. External links[edit] The Wikibook Computer Programming has a page on the topic of: Control BPStruct - A tool to structure concurrent systems (programs, process models) J. Darlinton; M. Ghanem; H. W. To (1993), \"Structured Parallel Programming\", In Programming Models for Massively Parallel Computers. IEEE Computer Society Press. 1993: 160–169, CiteSeerX 10.1.1.37.4610 vteProgramming paradigms (Comparison by language)ImperativeStructured Jackson structures Block-structured Modular Non-structured Procedural Programming in the large and in the small Design by contract Invariant-based Nested function Object-oriented(comparison, list) Class-based, Prototype-based, Object-based Agent Immutable object Persistent Uniform Function Call Syntax DeclarativeFunctional(comparison) Recursive Anonymous function (Partial application) Higher-order Purely functional Total Strict GADTs Dependent types Functional logic Point-free style Expression-oriented Applicative, Concatenative Function-level, Value-level Dataflow Flow-based Reactive (Functional reactive) Signals Streams Synchronous Logic Abductive logic Answer set Constraint (Constraint logic) Inductive logic Nondeterministic Ontology Probabilistic logic Query DSL Algebraic modeling Array Automata-based (Action) Command (Spacecraft) Differentiable End-user Grammar-oriented Interface description Language-oriented List comprehension Low-code Modeling Natural language Non-English-based Page description Pipes and filters Probabilistic Quantum Scientific Scripting Set-theoretic Simulation Stack-based System Tactile Templating Transformation (Graph rewriting, Production, Pattern) Visual Concurrent,distributed,parallel Actor-based Automatic mutual exclusion Choreographic programming Concurrent logic (Concurrent constraint logic) Concurrent OO Macroprogramming Multitier programming Organic computing Parallel programming models Partitioned global address space Process-oriented Relativistic programming Service-oriented Structured concurrency Metaprogramming Attribute-oriented Automatic (Inductive) Dynamic Extensible Generic Homoiconicity Interactive Macro (Hygienic) Metalinguistic abstraction Multi-stage Program synthesis (Bayesian, Inferential, by demonstration, by example) Reflective Self-modifying code Symbolic Template Separationof concerns Aspects Components Data-driven Data-oriented Event-driven Features Intentional Literate Roles Subjects Authority control databases: National GermanyUnited StatesFranceBnF dataCzech RepublicSpainIsrael"
    },
    {
        "id": 11,
        "url": "https://en.wikipedia.org/wiki/Reflective_programming",
        "title": "Reflective programming",
        "content": "Ability of a process to examine and modify itself Not to be confused with Reflection (computer graphics). In computer science, reflective programming or reflection is the ability of a process to examine, introspect, and modify its own structure and behavior. Historical background[edit] The earliest computers were programmed in their native assembly languages, which were inherently reflective, as these original architectures could be programmed by defining instructions as data and using self-modifying code. As the bulk of programming moved to higher-level compiled languages such as Algol, Cobol, Fortran, Pascal, and C, this reflective ability largely disappeared until new programming languages with reflection built into their type systems appeared.[citation needed] Brian Cantwell Smith's 1982 doctoral dissertation introduced the notion of computational reflection in procedural programming languages and the notion of the meta-circular interpreter as a component of 3-Lisp. Uses[edit] Reflection helps programmers make generic software libraries to display data, process different formats of data, perform serialization and deserialization of data for communication, or do bundling and unbundling of data for containers or bursts of communication. Effective use of reflection almost always requires a plan: A design framework, encoding description, object library, a map of a database or entity relations. Reflection makes a language more suited to network-oriented code. For example, it assists languages such as Java to operate well in networks by enabling libraries for serialization, bundling and varying data formats. Languages without reflection such as C are required to use auxiliary compilers for tasks like Abstract Syntax Notation to produce code for serialization and bundling. Reflection can be used for observing and modifying program execution at runtime. A reflection-oriented program component can monitor the execution of an enclosure of code and can modify itself according to a desired goal of that enclosure. This is typically accomplished by dynamically assigning program code at runtime. In object-oriented programming languages such as Java, reflection allows inspection of classes, interfaces, fields and methods at runtime without knowing the names of the interfaces, fields, methods at compile time. It also allows instantiation of new objects and invocation of methods. Reflection is often used as part of software testing, such as for the runtime creation/instantiation of mock objects. Reflection is also a key strategy for metaprogramming. In some object-oriented programming languages such as C# and Java, reflection can be used to bypass member accessibility rules. For C#-properties this can be achieved by writing directly onto the (usually invisible) backing field of a non-public property. It is also possible to find non-public methods of classes and types and manually invoke them. This works for project-internal files as well as external libraries such as .NET's assemblies and Java's archives. Implementation[edit] This section does not cite any sources. Please help improve this section by adding citations to reliable sources. Unsourced material may be challenged and removed. (January 2008) (Learn how and when to remove this message) A language that supports reflection provides a number of features available at runtime that would otherwise be difficult to accomplish in a lower-level language. Some of these features are the abilities to: Discover and modify source-code constructions (such as code blocks, classes, methods, protocols, etc.) as first-class objects at runtime. Convert a string matching the symbolic name of a class or function into a reference to or invocation of that class or function. Evaluate a string as if it were a source-code statement at runtime. Create a new interpreter for the language's bytecode to give a new meaning or purpose for a programming construct. These features can be implemented in different ways. In MOO, reflection forms a natural part of everyday programming idiom. When verbs (methods) are called, various variables such as verb (the name of the verb being called) and this (the object on which the verb is called) are populated to give the context of the call. Security is typically managed by accessing the caller stack programmatically: Since callers() is a list of the methods by which the current verb was eventually called, performing tests on callers() (the command invoked by the original user) allows the verb to protect itself against unauthorised use. Compiled languages rely on their runtime system to provide information about the source code. A compiled Objective-C executable, for example, records the names of all methods in a block of the executable, providing a table to correspond these with the underlying methods (or selectors for these methods) compiled into the program. In a compiled language that supports runtime creation of functions, such as Common Lisp, the runtime environment must include a compiler or an interpreter. Reflection can be implemented for languages without built-in reflection by using a program transformation system to define automated source-code changes. Security considerations[edit] Reflection may allow a user to create unexpected control flow paths through an application, potentially bypassing security measures. This may be exploited by attackers. Historical vulnerabilities in Java caused by unsafe reflection allowed code retrieved from potentially untrusted remote machines to break out of the Java sandbox security mechanism. A large scale study of 120 Java vulnerabilities in 2013 concluded that unsafe reflection is the most common vulnerability in Java, though not the most exploited. Examples[edit] The following code snippets create an instance foo of class Foo and invoke its method PrintHello. For each programming language, normal and reflection-based call sequences are shown. Common Lisp[edit] The following is an example in Common Lisp using the Common Lisp Object System: (defclass foo () ()) (defmethod print-hello ((f foo)) (format T \"Hello from ~S~%\" f)) ;; Normal, without reflection (let ((foo (make-instance 'foo))) (print-hello foo)) ;; With reflection to look up the class named \"foo\" and the method ;; named \"print-hello\" that specializes on \"foo\". (let* ((foo-class (find-class (read-from-string \"foo\"))) (print-hello-method (find-method (symbol-function (read-from-string \"print-hello\")) nil (list foo-class)))) (funcall (sb-mop:method-generic-function print-hello-method) (make-instance foo-class))) C#[edit] The following is an example in C#: // Without reflection var foo = new Foo(); foo.PrintHello(); // With reflection Object foo = Activator.CreateInstance(\"complete.classpath.and.Foo\"); MethodInfo method = foo.GetType().GetMethod(\"PrintHello\"); method.Invoke(foo, null); Delphi, Object Pascal[edit] This Delphi and Object Pascal example assumes that a TFoo class has been declared in a unit called Unit1: uses RTTI, Unit1; procedure WithoutReflection; var Foo: TFoo; begin Foo := TFoo.Create; try Foo.Hello; finally Foo.Free; end; end; procedure WithReflection; var RttiContext: TRttiContext; RttiType: TRttiInstanceType; Foo: TObject; begin RttiType := RttiContext.FindType('Unit1.TFoo') as TRttiInstanceType; Foo := RttiType.GetMethod('Create').Invoke(RttiType.MetaclassType, []).AsObject; try RttiType.GetMethod('Hello').Invoke(Foo, []); finally Foo.Free; end; end; eC[edit] The following is an example in eC: // Without reflection Foo foo { }; foo.hello(); // With reflection Class fooClass = eSystem_FindClass(__thisModule, \"Foo\"); Instance foo = eInstance_New(fooClass); Method m = eClass_FindMethod(fooClass, \"hello\", fooClass.module); ((void (*)())(void *)m.function)(foo); Go[edit] The following is an example in Go: import \"reflect\" // Without reflection f := Foo{} f.Hello() // With reflection fT := reflect.TypeOf(Foo{}) fV := reflect.New(fT) m := fV.MethodByName(\"Hello\") if m.IsValid() { m.Call(nil) } Java[edit] The following is an example in Java: import java.lang.reflect.Method; // Without reflection Foo foo = new Foo(); foo.hello(); // With reflection try { Object foo = Foo.class.getDeclaredConstructor().newInstance(); Method m = foo.getClass().getDeclaredMethod(\"hello\", new Class<?>); m.invoke(foo); } catch (ReflectiveOperationException ignored) {} JavaScript[edit] The following is an example in JavaScript: // Without reflection const foo = new Foo() foo.hello() // With reflection const foo = Reflect.construct(Foo) const hello = Reflect.get(foo, 'hello') Reflect.apply(hello, foo, []) // With eval eval('new Foo().hello()') Julia[edit] The following is an example in Julia: julia> struct Point x::Int y end # Inspection with reflection julia> fieldnames(Point) (:x, :y) julia> fieldtypes(Point) (Int64, Any) julia> p = Point(3,4) # Access with reflection julia> getfield(p, :x) 3 Objective-C[edit] The following is an example in Objective-C, implying either the OpenStep or Foundation Kit framework is used: // Foo class. @interface Foo : NSObject - (void)hello; @end // Sending \"hello\" to a Foo instance without reflection. Foo *obj = [[Foo alloc] init]; [obj hello]; // Sending \"hello\" to a Foo instance with reflection. id obj = [[NSClassFromString(@\"Foo\") alloc] init]; [obj performSelector: @selector(hello)]; Perl[edit] The following is an example in Perl: # Without reflection my $foo = Foo->new; $foo->hello; # or Foo->new->hello; # With reflection my $class = \"Foo\" my $constructor = \"new\"; my $method = \"hello\"; my $f = $class->$constructor; $f->$method; # or $class->$constructor->$method; # with eval eval \"new Foo->hello;\"; PHP[edit] The following is an example in PHP: // Without reflection $foo = new Foo(); $foo->hello(); // With reflection, using Reflections API $reflector = new ReflectionClass(\"Foo\"); $foo = $reflector->newInstance(); $hello = $reflector->getMethod(\"hello\"); $hello->invoke($foo); Python[edit] The following is an example in Python: # Without reflection obj = Foo() obj.hello() # With reflection obj = globals()[\"Foo\"]() getattr(obj, \"hello\")() # With eval eval(\"Foo().hello()\") R[edit] The following is an example in R: # Without reflection, assuming foo() returns an S3-type object that has method \"hello\" obj <- foo() hello(obj) # With reflection class_name <- \"foo\" generic_having_foo_method <- \"hello\" obj <- do.call(class_name, list()) do.call(generic_having_foo_method, alist(obj)) Ruby[edit] The following is an example in Ruby: # Without reflection obj = Foo.new obj.hello # With reflection obj = Object.const_get(\"Foo\").new obj.send :hello # With eval eval \"Foo.new.hello\" Xojo[edit] The following is an example using Xojo: ' Without reflection Dim fooInstance As New Foo fooInstance.PrintHello ' With reflection Dim classInfo As Introspection.Typeinfo = GetTypeInfo(Foo) Dim constructors() As Introspection.ConstructorInfo = classInfo.GetConstructors Dim fooInstance As Foo = constructors(0).Invoke Dim methods() As Introspection.MethodInfo = classInfo.GetMethods For Each m As Introspection.MethodInfo In methods If m.Name = \"PrintHello\" Then m.Invoke(fooInstance) End If Next See also[edit] List of reflective programming languages and platforms Mirror (programming) Programming paradigms Self-hosting (compilers) Self-modifying code Type introspection typeof References[edit] Citations[edit] ^ A Tutorial on Behavioral Reflection and its Implementation by Jacques Malenfant et al. (PDF), unknown, archived from the original (PDF) on 21 August 2017, retrieved 23 June 2019 ^ Brian Cantwell Smith, Procedural Reflection in Programming Languages, Department of Electrical Engineering and Computer Science, Massachusetts Institute of Technology, PhD dissertation, 1982. ^ Brian C. Smith. Reflection and semantics in a procedural language Archived 2015-12-13 at the Wayback Machine. Technical Report MIT-LCS-TR-272, Massachusetts Institute of Technology, Cambridge, Massachusetts, January 1982. ^ Barros, Paulo; Just, René; Millstein, Suzanne; Vines, Paul; Dietl, Werner; d'Amorim, Marcelo; Ernst, Michael D. (August 2015). Static Analysis of Implicit Control Flow: Resolving Java Reflection and Android Intents (PDF) (Report). University of Washington. UW-CSE-15-08-01. Retrieved October 7, 2021. ^ Eauvidoum, Ieu; disk noise (October 5, 2021). \"Twenty years of Escaping the Java Sandbox\". Phrack. Vol. 10, no. 46. Retrieved October 7, 2021. ^ \"PHP: ReflectionClass - Manual\". www.php.net. Sources[edit] Jonathan M. Sobel and Daniel P. Friedman. An Introduction to Reflection-Oriented Programming (1996), Indiana University. Anti-Reflection technique using C# and C++/CLI wrapper to prevent code thief Further reading[edit] Ira R. Forman and Nate Forman, Java Reflection in Action (2005), ISBN 1-932394-18-4 Ira R. Forman and Scott Danforth, Putting Metaclasses to Work (1999), ISBN 0-201-43305-2 External links[edit] Reflection in logic, functional and object-oriented programming: a short comparative study An Introduction to Reflection-Oriented Programming Brian Foote's pages on Reflection in Smalltalk Java Reflection API Tutorial from Oracle vteProgramming paradigms (Comparison by language)ImperativeStructured Jackson structures Block-structured Modular Non-structured Procedural Programming in the large and in the small Design by contract Invariant-based Nested function Object-oriented(comparison, list) Class-based, Prototype-based, Object-based Agent Immutable object Persistent Uniform Function Call Syntax DeclarativeFunctional(comparison) Recursive Anonymous function (Partial application) Higher-order Purely functional Total Strict GADTs Dependent types Functional logic Point-free style Expression-oriented Applicative, Concatenative Function-level, Value-level Dataflow Flow-based Reactive (Functional reactive) Signals Streams Synchronous Logic Abductive logic Answer set Constraint (Constraint logic) Inductive logic Nondeterministic Ontology Probabilistic logic Query DSL Algebraic modeling Array Automata-based (Action) Command (Spacecraft) Differentiable End-user Grammar-oriented Interface description Language-oriented List comprehension Low-code Modeling Natural language Non-English-based Page description Pipes and filters Probabilistic Quantum Scientific Scripting Set-theoretic Simulation Stack-based System Tactile Templating Transformation (Graph rewriting, Production, Pattern) Visual Concurrent,distributed,parallel Actor-based Automatic mutual exclusion Choreographic programming Concurrent logic (Concurrent constraint logic) Concurrent OO Macroprogramming Multitier programming Organic computing Parallel programming models Partitioned global address space Process-oriented Relativistic programming Service-oriented Structured concurrency Metaprogramming Attribute-oriented Automatic (Inductive) Dynamic Extensible Generic Homoiconicity Interactive Macro (Hygienic) Metalinguistic abstraction Multi-stage Program synthesis (Bayesian, Inferential, by demonstration, by example) Reflective Self-modifying code Symbolic Template Separationof concerns Aspects Components Data-driven Data-oriented Event-driven Features Intentional Literate Roles Subjects vteTypes of programming languagesLevel Machine Assembly Compiled Interpreted Low-level High-level Very high-level Esoteric Generation First Second Third Fourth Fifth"
    },
    {
        "id": 12,
        "url": "https://en.wikipedia.org/wiki/Software_design",
        "title": "Software design",
        "content": "Process of planning software solutions Part of a series onSoftware development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DevOps DAD DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Software quality assurance Project management User experience Practices ATDD BDD CCO CI CD DDD PP SBE Stand-up TDD Tools Compiler Debugger Profiler GUI designer UML Modeling IDE Build automation Release automation Infrastructure as code Standards and bodies of knowledge CMMI IEEE standards ISO 9001 ISO/IEC standards PMBOK SWEBOK ITIL IREB OMG Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Outline of software development vte Software design is the process of conceptualizing how a software system will work before it is implemented or modified. Software design also refers to the direct result of the design process – the concepts of how the software will work which consists of both design documentation and undocumented concepts. Software design usually is directed by goals for the resulting system and involves problem-solving and planning – including both high-level software architecture and low-level component and algorithm design. In terms of the waterfall development process, software design is the activity of following requirements specification and before coding. General process[edit] The design process enables a designer to model various aspects of a software system before it exists. Creativity, past experience, a sense of what makes \"good\" software, and a commitment to quality are success factors for a competent design. However, the design process is not always a straightforward procedure. The software design model can be compared to an architected plan for a house. High-level plans represent the totality of the house (e.g., a three-dimensional rendering of the house). Lower-level plans provide guidance for constructing each detail (e.g., the plumbing lay). Similarly, the software design model provides a variety of views of the proposed software solution. Iterative Design for Software Components[edit] Software systems inherently deal with uncertainties, and the size of software components can significantly influence a system's outcomes, both positively and negatively. Neal Ford and Mark Richards propose an iterative approach to address the challenge of identifying and right-sizing components. This method emphasizes continuous refinement as teams develop a more nuanced understanding of system behavior and requirements. The approach typically involves a cycle with several stages: A high-level partitioning strategy is established, often categorized as technical or domain-based. Guidelines for the smallest meaningful deployable unit, referred to as \"quanta,\" are defined. While these foundational decisions are made early, they may be revisited later in the cycle if necessary. Initial components are identified based on the established strategy. Requirements are assigned to the identified components. The roles and responsibilities of each component are analyzed to ensure clarity and minimize overlap. Architectural characteristics, such as scalability, fault tolerance, and maintainability, are evaluated. Components may be restructured based on feedback from development teams. This cycle serves as a general framework and can be adapted to different domains. Value[edit] Software design documentation may be reviewed or presented to allow constraints, specifications and even requirements to be adjusted prior to coding. Redesign may occur after a review of a programmed simulation or prototype. It is possible to design software in the process of coding, without a plan or requirement analysis, but for more complex projects this is less feasible. A separate design prior to coding allows for multidisciplinary designers and subject-matter experts (SMEs) to collaborate with programmers in order to produce software that is useful and technically sound. Requirements analysis[edit] One component of software design is software requirements analysis (SRA). SRA is a part of the software development process that lists specifications used in software engineering. The output of the analysis is smaller problems to solve. In contrast, the design focuses on capabilities, and thus multiple designs for the same problem can exist. Depending on the environment, the design often varies, whether it is created from reliable frameworks or implemented with suitable design patterns. Artifacts[edit] A design process may include the production of artifacts such as flow chart, use case, Pseudocode, Unified Modeling Language model and other Fundamental modeling concepts. For user centered software, design may involve user experience design yielding a storyboard to help determine those specifications. Sometimes the output of a design process is design documentation. Design principles[edit] Basic design principles enable a software engineer to navigate the design process. Davis suggests a set of principles for software design, which have been adapted and extended in the following list: The design process should not suffer from \"tunnel vision\". A good designer should consider alternative approaches, judging each based on the requirements of the problem, the resources available to do the job. The design should be traceable to the analysis model. Because a single element of the design model can often be traced back to multiple requirements, it is necessary to have a means for tracking how requirements have been satisfied by the design model. The design should not reinvent the wheel. Systems are constructed using a set of design patterns, many of which have likely been encountered before. These patterns should always be chosen as an alternative to reinvention. Time is short and resources are limited; design time should be invested in representing (truly new) ideas by integrating patterns that already exist (when applicable). The design should \"minimize the intellectual distance\" between the software and the problem as it exists in the real world. That is, the structure of the software design should, whenever possible, mimic the structure of the problem domain. The design should exhibit uniformity and integration. A design is uniform if it appears fully coherent. In order to achieve this outcome, rules of style and format should be defined for a design team before design work begins. A design is integrated if care is taken in defining interfaces between design components. The design should be structured to accommodate change. The design concepts discussed in the next section enable a design to achieve this principle. The design should be structured to degrade gently, even when aberrant data, events, or operating conditions are encountered. Well-designed software should never \"bomb\"; it should be designed to accommodate unusual circumstances, and if it must terminate processing, it should do so in a graceful manner. Design is not coding, coding is not design. Even when detailed procedural designs are created for program components, the level of abstraction of the design model is higher than the source code. The only design decisions made at the coding level should address the small implementation details that enable the procedural design to be coded. The design should be assessed for quality as it is being created, not after the fact. A variety of design concepts and design measures are available to assist the designer in assessing quality throughout the development process. The design should be reviewed to minimize conceptual (semantic) errors. There is sometimes a tendency to focus on minutiae when the design is reviewed, missing the forest for the trees. A design team should ensure that major conceptual elements of the design (omissions, ambiguity, inconsistency) have been addressed before worrying about the syntax of the design model. Design concepts[edit] Design concepts provide a designer with a foundation from which more sophisticated methods can be applied. A set of design concepts has evolved including: Abstraction - Abstraction is the process or result of generalization by reducing the information content of a concept or an observable phenomenon, typically to retain only information that is relevant for a particular purpose. It is an act of Representing essential features without including the background details or explanations. Refinement - It is the process of elaboration. A hierarchy is developed by decomposing a macroscopic statement of function in a step-wise fashion until programming language statements are reached. In each step, one or several instructions of a given program are decomposed into more detailed instructions. Abstraction and Refinement are complementary concepts. Modularity - Software architecture is divided into components called modules. Software Architecture - It refers to the overall structure of the software and the ways in which that structure provides conceptual integrity for a system. Good software architecture will yield a good return on investment with respect to the desired outcome of the project, e.g. in terms of performance, quality, schedule and cost. Control Hierarchy - A program structure that represents the organization of a program component and implies a hierarchy of control. Structural Partitioning - The program structure can be divided horizontally and vertically. Horizontal partitions define separate branches of modular hierarchy for each major program function. Vertical partitioning suggests that control and work should be distributed top-down in the program structure. Data Structure - It is a representation of the logical relationship among individual elements of data. Software Procedure - It focuses on the processing of each module individually. Information Hiding - Modules should be specified and designed so that information contained within a module is inaccessible to other modules that have no need for such information. In his object model, Grady Booch mentions Abstraction, Encapsulation, Modularisation, and Hierarchy as fundamental software design principles. The acronym PHAME (Principles of Hierarchy, Abstraction, Modularisation, and Encapsulation) is sometimes used to refer to these four fundamental principles. Design considerations[edit] There are many aspects to consider in the design of a piece of software. The importance of each consideration should reflect the goals and expectations that the software is being created to meet. Some of these aspects are: Compatibility - The software is able to operate with other products that are designed for interoperability with another product. For example, a piece of software may be backward-compatible with an older version of itself. Extensibility - New capabilities can be added to the software without major changes to the underlying architecture. Modularity - the resulting software comprises well defined, independent components which leads to better maintainability. The components could be then implemented and tested in isolation before being integrated to form a desired software system. This allows division of work in a software development project. Fault-tolerance - The software is resistant to and able to recover from component failure. Maintainability - A measure of how easily bug fixes or functional modifications can be accomplished. High maintainability can be the product of modularity and extensibility. Reliability (Software durability) - The software is able to perform a required function under stated conditions for a specified period of time. Reusability - The ability to use some or all of the aspects of the preexisting software in other projects with little to no modification. Robustness - The software is able to operate under stress or tolerate unpredictable or invalid input. For example, it can be designed with resilience to low memory conditions. Security - The software is able to withstand and resist hostile acts and influences. Usability - The software user interface must be usable for its target user/audience. Default values for the parameters must be chosen so that they are a good choice for the majority of the users. Performance - The software performs its tasks within a time-frame that is acceptable for the user, and does not require too much memory. Portability - The software should be usable across a number of different conditions and environments. Scalability - The software adapts well to increasing data or added features or number of users. According to Marc Brooker: \"a system is scalable in the range where marginal cost of additional workload is nearly constant.\" Serverless technologies fit this definition but you need to consider total cost of ownership not just the infra cost. Modeling language[edit] A modeling language can be used to express information, knowledge or systems in a structure that is defined by a consistent set of rules. These rules are used for interpretation of the components within the structure. A modeling language can be graphical or textual. Examples of graphical modeling languages for software design include: Architecture description language (ADL) is a language used to describe and represent the software architecture of a software system. Business Process Modeling Notation (BPMN) is an example of a Process Modeling language. EXPRESS and EXPRESS-G (ISO 10303-11) is an international standard general-purpose data modeling language. Extended Enterprise Modeling Language (EEML) is commonly used for business process modeling across a number of layers. Flowcharts are schematic representations of algorithms or other step-wise processes. Fundamental Modeling Concepts (FMC) is modeling language for software-intensive systems. IDEF is a family of modeling languages, the most notable of which include IDEF0 for functional modeling, IDEF1X for information modeling, and IDEF5 for modeling ontologies. Jackson Structured Programming (JSP) is a method for structured programming based on correspondences between data stream structure and program structure. LePUS3 is an object-oriented visual Design Description Language and a formal specification language that is suitable primarily for modeling large object-oriented (Java, C++, C#) programs and design patterns. Unified Modeling Language (UML) is a general modeling language to describe software both structurally and behaviorally. It has a graphical notation and allows for extension with a Profile (UML). Alloy (specification language) is a general purpose specification language for expressing complex structural constraints and behavior in a software system. It provides a concise language base on first-order relational logic. Systems Modeling Language (SysML) is a new general-purpose modeling language for systems engineering. Service-oriented modeling framework (SOMF) Design patterns[edit] A software designer may identify a design aspect which has been visited and perhaps even solved by others in the past. A template or pattern describing a solution to a common problem is known as a design pattern. The reuse of such patterns can increase software development velocity. Code as design[edit] The difficulty of using the term \"design\" in relation to software is that in some senses, the source code of a program is the design for the program that it produces. To the extent that this is true, \"software design\" refers to the design of the design. Edsger W. Dijkstra referred to this layering of semantic levels as the \"radical novelty\" of computer programming, and Donald Knuth used his experience writing TeX to describe the futility of attempting to design a program prior to implementing it: TEX would have been a complete failure if I had merely specified it and not participated fully in its initial implementation. The process of implementation constantly led me to unanticipated questions and to new insights about how the original specifications could be improved. See also[edit] Wikimedia Commons has media related to Software design. Aspect-oriented software development Design Design rationale Graphic design Interaction design Icon design Outline of software Outline of software development Outline of software engineering Search-based software engineering Software Design Description (IEEE 1016) Software development User experience User interface design Web design Zero One Infinity References[edit] ^ Ralph, P. and Wand, Y. (2009). A proposal for a formal definition of the design concept. In Lyytinen, K., Loucopoulos, P., Mylopoulos, J., and Robinson, W., editors, Design Requirements Workshop (LNBIP 14), pp. 103–136. Springer-Verlag, p. 109 doi:10.1007/978-3-540-92966-6_6. ^ Freeman, Peter; David Hart (2004). \"A Science of design for software-intensive systems\". Communications of the ACM. 47 (8): 19–21 . doi:10.1145/1012037.1012054. S2CID 14331332. ^ a b Fundamentals of Software Architecture: An Engineering Approach. O'Reilly Media. 2020. ISBN 978-1492043454. ^ Ralph, P., and Wand, Y. A Proposal for a Formal Definition of the Design Concept. In, Lyytinen, K., Loucopoulos, P., Mylopoulos, J., and Robinson, W., (eds.), Design Requirements Engineering: A Ten-Year Perspective: Springer-Verlag, 2009, pp. 103-136 ^ Davis, A:\"201 Principles of Software Development\", McGraw Hill, 1995. ^ Booch, Grady; et al. (2004). Object-Oriented Analysis and Design with Applications (3rd ed.). MA, US: Addison Wesley. ISBN 0-201-89551-X. Retrieved 30 January 2015. ^ Suryanarayana, Girish (November 2014). Refactoring for Software Design Smells. Morgan Kaufmann. p. 258. ISBN 978-0128013977. ^ Carroll, John, ed. (1995). Scenario-Based Design: Envisioning Work and Technology in System Development. New York: John Wiley & Sons. ISBN 0471076597. ^ Building Serverless Applications on Knative. O'Reilly Media. ISBN 9781098142049. ^ Bell, Michael (2008). \"Introduction to Service-Oriented Modeling\". Service-Oriented Modeling: Service Analysis, Design, and Architecture. Wiley & Sons. ISBN 978-0-470-14111-3. ^ Judith Bishop. \"C# 3.0 Design Patterns: Use the Power of C# 3.0 to Solve Real-World Problems\". C# Books from O'Reilly Media. Retrieved 2012-05-15. If you want to speed up the development of your .NET applications, you're ready for C# design patterns -- elegant, accepted and proven ways to tackle common programming problems. ^ Dijkstra, E. W. (1988). \"On the cruelty of really teaching computing science\". Retrieved 2014-01-10. ^ Knuth, Donald E. (1989). \"Notes on the Errors of TeX\" (PDF). ^Roger S. Pressman (2001). Software engineering: a practitioner's approach. McGraw-Hill. ISBN 0-07-365578-3. vteComputer scienceNote: This template roughly follows the 2012 ACM Computing Classification System.Hardware Printed circuit board Peripheral Integrated circuit Very Large Scale Integration Systems on Chip (SoCs) Energy consumption (Green computing) Electronic design automation Hardware acceleration Processor Size / Form Computer systems organization Computer architecture Computational complexity Dependability Embedded system Real-time computing Networks Network architecture Network protocol Network components Network scheduler Network performance evaluation Network service Software organization Interpreter Middleware Virtual machine Operating system Software quality Software notations and tools Programming paradigm Programming language Compiler Domain-specific language Modeling language Software framework Integrated development environment Software configuration management Software library Software repository Software development Control variable Software development process Requirements analysis Software design Software construction Software deployment Software engineering Software maintenance Programming team Open-source model Theory of computation Model of computation Stochastic Formal language Automata theory Computability theory Computational complexity theory Logic Semantics Algorithms Algorithm design Analysis of algorithms Algorithmic efficiency Randomized algorithm Computational geometry Mathematics of computing Discrete mathematics Probability Statistics Mathematical software Information theory Mathematical analysis Numerical analysis Theoretical computer science Information systems Database management system Information storage systems Enterprise information system Social information systems Geographic information system Decision support system Process control system Multimedia information system Data mining Digital library Computing platform Digital marketing World Wide Web Information retrieval Security Cryptography Formal methods Security hacker Security services Intrusion detection system Hardware security Network security Information security Application security Human–computer interaction Interaction design Social computing Ubiquitous computing Visualization Accessibility Concurrency Concurrent computing Parallel computing Distributed computing Multithreading Multiprocessing Artificial intelligence Natural language processing Knowledge representation and reasoning Computer vision Automated planning and scheduling Search methodology Control method Philosophy of artificial intelligence Distributed artificial intelligence Machine learning Supervised learning Unsupervised learning Reinforcement learning Multi-task learning Cross-validation Graphics Animation Rendering Photograph manipulation Graphics processing unit Mixed reality Virtual reality Image compression Solid modeling Applied computing Quantum Computing E-commerce Enterprise software Computational mathematics Computational physics Computational chemistry Computational biology Computational social science Computational engineering Differentiable computing Computational healthcare Digital art Electronic publishing Cyberwarfare Electronic voting Video games Word processing Operations research Educational technology Document management Category Outline Glossaries vteSoftware engineeringFields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction Component-based software engineering Software compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software verification and validation Software system Structured analysis Essential analysis CI/CD Orientations Agile Aspect-oriented Object orientation Ontology Service orientation SDLC ModelsDevelopmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD UP Scrum Spiral model V-model Waterfall model XP Model-driven engineering Round-trip engineering Other SPICE CMMI Data model ER model Function model Information model Metamodeling Object model Systems model View model Languages IDEF UML USL SysML Related fields Computer science Computer engineering Information science Project management Risk management Systems engineering Commons Category vteDesign Outline Designer DisciplinesCommunicationdesign Advertising Book design Brand design Exhibit design Film title design Graphic design Motion Postage stamp design Print design Illustration Information design Instructional design News design Photography Retail design Signage / Traffic sign design Typography / Type design Video design Visual merchandising Environmentaldesign Architecture Architectural lighting design Building design Passive solar Ecological design Environmental impact design Garden design Computer-aided Healthy community design Hotel design Interior architecture Interior design EID Keyline design Landscape architecture Sustainable Landscape design Spatial design Urban design Industrialdesign Automotive design Automotive suspension design CMF design Corrugated box design Electric guitar design Furniture design Sustainable Hardware interface design Motorcycle design Packaging and labeling Photographic lens design Product design Production design Sensory design Service design Interactiondesign Experience design EED Game design Level design Video game design Hardware interface design Icon design Immersive design Information design Sonic interaction design User experience design User interface design Web design Otherapplied arts Public art design Ceramic / glass design Fashion design Costume design Jewellery design Floral design Game art design Property design Scenic design Sound design Stage/set lighting design Textile design Otherdesign& engineering Algorithm design Behavioural design Boiler design Database design Drug design Electrical system design Experimental design Filter design Geometric design Work design Integrated circuit design Circuit design Physical design Power network design Mechanism design Nuclear weapon design Nucleic acid design Organization design Process design Processor design Protein design Research design Social design Software design Spacecraft design Strategic design Systems design Approaches Activity-centered Adaptive web Affective Brainstorming By committee By contract C-K theory Closure Co-design Concept-oriented Configuration Contextual Continuous Cradle-to-cradle Creative problem-solving Creativity techniques Critical Design fiction Defensive Design–bid–build Design–build architect-led Diffuse Domain-driven Ecological design Energy neutral Engineering design process Probabilistic design Error-tolerant Fault-tolerant Framework-oriented For assembly For behaviour change For manufacturability For Six Sigma For testing For X Functional Generative Geodesign HCD High-level Inclusive Integrated Integrated topside Intelligence-based Iterative KISS principle Low-level Metadesign Mind mapping Modular New Wave Object-oriented Open Parametric Participatory Platform-based Policy-based Process-centered Public interest Rational Regenerative Reliability engineering Research-based Responsibility-driven RWD Safe-life Sustainable Systemic SOD Tableless web Theory of constraints Top-down and bottom-up Transformation Transgenerational TRIZ Universal Design for All Usage-centered Use-centered User-centered Empathic User innovation Value-driven Value sensitive Privacy by Design choice computing controls culture flow leadership management marker methods pattern research science sprint strategy theory thinking ToolsIntellectual propertyOrganizationsAwardsTools AAD Architectural model Blueprint Comprehensive layout CAD CAID Virtual home design software CAutoD Design quality indicator Electronic design automation Flowchart Mockup Design specification Prototype Sketch Storyboard Technical drawing HTML editor Website wireframe Intellectualproperty Community design Design around Design infringement Design patent Fashion design copyright Geschmacksmuster Industrial design rights European Union Organizations American Institute of Graphic Arts Chartered Society of Designers Design and Industries Association Design Council International Forum Design Design Research Society Awards European Design Award German Design Award Good Design Award (Museum of Modern Art) Good Design Award (Chicago Athenaeum) Graphex IF Product Design Award James Dyson Award Prince Philip Designers Prize Related topics Agile Concept art Conceptual design Creative industries Cultural icon .design Enterprise architecture Form factor Futures studies Indie design Innovation management Intelligent design Lean startup New product development OODA loop Philosophy of design Process simulation Slow design STEAM fields Unintelligent design Visualization Wicked problem Design brief change classic competition architectural student director education elements engineer firm history knowledge language life load museum paradigm principles rationale review specification studies studio technology Commons Wikibooks Wikinews Wikiquote Wikisource Wiktionary"
    },
    {
        "id": 13,
        "url": "https://en.wikipedia.org/wiki/Guido_van_Rossum",
        "title": "Guido van Rossum",
        "content": "Dutch programmer and creator of Python \"GvR\" redirects here. For other uses, see GVR (disambiguation). In this Dutch name, the surname is Van Rossum. Guido van RossumVan Rossum at PyCon US 2024Born (1956-01-31) 31 January 1956 (age 68)The Hague, NetherlandsNationalityDutchAlma materUniversity of AmsterdamOccupation(s)Computer programmer, authorEmployerMicrosoftKnown forCreating the Python programming languageSpouse Kim Knapp ​(m. 2000)​Children1AwardsAward for the Advancement of Free Software (2001)Websitegvanrossum.github.io Van Rossum at the 2008 Google I/O Developer's Conference Van Rossum at the 2006 O'Reilly Open Source Convention (OSCON) Guido van Rossum (Dutch: [ˈxidoː vɑn ˈrɔsʏm, -səm]; born 31 January 1956) is a Dutch programmer. He is the creator of the Python programming language, for which he was the \"benevolent dictator for life\" (BDFL) until he stepped down from the position on 12 July 2018. He remained a member of the Python Steering Council through 2019, and withdrew from nominations for the 2020 election. Life and education[edit] Van Rossum was born and raised in the Netherlands, where he received a master's degree in mathematics and computer science from the University of Amsterdam in 1982. He received a bronze medal in 1974 in the International Mathematical Olympiad. He has a brother, Just van Rossum, who is a type designer and programmer who designed the typeface used in the \"Python Powered\" logo. Van Rossum lives in Belmont, California, with his wife, Kim Knapp, and their son. Work[edit] Centrum Wiskunde & Informatica[edit] While working at the Centrum Wiskunde & Informatica (CWI), Van Rossum wrote and contributed a glob() routine to BSD Unix in 1986 and helped develop the ABC programming language. He once stated, \"I try to mention ABC's influence because I'm indebted to everything I learned during that project and to the people who worked on it.\" He also created Grail, an early web browser written in Python, and engaged in discussions about the HTML standard. He has worked for various research institutes, including the Centrum Wiskunde & Informatica (CWI) in the Netherlands, the U.S. National Institute of Standards and Technology (NIST), and the Corporation for National Research Initiatives (CNRI). In May 2000, he left CNRI along with three other Python core developers to work for tech startup BeOpen.com, which subsequently collapsed by October of the same year. From late 2000 until 2003 he worked for Zope Corporation. In 2003 Van Rossum left Zope for Elemental Security. While there he worked on a custom programming language for the organization. Google[edit] From 2005 to December 2012, Van Rossum worked at Google, where he spent half of his time developing the Python language. At Google, he developed Mondrian, a web-based code review system written in Python and used within the company. He named the software after the Dutch painter Piet Mondrian. He named Rietveld, another related software project, after Gerrit Rietveld, a Dutch designer. On 7 December 2012, Van Rossum left Google. Dropbox[edit] In January 2013, Van Rossum started working at the cloud file storage company Dropbox. In October 2019, Van Rossum left Dropbox and officially retired. Microsoft[edit] On 12 November 2020 Van Rossum announced that he was coming out of retirement to join the Developer Division at Microsoft. He currently holds the title Distinguished Engineer at Microsoft. Python[edit] In December 1989, Van Rossum had been looking for a \"'hobby' programming project that would keep [him] occupied during the week around Christmas\" as his office was closed when he decided to write an interpreter for a \"new scripting language [he] had been thinking about lately: a descendant of ABC that would appeal to Unix/C hackers\". He attributes choosing the name \"Python\" to \"being in a slightly irreverent mood (and a big fan of Monty Python's Flying Circus)\". He has explained that Python's predecessor, ABC, was inspired by SETL, noting that ABC co-developer Lambert Meertens had \"spent a year with the SETL group at NYU before coming up with the final ABC design\". On 12 July 2018, Van Rossum announced that he would be stepping down from the position of benevolent dictator for life of the Python programming language. \"Computer Programming for Everybody\" proposal[edit] In 1999, Van Rossum submitted a funding proposal to the Defense Advanced Research Projects Agency (DARPA) called \"Computer Programming for Everybody\", in which he further defined his goals for Python: An easy and intuitive language just as powerful as major competitors Open source, so anyone can contribute to its development Code that is as understandable as plain English Suitability for everyday tasks, allowing for short development times In 2019, Python became the second most popular language on GitHub, the largest source code management website on the internet, after JavaScript. In 2024 Python became the most used language on GitHub, overtaking JavaScript after a 10-year run as the most used language. According to a programming language popularity survey it is consistently among the top 10 most mentioned languages in job postings. Furthermore, Python has been among the 10 most popular programming languages every year since 2004 according to the TIOBE Programming Community Index and got the number one spot on the index in October 2021. Awards[edit] At the 2002 FOSDEM conference in Brussels, Van Rossum received the 2001 Award for the Advancement of Free Software from the Free Software Foundation (FSF) for his work on Python. In May 2003, he received a NLUUG Award. In 2006, he was recognized as a Distinguished Engineer by the Association for Computing Machinery. In 2018, he was made a Fellow of the Computer History museum. In 2019, he was awarded the honorary title of Dijkstra Fellow by CWI. In 2023, he was awarded the C&C Prize by NEC Corporation for developing the Python programming language. References[edit] ^ van Rossum, Guido (31 January 2007). \"(Python-Dev) Happy Birthday, Guido!\". Python-Dev mailing list. Archived from the original on 8 September 2009. ^ Hsu, Hansen (5 April 2018). \"2018 Museum Fellow Guido van Rossum, Python Creator & Benevolent Dictator for Life\". Computer History Museum. Archived from the original on 24 July 2018. Retrieved 19 May 2021. ^ \"Guido van Rossum\". CodeCall Programming Wiki. Archived from the original on 31 October 2008. ^ \"Benevolent dictator for life\". Linux Format. 1 February 2005. Archived from the original on 1 October 2006. Retrieved 1 November 2007. ^ \"[python-committers] Transfer of power\". www.mail-archive.com. Archived from the original on 12 July 2018. Retrieved 12 July 2018. ^ \"Steering Council nomination: Guido van Rossum (2020 term)\". 27 November 2019. Archived from the original on 14 December 2021. Retrieved 13 November 2020. ^ \"International Mathematical Olympiad\". www.imo-official.org. Archived from the original on 10 March 2023. Retrieved 23 May 2022. ^ Thomas, Jockin (28 May 2016). \"Learning Python Makes You A Better Designer: An Interview with Just van Rossum\". Medium. Archived from the original on 25 October 2019. Retrieved 25 October 2019. ^ Manheimer, Ken (6 June 2000). \"(Python-Dev) Guido and Kim married\". Python-Dev -- Python core developers. Archived from the original on 28 September 2010. ^ \"Guido van Rossum - Brief Bio\". Archived from the original on 19 August 2014. ^ \"(Mailman-Announce) forwarded message from Guido van Rossum\". 30 May 2000. Archived from the original on 27 May 2008. Oh, and to top it all off, I'm going on vacation. I'm getting married and will be relaxing on my honeymoon. ^ van Rossum, Guido. \"What's New in Python?\" (PDF). \"Not your usual list of new features\". Stanford CSL Colloquium, 29 October 2003; BayPiggies, 13 November 2003. Elemental Security. Archived (PDF) from the original on 27 June 2010. ^ \"'Globbing' library routine\". Archived from the original on 19 December 2007. ^ \"File::Glob - Perl extension for BSD glob routine\". metacpan.org. Archived from the original on 7 August 2013. ^ Venners, Bill. \"The Making of Python\". www.artima.com. Archived from the original on 1 September 2016. Retrieved 14 September 2016. ^ \"Re: xmosaic experience\". Archived from the original on 28 August 2016. ^ \"Oral History of Guido van Rossum, part 2 - Computer History Museum\" (PDF). Archived (PDF) from the original on 17 November 2021. Retrieved 17 November 2021. ^ \"Python 2.3.2 License A. HISTORY OF THE SOFTWARE\". Archived from the original on 17 November 2021. Retrieved 17 November 2020. ^ \"2018 Museum Fellow Guido van Rossum, Python Creator & Benevolent Dictator for Life - Computer History Museum\". 5 April 2018. Archived from the original on 24 July 2018. Retrieved 23 August 2018. ^ van Rossum, Guido (May 2008). \"An Open Source App: Rietveld Code Review Tool\". Archived from the original on 17 October 2015. Retrieved 24 August 2012. ... the internal web app, which I code-named Mondrian after one of my favorite Dutch painters ^ \"An Open Source App: Rietveld Code Review Tool\". Archived from the original on 17 October 2015. ^ \"Guido van Rossum\". @gvanrossum. Twitter. Archived from the original on 16 December 2013. Retrieved 15 August 2022. Today's my last day at Google. In January I start a new job at Dropbox: t.co/JxnfdBM0 ^ Constine, Josh (7 December 2012). \"Dropbox Hires Away Google's Guido van Rossum, The Father Of Python\". Techcrunch. Archived from the original on 9 December 2012. Retrieved 7 December 2012. ^ \"Welcome Guido!\". Dropbox Tech Blog. 7 December 2012. Archived from the original on 7 September 2013. Retrieved 6 September 2013. ^ @gvanrossum (30 October 2019). \"It's bittersweet: I'm leaving @dropbox, and am now retired. I've learned a lot during my time as an engineer here -- e.g. type annotations came from this experience -- and I'll miss working here\" (Tweet). Retrieved 30 October 2019 – via Twitter. ^ \"Thank you, Guido\". Dropbox Blog. Dropbox. Archived from the original on 16 February 2021. Retrieved 1 February 2021. ^ Tung, Liam (31 October 2019). \"Python programming language creator retires, saying: 'It's been an amazing ride'\". ZDNet. Archived from the original on 21 January 2021. Retrieved 1 February 2021. ^ \"Guido van Rossum\". Python's BDFL-emeritus, Distinguished Engineer at Microsoft, Computer History Fellow. [self-published source] ^ @gvanrossum (12 November 2020). \"I decided that retirement was boring and have joined the Developer Division at Microsoft. To do what? Too many options to say! But it'll make using Python better for sure (and not just on Windows :-). There's lots of open source here. Watch this space\" (Tweet). Retrieved 12 November 2020 – via Twitter. ^ Lardinois, Frederic (12 November 2020). \"Python creator Guido van Rossum joins Microsoft\". TechCrunch. Archived from the original on 24 January 2021. Retrieved 16 November 2020. ^ \"Foreword for \"Programming Python\" (1st ed.)\". Archived from the original on 24 July 2014. ^ \"Python-Dev] SETL (was: Lukewarm about range literals)\". 29 August 2000. Archived from the original on 14 May 2011. ^ Fairchild, Carlie (12 July 2018). \"Guido van Rossum Stepping Down from Role as Python's Benevolent Dictator For Life\". Linux Journal. Archived from the original on 13 July 2018. Retrieved 12 July 2018. ^ \"The State of the Octoverse\". The State of the Octoverse. Archived from the original on 5 April 2017. Retrieved 6 May 2021. ^ \"Octoverse: AI leads Python to top language as the number of global developers surges\". GitHub Insights. Archived from the original on 16 November 2024. Retrieved 6 January 2025. ^ \"Programming Language Popularity\". Archived from the original on 12 April 2015. ^ \"index | TIOBE - The Software Quality Company\". www.tiobe.com. Archived from the original on 15 October 2023. Retrieved 29 May 2020. ^ \"Guido van Rossum Ontvangt NLUUG Award\". NLUUG. 28 May 2003. Archived from the original on 8 March 2021. Retrieved 22 January 2018. ^ \"Guido van Rossum\". Computer History Museum. Archived from the original on 3 July 2019. Retrieved 22 February 2018. ^ \"David Chaum and Guido van Rossum awarded Dijkstra Fellowship\". www.cwi.nl. Archived from the original on 21 March 2024. Retrieved 21 March 2024. ^ \"NEC C&C Foundation Awards 2023 C&C Prize\". nec.com. Tokyo. 10 October 2023. Archived from the original on 19 February 2024. Retrieved 19 February 2024. External links[edit] Free and open-source software portal Wikimedia Commons has media related to Guido van Rossum. Official website Guido van Rossum. The History of Python Guido van Rossum. Neopythonic: Ramblings Computer Programming for Everybody Guido van Rossum Interview on FLOSS Weekly Guido van Rossum interview - Workspiration.org Guido van Rossum on Python Interview - Computerworld Guido van Rossum Run your web applications on Google's infrastructure — Google App Engine technical talk at Stanford University. (video archive) Oral History of Guido Van Rossum Part 1 on YouTube Computer History Museum Oral History of Guido Van Rossum Part 2 on YouTube Computer History Museum vtePythonImplementations CircuitPython CLPython CPython Cython MicroPython Numba IronPython Jython Psyco PyPy Python for S60 Shed Skin Stackless Python Unladen Swallow more... IDEs eric IDLE Ninja-IDE PyCharm PyDev Spyder more... Topics WSGI ASGI Designer Guido van Rossum Software (list) Python Software Foundation Python Conference (PyCon) Authority control databases InternationalISNIVIAFWorldCatNationalGermanyUnited StatesJapanNetherlandsAcademicsCiNiiAssociation for Computing MachineryzbMATHDBLP"
    },
    {
        "id": 14,
        "url": "https://en.wikipedia.org/wiki/Software_developer",
        "title": "Software development",
        "content": "Creation and maintenance of software Part of a series onSoftware development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DevOps DAD DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Software quality assurance Project management User experience Practices ATDD BDD CCO CI CD DDD PP SBE Stand-up TDD Tools Compiler Debugger Profiler GUI designer UML Modeling IDE Build automation Release automation Infrastructure as code Standards and bodies of knowledge CMMI IEEE standards ISO 9001 ISO/IEC standards PMBOK SWEBOK ITIL IREB OMG Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Outline of software development vte Software development is the process of designing and implementing a software solution to satisfy a user. The process is more encompassing than programming, writing code, in that it includes conceiving the goal, evaluating feasibility, analyzing requirements, design, testing and release. The process is part of software engineering which also includes organizational management, project management, configuration management and other aspects. Software development involves many skills and job specializations including programming, testing, documentation, graphic design, user support, marketing, and fundraising. Software development involves many tools including: compiler, integrated development environment (IDE), version control, computer-aided software engineering, and word processor. The details of the process used for a development effort varies. The process may be confined to a formal, documented standard, or it can be customized and emergent for the development effort. The process may be sequential, in which each major phase (i.e. design, implement and test) is completed before the next begins, but an iterative approach – where small aspects are separately designed, implemented and tested – can reduce risk and cost and increase quality. Methodologies[edit] Main article: Software development methodology Flowchart of the evolutionary prototyping model, an iterative development model Each of the available methodologies are best suited to specific kinds of projects, based on various technical, organizational, project, and team considerations. The simplest methodology is the \"code and fix\", typically used by a single programmer working on a small project. After briefly considering the purpose of the program, the programmer codes it and runs it to see if it works. When they are done, the product is released. This methodology is useful for prototypes but cannot be used for more elaborate programs. In the top-down waterfall model, feasibility, analysis, design, development, quality assurance, and implementation occur sequentially in that order. This model requires one step to be complete before the next begins, causing delays, and makes it impossible to revise previous steps if necessary. With iterative processes these steps are interleaved with each other for improved flexibility, efficiency, and more realistic scheduling. Instead of completing the project all at once, one might go through most of the steps with one component at a time. Iterative development also lets developers prioritize the most important features, enabling lower priority ones to be dropped later on if necessary. Agile is one popular method, originally intended for small or medium sized projects, that focuses on giving developers more control over the features that they work on to reduce the risk of time or cost overruns. Derivatives of agile include extreme programming and Scrum. Open-source software development typically uses agile methodology with concurrent design, coding, and testing, due to reliance on a distributed network of volunteer contributors. Beyond agile, some companies integrate information technology (IT) operations with software development, which is called DevOps or DevSecOps including computer security. DevOps includes continuous development, testing, integration of new code in the version control system, deployment of the new code, and sometimes delivery of the code to clients. The purpose of this integration is to deliver IT services more quickly and efficiently. Another focus in many programming methodologies is the idea of trying to catch issues such as security vulnerabilities and bugs as early as possible (shift-left testing) to reduce the cost of tracking and fixing them. In 2009, it was estimated that 32 percent of software projects were delivered on time and budget, and with the full functionality. An additional 44 percent were delivered, but missing at least one of these features. The remaining 24 percent were cancelled prior to release. Steps[edit] Software development life cycle refers to the systematic process of developing applications. Feasibility[edit] The sources of ideas for software products are plentiful. These ideas can come from market research including the demographics of potential new customers, existing customers, sales prospects who rejected the product, other internal software development staff, or a creative third party. Ideas for software products are usually first evaluated by marketing personnel for economic feasibility, fit with existing channels of distribution, possible effects on existing product lines, required features, and fit with the company's marketing objectives. In the marketing evaluation phase, the cost and time assumptions become evaluated. The feasibility analysis estimates the project's return on investment, its development cost and timeframe. Based on this analysis, the company can make a business decision to invest in further development. After deciding to develop the software, the company is focused on delivering the product at or below the estimated cost and time, and with a high standard of quality (i.e., lack of bugs) and the desired functionality. Nevertheless, most software projects run late and sometimes compromises are made in features or quality to meet a deadline. Analysis[edit] Software analysis begins with a requirements analysis to capture the business needs of the software. Challenges for the identification of needs are that current or potential users may have different and incompatible needs, may not understand their own needs, and change their needs during the process of software development. Ultimately, the result of analysis is a detailed specification for the product that developers can work from. Software analysts often decompose the project into smaller objects, components that can be reused for increased cost-effectiveness, efficiency, and reliability. Decomposing the project may enable a multi-threaded implementation that runs significantly faster on multiprocessor computers. During the analysis and design phases of software development, structured analysis is often used to break down the customer's requirements into pieces that can be implemented by software programmers. The underlying logic of the program may be represented in data-flow diagrams, data dictionaries, pseudocode, state transition diagrams, and/or entity relationship diagrams. If the project incorporates a piece of legacy software that has not been modeled, this software may be modeled to help ensure it is correctly incorporated with the newer software. Design[edit] Main article: software design Design involves choices about the implementation of the software, such as which programming languages and database software to use, or how the hardware and network communications will be organized. Design may be iterative with users consulted about their needs in a process of trial and error. Design often involves people expert in aspect such as database design, screen architecture, and the performance of servers and other hardware. Designers often attempt to find patterns in the software's functionality to spin off distinct modules that can be reused with object-oriented programming. An example of this is the model–view–controller, an interface between a graphical user interface and the backend. Programming[edit] Main article: computer programming The central feature of software development is creating and understanding the software that implements the desired functionality. There are various strategies for writing the code. Cohesive software has various components that are independent from each other. Coupling is the interrelation of different software components, which is viewed as undesirable because it increases the difficulty of maintenance. Often, software programmers do not follow industry best practices, resulting in code that is inefficient, difficult to understand, or lacking documentation on its functionality. These standards are especially likely to break down in the presence of deadlines. As a result, testing, debugging, and revising the code becomes much more difficult. Code refactoring, for example adding more comments to the code, is a solution to improve the understandability of code. Testing[edit] Main article: software testing Testing is the process of ensuring that the code executes correctly and without errors. Debugging is performed by each software developer on their own code to confirm that the code does what it is intended to. In particular, it is crucial that the software executes on all inputs, even if the result is incorrect. Code reviews by other developers are often used to scrutinize new code added to the project, and according to some estimates dramatically reduce the number of bugs persisting after testing is complete. Once the code has been submitted, quality assurance—a separate department of non-programmers for most large companies—test the accuracy of the entire software product. Acceptance tests derived from the original software requirements are a popular tool for this. Quality testing also often includes stress and load checking (whether the software is robust to heavy levels of input or usage), integration testing (to ensure that the software is adequately integrated with other software), and compatibility testing (measuring the software's performance across different operating systems or browsers). When tests are written before the code, this is called test-driven development. Production[edit] See also: Software release life cycle Production is the phase in which software is deployed to the end user. During production, the developer may create technical support resources for users or a process for fixing bugs and errors that were not caught earlier. There might also be a return to earlier development phases if user needs changed or were misunderstood. Workers[edit] Software development is performed by software developers, usually working on a team. Efficient communications between team members is essential to success. This is more easily achieved if the team is small, used to working together, and located near each other. Communications also help identify problems at an earlier state of development and avoid duplicated effort. Many development projects avoid the risk of losing essential knowledge held by only one employee by ensuring that multiple workers are familiar with each component. Software development involves professionals from various fields, not just software programmers but also individuals specialized in testing, documentation writing, graphic design, user support, marketing, and fundraising. Although workers for proprietary software are paid, most contributors to open-source software are volunteers. Alternately, they may be paid by companies whose business model does not involve selling the software, but something else—such as services and modifications to open source software. Models and tools[edit] Computer-aided software engineering[edit] Computer-aided software engineering (CASE) is tools for the partial automation of software development. CASE enables designers to sketch out the logic of a program, whether one to be written, or an already existing one to help integrate it with new code or reverse engineer it (for example, to change the programming language). Documentation[edit] Main article: Software documentation Documentation comes in two forms that are usually kept separate—that intended for software developers, and that made available to the end user to help them use the software. Most developer documentation is in the form of code comments for each file, class, and method that cover the application programming interface (API)—how the piece of software can be accessed by another—and often implementation details. This documentation is helpful for new developers to understand the project when they begin working on it. In agile development, the documentation is often written at the same time as the code. User documentation is more frequently written by technical writers. Effort estimation[edit] Main article: Software development effort estimation Accurate estimation is crucial at the feasibility stage and in delivering the product on time and within budget. The process of generating estimations is often delegated by the project manager. Because the effort estimation is directly related to the size of the complete application, it is strongly influenced by addition of features in the requirements—the more requirements, the higher the development cost. Aspects not related to functionality, such as the experience of the software developers and code reusability, are also essential to consider in estimation. As of 2019[update], most of the tools for estimating the amount of time and resources for software development were designed for conventional applications and are not applicable to web applications or mobile applications. Integrated development environment[edit] Anjuta, a C and C++ IDE for the GNOME environment An integrated development environment (IDE) supports software development with enhanced features compared to a simple text editor. IDEs often include automated compiling, syntax highlighting of errors, debugging assistance, integration with version control, and semi-automation of tests. Version control[edit] Main article: Version control Version control is a popular way of managing changes made to the software. Whenever a new version is checked in, the software saves a backup of all modified files. If multiple programmers are working on the software simultaneously, it manages the merging of their code changes. The software highlights cases where there is a conflict between two sets of changes and allows programmers to fix the conflict. View model[edit] The TEAF Matrix of Views and Perspectives A view model is a framework that provides the viewpoints on the system and its environment, to be used in the software development process. It is a graphical representation of the underlying semantics of a view. The purpose of viewpoints and views is to enable human engineers to comprehend very complex systems and to organize the elements of the problem around domains of expertise. In the engineering of physically intensive systems, viewpoints often correspond to capabilities and responsibilities within the engineering organization. Fitness functions[edit] Fitness functions are automated and objective tests to ensure that the new developments don't deviate from the established constraints, checks and compliance controls. Intellectual property[edit] Intellectual property can be an issue when developers integrate open-source code or libraries into a proprietary product, because most open-source licenses used for software require that modifications be released under the same license. As an alternative, developers may choose a proprietary alternative or write their own software module. References[edit] ^ Dooley 2017, p. 1. ^ Dooley 2017, p. 12. ^ System Development Methodologies for Web-Enabled E-Business: A Customization Framework Linda V. Knight (DePaul University, USA), Theresa A. Steinbach (DePaul University, USA) and Vince Kellen (Blue Wolf, USA) ^ Dooley 2017, pp. 8–9. ^ Dooley 2017, p. 9. ^ a b Langer 2016, pp. 2–3, 5–6. ^ Tucker, Morelli & de Silva 2011, p. 8. ^ Dooley 2017, p. 11. ^ a b Dooley 2017, p. 13. ^ Tucker, Morelli & de Silva 2011, pp. 41–42. ^ a b Vishnu 2019, pp. 1–2. ^ Laukkanen, Eero; Itkonen, Juha; Lassenius, Casper (2017). \"Problems, causes and solutions when adopting continuous delivery—A systematic literature review\". Information and Software Technology. 82: 55–79. doi:10.1016/j.infsof.2016.10.001. ^ Winters, Manshreck & Wright 2020, p. 17. ^ Tucker, Morelli & de Silva 2011, p. 6. ^ Saif 2019, pp. 46–47. ^ Morris 2001, p. 1.10. ^ Langer 2016, p. 7. ^ Dooley 2017, pp. 3, 8. ^ a b c d Langer 2016, p. 8. ^ Langer 2016, pp. 2–3. ^ Dooley 2017, pp. 193–194. ^ Langer 2016, pp. 103–104. ^ Langer 2016, pp. 117, 127, 131, 137, 141. ^ Langer 2016, p. 106. ^ Dooley 2017, p. 142. ^ Tucker, Morelli & de Silva 2011, p. 31. ^ Langer 2016, pp. 8–9. ^ Tucker, Morelli & de Silva 2011, pp. 31–32. ^ Tucker, Morelli & de Silva 2011, pp. 34–35. ^ Tucker, Morelli & de Silva 2011, pp. 31–32, 35. ^ a b c Langer 2016, p. 9. ^ Dooley 2017, p. 272. ^ Tucker, Morelli & de Silva 2011, p. 9. ^ a b c Langer 2016, p. 10. ^ Tucker, Morelli & de Silva 2011, p. 37. ^ Dooley 2017, p. 2. ^ Winters, Manshreck & Wright 2020, pp. 30–31. ^ Tucker, Morelli & de Silva 2011, p. 7. ^ Tucker, Morelli & de Silva 2011, pp. 14–15. ^ Langer 2016, p. 22. ^ Langer 2016, pp. 108–110, 206. ^ Tucker, Morelli & de Silva 2011, p. 243. ^ Winters, Manshreck & Wright 2020, p. 192. ^ Winters, Manshreck & Wright 2020, pp. 193–195. ^ Tucker, Morelli & de Silva 2011, p. 143. ^ Tucker, Morelli & de Silva 2011, p. 144. ^ Winters, Manshreck & Wright 2020, p. 204. ^ Saif 2019, pp. 50–51. ^ Saif 2019, pp. 52–53. ^ Saif 2019, p. 45. ^ a b Tucker, Morelli & de Silva 2011, p. 68. ^ Dooley 2017, p. 236. ^ Dooley 2017, p. 239. ^ Dooley 2017, pp. 246–247. ^ Edward J. Barkmeyer ea (2003). Concepts for Automating Systems Integration Archived 25 January 2017 at the Wayback Machine NIST 2003. ^ Fundamentals of Software Architecture: An Engineering Approach. O'Reilly Media. 2020. ISBN 978-1492043454. ^ Langer 2016, pp. 44–45. Further reading[edit] Conde, Dan (2002). Software Product Management: Managing Software Development from Idea to Product to Marketing to Sales. Aspatore Books. ISBN 1587622025. Davis, A. M. (2005). Just enough requirements management: Where software development meets marketing. Dorset House Publishing Company, Incorporated. ISBN 0932633641. Dooley, John F. (2017). Software Development, Design and Coding: With Patterns, Debugging, Unit Testing, and Refactoring. Apress. ISBN 978-1-4842-3153-1. Kit, Edward (1992). Software Testing in The Real World. Addison-Wesley Professional. ISBN 0201877562. Hasted, Edward (2005). Software That Sells: A Practical Guide to Developing and Marketing Your Software Project. Wiley Publishing. ISBN 0764597833. Hohmann, Luke (2003). Beyond Software Architecture: Creating and Sustaining Winning Solutions. Addison-Wesley Professional. ISBN 0201775948. Horch, John W. (March 1995). \"Two Orientations On How To Work With Objects\". IEEE Software. 12 (2): 117–118. ProQuest 215832531. Langer, Arthur M. (2016). Guide to Software Development: Designing and Managing the Life Cycle. Springer. ISBN 978-1-4471-6799-0. McCarthy, Jim (1995). Dynamics of Software Development. Microsoft Press. ISBN 1556158238. Morris, Joseph M. (2001). Software industry accounting (2nd ed.). John Wiley & Sons. OCLC 53863959. Rittinghouse, John (2003). Managing Software Deliverables: A Software Development Management Methodology. Digital Press. ISBN 155558313X. Saif, Syed Mohsin (2019). \"Software Effort Estimation for Successful Software Application Development\". In Vishnu, Pendyala (ed.). Tools and Techniques for Software Development in Large Organizations: Emerging Research and Opportunities: Emerging Research and Opportunities. IGI Global. pp. 45–97. ISBN 978-1-7998-1865-6. Tucker, Allen; Morelli, Ralph; de Silva, Chamindra (2011). Software Development: An Open Source Approach. CRC Press. ISBN 978-1-4398-8460-7. Vishnu, Pendyala (2019). \"Evolution of Integration, Build, Test, and Release Engineering Into DevOps and to DevSecOps\". In Vishnu, Pendyala (ed.). Tools and Techniques for Software Development in Large Organizations: Emerging Research and Opportunities: Emerging Research and Opportunities. IGI Global. pp. 1–20. ISBN 978-1-7998-1865-6. Wiegers, Karl E. (2005). More About Software Requirements: Thorny Issues and Practical Advice. Microsoft Press. ISBN 0735622671. Winters, Titus; Manshreck, Tom; Wright, Hyrum (2020). Software Engineering at Google: Lessons Learned from Programming Over Time. O'Reilly Media, Inc. ISBN 978-1-4920-8276-7. Wysocki, Robert K. (2006). Effective Software Project Management. Wiley. ISBN 0764596365. External links[edit] Media related to Software development at Wikimedia Commons vteSoftware engineeringFields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction Component-based software engineering Software compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software verification and validation Software system Structured analysis Essential analysis CI/CD Orientations Agile Aspect-oriented Object orientation Ontology Service orientation SDLC ModelsDevelopmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD UP Scrum Spiral model V-model Waterfall model XP Model-driven engineering Round-trip engineering Other SPICE CMMI Data model ER model Function model Information model Metamodeling Object model Systems model View model Languages IDEF UML USL SysML Related fields Computer science Computer engineering Information science Project management Risk management Systems engineering Commons Category vteComputer scienceNote: This template roughly follows the 2012 ACM Computing Classification System.Hardware Printed circuit board Peripheral Integrated circuit Very Large Scale Integration Systems on Chip (SoCs) Energy consumption (Green computing) Electronic design automation Hardware acceleration Processor Size / Form Computer systems organization Computer architecture Computational complexity Dependability Embedded system Real-time computing Networks Network architecture Network protocol Network components Network scheduler Network performance evaluation Network service Software organization Interpreter Middleware Virtual machine Operating system Software quality Software notations and tools Programming paradigm Programming language Compiler Domain-specific language Modeling language Software framework Integrated development environment Software configuration management Software library Software repository Software development Control variable Software development process Requirements analysis Software design Software construction Software deployment Software engineering Software maintenance Programming team Open-source model Theory of computation Model of computation Stochastic Formal language Automata theory Computability theory Computational complexity theory Logic Semantics Algorithms Algorithm design Analysis of algorithms Algorithmic efficiency Randomized algorithm Computational geometry Mathematics of computing Discrete mathematics Probability Statistics Mathematical software Information theory Mathematical analysis Numerical analysis Theoretical computer science Information systems Database management system Information storage systems Enterprise information system Social information systems Geographic information system Decision support system Process control system Multimedia information system Data mining Digital library Computing platform Digital marketing World Wide Web Information retrieval Security Cryptography Formal methods Security hacker Security services Intrusion detection system Hardware security Network security Information security Application security Human–computer interaction Interaction design Social computing Ubiquitous computing Visualization Accessibility Concurrency Concurrent computing Parallel computing Distributed computing Multithreading Multiprocessing Artificial intelligence Natural language processing Knowledge representation and reasoning Computer vision Automated planning and scheduling Search methodology Control method Philosophy of artificial intelligence Distributed artificial intelligence Machine learning Supervised learning Unsupervised learning Reinforcement learning Multi-task learning Cross-validation Graphics Animation Rendering Photograph manipulation Graphics processing unit Mixed reality Virtual reality Image compression Solid modeling Applied computing Quantum Computing E-commerce Enterprise software Computational mathematics Computational physics Computational chemistry Computational biology Computational social science Computational engineering Differentiable computing Computational healthcare Digital art Electronic publishing Cyberwarfare Electronic voting Video games Word processing Operations research Educational technology Document management Category Outline Glossaries Authority control databases: National GermanyUnited StatesJapanSpainIsrael"
    },
    {
        "id": 15,
        "url": "https://en.wikipedia.org/wiki/Python_Software_Foundation",
        "title": "Python Software Foundation",
        "content": "American nonprofit organization Python Software FoundationAbbreviationPSFFormationMarch 6, 2001Type501(c)(3) nonprofit organizationPurposePromote, protect, and advance the Python programming language, and to support and facilitate the growth of a diverse and international community of Python programmersHeadquartersWilmington, Delaware, United StatesRegion served WorldwideOfficial language EnglishFounderGuido van RossumChairDawn WagesExecutive DirectorDeb NicholsonRevenue$3.9 million (2022)Websitepython.org/psf-landing The Python Software Foundation (PSF) is an American nonprofit organization devoted to the Python programming language, launched on March 6, 2001. The mission of the foundation is to foster development of the Python community and is responsible for various processes within the Python community, including developing the core Python distribution, managing intellectual rights, developer conferences including the Python Conference (PyCon), and raising funds. In 2005, the Python Software Foundation received the Computerworld Horizon Award for \"cutting-edge\" technology. Overview[edit] The PSF focuses on empowering and supporting people within the Python community with grant programs that support sprints, conferences, meetups, user groups, and Python development. The PSF runs Python Conference (PyCon) US, the leading Python community conference. The PSF is the primary point of contact for organizations that wish to work with Python, to support Python, or sponsor Python development. The PSF provides a structure by which work, donations, and sponsorships are coordinated worldwide. The PSF also possesses and protects intellectual property associated with Python and the Python community, such as the word \"Python,\" the two-snakes logo, and the terms \"PyLadies\" and \"PyCon.\" Membership[edit] There are five tiers of membership within the PSF. These tiers include: Basic members – Basic members are individuals or entities who are part of the Python language community and who have decided to declare their support for Python and agree to the community Code of Conduct. Supporting members – Supporting members make an annual donation to the PSF to sustain the foundation and support the Python community. Supporting members are eligible to vote. Managing members – Managing members are people who commit to working at least five hours per month to support the Python ecosystem, by organizing Python events, managing or contributing to PSF projects, running infrastructure, participating in one of the PSF's working groups, etc. Managing members are eligible to vote. Contributing members – Contributing members are people who dedicate at least five hours per month working on projects that advance the mission of the PSF, where the work relates to the creation or maintenance of open source software available to the public at no charge. Contributing members are eligible to vote. Fellows – Fellows are members who have been nominated by their extraordinary efforts and impact upon Python, the community, and the broader Python ecosystem. Fellows are nominated from the broader community and elevated by a vote of the members. Fellow members are eligible to vote. Code of Conduct[edit] Since late 2012, the Python Software Foundation started recommending that all Python conferences create and apply a code of conduct. This is mandatory to any event to be granted funds by the Python Software Foundation. See also[edit] PyLadies PyCon References[edit] ^ \"Mission\". Python Software Foundation. Retrieved 28 March 2018. ^ \"ProPublica report for Python Software Foundation\". ProPublica. ProPublica. 15 Nov 2023. Retrieved 8 December 2024. ^ Deibel, Stephan (March 2008). \"Executive Summary: The Python Software Foundation\". Retrieved 2016-10-05. ^ \"Python Software Foundation Wins Computerworld Horizon Award for Popular Python Programming Language\" (Press release). 2005-09-15. Archived from the original on 2015-05-01. Retrieved 2016-10-05. ^ \"Computerworld Horizon Awards 2005 Honorees\". Computerworld. 2005-09-12. Archived from the original on 2019-07-31. Retrieved 2016-10-05. ^ \"PSF Membership FAQ\". python.org. Retrieved 24 October 2020. ^ \"PSF Membership FAQ\". python.org. Retrieved 24 October 2020. ^ Endsley, Rikki (17 May 2013). \"7 open source projects to cut your teeth on (and the ones to avoid)\". IT World. Retrieved 17 June 2017. Further reading[edit] Jyh-An Lee (2012). Nonprofit Organizations and the Intellectual Commons. Edward Elgar Publishing. ISBN 978-1-78100-158-5. OCLC 1027550705. External links[edit] Python Software Foundation vtePythonImplementations CircuitPython CLPython CPython Cython MicroPython Numba IronPython Jython Psyco PyPy Python for S60 Shed Skin Stackless Python Unladen Swallow more... IDEs eric IDLE Ninja-IDE PyCharm PyDev Spyder more... Topics WSGI ASGI Designer Guido van Rossum Software (list) Python Software Foundation Python Conference (PyCon) This article about an organization in the United States is a stub. You can help Wikipedia by expanding it.vte"
    },
    {
        "id": 16,
        "url": "https://en.wikipedia.org/wiki/Software_release_life_cycle",
        "title": "Software release life cycle",
        "content": "Stages in creation of computer software This article needs additional citations for verification. Please help improve this article by adding citations to reliable sources. Unsourced material may be challenged and removed.Find sources: \"Software release life cycle\" – news · newspapers · books · scholar · JSTOR (April 2023) (Learn how and when to remove this message) The software release life cycle is the process of developing, testing, and distributing a software product (e.g., an operating system). It typically consists of several stages, such as pre-alpha, alpha, beta, and release candidate, before the final version, or \"gold\", is released to the public. An example of a basic software release life cycle Pre-alpha refers to the early stages of development, when the software is still being designed and built. Alpha testing is the first phase of formal testing, during which the software is tested internally using white-box techniques. Beta testing is the next phase, in which the software is tested by a larger group of users, typically outside of the organization that developed it. The beta phase is focused on reducing impacts on users and may include usability testing. After beta testing, the software may go through one or more release candidate phases, in which it is refined and tested further, before the final version is released. Some software, particularly in the internet and technology industries, is released in a perpetual beta state, meaning that it is continuously being updated and improved, and is never considered to be a fully completed product. This approach allows for a more agile development process and enables the software to be released and used by users earlier in the development cycle. Stages of development[edit] Pre-alpha[edit] Pre-alpha refers to all activities performed during the software project before formal testing. These activities can include requirements analysis, software design, software development, and unit testing. In typical open source development, there are several types of pre-alpha versions. Milestone versions include specific sets of functions and are released as soon as the feature is complete.[citation needed] Alpha[edit] The alpha phase of the release life cycle is the first phase of software testing (alpha is the first letter of the Greek alphabet, used as the number 1). In this phase, developers generally test the software using white-box techniques. Additional validation is then performed using black-box or gray-box techniques, by another testing team. Moving to black-box testing inside the organization is known as alpha release. Alpha software is not thoroughly tested by the developer before it is released to customers. Alpha software may contain serious errors, and any resulting instability could cause crashes or data loss. Alpha software may not contain all of the features that are planned for the final version. In general, external availability of alpha software is uncommon for proprietary software, while open source software often has publicly available alpha versions. The alpha phase usually ends with a feature freeze, indicating that no more features will be added to the software. At this time, the software is said to be feature-complete. A beta test is carried out following acceptance testing at the supplier's site (the alpha test) and immediately before the general release of the software as a product. Feature-complete[edit] A feature-complete (FC) version of a piece of software has all of its planned or primary features implemented but is not yet final due to bugs, performance or stability issues. This occurs at the end of alpha testing in development. Usually, feature-complete software still has to undergo beta testing and bug fixing, as well as performance or stability enhancement before it can go to release candidate, and finally gold status. Beta[edit] \"Beta test\" redirects here. For the 2016 film, see Beta Test (film). For the 2021 film, see The Beta Test. See also: Software testing § Beta testing Beta, named after the second letter of the Greek alphabet, is the software development phase following alpha. A beta phase generally begins when the software is feature-complete but likely to contain several known or unknown bugs. Software in the beta phase will generally have many more bugs in it than completed software and speed or performance issues, and may still cause crashes or data loss. The focus of beta testing is reducing impacts on users, often incorporating usability testing. The process of delivering a beta version to the users is called beta release and is typically the first time that the software is available outside of the organization that developed it. Software beta releases can be either open or closed, depending on whether they are openly available or only available to a limited audience. Beta version software is often useful for demonstrations and previews within an organization and to prospective customers. Some developers refer to this stage as a preview, preview release, prototype, technical preview or technology preview (TP), or early access. Beta testers are people who actively report issues with beta software. They are usually customers or representatives of prospective customers of the organization that develops the software. Beta testers tend to volunteer their services free of charge but often receive versions of the product they test, discounts on the release version, or other incentives. Perpetual beta[edit] Main article: Perpetual beta Some software is kept in so-called perpetual beta, where new features are continually added to the software without establishing a final \"stable\" release. As the Internet has facilitated the rapid and inexpensive distribution of software, companies have begun to take a looser approach to the use of the word beta. Open and closed beta[edit] Developers may release either a closed beta, or an open beta; closed beta versions are released to a restricted group of individuals for a user test by invitation, while open beta testers are from a larger group, or anyone interested. Private beta could be suitable for the software that is capable of delivering value but is not ready to be used by everyone either due to scaling issues, lack of documentation or still missing vital features. The testers report any bugs that they find, and sometimes suggest additional features they think should be available in the final version. Open betas serve the dual purpose of demonstrating a product to potential consumers, and testing among a wide user base is likely to bring to light obscure errors that a much smaller testing team might not find.[citation needed] Release candidate[edit] Microsoft Windows 2000 Server Release Candidate 2 media. A release candidate (RC), also known as gamma testing or \"going silver\", is a beta version with the potential to be a stable product, which is ready to release unless significant bugs emerge. In this stage of product stabilization, all product features have been designed, coded, and tested through one or more beta cycles with no known showstopper-class bugs. A release is called code complete when the development team agrees that no entirely new source code will be added to this release. There could still be source code changes to fix defects, changes to documentation and data files, and peripheral code for test cases or utilities.[citation needed] Stable release[edit] Also called production release, the stable release is the last release candidate (RC) which has passed all stages of verification and tests. Any known remaining bugs are considered acceptable. This release goes to production. Some software products (e.g. Linux distributions like Debian) also have long-term support (LTS) releases which are based on full releases that have already been tried and tested and receive only security updates.[citation needed] Release[edit] Once released, the software is generally known as a \"stable release\". The formal term often depends on the method of release: physical media, online release, or a web application. Release to manufacturing (RTM)[edit] Satya Nadella of Microsoft with the gold master disc of Gears of War 4 The term \"release to manufacturing\" (RTM), also known as \"going gold\", is a term used when a software product is ready to be delivered. This build may be digitally signed, allowing the end user to verify the integrity and authenticity of the software purchase. A copy of the RTM build known as the \"gold master\" or GM is sent for mass duplication or disc replication if applicable. The terminology is taken from the audio record-making industry, specifically the process of mastering. RTM precedes general availability (GA) when the product is released to the public. A golden master build (GM) is typically the final build of a piece of software in the beta stages for developers. Typically, for iOS, it is the final build before a major release, however, there have been a few exceptions. RTM is typically used in certain retail mass-production software contexts—as opposed to a specialized software production or project in a commercial or government production and distribution—where the software is sold as part of a bundle in a related computer hardware sale and typically where the software and related hardware is ultimately to be available and sold on mass/public basis at retail stores to indicate that the software has met a defined quality level and is ready for mass retail distribution. RTM could also mean in other contexts that the software has been delivered or released to a client or customer for installation or distribution to the related hardware end user computers or machines. The term does not define the delivery mechanism or volume; it only states that the quality is sufficient for mass distribution. The deliverable from the engineering organization is frequently in the form of a golden master media used for duplication or to produce the image for the web. General availability (GA)[edit] Milestones in a product life cycle: general availability (GA), end of life announcement (EOLA), last order date (LOD), and end-of-life (EOL) General availability (GA) is the marketing stage at which all necessary commercialization activities have been completed and a software product is available for purchase, depending, however, on language, region, and electronic vs. media availability. Commercialization activities could include security and compliance tests, as well as localization and worldwide availability. The time between RTM and GA can take from days to months before a generally available release can be declared, due to the time needed to complete all commercialization activities required by GA. At this stage, the software has \"gone live\". Release to the Web (RTW)[edit] Release to the Web (RTW) or Web release is a means of software delivery that utilizes the Internet for distribution. No physical media are produced in this type of release mechanism by the manufacturer. Web releases have become more common as Internet usage grew.[citation needed] Support[edit] During its supported lifetime, the software is sometimes subjected to service releases, patches or service packs, sometimes also called \"interim releases\" or \"maintenance releases\" (MR). For example, Microsoft released three major service packs for the 32-bit editions of Windows XP and two service packs for the 64-bit editions. Such service releases contain a collection of updates, fixes, and enhancements, delivered in the form of a single installable package. They may also implement new features. Some software is released with the expectation of regular support. Classes of software that generally involve protracted support as the norm include anti-virus suites and massively multiplayer online games. Continuing with this Windows XP example, Microsoft did offer paid updates for five more years after the end of extended support. This means that support ended on April 8, 2019. End-of-life [edit] See also: End-of-life product and Abandonware When software is no longer sold or supported, the product is said to have reached end-of-life, to be discontinued, retired, deprecated, abandoned, or obsolete, but user loyalty may continue its existence for some time, even long after its platform is obsolete—e.g., the Common Desktop Environment and Sinclair ZX Spectrum. After the end-of-life date, the developer will usually not implement any new features, fix existing defects, bugs, or vulnerabilities (whether known before that date or not), or provide any support for the product. If the developer wishes, they may release the source code, so the platform will live again, and be maintained by volunteers, and if not, it may be reverse-engineered later when it becomes abandonware. History[edit] Usage of the \"alpha/beta\" test terminology originated at IBM.[citation needed] Similar terminologies for IBM's software development were used by people involved with IBM from at least the 1950s (and probably earlier). \"A\" test was the verification of a new product before the public announcement. The \"B\" test was the verification before releasing the product to be manufactured. The \"C\" test was the final test before the general availability of the product. As software became a significant part of IBM's offerings, the alpha test terminology was used to denote the pre-announcement test and the beta test was used to show product readiness for general availability. Martin Belsky, a manager on some of IBM's earlier software projects claimed to have invented the terminology. IBM dropped the alpha/beta terminology during the 1960s, but by then it had received fairly wide notice. The usage of \"beta test\" to refer to testing done by customers was not done in IBM. Rather, IBM used the term \"field test\". Major public betas developed afterward, with early customers having purchased a \"pioneer edition\" of the WordVision word processor for the IBM PC for $49.95. In 1984, Stephen Manes wrote that \"in a brilliant marketing coup, Bruce and James Program Publishers managed to get people to pay for the privilege of testing the product.\" In September 2000, a boxed version of Apple's Mac OS X Public Beta operating system was released. Between September 2005 and May 2006, Microsoft released community technology previews (CTPs) for Windows Vista. From 2009 to 2011, Minecraft was in public beta. In February 2005, ZDNet published an article about the phenomenon of a beta version often staying for years and being used as if it were at the production level. It noted that Gmail and Google News, for example, had been in beta for a long time although widely used; Google News left beta in January 2006, followed by Google Apps (now named Google Workspace), including Gmail, in July 2009. Since the introduction of Windows 8, Microsoft has called pre-release software a preview rather than beta. All pre-release builds released through the Windows Insider Program launched in 2014 are termed \"Insider Preview builds\". \"Beta\" may also indicate something more like a release candidate, or as a form of time-limited demo, or marketing technique. See also[edit] Computer programming portal Application lifecycle management Application-release automation Application retirement Release engineering Release management Rolling release Software deployment Software versioning References[edit] ^ \"Encyclopedia definition of alpha version\". PC Magazine. Archived from the original on 2011-04-27. Retrieved 2011-01-12. ^ \"What is an alpha version of a game?\". Archived from the original on 2022-09-23. Retrieved 2022-09-23. ^ Ince, Darrel, ed. (2013). \"Alpha software\". A Dictionary of the Internet (3rd ed.). Oxford University Press. ISBN 978-0-19-174415-0. Retrieved 2019-07-15. ^ \"The Next Generation 1996 Lexicon A to Z\". Next Generation. No. 15. Imagine Media. March 1996. p. 29. Alpha software generally barely runs and is missing major features like gameplay and complete levels. ^ A Dictionary of Computer Science (7th ed.). Oxford University Press. 2016. p. 44. ISBN 978-0-19-968897-5. ^ Cusumano, Michael (1998). Microsoft Secrets: How the World's Most Powerful Software Company Creates Technology, Shapes Markets, and Manages People. Free Press. pp. 202–203. ISBN 978-0-684-85531-8. ^ \"The Next Generation 1996 Lexicon A to Z\". Next Generation. No. 15. Imagine Media. March 1996. p. 30. ^ \"Technology Preview Features Support Scope\". Red Hat. Retrieved 2015-03-18. ^ Amit Mehra; Rajib Lochan Saha (2017-06-19). \"Utilizing Public Betas and Free Trials to Launch a Software Product\". Production and Operations Management. Vol. 27, no. 11. ^ Lang, Michelle M. (2004-05-17). \"Beta Wars\". Design News. Vol. 59, no. 7. ^ \"Waiting with Beta'd Breath TidBITS #328 (May 13, 1996)\". 1996-05-13. Archived from the original on 2006-05-15. ^ a b \"Google Apps is out of beta (yes, really)\". Google Blog. 2009-07-07. Archived from the original on 2011-01-21. Retrieved 2011-01-12. ^ \"What is Golden Master (GM)? - Definition from Techopedia\". Techopedia.com. 2013-08-19. ^ Luxembourg, Yvan Philippe (2013-05-20). \"Top 200 SAM Terms – A Glossary Of Software Asset Management Terms\". Operations Management Technology Consulting. Archived from the original on 2013-08-10. Retrieved 2013-05-21. ^ \"Microsoft Update Catalog\". www.catalog.update.microsoft.com. Retrieved 2024-05-03. ^ \"Microsoft Product Lifecycle Search\". 2012-07-20. Archived from the original on 2012-07-20. Retrieved 2024-05-03. ^ \"[cdesktopenv-devel] CDE 2.2.1 released | CDE - Common Desktop Environment\". sourceforge.net. Retrieved 2024-05-03. ^ \"ZX-Uno [ZX Spectrum Computer Clone Based on FPGA]\". 2018-01-05. Archived from the original on 2018-01-05. Retrieved 2024-05-03. ^ Manes, Stephen (1984-04-03). \"Taking A Gamble With Word Vision\". PC Magazine - The Independent Guide To IBM Personal Computers. Vol. 3, no. 6. PC Communications Corp. pp. 211–221. ISSN 0745-2500. Archived from the original on 2015-03-17. Retrieved 2015-02-15. ^ \"Apple Releases Mac OS X Public Beta\" (Press release). Apple Inc. 2000-09-13. Retrieved 2024-01-28. ^ \"Microsoft Windows Vista October Community Technology Preview Fact Sheet\" (Press release). Microsoft. October 2005. Archived from the original on 2011-04-30. Retrieved 2011-02-22. ^ Festa, Paul (2005-02-14). \"A long winding road out of beta\". Tech News on ZDNet. Archived from the original on 2005-02-14. Retrieved 2019-04-28. ^ Houghton, David (2010-05-17). \"The inconvenient truths behind betas\". GamesRadar. Archived from the original on 2011-04-30. vteSoftware distributionLicenses Beerware Floating licensing Free and open-source Free Open source Freely redistributable License-free Proprietary Public domain Source-available Compensation models Adware Commercial software Retail software Crippleware Crowdfunding Freemium Freeware Pay what you want Careware Donationware Open-core model Postcardware Shareware Nagware Trialware Delivery methods Digital distribution File sharing On-premises Pre-installed Product bundling Retail software Sneakernet Software as a service Deceptive and/or illicit Unwanted software bundling Malware Infostealer Ransomware Spyware Trojan horse Worm Scareware Shovelware Software release life cycle Abandonware End-of-life Long-term support Software maintenance Software maintainer Software publisher Vaporware list Copy protection Digital rights management Software protection dongle License manager Product activation Product key Software copyright Software license server Software patent Torrent poisoning"
    },
    {
        "id": 17,
        "url": "https://en.wikipedia.org/wiki/Type_system",
        "title": "Type system",
        "content": "Computer science concept This article is about type systems in computer programming. For the formal study of type systems, see Type theory. This article includes a list of general references, but it lacks sufficient corresponding inline citations. Please help to improve this article by introducing more precise citations. (October 2010) (Learn how and when to remove this message) This article is written like a personal reflection, personal essay, or argumentative essay that states a Wikipedia editor's personal feelings or presents an original argument about a topic. Please help improve it by rewriting it in an encyclopedic style. (July 2016) (Learn how and when to remove this message) Type systems General concepts Type safety Strong vs. weak typing Major categories Static vs. dynamic Manifest vs. inferred Nominal vs. structural Duck typing Minor categories Abstract Dependent Flow-sensitive Gradual Intersection Latent Refinement Substructural Unique Session vte In computer programming, a type system is a logical system comprising a set of rules that assigns a property called a type (for example, integer, floating point, string) to every term (a word, phrase, or other set of symbols). Usually the terms are various language constructs of a computer program, such as variables, expressions, functions, or modules. A type system dictates the operations that can be performed on a term. For variables, the type system determines the allowed values of that term. Type systems formalize and enforce the otherwise implicit categories the programmer uses for algebraic data types, data structures, or other data types, such as \"string\", \"array of float\", \"function returning boolean\". Type systems are often specified as part of programming languages and built into interpreters and compilers, although the type system of a language can be extended by optional tools that perform added checks using the language's original type syntax and grammar. The main purpose of a type system in a programming language is to reduce possibilities for bugs in computer programs due to type errors. The given type system in question determines what constitutes a type error, but in general, the aim is to prevent operations expecting a certain kind of value from being used with values of which that operation does not make sense (validity errors). Type systems allow defining interfaces between different parts of a computer program, and then checking that the parts have been connected in a consistent way. This checking can happen statically (at compile time), dynamically (at run time), or as a combination of both. Type systems have other purposes as well, such as expressing business rules, enabling certain compiler optimizations, allowing for multiple dispatch, and providing a form of documentation. Usage overview[edit] An example of a simple type system is that of the C language. The portions of a C program are the function definitions. One function is invoked by another function. The interface of a function states the name of the function and a list of parameters that are passed to the function's code. The code of an invoking function states the name of the invoked, along with the names of variables that hold values to pass to it. During a computer program's execution, the values are placed into temporary storage, then execution jumps to the code of the invoked function. The invoked function's code accesses the values and makes use of them. If the instructions inside the function are written with the assumption of receiving an integer value, but the calling code passed a floating-point value, then the wrong result will be computed by the invoked function. The C compiler checks the types of the arguments passed to a function when it is called against the types of the parameters declared in the function's definition. If the types do not match, the compiler throws a compile-time error or warning. A compiler may also use the static type of a value to optimize the storage it needs and the choice of algorithms for operations on the value. In many C compilers the float data type, for example, is represented in 32 bits, in accord with the IEEE specification for single-precision floating point numbers. They will thus use floating-point-specific microprocessor operations on those values (floating-point addition, multiplication, etc.). The depth of type constraints and the manner of their evaluation affect the typing of the language. A programming language may further associate an operation with various resolutions for each type, in the case of type polymorphism. Type theory is the study of type systems. The concrete types of some programming languages, such as integers and strings, depend on practical issues of computer architecture, compiler implementation, and language design. Fundamentals[edit] Formally, type theory studies type systems. A programming language must have the opportunity to type check using the type system whether at compile time or runtime, manually annotated or automatically inferred. As Mark Manasse concisely put it: The fundamental problem addressed by a type theory is to ensure that programs have meaning. The fundamental problem caused by a type theory is that meaningful programs may not have meanings ascribed to them. The quest for richer type systems results from this tension. Assigning a data type, termed typing, gives meaning to a sequence of bits such as a value in memory or some object such as a variable. The hardware of a general purpose computer is unable to discriminate between for example a memory address and an instruction code, or between a character, an integer, or a floating-point number, because it makes no intrinsic distinction between any of the possible values that a sequence of bits might mean.[note 1] Associating a sequence of bits with a type conveys that meaning to the programmable hardware to form a symbolic system composed of that hardware and some program. A program associates each value with at least one specific type, but it also can occur that one value is associated with many subtypes. Other entities, such as objects, modules, communication channels, and dependencies can become associated with a type. Even a type can become associated with a type. An implementation of a type system could in theory associate identifications called data type (a type of a value), class (a type of an object), and kind (a type of a type, or metatype). These are the abstractions that typing can go through, on a hierarchy of levels contained in a system. When a programming language evolves a more elaborate type system, it gains a more finely grained rule set than basic type checking, but this comes at a price when the type inferences (and other properties) become undecidable, and when more attention must be paid by the programmer to annotate code or to consider computer-related operations and functioning. It is challenging to find a sufficiently expressive type system that satisfies all programming practices in a type safe manner. A programming language compiler can also implement a dependent type or an effect system, which enables even more program specifications to be verified by a type checker. Beyond simple value-type pairs, a virtual \"region\" of code is associated with an \"effect\" component describing what is being done with what, and enabling for example to \"throw\" an error report. Thus the symbolic system may be a type and effect system, which endows it with more safety checking than type checking alone. Whether automated by the compiler or specified by a programmer, a type system renders program behavior illegal if it falls outside the type-system rules. Advantages provided by programmer-specified type systems include: Abstraction (or modularity) – Types enable programmers to think at a higher level than the bit or byte, not bothering with low-level implementation. For example, programmers can begin to think of a string as a set of character values instead of as an array of bytes. Higher still, types enable programmers to think about and express interfaces between two of any-sized subsystems. This enables more levels of localization so that the definitions required for interoperability of the subsystems remain consistent when those two subsystems communicate. Documentation – In more expressive type systems, types can serve as a form of documentation clarifying the intent of the programmer. For example, if a programmer declares a function as returning a timestamp type, this documents the function when the timestamp type can be explicitly declared deeper in the code to be an integer type. Advantages provided by compiler-specified type systems include: Optimization – Static type-checking may provide useful compile-time information. For example, if a type requires that a value must align in memory at a multiple of four bytes, the compiler may be able to use more efficient machine instructions. Safety – A type system enables the compiler to detect meaningless or invalid code. For example, we can identify an expression 3 / \"Hello, World\" as invalid, when the rules do not specify how to divide an integer by a string. Strong typing offers more safety, but cannot guarantee complete type safety. Type errors[edit] A type error occurs when an operation receives a different type of data than it expected. For example, a type error would happen if a line of code divides two integers, and is passed a string of letters instead of an integer. It is an unintended condition[note 2] which might manifest in multiple stages of a program's development. Thus a facility for detection of the error is needed in the type system. In some languages, such as Haskell, for which type inference is automated, lint might be available to its compiler to aid in the detection of error. Type safety contributes to program correctness, but might only guarantee correctness at the cost of making the type checking itself an undecidable problem (as in the Halting problem). In a type system with automated type checking, a program may prove to run incorrectly yet produce no compiler errors. Division by zero is an unsafe and incorrect operation, but a type checker which only runs at compile time does not scan for division by zero in most languages; that division would surface as a runtime error. To prove the absence of these defects, other kinds of formal methods, collectively known as program analyses, are in common use. Alternatively, a sufficiently expressive type system, such as in dependently typed languages, can prevent these kinds of errors (for example, expressing the type of non-zero numbers). In addition, software testing is an empirical method for finding errors that such a type checker would not detect. Type checking[edit] The process of verifying and enforcing the constraints of types—type checking—may occur at compile time (a static check) or at run-time (a dynamic check). If a language specification requires its typing rules strongly, more or less allowing only those automatic type conversions that do not lose information, one can refer to the process as strongly typed; if not, as weakly typed. The terms are not usually used in a strict sense. Static type checking[edit] See also: Category:Statically typed programming languages Static type checking is the process of verifying the type safety of a program based on analysis of a program's text (source code). If a program passes a static type checker, then the program is guaranteed to satisfy some set of type safety properties for all possible inputs. Static type checking can be considered a limited form of program verification (see type safety), and in a type-safe language, can also be considered an optimization. If a compiler can prove that a program is well-typed, then it does not need to emit dynamic safety checks, allowing the resulting compiled binary to run faster and to be smaller. Static type checking for Turing-complete languages is inherently conservative. That is, if a type system is both sound (meaning that it rejects all incorrect programs) and decidable (meaning that it is possible to write an algorithm that determines whether a program is well-typed), then it must be incomplete (meaning there are correct programs, which are also rejected, even though they do not encounter runtime errors). For example, consider a program containing the code: if <complex test> then <do something> else <signal that there is a type error> Even if the expression <complex test> always evaluates to true at run-time, most type checkers will reject the program as ill-typed, because it is difficult (if not impossible) for a static analyzer to determine that the else branch will not be taken. Consequently, a static type checker will quickly detect type errors in rarely used code paths. Without static type checking, even code coverage tests with 100% coverage may be unable to find such type errors. The tests may fail to detect such type errors, because the combination of all places where values are created and all places where a certain value is used must be taken into account. A number of useful and common programming language features cannot be checked statically, such as downcasting. Thus, many languages will have both static and dynamic type checking; the static type checker verifies what it can, and dynamic checks verify the rest. Many languages with static type checking provide a way to bypass the type checker. Some languages allow programmers to choose between static and dynamic type safety. For example, historically C# declares variables statically,: 77, Section 3.2 but C# 4.0 introduces the dynamic keyword, which is used to declare variables to be checked dynamically at runtime.: 117, Section 4.1 Other languages allow writing code that is not type-safe; for example, in C, programmers can freely cast a value between any two types that have the same size, effectively subverting the type concept. Dynamic type checking and runtime type information[edit] See also: Dynamic programming language, Interpreted language, and Category:Dynamically typed programming languages Dynamic type checking is the process of verifying the type safety of a program at runtime. Implementations of dynamically type-checked languages generally associate each runtime object with a type tag (i.e., a reference to a type) containing its type information. This runtime type information (RTTI) can also be used to implement dynamic dispatch, late binding, downcasting, reflective programming (reflection), and similar features. Most type-safe languages include some form of dynamic type checking, even if they also have a static type checker. The reason for this is that many useful features or properties are difficult or impossible to verify statically. For example, suppose that a program defines two types, A and B, where B is a subtype of A. If the program tries to convert a value of type A to type B, which is known as downcasting, then the operation is legal only if the value being converted is actually a value of type B. Thus, a dynamic check is needed to verify that the operation is safe. This requirement is one of the criticisms of downcasting. By definition, dynamic type checking may cause a program to fail at runtime. In some programming languages, it is possible to anticipate and recover from these failures. In others, type-checking errors are considered fatal. Programming languages that include dynamic type checking but not static type checking are often called \"dynamically typed programming languages\". Combining static and dynamic type checking[edit] Some languages allow both static and dynamic typing. For example, Java and some other ostensibly statically typed languages support downcasting types to their subtypes, querying an object to discover its dynamic type and other type operations that depend on runtime type information. Another example is C++ RTTI. More generally, most programming languages include mechanisms for dispatching over different 'kinds' of data, such as disjoint unions, runtime polymorphism, and variant types. Even when not interacting with type annotations or type checking, such mechanisms are materially similar to dynamic typing implementations. See programming language for more discussion of the interactions between static and dynamic typing. Objects in object-oriented languages are usually accessed by a reference whose static target type (or manifest type) is equal to either the object's run-time type (its latent type) or a supertype thereof. This is conformant with the Liskov substitution principle, which states that all operations performed on an instance of a given type can also be performed on an instance of a subtype. This concept is also known as subsumption or subtype polymorphism. In some languages subtypes may also possess covariant or contravariant return types and argument types respectively. Certain languages, for example Clojure, Common Lisp, or Cython are dynamically type checked by default, but allow programs to opt into static type checking by providing optional annotations. One reason to use such hints would be to optimize the performance of critical sections of a program. This is formalized by gradual typing. The programming environment DrRacket, a pedagogic environment based on Lisp, and a precursor of the language Racket is also soft-typed. Conversely, as of version 4.0, the C# language provides a way to indicate that a variable should not be statically type checked. A variable whose type is dynamic will not be subject to static type checking. Instead, the program relies on runtime type information to determine how the variable may be used.: 113–119 In Rust, the dyn std::any::Any type provides dynamic typing of 'static types. Static and dynamic type checking in practice[edit] The choice between static and dynamic typing requires certain trade-offs. Static typing can find type errors reliably at compile time, which increases the reliability of the delivered program. However, programmers disagree over how commonly type errors occur, resulting in further disagreements over the proportion of those bugs that are coded that would be caught by appropriately representing the designed types in code. Static typing advocates[who?] believe programs are more reliable when they have been well type-checked, whereas dynamic-typing advocates[who?] point to distributed code that has proven reliable and to small bug databases.[citation needed] The value of static typing increases as the strength of the type system is increased. Advocates of dependent typing,[who?] implemented in languages such as Dependent ML and Epigram, have suggested that almost all bugs can be considered type errors, if the types used in a program are properly declared by the programmer or correctly inferred by the compiler. Static typing usually results in compiled code that executes faster. When the compiler knows the exact data types that are in use (which is necessary for static verification, either through declaration or inference) it can produce optimized machine code. Some dynamically typed languages such as Common Lisp allow optional type declarations for optimization for this reason. By contrast, dynamic typing may allow compilers to run faster and interpreters to dynamically load new code, because changes to source code in dynamically typed languages may result in less checking to perform and less code to revisit.[clarification needed] This too may reduce the edit-compile-test-debug cycle. Statically typed languages that lack type inference (such as C and Java prior to version 10) require that programmers declare the types that a method or function must use. This can serve as added program documentation, that is active and dynamic, instead of static. This allows a compiler to prevent it from drifting out of synchrony, and from being ignored by programmers. However, a language can be statically typed without requiring type declarations (examples include Haskell, Scala, OCaml, F#, Swift, and to a lesser extent C# and C++), so explicit type declaration is not a necessary requirement for static typing in all languages. Dynamic typing allows constructs that some (simple) static type checking would reject as illegal. For example, eval functions, which execute arbitrary data as code, become possible. An eval function is possible with static typing, but requires advanced uses of algebraic data types. Further, dynamic typing better accommodates transitional code and prototyping, such as allowing a placeholder data structure (mock object) to be transparently used in place of a full data structure (usually for the purposes of experimentation and testing). Dynamic typing typically allows duck typing (which enables easier code reuse). Many[specify] languages with static typing also feature duck typing or other mechanisms like generic programming that also enable easier code reuse. Dynamic typing typically makes metaprogramming easier to use. For example, C++ templates are typically more cumbersome to write than the equivalent Ruby or Python code since C++ has stronger rules regarding type definitions (for both functions and variables). This forces a developer to write more boilerplate code for a template than a Python developer would need to. More advanced run-time constructs such as metaclasses and introspection are often harder to use in statically typed languages. In some languages, such features may also be used e.g. to generate new types and behaviors on the fly, based on run-time data. Such advanced constructs are often provided by dynamic programming languages; many of these are dynamically typed, although dynamic typing need not be related to dynamic programming languages. Strong and weak type systems[edit] Main article: Strong and weak typing Languages are often colloquially referred to as strongly typed or weakly typed. In fact, there is no universally accepted definition of what these terms mean. In general, there are more precise terms to represent the differences between type systems that lead people to call them \"strong\" or \"weak\". Type safety and memory safety[edit] Main articles: Type safety and Memory safety A third way of categorizing the type system of a programming language is by the safety of typed operations and conversions. Computer scientists use the term type-safe language to describe languages that do not allow operations or conversions that violate the rules of the type system. Computer scientists use the term memory-safe language (or just safe language) to describe languages that do not allow programs to access memory that has not been assigned for their use. For example, a memory-safe language will check array bounds, or else statically guarantee (i.e., at compile time before execution) that array accesses out of the array boundaries will cause compile-time and perhaps runtime errors. Consider the following program of a language that is both type-safe and memory-safe: var x := 5; var y := \"37\"; var z := x + y; In this example, the variable z will have the value 42. Although this may not be what the programmer anticipated, it is a well-defined result. If y were a different string, one that could not be converted to a number (e.g. \"Hello World\"), the result would be well-defined as well. Note that a program can be type-safe or memory-safe and still crash on an invalid operation. This is for languages where the type system is not sufficiently advanced to precisely specify the validity of operations on all possible operands. But if a program encounters an operation that is not type-safe, terminating the program is often the only option. Now consider a similar example in C: int x = 5; char y[] = \"37\"; char* z = x + y; printf(\"%c\\n\", *z); In this example z will point to a memory address five characters beyond y, equivalent to three characters after the terminating zero character of the string pointed to by y. This is memory that the program is not expected to access. In C terms this is simply undefined behaviour and the program may do anything; with a simple compiler it might actually print whatever byte is stored after the string \"37\". As this example shows, C is not memory-safe. As arbitrary data was assumed to be a character, it is also not a type-safe language. In general, type-safety and memory-safety go hand in hand. For example, a language that supports pointer arithmetic and number-to-pointer conversions (like C) is neither memory-safe nor type-safe, because it allows arbitrary memory to be accessed as if it were valid memory of any type. Variable levels of type checking[edit] Some languages allow different levels of checking to apply to different regions of code. Examples include: The use strict directive in JavaScript and Perl applies stronger checking. The declare(strict_types=1) in PHP on a per-file basis allows only a variable of exact type of the type declaration will be accepted, or a TypeError will be thrown. The Option Strict On in VB.NET allows the compiler to require a conversion between objects. Additional tools such as lint and IBM Rational Purify can also be used to achieve a higher level of strictness. Optional type systems[edit] It has been proposed, chiefly by Gilad Bracha, that the choice of type system be made independent of choice of language; that a type system should be a module that can be plugged into a language as needed. He believes this is advantageous, because what he calls mandatory type systems make languages less expressive and code more fragile. The requirement that the type system does not affect the semantics of the language is difficult to fulfill. Optional typing is related to, but distinct from, gradual typing. While both typing disciplines can be used to perform static analysis of code (static typing), optional type systems do not enforce type safety at runtime (dynamic typing). Polymorphism and types[edit] Main article: Polymorphism (computer science) The term polymorphism refers to the ability of code (especially, functions or classes) to act on values of multiple types, or to the ability of different instances of the same data structure to contain elements of different types. Type systems that allow polymorphism generally do so in order to improve the potential for code re-use: in a language with polymorphism, programmers need only implement a data structure such as a list or an associative array once, rather than once for each type of element with which they plan to use it. For this reason computer scientists sometimes call the use of certain forms of polymorphism generic programming. The type-theoretic foundations of polymorphism are closely related to those of abstraction, modularity and (in some cases) subtyping. Specialized type systems[edit] Many type systems have been created that are specialized for use in certain environments with certain types of data, or for out-of-band static program analysis. Frequently, these are based on ideas from formal type theory and are only available as part of prototype research systems. The following table gives an overview over type theoretic concepts that are used in specialized type systems. The names M, N, O range over terms and the names σ , τ {\\displaystyle \\sigma ,\\tau } range over types. The following notation will be used: M : σ {\\displaystyle M:\\sigma } means that M {\\displaystyle M} has type σ {\\displaystyle \\sigma } ; M ( N ) {\\displaystyle M(N)} is that application of M {\\displaystyle M} on N {\\displaystyle N} ; τ [ α := σ ] {\\displaystyle \\tau [\\alpha :=\\sigma ]} (resp. τ [ x := N ] {\\displaystyle \\tau [x:=N]} ) describes the type which results from replacing all occurrences of the type variable α (resp. term variable x) in τ {\\displaystyle \\tau } by the type σ (resp. term N). Type notion Notation Meaning Function σ → τ {\\displaystyle \\sigma \\to \\tau } If M : σ → τ {\\displaystyle M:\\sigma \\to \\tau } and N : σ {\\displaystyle N:\\sigma } , then M ( N ) : τ {\\displaystyle M(N):\\tau } . Product σ × τ {\\displaystyle \\sigma \\times \\tau } If M : σ × τ {\\displaystyle M:\\sigma \\times \\tau } , then M = ( N , O ) {\\displaystyle M=(N,O)} is a pair s.t. N : σ {\\displaystyle N:\\sigma } and O : τ {\\displaystyle O:\\tau } . Sum σ + τ {\\displaystyle \\sigma +\\tau } If M : σ + τ {\\displaystyle M:\\sigma +\\tau } , then M = ι 1 ( N ) {\\displaystyle M=\\iota _{1}(N)} is the first injection s.t. N : σ {\\displaystyle N:\\sigma } , or M = ι 2 ( N ) {\\displaystyle M=\\iota _{2}(N)} is the second injection s.t. N : τ {\\displaystyle N:\\tau } . Intersection σ ∩ τ {\\displaystyle \\sigma \\cap \\tau } If M : σ ∩ τ {\\displaystyle M:\\sigma \\cap \\tau } , then M : σ {\\displaystyle M:\\sigma } and M : τ {\\displaystyle M:\\tau } . Union σ ∪ τ {\\displaystyle \\sigma \\cup \\tau } If M : σ ∪ τ {\\displaystyle M:\\sigma \\cup \\tau } , then M : σ {\\displaystyle M:\\sigma } or M : τ {\\displaystyle M:\\tau } . Record ⟨ x : τ ⟩ {\\displaystyle \\langle x:\\tau \\rangle } If M : ⟨ x : τ ⟩ {\\displaystyle M:\\langle x:\\tau \\rangle } , then M has a member x : τ {\\displaystyle x:\\tau } . Polymorphic ∀ α . τ {\\displaystyle \\forall {}\\alpha .\\tau } If M : ∀ α . τ {\\displaystyle M:\\forall {}\\alpha .\\tau } , then M : τ [ α := σ ] {\\displaystyle M:\\tau [\\alpha :=\\sigma ]} for any type σ. Existential ∃ α . τ {\\displaystyle \\exists {}\\alpha .\\tau } If M : ∃ α . τ {\\displaystyle M:\\exists {}\\alpha .\\tau } , then M : τ [ α := σ ] {\\displaystyle M:\\tau [\\alpha :=\\sigma ]} for some type σ. Recursive μ α . τ {\\displaystyle \\mu \\alpha .\\tau } If M : μ α . τ {\\displaystyle M:\\mu \\alpha .\\tau } , then M : τ [ α := μ α . τ ] {\\displaystyle M:\\tau [\\alpha :=\\mu \\alpha .\\tau ]} . Dependent function[a] ( x : σ ) → τ {\\displaystyle (x:\\sigma )\\to \\tau } If M : ( x : σ ) → τ {\\displaystyle M:(x:\\sigma )\\to \\tau } and N : σ {\\displaystyle N:\\sigma } , then M ( N ) : τ [ x := N ] {\\displaystyle M(N):\\tau [x:=N]} . Dependent pair[b] ( x : σ ) × τ {\\displaystyle (x:\\sigma )\\times \\tau } If M : ( x : σ ) × τ {\\displaystyle M:(x:\\sigma )\\times \\tau } , then M = ( N , O ) {\\displaystyle M=(N,O)} is a pair s.t. N : σ {\\displaystyle N:\\sigma } and O : τ [ x := N ] {\\displaystyle O:\\tau [x:=N]} . Dependent intersection ( x : σ ) ∩ τ {\\displaystyle (x:\\sigma )\\cap \\tau } If M : ( x : σ ) ∩ τ {\\displaystyle M:(x:\\sigma )\\cap \\tau } , then M : σ {\\displaystyle M:\\sigma } and M : τ [ x := M ] {\\displaystyle M:\\tau [x:=M]} . Familial intersection ⋂ x : σ τ {\\displaystyle \\bigcap _{x:\\sigma }\\tau } If M : ⋂ x : σ τ {\\textstyle M:\\bigcap _{x:\\sigma }\\tau } , then M : τ [ x := N ] {\\displaystyle M:\\tau [x:=N]} for any term N : σ {\\displaystyle N:\\sigma } . Familial union ⋃ x : σ τ {\\displaystyle \\bigcup _{x:\\sigma }\\tau } If M : ⋃ x : σ τ {\\textstyle M:\\bigcup _{x:\\sigma }\\tau } , then M : τ [ x := N ] {\\displaystyle M:\\tau [x:=N]} for some term N : σ {\\displaystyle N:\\sigma } . ^ Also referred to as dependent product type, since ( x : σ ) → τ = ∏ x : σ τ {\\textstyle (x:\\sigma )\\to \\tau =\\prod _{x:\\sigma }\\tau } . ^ Also referred to as dependent sum type, since ( x : σ ) × τ = ∑ x : σ τ {\\textstyle (x:\\sigma )\\times \\tau =\\sum _{x:\\sigma }\\tau } . Dependent types[edit] Main article: Dependent type Dependent types are based on the idea of using scalars or values to more precisely describe the type of some other value. For example, m a t r i x ( 3 , 3 ) {\\displaystyle \\mathrm {matrix} (3,3)} might be the type of a 3 × 3 {\\displaystyle 3\\times 3} matrix. We can then define typing rules such as the following rule for matrix multiplication: m a t r i x m u l t i p l y : m a t r i x ( k , m ) × m a t r i x ( m , n ) → m a t r i x ( k , n ) {\\displaystyle \\mathrm {matrix} _{\\mathrm {multiply} }:\\mathrm {matrix} (k,m)\\times \\mathrm {matrix} (m,n)\\to \\mathrm {matrix} (k,n)} where k, m, n are arbitrary positive integer values. A variant of ML called Dependent ML has been created based on this type system, but because type checking for conventional dependent types is undecidable, not all programs using them can be type-checked without some kind of limits. Dependent ML limits the sort of equality it can decide to Presburger arithmetic. Other languages such as Epigram make the value of all expressions in the language decidable so that type checking can be decidable. However, in general proof of decidability is undecidable, so many programs require hand-written annotations that may be very non-trivial. As this impedes the development process, many language implementations provide an easy way out in the form of an option to disable this condition. This, however, comes at the cost of making the type-checker run in an infinite loop when fed programs that do not type-check, causing the compilation to fail. Linear types[edit] Main article: Linear type Linear types, based on the theory of linear logic, and closely related to uniqueness types, are types assigned to values having the property that they have one and only one reference to them at all times. These are valuable for describing large immutable values such as files, strings, and so on, because any operation that simultaneously destroys a linear object and creates a similar object (such as str = str + \"a\") can be optimized \"under the hood\" into an in-place mutation. Normally this is not possible, as such mutations could cause side effects on parts of the program holding other references to the object, violating referential transparency. They are also used in the prototype operating system Singularity for interprocess communication, statically ensuring that processes cannot share objects in shared memory in order to prevent race conditions. The Clean language (a Haskell-like language) uses this type system in order to gain a lot of speed (compared to performing a deep copy) while remaining safe. Intersection types[edit] Main article: Intersection type Intersection types are types describing values that belong to both of two other given types with overlapping value sets. For example, in most implementations of C the signed char has range -128 to 127 and the unsigned char has range 0 to 255, so the intersection type of these two types would have range 0 to 127. Such an intersection type could be safely passed into functions expecting either signed or unsigned chars, because it is compatible with both types. Intersection types are useful for describing overloaded function types: for example, if \"int → int\" is the type of functions taking an integer argument and returning an integer, and \"float → float\" is the type of functions taking a float argument and returning a float, then the intersection of these two types can be used to describe functions that do one or the other, based on what type of input they are given. Such a function could be passed into another function expecting an \"int → int\" function safely; it simply would not use the \"float → float\" functionality. In a subclassing hierarchy, the intersection of a type and an ancestor type (such as its parent) is the most derived type. The intersection of sibling types is empty. The Forsythe language includes a general implementation of intersection types. A restricted form is refinement types. Union types[edit] Main article: Union type Union types are types describing values that belong to either of two types. For example, in C, the signed char has a -128 to 127 range, and the unsigned char has a 0 to 255 range, so the union of these two types would have an overall \"virtual\" range of -128 to 255 that may be used partially depending on which union member is accessed. Any function handling this union type would have to deal with integers in this complete range. More generally, the only valid operations on a union type are operations that are valid on both types being unioned. C's \"union\" concept is similar to union types, but is not typesafe, as it permits operations that are valid on either type, rather than both. Union types are important in program analysis, where they are used to represent symbolic values whose exact nature (e.g., value or type) is not known. In a subclassing hierarchy, the union of a type and an ancestor type (such as its parent) is the ancestor type. The union of sibling types is a subtype of their common ancestor (that is, all operations permitted on their common ancestor are permitted on the union type, but they may also have other valid operations in common). Existential types[edit] Main article: Existential quantifier Existential types are frequently used in connection with record types to represent modules and abstract data types, due to their ability to separate implementation from interface. For example, the type \"T = ∃X { a: X; f: (X → int); }\" describes a module interface that has a data member named a of type X and a function named f that takes a parameter of the same type X and returns an integer. This could be implemented in different ways; for example: intT = { a: int; f: (int → int); } floatT = { a: float; f: (float → int); } These types are both subtypes of the more general existential type T and correspond to concrete implementation types, so any value of one of these types is a value of type T. Given a value \"t\" of type \"T\", we know that \"t.f(t.a)\" is well-typed, regardless of what the abstract type X is. This gives flexibility for choosing types suited to a particular implementation, while clients that use only values of the interface type—the existential type—are isolated from these choices. In general it's impossible for the typechecker to infer which existential type a given module belongs to. In the above example intT { a: int; f: (int → int); } could also have the type ∃X { a: X; f: (int → int); }. The simplest solution is to annotate every module with its intended type, e.g.: intT = { a: int; f: (int → int); } as ∃X { a: X; f: (X → int); } Although abstract data types and modules had been implemented in programming languages for quite some time, it wasn't until 1988 that John C. Mitchell and Gordon Plotkin established the formal theory under the slogan: \"Abstract [data] types have existential type\". The theory is a second-order typed lambda calculus similar to System F, but with existential instead of universal quantification. Gradual typing[edit] Main article: Gradual typing In a type system with Gradual typing, variables may be assigned a type either at compile-time (which is static typing), or at run-time (which is dynamic typing). This allows software developers to choose either type paradigm as appropriate, from within a single language. Gradual typing uses a special type named dynamic to represent statically unknown types; gradual typing replaces the notion of type equality with a new relation called consistency that relates the dynamic type to every other type. The consistency relation is symmetric but not transitive. Explicit or implicit declaration and inference[edit] Further information: Type inference Many static type systems, such as those of C and Java, require type declarations: the programmer must explicitly associate each variable with a specific type. Others, such as Haskell's, perform type inference: the compiler draws conclusions about the types of variables based on how programmers use those variables. For example, given a function f(x, y) that adds x and y together, the compiler can infer that x and y must be numbers—since addition is only defined for numbers. Thus, any call to f elsewhere in the program that specifies a non-numeric type (such as a string or list) as an argument would signal an error. Numerical and string constants and expressions in code can and often do imply type in a particular context. For example, an expression 3.14 might imply a type of floating-point, while [1, 2, 3] might imply a list of integers—typically an array. Type inference is in general possible, if it is computable in the type system in question. Moreover, even if inference is not computable in general for a given type system, inference is often possible for a large subset of real-world programs. Haskell's type system, a version of Hindley–Milner, is a restriction of System Fω to so-called rank-1 polymorphic types, in which type inference is computable. Most Haskell compilers allow arbitrary-rank polymorphism as an extension, but this makes type inference not computable. (Type checking is decidable, however, and rank-1 programs still have type inference; higher rank polymorphic programs are rejected unless given explicit type annotations.) Decision problems[edit] Main article: Type theory § Decision problems A type system that assigns types to terms in type environments using typing rules is naturally associated with the decision problems of type checking, typability, and type inhabitation. Given a type environment Γ {\\displaystyle \\Gamma } , a term e {\\displaystyle e} , and a type τ {\\displaystyle \\tau } , decide whether the term e {\\displaystyle e} can be assigned the type τ {\\displaystyle \\tau } in the type environment. Given a term e {\\displaystyle e} , decide whether there exists a type environment Γ {\\displaystyle \\Gamma } and a type τ {\\displaystyle \\tau } such that the term e {\\displaystyle e} can be assigned the type τ {\\displaystyle \\tau } in the type environment Γ {\\displaystyle \\Gamma } . Given a type environment Γ {\\displaystyle \\Gamma } and a type τ {\\displaystyle \\tau } , decide whether there exists a term e {\\displaystyle e} that can be assigned the type τ {\\displaystyle \\tau } in the type environment. Unified type system[edit] Some languages like C# or Scala have a unified type system. This means that all C# types including primitive types inherit from a single root object. Every type in C# inherits from the Object class. Some languages, like Java and Raku, have a root type but also have primitive types that are not objects. Java provides wrapper object types that exist together with the primitive types so developers can use either the wrapper object types or the simpler non-object primitive types. Raku automatically converts primitive types to objects when their methods are accessed. Compatibility: equivalence and subtyping[edit] A type checker for a statically typed language must verify that the type of any expression is consistent with the type expected by the context in which that expression appears. For example, in an assignment statement of the form x := e, the inferred type of the expression e must be consistent with the declared or inferred type of the variable x. This notion of consistency, called compatibility, is specific to each programming language. If the type of e and the type of x are the same, and assignment is allowed for that type, then this is a valid expression. Thus, in the simplest type systems, the question of whether two types are compatible reduces to that of whether they are equal (or equivalent). Different languages, however, have different criteria for when two type expressions are understood to denote the same type. These different equational theories of types vary widely, two extreme cases being structural type systems, in which any two types that describe values with the same structure are equivalent, and nominative type systems, in which no two syntactically distinct type expressions denote the same type (i.e., types must have the same \"name\" in order to be equal). In languages with subtyping, the compatibility relation is more complex: If B is a subtype of A, then a value of type B can be used in a context where one of type A is expected (covariant), even if the reverse is not true. Like equivalence, the subtype relation is defined differently for each programming language, with many variations possible. The presence of parametric or ad hoc polymorphism in a language may also have implications for type compatibility. See also[edit] Computer programming portal Comparison of type systems Covariance and contravariance (computer science) Polymorphism in object-oriented programming Type signature Type theory Notes[edit] ^ The Burroughs ALGOL computer line determined a memory location's contents by its flag bits. Flag bits specify the contents of a memory location. Instruction, data type, and functions are specified by a 3 bit code in addition to its 48 bit contents. Only the MCP (Master Control Program) could write to the flag code bits. ^ For example, a leaky abstraction might surface during development, which may show that more type development is needed. —\"The evaluation of a well-typed program always terminates\".—B. Nordström, K. Petersson, and J. M. Smith A systematic change in variables to avoid capture of a free variable can introduce error, in a functional programming language where functions are first class citizens. —From the lambda calculus article. References[edit] ^ Pierce 2002, p. 1: \"A type system is a tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute.\" ^ Cardelli 2004, p. 1: \"The fundamental purpose of a type system is to prevent the occurrence of execution errors during the running of a program.\" ^ Pierce 2002, p. 208. ^ a b Sethi, R. (1996). Programming languages: Concepts and constructs (2nd ed.). Addison-Wesley. p. 142. ISBN 978-0-201-59065-4. OCLC 604732680. ^ Nordström, B.; Petersson, K.; Smith, J.M. (2001). \"Martin-Löf's Type Theory\". Algebraic and Logical Structures. Handbook of Logic in Computer Science. Vol. 5. Oxford University Press. p. 2. ISBN 978-0-19-154627-3. ^ Turner, D.A. (12 June 2012). \"Some History of Functional Programming Languages\" (PDF). invited lecture at TFP12, at St Andrews University. See the section on Algol 60. ^ \"... any sound, decidable type system must be incomplete\" —D. Remy (2017). p. 29, Remy, Didier. \"Type systems for programming languages\" (PDF). Archived from the original (PDF) on 14 November 2017. Retrieved 26 May 2013. ^ Pierce 2002. ^ a b c Skeet, Jon (2019). C# in Depth (4 ed.). Manning. ISBN 978-1617294532. ^ Miglani, Gaurav (2018). \"Dynamic Method Dispatch or Runtime Polymorphism in Java\". Archived from the original on 2020-12-07. Retrieved 2021-03-28. ^ Wright, Andrew K. (1995). Practical Soft Typing (PhD). Rice University. hdl:1911/16900. ^ \"dynamic (C# Reference)\". MSDN Library. Microsoft. Retrieved 14 January 2014. ^ \"std::any — Rust\". doc.rust-lang.org. Retrieved 2021-07-07. ^ Meijer, Erik; Drayton, Peter. \"Static Typing Where Possible, Dynamic Typing When Needed: The End of the Cold War Between Programming Languages\" (PDF). Microsoft Corporation. ^ Laucher, Amanda; Snively, Paul (2012). \"Types vs Tests\". InfoQ. ^ Xi, Hongwei (1998). Dependent Types in Practical Programming (PhD). Department of Mathematical Sciences, Carnegie Mellon University. CiteSeerX 10.1.1.41.548.Xi, Hongwei; Pfenning, Frank (1999). \"Dependent Types in Practical Programming\". Proceedings of the 26th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. ACM. pp. 214–227. CiteSeerX 10.1.1.69.2042. doi:10.1145/292540.292560. ISBN 1581130953. S2CID 245490. ^ Visual Basic is an example of a language that is both type-safe and memory-safe. ^ \"4.2.2 The Strict Variant of ECMAScript\". ECMAScript® 2020 Language Specification (11th ed.). ECMA. June 2020. ECMA-262. ^ \"Strict mode – JavaScript\". MDN. Developer.mozilla.org. 2013-07-03. Retrieved 2013-07-17. ^ \"Strict Mode (JavaScript)\". MSDN. Microsoft. Retrieved 2013-07-17. ^ \"Strict typing\". PHP Manual: Language Reference: Functions. ^ a b Bracha, G. \"Pluggable Types\" (PDF). ^ \"Sure. It's called \"gradual typing\", and I would qualify it as trendy. ...\" Is there a language that allows both static and dynamic typing?. stackoverflow. 2012. ^ a b c Kopylov, Alexei (2003). \"Dependent intersection: A new way of defining records in type theory\". 18th IEEE Symposium on Logic in Computer Science. LICS 2003. IEEE Computer Society. pp. 86–95. CiteSeerX 10.1.1.89.4223. doi:10.1109/LICS.2003.1210048. ^ Mitchell, John C.; Plotkin, Gordon D. (July 1988). \"Abstract Types Have Existential Type\" (PDF). ACM Trans. Program. Lang. Syst. 10 (3): 470–502. doi:10.1145/44501.45065. S2CID 1222153. ^ a b Siek, Jeremy (24 March 2014). \"What is gradual typing?\". ^ Siek, Jeremy; Taha, Walid (September 2006). Gradual Typing for Functional Languages (PDF). Scheme and Functional Programming 2006. University of Chicago. pp. 81–92. ^ Barendregt, Henk; Dekkers, Wil; Statman, Richard (20 June 2013). Lambda Calculus with Types. Cambridge University Press. p. 66. ISBN 978-0-521-76614-2. ^ \"8.2.4 Type system unification\". C# Language Specification (5th ed.). ECMA. December 2017. ECMA-334. ^ \"Native Types\". Perl 6 Documentation. ^ \"Numerics, § Auto-boxing\". Perl 6 Documentation. Further reading[edit] Cardelli, Luca; Wegner, Peter (December 1985). \"On Understanding Types, Data Abstraction, and Polymorphism\" (PDF). ACM Computing Surveys. 17 (4): 471–523. CiteSeerX 10.1.1.117.695. doi:10.1145/6041.6042. S2CID 2921816. Pierce, Benjamin C. (2002). Types and Programming Languages. MIT Press. ISBN 978-0-262-16209-8. Cardelli, Luca (2004). \"Type systems\" (PDF). In Allen B. Tucker (ed.). CRC Handbook of Computer Science and Engineering (2nd ed.). CRC Press. ISBN 978-1584883609. Tratt, Laurence (July 2009). \"5. Dynamically Typed Languages\". Advances in Computers. Vol. 77. Elsevier. pp. 149–184. doi:10.1016/S0065-2458(09)01205-4. ISBN 978-0-12-374812-6. External links[edit] The Wikibook Ada Programming has a page on the topic of: Types The Wikibook Haskell has a page on the topic of: Class declarations Media related to Type systems at Wikimedia Commons Smith, Chris (2011). \"What to Know Before Debating Type Systems\". vteData typesUninterpreted Bit Byte Trit Tryte Word Bit array Numeric Arbitrary-precision or bignum Complex Decimal Fixed point Floating point Reduced precision Minifloat Half precision bfloat16 Single precision Double precision Quadruple precision Octuple precision Extended precision Long double Integer signedness Interval Rational Pointer Address physical virtual Reference Text Character String null-terminated Composite Algebraic data type generalized Array Associative array Class Dependent Equality Inductive Intersection List Object metaobject Option type Product Record or Struct Refinement Set Union tagged Other Boolean Bottom type Collection Enumerated type Exception Function type Opaque data type Recursive data type Semaphore Stream Strongly typed identifier Top type Type class Empty type Unit type Void Relatedtopics Abstract data type Boxing Data structure Generic Kind metaclass Parametric polymorphism Primitive data type Interface Subtyping Type constructor Type conversion Type system Type theory Variable"
    },
    {
        "id": 18,
        "url": "https://en.wikipedia.org/wiki/Duck_typing",
        "title": "Duck typing",
        "content": "Style of dynamic typing in object-oriented programming Type systems General concepts Type safety Strong vs. weak typing Major categories Static vs. dynamic Manifest vs. inferred Nominal vs. structural Duck typing Minor categories Abstract Dependent Flow-sensitive Gradual Intersection Latent Refinement Substructural Unique Session vte In computer programming, duck typing is an application of the duck test—\"If it walks like a duck and it quacks like a duck, then it must be a duck\"—to determine whether an object can be used for a particular purpose. With nominative typing, an object is of a given type if it is declared as such (or if a type's association with the object is inferred through mechanisms such as object inheritance). With duck typing, an object is of a given type if it has all methods and properties required by that type. Duck typing may be viewed as a usage-based structural equivalence between a given object and the requirements of a type. Example[edit] This simple example in Python 3 demonstrates how any object may be used in any context until it is used in a way that it does not support. class Duck: def swim(self): print(\"Duck swimming\") def fly(self): print(\"Duck flying\") class Whale: def swim(self): print(\"Whale swimming\") for animal in [Duck(), Whale()]: animal.swim() animal.fly() Output: Duck swimming Duck flying Whale swimming AttributeError: 'Whale' object has no attribute 'fly' If it can be assumed that anything that can swim is a duck because ducks can swim, a whale could be considered a duck; however, if it is also assumed that a duck must be capable of flying, the whale will not be considered a duck. In statically typed languages[edit] In some statically typed languages such as Boo and D, class type checking can be specified to occur at runtime rather than at compile time. Comparison with other type systems[edit] Structural type systems[edit] Duck typing is similar to, but distinct from, structural typing. Structural typing is a static typing system that determines type compatibility and equivalence by a type's structure, whereas duck typing is dynamic and determines type compatibility by only that part of a type's structure that is accessed during runtime. The TypeScript, Elm and Python languages support structural typing to varying degrees. Protocols and interfaces[edit] Protocols and interfaces provide a way to explicitly declare that some methods, operators or behaviors must be defined. If a third-party library implements a class that cannot be modified, a client cannot use an instance of it with an interface unknown to that library even if the class satisfies the interface requirements. A common solution to this problem is the adapter pattern. In contrast, with duck typing, the object would be accepted directly without the need for an adapter. Templates or generic types[edit] Template (also called generic) functions or methods apply the duck test in a static typing context; this brings all of the advantages and disadvantages of static versus dynamic type checking. Duck typing can also be more flexible in that only the methods actually called at runtime must be implemented, while templates require implementations of all methods that cannot be proven unreachable at compile time. In languages such as Java, Scala and Objective-C, reflection may be employed to inspect whether objects implement methods or add necessary methods at runtime. For example, Java's MethodHandle API can be used in this manner. See also[edit] Ad hoc polymorphism Dynamic dispatch Dynamic programming language Extension method Loose coupling Monkey patch Operator overloading References[edit] ^ \"Glossary — Python 3.7.1 documentation\". docs.python.org. Retrieved 2018-11-08. ^ \"Python Duck Typing - Example\". Techie Hours. 2020-06-28. Archived from the original on 2022-03-31. Retrieved 2020-07-26. ^ Boo: Duck TypingArchived October 6, 2008, at the Wayback Machine ^ \"Dynamic classes and duck typing\". ^ \"Metaprogramming - duck typing in D\". ^ \"SE Radio Episode 384: Boris Cherny on TypeScript\". se-radio.net. Retrieved 2019-10-25. ^ Czaplicki, Evan. \"Core Language · An Introduction to Elm\". Retrieved 30 January 2017. ^ \"PEP 544 – Protocols: Structural subtyping (static duck typing)\". ^ \"StackOverflow: Implement duck typing using java MethodHandles\". Retrieved 13 June 2020."
    },
    {
        "id": 19,
        "url": "https://en.wikipedia.org/wiki/Dynamic_typing",
        "title": "Type system",
        "content": "Computer science concept This article is about type systems in computer programming. For the formal study of type systems, see Type theory. This article includes a list of general references, but it lacks sufficient corresponding inline citations. Please help to improve this article by introducing more precise citations. (October 2010) (Learn how and when to remove this message) This article is written like a personal reflection, personal essay, or argumentative essay that states a Wikipedia editor's personal feelings or presents an original argument about a topic. Please help improve it by rewriting it in an encyclopedic style. (July 2016) (Learn how and when to remove this message) Type systems General concepts Type safety Strong vs. weak typing Major categories Static vs. dynamic Manifest vs. inferred Nominal vs. structural Duck typing Minor categories Abstract Dependent Flow-sensitive Gradual Intersection Latent Refinement Substructural Unique Session vte In computer programming, a type system is a logical system comprising a set of rules that assigns a property called a type (for example, integer, floating point, string) to every term (a word, phrase, or other set of symbols). Usually the terms are various language constructs of a computer program, such as variables, expressions, functions, or modules. A type system dictates the operations that can be performed on a term. For variables, the type system determines the allowed values of that term. Type systems formalize and enforce the otherwise implicit categories the programmer uses for algebraic data types, data structures, or other data types, such as \"string\", \"array of float\", \"function returning boolean\". Type systems are often specified as part of programming languages and built into interpreters and compilers, although the type system of a language can be extended by optional tools that perform added checks using the language's original type syntax and grammar. The main purpose of a type system in a programming language is to reduce possibilities for bugs in computer programs due to type errors. The given type system in question determines what constitutes a type error, but in general, the aim is to prevent operations expecting a certain kind of value from being used with values of which that operation does not make sense (validity errors). Type systems allow defining interfaces between different parts of a computer program, and then checking that the parts have been connected in a consistent way. This checking can happen statically (at compile time), dynamically (at run time), or as a combination of both. Type systems have other purposes as well, such as expressing business rules, enabling certain compiler optimizations, allowing for multiple dispatch, and providing a form of documentation. Usage overview[edit] An example of a simple type system is that of the C language. The portions of a C program are the function definitions. One function is invoked by another function. The interface of a function states the name of the function and a list of parameters that are passed to the function's code. The code of an invoking function states the name of the invoked, along with the names of variables that hold values to pass to it. During a computer program's execution, the values are placed into temporary storage, then execution jumps to the code of the invoked function. The invoked function's code accesses the values and makes use of them. If the instructions inside the function are written with the assumption of receiving an integer value, but the calling code passed a floating-point value, then the wrong result will be computed by the invoked function. The C compiler checks the types of the arguments passed to a function when it is called against the types of the parameters declared in the function's definition. If the types do not match, the compiler throws a compile-time error or warning. A compiler may also use the static type of a value to optimize the storage it needs and the choice of algorithms for operations on the value. In many C compilers the float data type, for example, is represented in 32 bits, in accord with the IEEE specification for single-precision floating point numbers. They will thus use floating-point-specific microprocessor operations on those values (floating-point addition, multiplication, etc.). The depth of type constraints and the manner of their evaluation affect the typing of the language. A programming language may further associate an operation with various resolutions for each type, in the case of type polymorphism. Type theory is the study of type systems. The concrete types of some programming languages, such as integers and strings, depend on practical issues of computer architecture, compiler implementation, and language design. Fundamentals[edit] Formally, type theory studies type systems. A programming language must have the opportunity to type check using the type system whether at compile time or runtime, manually annotated or automatically inferred. As Mark Manasse concisely put it: The fundamental problem addressed by a type theory is to ensure that programs have meaning. The fundamental problem caused by a type theory is that meaningful programs may not have meanings ascribed to them. The quest for richer type systems results from this tension. Assigning a data type, termed typing, gives meaning to a sequence of bits such as a value in memory or some object such as a variable. The hardware of a general purpose computer is unable to discriminate between for example a memory address and an instruction code, or between a character, an integer, or a floating-point number, because it makes no intrinsic distinction between any of the possible values that a sequence of bits might mean.[note 1] Associating a sequence of bits with a type conveys that meaning to the programmable hardware to form a symbolic system composed of that hardware and some program. A program associates each value with at least one specific type, but it also can occur that one value is associated with many subtypes. Other entities, such as objects, modules, communication channels, and dependencies can become associated with a type. Even a type can become associated with a type. An implementation of a type system could in theory associate identifications called data type (a type of a value), class (a type of an object), and kind (a type of a type, or metatype). These are the abstractions that typing can go through, on a hierarchy of levels contained in a system. When a programming language evolves a more elaborate type system, it gains a more finely grained rule set than basic type checking, but this comes at a price when the type inferences (and other properties) become undecidable, and when more attention must be paid by the programmer to annotate code or to consider computer-related operations and functioning. It is challenging to find a sufficiently expressive type system that satisfies all programming practices in a type safe manner. A programming language compiler can also implement a dependent type or an effect system, which enables even more program specifications to be verified by a type checker. Beyond simple value-type pairs, a virtual \"region\" of code is associated with an \"effect\" component describing what is being done with what, and enabling for example to \"throw\" an error report. Thus the symbolic system may be a type and effect system, which endows it with more safety checking than type checking alone. Whether automated by the compiler or specified by a programmer, a type system renders program behavior illegal if it falls outside the type-system rules. Advantages provided by programmer-specified type systems include: Abstraction (or modularity) – Types enable programmers to think at a higher level than the bit or byte, not bothering with low-level implementation. For example, programmers can begin to think of a string as a set of character values instead of as an array of bytes. Higher still, types enable programmers to think about and express interfaces between two of any-sized subsystems. This enables more levels of localization so that the definitions required for interoperability of the subsystems remain consistent when those two subsystems communicate. Documentation – In more expressive type systems, types can serve as a form of documentation clarifying the intent of the programmer. For example, if a programmer declares a function as returning a timestamp type, this documents the function when the timestamp type can be explicitly declared deeper in the code to be an integer type. Advantages provided by compiler-specified type systems include: Optimization – Static type-checking may provide useful compile-time information. For example, if a type requires that a value must align in memory at a multiple of four bytes, the compiler may be able to use more efficient machine instructions. Safety – A type system enables the compiler to detect meaningless or invalid code. For example, we can identify an expression 3 / \"Hello, World\" as invalid, when the rules do not specify how to divide an integer by a string. Strong typing offers more safety, but cannot guarantee complete type safety. Type errors[edit] A type error occurs when an operation receives a different type of data than it expected. For example, a type error would happen if a line of code divides two integers, and is passed a string of letters instead of an integer. It is an unintended condition[note 2] which might manifest in multiple stages of a program's development. Thus a facility for detection of the error is needed in the type system. In some languages, such as Haskell, for which type inference is automated, lint might be available to its compiler to aid in the detection of error. Type safety contributes to program correctness, but might only guarantee correctness at the cost of making the type checking itself an undecidable problem (as in the Halting problem). In a type system with automated type checking, a program may prove to run incorrectly yet produce no compiler errors. Division by zero is an unsafe and incorrect operation, but a type checker which only runs at compile time does not scan for division by zero in most languages; that division would surface as a runtime error. To prove the absence of these defects, other kinds of formal methods, collectively known as program analyses, are in common use. Alternatively, a sufficiently expressive type system, such as in dependently typed languages, can prevent these kinds of errors (for example, expressing the type of non-zero numbers). In addition, software testing is an empirical method for finding errors that such a type checker would not detect. Type checking[edit] The process of verifying and enforcing the constraints of types—type checking—may occur at compile time (a static check) or at run-time (a dynamic check). If a language specification requires its typing rules strongly, more or less allowing only those automatic type conversions that do not lose information, one can refer to the process as strongly typed; if not, as weakly typed. The terms are not usually used in a strict sense. Static type checking[edit] See also: Category:Statically typed programming languages Static type checking is the process of verifying the type safety of a program based on analysis of a program's text (source code). If a program passes a static type checker, then the program is guaranteed to satisfy some set of type safety properties for all possible inputs. Static type checking can be considered a limited form of program verification (see type safety), and in a type-safe language, can also be considered an optimization. If a compiler can prove that a program is well-typed, then it does not need to emit dynamic safety checks, allowing the resulting compiled binary to run faster and to be smaller. Static type checking for Turing-complete languages is inherently conservative. That is, if a type system is both sound (meaning that it rejects all incorrect programs) and decidable (meaning that it is possible to write an algorithm that determines whether a program is well-typed), then it must be incomplete (meaning there are correct programs, which are also rejected, even though they do not encounter runtime errors). For example, consider a program containing the code: if <complex test> then <do something> else <signal that there is a type error> Even if the expression <complex test> always evaluates to true at run-time, most type checkers will reject the program as ill-typed, because it is difficult (if not impossible) for a static analyzer to determine that the else branch will not be taken. Consequently, a static type checker will quickly detect type errors in rarely used code paths. Without static type checking, even code coverage tests with 100% coverage may be unable to find such type errors. The tests may fail to detect such type errors, because the combination of all places where values are created and all places where a certain value is used must be taken into account. A number of useful and common programming language features cannot be checked statically, such as downcasting. Thus, many languages will have both static and dynamic type checking; the static type checker verifies what it can, and dynamic checks verify the rest. Many languages with static type checking provide a way to bypass the type checker. Some languages allow programmers to choose between static and dynamic type safety. For example, historically C# declares variables statically,: 77, Section 3.2 but C# 4.0 introduces the dynamic keyword, which is used to declare variables to be checked dynamically at runtime.: 117, Section 4.1 Other languages allow writing code that is not type-safe; for example, in C, programmers can freely cast a value between any two types that have the same size, effectively subverting the type concept. Dynamic type checking and runtime type information[edit] See also: Dynamic programming language, Interpreted language, and Category:Dynamically typed programming languages Dynamic type checking is the process of verifying the type safety of a program at runtime. Implementations of dynamically type-checked languages generally associate each runtime object with a type tag (i.e., a reference to a type) containing its type information. This runtime type information (RTTI) can also be used to implement dynamic dispatch, late binding, downcasting, reflective programming (reflection), and similar features. Most type-safe languages include some form of dynamic type checking, even if they also have a static type checker. The reason for this is that many useful features or properties are difficult or impossible to verify statically. For example, suppose that a program defines two types, A and B, where B is a subtype of A. If the program tries to convert a value of type A to type B, which is known as downcasting, then the operation is legal only if the value being converted is actually a value of type B. Thus, a dynamic check is needed to verify that the operation is safe. This requirement is one of the criticisms of downcasting. By definition, dynamic type checking may cause a program to fail at runtime. In some programming languages, it is possible to anticipate and recover from these failures. In others, type-checking errors are considered fatal. Programming languages that include dynamic type checking but not static type checking are often called \"dynamically typed programming languages\". Combining static and dynamic type checking[edit] Some languages allow both static and dynamic typing. For example, Java and some other ostensibly statically typed languages support downcasting types to their subtypes, querying an object to discover its dynamic type and other type operations that depend on runtime type information. Another example is C++ RTTI. More generally, most programming languages include mechanisms for dispatching over different 'kinds' of data, such as disjoint unions, runtime polymorphism, and variant types. Even when not interacting with type annotations or type checking, such mechanisms are materially similar to dynamic typing implementations. See programming language for more discussion of the interactions between static and dynamic typing. Objects in object-oriented languages are usually accessed by a reference whose static target type (or manifest type) is equal to either the object's run-time type (its latent type) or a supertype thereof. This is conformant with the Liskov substitution principle, which states that all operations performed on an instance of a given type can also be performed on an instance of a subtype. This concept is also known as subsumption or subtype polymorphism. In some languages subtypes may also possess covariant or contravariant return types and argument types respectively. Certain languages, for example Clojure, Common Lisp, or Cython are dynamically type checked by default, but allow programs to opt into static type checking by providing optional annotations. One reason to use such hints would be to optimize the performance of critical sections of a program. This is formalized by gradual typing. The programming environment DrRacket, a pedagogic environment based on Lisp, and a precursor of the language Racket is also soft-typed. Conversely, as of version 4.0, the C# language provides a way to indicate that a variable should not be statically type checked. A variable whose type is dynamic will not be subject to static type checking. Instead, the program relies on runtime type information to determine how the variable may be used.: 113–119 In Rust, the dyn std::any::Any type provides dynamic typing of 'static types. Static and dynamic type checking in practice[edit] The choice between static and dynamic typing requires certain trade-offs. Static typing can find type errors reliably at compile time, which increases the reliability of the delivered program. However, programmers disagree over how commonly type errors occur, resulting in further disagreements over the proportion of those bugs that are coded that would be caught by appropriately representing the designed types in code. Static typing advocates[who?] believe programs are more reliable when they have been well type-checked, whereas dynamic-typing advocates[who?] point to distributed code that has proven reliable and to small bug databases.[citation needed] The value of static typing increases as the strength of the type system is increased. Advocates of dependent typing,[who?] implemented in languages such as Dependent ML and Epigram, have suggested that almost all bugs can be considered type errors, if the types used in a program are properly declared by the programmer or correctly inferred by the compiler. Static typing usually results in compiled code that executes faster. When the compiler knows the exact data types that are in use (which is necessary for static verification, either through declaration or inference) it can produce optimized machine code. Some dynamically typed languages such as Common Lisp allow optional type declarations for optimization for this reason. By contrast, dynamic typing may allow compilers to run faster and interpreters to dynamically load new code, because changes to source code in dynamically typed languages may result in less checking to perform and less code to revisit.[clarification needed] This too may reduce the edit-compile-test-debug cycle. Statically typed languages that lack type inference (such as C and Java prior to version 10) require that programmers declare the types that a method or function must use. This can serve as added program documentation, that is active and dynamic, instead of static. This allows a compiler to prevent it from drifting out of synchrony, and from being ignored by programmers. However, a language can be statically typed without requiring type declarations (examples include Haskell, Scala, OCaml, F#, Swift, and to a lesser extent C# and C++), so explicit type declaration is not a necessary requirement for static typing in all languages. Dynamic typing allows constructs that some (simple) static type checking would reject as illegal. For example, eval functions, which execute arbitrary data as code, become possible. An eval function is possible with static typing, but requires advanced uses of algebraic data types. Further, dynamic typing better accommodates transitional code and prototyping, such as allowing a placeholder data structure (mock object) to be transparently used in place of a full data structure (usually for the purposes of experimentation and testing). Dynamic typing typically allows duck typing (which enables easier code reuse). Many[specify] languages with static typing also feature duck typing or other mechanisms like generic programming that also enable easier code reuse. Dynamic typing typically makes metaprogramming easier to use. For example, C++ templates are typically more cumbersome to write than the equivalent Ruby or Python code since C++ has stronger rules regarding type definitions (for both functions and variables). This forces a developer to write more boilerplate code for a template than a Python developer would need to. More advanced run-time constructs such as metaclasses and introspection are often harder to use in statically typed languages. In some languages, such features may also be used e.g. to generate new types and behaviors on the fly, based on run-time data. Such advanced constructs are often provided by dynamic programming languages; many of these are dynamically typed, although dynamic typing need not be related to dynamic programming languages. Strong and weak type systems[edit] Main article: Strong and weak typing Languages are often colloquially referred to as strongly typed or weakly typed. In fact, there is no universally accepted definition of what these terms mean. In general, there are more precise terms to represent the differences between type systems that lead people to call them \"strong\" or \"weak\". Type safety and memory safety[edit] Main articles: Type safety and Memory safety A third way of categorizing the type system of a programming language is by the safety of typed operations and conversions. Computer scientists use the term type-safe language to describe languages that do not allow operations or conversions that violate the rules of the type system. Computer scientists use the term memory-safe language (or just safe language) to describe languages that do not allow programs to access memory that has not been assigned for their use. For example, a memory-safe language will check array bounds, or else statically guarantee (i.e., at compile time before execution) that array accesses out of the array boundaries will cause compile-time and perhaps runtime errors. Consider the following program of a language that is both type-safe and memory-safe: var x := 5; var y := \"37\"; var z := x + y; In this example, the variable z will have the value 42. Although this may not be what the programmer anticipated, it is a well-defined result. If y were a different string, one that could not be converted to a number (e.g. \"Hello World\"), the result would be well-defined as well. Note that a program can be type-safe or memory-safe and still crash on an invalid operation. This is for languages where the type system is not sufficiently advanced to precisely specify the validity of operations on all possible operands. But if a program encounters an operation that is not type-safe, terminating the program is often the only option. Now consider a similar example in C: int x = 5; char y[] = \"37\"; char* z = x + y; printf(\"%c\\n\", *z); In this example z will point to a memory address five characters beyond y, equivalent to three characters after the terminating zero character of the string pointed to by y. This is memory that the program is not expected to access. In C terms this is simply undefined behaviour and the program may do anything; with a simple compiler it might actually print whatever byte is stored after the string \"37\". As this example shows, C is not memory-safe. As arbitrary data was assumed to be a character, it is also not a type-safe language. In general, type-safety and memory-safety go hand in hand. For example, a language that supports pointer arithmetic and number-to-pointer conversions (like C) is neither memory-safe nor type-safe, because it allows arbitrary memory to be accessed as if it were valid memory of any type. Variable levels of type checking[edit] Some languages allow different levels of checking to apply to different regions of code. Examples include: The use strict directive in JavaScript and Perl applies stronger checking. The declare(strict_types=1) in PHP on a per-file basis allows only a variable of exact type of the type declaration will be accepted, or a TypeError will be thrown. The Option Strict On in VB.NET allows the compiler to require a conversion between objects. Additional tools such as lint and IBM Rational Purify can also be used to achieve a higher level of strictness. Optional type systems[edit] It has been proposed, chiefly by Gilad Bracha, that the choice of type system be made independent of choice of language; that a type system should be a module that can be plugged into a language as needed. He believes this is advantageous, because what he calls mandatory type systems make languages less expressive and code more fragile. The requirement that the type system does not affect the semantics of the language is difficult to fulfill. Optional typing is related to, but distinct from, gradual typing. While both typing disciplines can be used to perform static analysis of code (static typing), optional type systems do not enforce type safety at runtime (dynamic typing). Polymorphism and types[edit] Main article: Polymorphism (computer science) The term polymorphism refers to the ability of code (especially, functions or classes) to act on values of multiple types, or to the ability of different instances of the same data structure to contain elements of different types. Type systems that allow polymorphism generally do so in order to improve the potential for code re-use: in a language with polymorphism, programmers need only implement a data structure such as a list or an associative array once, rather than once for each type of element with which they plan to use it. For this reason computer scientists sometimes call the use of certain forms of polymorphism generic programming. The type-theoretic foundations of polymorphism are closely related to those of abstraction, modularity and (in some cases) subtyping. Specialized type systems[edit] Many type systems have been created that are specialized for use in certain environments with certain types of data, or for out-of-band static program analysis. Frequently, these are based on ideas from formal type theory and are only available as part of prototype research systems. The following table gives an overview over type theoretic concepts that are used in specialized type systems. The names M, N, O range over terms and the names σ , τ {\\displaystyle \\sigma ,\\tau } range over types. The following notation will be used: M : σ {\\displaystyle M:\\sigma } means that M {\\displaystyle M} has type σ {\\displaystyle \\sigma } ; M ( N ) {\\displaystyle M(N)} is that application of M {\\displaystyle M} on N {\\displaystyle N} ; τ [ α := σ ] {\\displaystyle \\tau [\\alpha :=\\sigma ]} (resp. τ [ x := N ] {\\displaystyle \\tau [x:=N]} ) describes the type which results from replacing all occurrences of the type variable α (resp. term variable x) in τ {\\displaystyle \\tau } by the type σ (resp. term N). Type notion Notation Meaning Function σ → τ {\\displaystyle \\sigma \\to \\tau } If M : σ → τ {\\displaystyle M:\\sigma \\to \\tau } and N : σ {\\displaystyle N:\\sigma } , then M ( N ) : τ {\\displaystyle M(N):\\tau } . Product σ × τ {\\displaystyle \\sigma \\times \\tau } If M : σ × τ {\\displaystyle M:\\sigma \\times \\tau } , then M = ( N , O ) {\\displaystyle M=(N,O)} is a pair s.t. N : σ {\\displaystyle N:\\sigma } and O : τ {\\displaystyle O:\\tau } . Sum σ + τ {\\displaystyle \\sigma +\\tau } If M : σ + τ {\\displaystyle M:\\sigma +\\tau } , then M = ι 1 ( N ) {\\displaystyle M=\\iota _{1}(N)} is the first injection s.t. N : σ {\\displaystyle N:\\sigma } , or M = ι 2 ( N ) {\\displaystyle M=\\iota _{2}(N)} is the second injection s.t. N : τ {\\displaystyle N:\\tau } . Intersection σ ∩ τ {\\displaystyle \\sigma \\cap \\tau } If M : σ ∩ τ {\\displaystyle M:\\sigma \\cap \\tau } , then M : σ {\\displaystyle M:\\sigma } and M : τ {\\displaystyle M:\\tau } . Union σ ∪ τ {\\displaystyle \\sigma \\cup \\tau } If M : σ ∪ τ {\\displaystyle M:\\sigma \\cup \\tau } , then M : σ {\\displaystyle M:\\sigma } or M : τ {\\displaystyle M:\\tau } . Record ⟨ x : τ ⟩ {\\displaystyle \\langle x:\\tau \\rangle } If M : ⟨ x : τ ⟩ {\\displaystyle M:\\langle x:\\tau \\rangle } , then M has a member x : τ {\\displaystyle x:\\tau } . Polymorphic ∀ α . τ {\\displaystyle \\forall {}\\alpha .\\tau } If M : ∀ α . τ {\\displaystyle M:\\forall {}\\alpha .\\tau } , then M : τ [ α := σ ] {\\displaystyle M:\\tau [\\alpha :=\\sigma ]} for any type σ. Existential ∃ α . τ {\\displaystyle \\exists {}\\alpha .\\tau } If M : ∃ α . τ {\\displaystyle M:\\exists {}\\alpha .\\tau } , then M : τ [ α := σ ] {\\displaystyle M:\\tau [\\alpha :=\\sigma ]} for some type σ. Recursive μ α . τ {\\displaystyle \\mu \\alpha .\\tau } If M : μ α . τ {\\displaystyle M:\\mu \\alpha .\\tau } , then M : τ [ α := μ α . τ ] {\\displaystyle M:\\tau [\\alpha :=\\mu \\alpha .\\tau ]} . Dependent function[a] ( x : σ ) → τ {\\displaystyle (x:\\sigma )\\to \\tau } If M : ( x : σ ) → τ {\\displaystyle M:(x:\\sigma )\\to \\tau } and N : σ {\\displaystyle N:\\sigma } , then M ( N ) : τ [ x := N ] {\\displaystyle M(N):\\tau [x:=N]} . Dependent pair[b] ( x : σ ) × τ {\\displaystyle (x:\\sigma )\\times \\tau } If M : ( x : σ ) × τ {\\displaystyle M:(x:\\sigma )\\times \\tau } , then M = ( N , O ) {\\displaystyle M=(N,O)} is a pair s.t. N : σ {\\displaystyle N:\\sigma } and O : τ [ x := N ] {\\displaystyle O:\\tau [x:=N]} . Dependent intersection ( x : σ ) ∩ τ {\\displaystyle (x:\\sigma )\\cap \\tau } If M : ( x : σ ) ∩ τ {\\displaystyle M:(x:\\sigma )\\cap \\tau } , then M : σ {\\displaystyle M:\\sigma } and M : τ [ x := M ] {\\displaystyle M:\\tau [x:=M]} . Familial intersection ⋂ x : σ τ {\\displaystyle \\bigcap _{x:\\sigma }\\tau } If M : ⋂ x : σ τ {\\textstyle M:\\bigcap _{x:\\sigma }\\tau } , then M : τ [ x := N ] {\\displaystyle M:\\tau [x:=N]} for any term N : σ {\\displaystyle N:\\sigma } . Familial union ⋃ x : σ τ {\\displaystyle \\bigcup _{x:\\sigma }\\tau } If M : ⋃ x : σ τ {\\textstyle M:\\bigcup _{x:\\sigma }\\tau } , then M : τ [ x := N ] {\\displaystyle M:\\tau [x:=N]} for some term N : σ {\\displaystyle N:\\sigma } . ^ Also referred to as dependent product type, since ( x : σ ) → τ = ∏ x : σ τ {\\textstyle (x:\\sigma )\\to \\tau =\\prod _{x:\\sigma }\\tau } . ^ Also referred to as dependent sum type, since ( x : σ ) × τ = ∑ x : σ τ {\\textstyle (x:\\sigma )\\times \\tau =\\sum _{x:\\sigma }\\tau } . Dependent types[edit] Main article: Dependent type Dependent types are based on the idea of using scalars or values to more precisely describe the type of some other value. For example, m a t r i x ( 3 , 3 ) {\\displaystyle \\mathrm {matrix} (3,3)} might be the type of a 3 × 3 {\\displaystyle 3\\times 3} matrix. We can then define typing rules such as the following rule for matrix multiplication: m a t r i x m u l t i p l y : m a t r i x ( k , m ) × m a t r i x ( m , n ) → m a t r i x ( k , n ) {\\displaystyle \\mathrm {matrix} _{\\mathrm {multiply} }:\\mathrm {matrix} (k,m)\\times \\mathrm {matrix} (m,n)\\to \\mathrm {matrix} (k,n)} where k, m, n are arbitrary positive integer values. A variant of ML called Dependent ML has been created based on this type system, but because type checking for conventional dependent types is undecidable, not all programs using them can be type-checked without some kind of limits. Dependent ML limits the sort of equality it can decide to Presburger arithmetic. Other languages such as Epigram make the value of all expressions in the language decidable so that type checking can be decidable. However, in general proof of decidability is undecidable, so many programs require hand-written annotations that may be very non-trivial. As this impedes the development process, many language implementations provide an easy way out in the form of an option to disable this condition. This, however, comes at the cost of making the type-checker run in an infinite loop when fed programs that do not type-check, causing the compilation to fail. Linear types[edit] Main article: Linear type Linear types, based on the theory of linear logic, and closely related to uniqueness types, are types assigned to values having the property that they have one and only one reference to them at all times. These are valuable for describing large immutable values such as files, strings, and so on, because any operation that simultaneously destroys a linear object and creates a similar object (such as str = str + \"a\") can be optimized \"under the hood\" into an in-place mutation. Normally this is not possible, as such mutations could cause side effects on parts of the program holding other references to the object, violating referential transparency. They are also used in the prototype operating system Singularity for interprocess communication, statically ensuring that processes cannot share objects in shared memory in order to prevent race conditions. The Clean language (a Haskell-like language) uses this type system in order to gain a lot of speed (compared to performing a deep copy) while remaining safe. Intersection types[edit] Main article: Intersection type Intersection types are types describing values that belong to both of two other given types with overlapping value sets. For example, in most implementations of C the signed char has range -128 to 127 and the unsigned char has range 0 to 255, so the intersection type of these two types would have range 0 to 127. Such an intersection type could be safely passed into functions expecting either signed or unsigned chars, because it is compatible with both types. Intersection types are useful for describing overloaded function types: for example, if \"int → int\" is the type of functions taking an integer argument and returning an integer, and \"float → float\" is the type of functions taking a float argument and returning a float, then the intersection of these two types can be used to describe functions that do one or the other, based on what type of input they are given. Such a function could be passed into another function expecting an \"int → int\" function safely; it simply would not use the \"float → float\" functionality. In a subclassing hierarchy, the intersection of a type and an ancestor type (such as its parent) is the most derived type. The intersection of sibling types is empty. The Forsythe language includes a general implementation of intersection types. A restricted form is refinement types. Union types[edit] Main article: Union type Union types are types describing values that belong to either of two types. For example, in C, the signed char has a -128 to 127 range, and the unsigned char has a 0 to 255 range, so the union of these two types would have an overall \"virtual\" range of -128 to 255 that may be used partially depending on which union member is accessed. Any function handling this union type would have to deal with integers in this complete range. More generally, the only valid operations on a union type are operations that are valid on both types being unioned. C's \"union\" concept is similar to union types, but is not typesafe, as it permits operations that are valid on either type, rather than both. Union types are important in program analysis, where they are used to represent symbolic values whose exact nature (e.g., value or type) is not known. In a subclassing hierarchy, the union of a type and an ancestor type (such as its parent) is the ancestor type. The union of sibling types is a subtype of their common ancestor (that is, all operations permitted on their common ancestor are permitted on the union type, but they may also have other valid operations in common). Existential types[edit] Main article: Existential quantifier Existential types are frequently used in connection with record types to represent modules and abstract data types, due to their ability to separate implementation from interface. For example, the type \"T = ∃X { a: X; f: (X → int); }\" describes a module interface that has a data member named a of type X and a function named f that takes a parameter of the same type X and returns an integer. This could be implemented in different ways; for example: intT = { a: int; f: (int → int); } floatT = { a: float; f: (float → int); } These types are both subtypes of the more general existential type T and correspond to concrete implementation types, so any value of one of these types is a value of type T. Given a value \"t\" of type \"T\", we know that \"t.f(t.a)\" is well-typed, regardless of what the abstract type X is. This gives flexibility for choosing types suited to a particular implementation, while clients that use only values of the interface type—the existential type—are isolated from these choices. In general it's impossible for the typechecker to infer which existential type a given module belongs to. In the above example intT { a: int; f: (int → int); } could also have the type ∃X { a: X; f: (int → int); }. The simplest solution is to annotate every module with its intended type, e.g.: intT = { a: int; f: (int → int); } as ∃X { a: X; f: (X → int); } Although abstract data types and modules had been implemented in programming languages for quite some time, it wasn't until 1988 that John C. Mitchell and Gordon Plotkin established the formal theory under the slogan: \"Abstract [data] types have existential type\". The theory is a second-order typed lambda calculus similar to System F, but with existential instead of universal quantification. Gradual typing[edit] Main article: Gradual typing In a type system with Gradual typing, variables may be assigned a type either at compile-time (which is static typing), or at run-time (which is dynamic typing). This allows software developers to choose either type paradigm as appropriate, from within a single language. Gradual typing uses a special type named dynamic to represent statically unknown types; gradual typing replaces the notion of type equality with a new relation called consistency that relates the dynamic type to every other type. The consistency relation is symmetric but not transitive. Explicit or implicit declaration and inference[edit] Further information: Type inference Many static type systems, such as those of C and Java, require type declarations: the programmer must explicitly associate each variable with a specific type. Others, such as Haskell's, perform type inference: the compiler draws conclusions about the types of variables based on how programmers use those variables. For example, given a function f(x, y) that adds x and y together, the compiler can infer that x and y must be numbers—since addition is only defined for numbers. Thus, any call to f elsewhere in the program that specifies a non-numeric type (such as a string or list) as an argument would signal an error. Numerical and string constants and expressions in code can and often do imply type in a particular context. For example, an expression 3.14 might imply a type of floating-point, while [1, 2, 3] might imply a list of integers—typically an array. Type inference is in general possible, if it is computable in the type system in question. Moreover, even if inference is not computable in general for a given type system, inference is often possible for a large subset of real-world programs. Haskell's type system, a version of Hindley–Milner, is a restriction of System Fω to so-called rank-1 polymorphic types, in which type inference is computable. Most Haskell compilers allow arbitrary-rank polymorphism as an extension, but this makes type inference not computable. (Type checking is decidable, however, and rank-1 programs still have type inference; higher rank polymorphic programs are rejected unless given explicit type annotations.) Decision problems[edit] Main article: Type theory § Decision problems A type system that assigns types to terms in type environments using typing rules is naturally associated with the decision problems of type checking, typability, and type inhabitation. Given a type environment Γ {\\displaystyle \\Gamma } , a term e {\\displaystyle e} , and a type τ {\\displaystyle \\tau } , decide whether the term e {\\displaystyle e} can be assigned the type τ {\\displaystyle \\tau } in the type environment. Given a term e {\\displaystyle e} , decide whether there exists a type environment Γ {\\displaystyle \\Gamma } and a type τ {\\displaystyle \\tau } such that the term e {\\displaystyle e} can be assigned the type τ {\\displaystyle \\tau } in the type environment Γ {\\displaystyle \\Gamma } . Given a type environment Γ {\\displaystyle \\Gamma } and a type τ {\\displaystyle \\tau } , decide whether there exists a term e {\\displaystyle e} that can be assigned the type τ {\\displaystyle \\tau } in the type environment. Unified type system[edit] Some languages like C# or Scala have a unified type system. This means that all C# types including primitive types inherit from a single root object. Every type in C# inherits from the Object class. Some languages, like Java and Raku, have a root type but also have primitive types that are not objects. Java provides wrapper object types that exist together with the primitive types so developers can use either the wrapper object types or the simpler non-object primitive types. Raku automatically converts primitive types to objects when their methods are accessed. Compatibility: equivalence and subtyping[edit] A type checker for a statically typed language must verify that the type of any expression is consistent with the type expected by the context in which that expression appears. For example, in an assignment statement of the form x := e, the inferred type of the expression e must be consistent with the declared or inferred type of the variable x. This notion of consistency, called compatibility, is specific to each programming language. If the type of e and the type of x are the same, and assignment is allowed for that type, then this is a valid expression. Thus, in the simplest type systems, the question of whether two types are compatible reduces to that of whether they are equal (or equivalent). Different languages, however, have different criteria for when two type expressions are understood to denote the same type. These different equational theories of types vary widely, two extreme cases being structural type systems, in which any two types that describe values with the same structure are equivalent, and nominative type systems, in which no two syntactically distinct type expressions denote the same type (i.e., types must have the same \"name\" in order to be equal). In languages with subtyping, the compatibility relation is more complex: If B is a subtype of A, then a value of type B can be used in a context where one of type A is expected (covariant), even if the reverse is not true. Like equivalence, the subtype relation is defined differently for each programming language, with many variations possible. The presence of parametric or ad hoc polymorphism in a language may also have implications for type compatibility. See also[edit] Computer programming portal Comparison of type systems Covariance and contravariance (computer science) Polymorphism in object-oriented programming Type signature Type theory Notes[edit] ^ The Burroughs ALGOL computer line determined a memory location's contents by its flag bits. Flag bits specify the contents of a memory location. Instruction, data type, and functions are specified by a 3 bit code in addition to its 48 bit contents. Only the MCP (Master Control Program) could write to the flag code bits. ^ For example, a leaky abstraction might surface during development, which may show that more type development is needed. —\"The evaluation of a well-typed program always terminates\".—B. Nordström, K. Petersson, and J. M. Smith A systematic change in variables to avoid capture of a free variable can introduce error, in a functional programming language where functions are first class citizens. —From the lambda calculus article. References[edit] ^ Pierce 2002, p. 1: \"A type system is a tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute.\" ^ Cardelli 2004, p. 1: \"The fundamental purpose of a type system is to prevent the occurrence of execution errors during the running of a program.\" ^ Pierce 2002, p. 208. ^ a b Sethi, R. (1996). Programming languages: Concepts and constructs (2nd ed.). Addison-Wesley. p. 142. ISBN 978-0-201-59065-4. OCLC 604732680. ^ Nordström, B.; Petersson, K.; Smith, J.M. (2001). \"Martin-Löf's Type Theory\". Algebraic and Logical Structures. Handbook of Logic in Computer Science. Vol. 5. Oxford University Press. p. 2. ISBN 978-0-19-154627-3. ^ Turner, D.A. (12 June 2012). \"Some History of Functional Programming Languages\" (PDF). invited lecture at TFP12, at St Andrews University. See the section on Algol 60. ^ \"... any sound, decidable type system must be incomplete\" —D. Remy (2017). p. 29, Remy, Didier. \"Type systems for programming languages\" (PDF). Archived from the original (PDF) on 14 November 2017. Retrieved 26 May 2013. ^ Pierce 2002. ^ a b c Skeet, Jon (2019). C# in Depth (4 ed.). Manning. ISBN 978-1617294532. ^ Miglani, Gaurav (2018). \"Dynamic Method Dispatch or Runtime Polymorphism in Java\". Archived from the original on 2020-12-07. Retrieved 2021-03-28. ^ Wright, Andrew K. (1995). Practical Soft Typing (PhD). Rice University. hdl:1911/16900. ^ \"dynamic (C# Reference)\". MSDN Library. Microsoft. Retrieved 14 January 2014. ^ \"std::any — Rust\". doc.rust-lang.org. Retrieved 2021-07-07. ^ Meijer, Erik; Drayton, Peter. \"Static Typing Where Possible, Dynamic Typing When Needed: The End of the Cold War Between Programming Languages\" (PDF). Microsoft Corporation. ^ Laucher, Amanda; Snively, Paul (2012). \"Types vs Tests\". InfoQ. ^ Xi, Hongwei (1998). Dependent Types in Practical Programming (PhD). Department of Mathematical Sciences, Carnegie Mellon University. CiteSeerX 10.1.1.41.548.Xi, Hongwei; Pfenning, Frank (1999). \"Dependent Types in Practical Programming\". Proceedings of the 26th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. ACM. pp. 214–227. CiteSeerX 10.1.1.69.2042. doi:10.1145/292540.292560. ISBN 1581130953. S2CID 245490. ^ Visual Basic is an example of a language that is both type-safe and memory-safe. ^ \"4.2.2 The Strict Variant of ECMAScript\". ECMAScript® 2020 Language Specification (11th ed.). ECMA. June 2020. ECMA-262. ^ \"Strict mode – JavaScript\". MDN. Developer.mozilla.org. 2013-07-03. Retrieved 2013-07-17. ^ \"Strict Mode (JavaScript)\". MSDN. Microsoft. Retrieved 2013-07-17. ^ \"Strict typing\". PHP Manual: Language Reference: Functions. ^ a b Bracha, G. \"Pluggable Types\" (PDF). ^ \"Sure. It's called \"gradual typing\", and I would qualify it as trendy. ...\" Is there a language that allows both static and dynamic typing?. stackoverflow. 2012. ^ a b c Kopylov, Alexei (2003). \"Dependent intersection: A new way of defining records in type theory\". 18th IEEE Symposium on Logic in Computer Science. LICS 2003. IEEE Computer Society. pp. 86–95. CiteSeerX 10.1.1.89.4223. doi:10.1109/LICS.2003.1210048. ^ Mitchell, John C.; Plotkin, Gordon D. (July 1988). \"Abstract Types Have Existential Type\" (PDF). ACM Trans. Program. Lang. Syst. 10 (3): 470–502. doi:10.1145/44501.45065. S2CID 1222153. ^ a b Siek, Jeremy (24 March 2014). \"What is gradual typing?\". ^ Siek, Jeremy; Taha, Walid (September 2006). Gradual Typing for Functional Languages (PDF). Scheme and Functional Programming 2006. University of Chicago. pp. 81–92. ^ Barendregt, Henk; Dekkers, Wil; Statman, Richard (20 June 2013). Lambda Calculus with Types. Cambridge University Press. p. 66. ISBN 978-0-521-76614-2. ^ \"8.2.4 Type system unification\". C# Language Specification (5th ed.). ECMA. December 2017. ECMA-334. ^ \"Native Types\". Perl 6 Documentation. ^ \"Numerics, § Auto-boxing\". Perl 6 Documentation. Further reading[edit] Cardelli, Luca; Wegner, Peter (December 1985). \"On Understanding Types, Data Abstraction, and Polymorphism\" (PDF). ACM Computing Surveys. 17 (4): 471–523. CiteSeerX 10.1.1.117.695. doi:10.1145/6041.6042. S2CID 2921816. Pierce, Benjamin C. (2002). Types and Programming Languages. MIT Press. ISBN 978-0-262-16209-8. Cardelli, Luca (2004). \"Type systems\" (PDF). In Allen B. Tucker (ed.). CRC Handbook of Computer Science and Engineering (2nd ed.). CRC Press. ISBN 978-1584883609. Tratt, Laurence (July 2009). \"5. Dynamically Typed Languages\". Advances in Computers. Vol. 77. Elsevier. pp. 149–184. doi:10.1016/S0065-2458(09)01205-4. ISBN 978-0-12-374812-6. External links[edit] The Wikibook Ada Programming has a page on the topic of: Types The Wikibook Haskell has a page on the topic of: Class declarations Media related to Type systems at Wikimedia Commons Smith, Chris (2011). \"What to Know Before Debating Type Systems\". vteData typesUninterpreted Bit Byte Trit Tryte Word Bit array Numeric Arbitrary-precision or bignum Complex Decimal Fixed point Floating point Reduced precision Minifloat Half precision bfloat16 Single precision Double precision Quadruple precision Octuple precision Extended precision Long double Integer signedness Interval Rational Pointer Address physical virtual Reference Text Character String null-terminated Composite Algebraic data type generalized Array Associative array Class Dependent Equality Inductive Intersection List Object metaobject Option type Product Record or Struct Refinement Set Union tagged Other Boolean Bottom type Collection Enumerated type Exception Function type Opaque data type Recursive data type Semaphore Stream Strongly typed identifier Top type Type class Empty type Unit type Void Relatedtopics Abstract data type Boxing Data structure Generic Kind metaclass Parametric polymorphism Primitive data type Interface Subtyping Type constructor Type conversion Type system Type theory Variable"
    },
    {
        "id": 20,
        "url": "https://en.wikipedia.org/wiki/Strong_and_weak_typing",
        "title": "Strong and weak typing",
        "content": "Programming language type systems Type systems General concepts Type safety Strong vs. weak typing Major categories Static vs. dynamic Manifest vs. inferred Nominal vs. structural Duck typing Minor categories Abstract Dependent Flow-sensitive Gradual Intersection Latent Refinement Substructural Unique Session vte In computer programming, one of the many ways that programming languages are colloquially classified is whether the language's type system makes it strongly typed or weakly typed (loosely typed). However, there is no precise technical definition of what the terms mean and different authors disagree about the implied meaning of the terms and the relative rankings of the \"strength\" of the type systems of mainstream programming languages. For this reason, writers who wish to write unambiguously about type systems often eschew the terms \"strong typing\" and \"weak typing\" in favor of specific expressions such as \"type safety\". Generally, a strongly typed language has stricter typing rules at compile time, which implies that errors and exceptions are more likely to happen during compilation. Most of these rules affect variable assignment, function return values, procedure arguments and function calling. Dynamically typed languages (where type checking happens at run time) can also be strongly typed. In dynamically typed languages, values, rather than variables, have types. A weakly typed language has looser typing rules and may produce unpredictable or even erroneous results or may perform implicit type conversion at runtime. A different but related concept is latent typing. History[edit] In 1974, Barbara Liskov and Stephen Zilles defined a strongly-typed language as one in which \"whenever an object is passed from a calling function to a called function, its type must be compatible with the type declared in the called function.\" In 1977, K. Jackson wrote, \"In a strongly typed language each data area will have a distinct type and each process will state its communication requirements in terms of these types.\" Definitions of \"strong\" or \"weak\"[edit] A number of different language design decisions have been referred to as evidence of \"strong\" or \"weak\" typing. Many of these are more accurately understood as the presence or absence of type safety, memory safety, static type-checking, or dynamic type-checking. \"Strong typing\" generally refers to use of programming language types in order to both capture invariants of the code, and ensure its correctness, and definitely exclude certain classes of programming errors. Thus there are many \"strong typing\" disciplines used to achieve these goals. Implicit type conversions and \"type punning\"[edit] Some programming languages make it easy to use a value of one type as if it were a value of another type. This is sometimes described as \"weak typing\". For example, Aahz Maruch observes that \"Coercion occurs when you have a statically typed language and you use the syntactic features of the language to force the usage of one type as if it were a different type (consider the common use of void* in C). Coercion is usually a symptom of weak typing. Conversion, on the other hand, creates a brand-new object of the appropriate type.\" As another example, GCC describes this as type-punning and warns that it will break strict aliasing. Thiago Macieira discusses several problems that can arise when type-punning causes the compiler to make inappropriate optimizations. There are many examples of languages that allow implicit type conversions, but in a type-safe manner. For example, both C++ and C# allow programs to define operators to convert a value from one type to another with well-defined semantics. When a C++ compiler encounters such a conversion, it treats the operation just like a function call. In contrast, converting a value to the C type void* is an unsafe operation that is invisible to the compiler. Pointers[edit] Some programming languages expose pointers as if they were numeric values, and allow users to perform arithmetic on them. These languages are sometimes referred to as \"weakly typed\", since pointer arithmetic can be used to bypass the language's type system. Untagged unions[edit] Some programming languages support untagged unions, which allow a value of one type to be viewed as if it were a value of another type. Static type-checking[edit] In Luca Cardelli's article Typeful Programming, a \"strong type system\" is described as one in which there is no possibility of an unchecked runtime type error. In other writing, the absence of unchecked run-time errors is referred to as safety or type safety; Tony Hoare's early papers call this property security. Variation across programming languages[edit] This section possibly contains original research. Please improve it by verifying the claims made and adding inline citations. Statements consisting only of original research should be removed. (May 2018) (Learn how and when to remove this message) This section needs additional citations for verification. Please help improve this article by adding citations to reliable sources in this section. Unsourced material may be challenged and removed. (May 2020) (Learn how and when to remove this message) Some of these definitions are contradictory, others are merely conceptually independent, and still others are special cases (with additional constraints) of other, more \"liberal\" (less strong) definitions. Because of the wide divergence among these definitions, it is possible to defend claims about most programming languages that they are either strongly or weakly typed. For instance: Java, Pascal, Ada, and C require variables to have a declared type, and support the use of explicit casts of arithmetic values to other arithmetic types. Java, C#, Ada, and Pascal are sometimes said to be more strongly typed than C, because C supports more kinds of implicit conversions, and allows pointer values to be explicitly cast while Java and Pascal do not. Java may be considered more strongly typed than Pascal as methods of evading the static type system in Java are controlled by the Java virtual machine's type system. C# and VB.NET are similar to Java in that respect, though they allow disabling of dynamic type checking by explicitly putting code segments in an \"unsafe context\". Pascal's type system has been described as \"too strong\", because the size of an array or string is part of its type, making some programming tasks very difficult. However, Delphi fixes this issue. Smalltalk, Ruby, Python, and Self are all \"strongly typed\" in the sense that typing errors are prevented at runtime and they do little implicit type conversion, but these languages make no use of static type checking: the compiler does not check or enforce type constraint rules. The term duck typing is now used to describe the dynamic typing paradigm used by the languages in this group. The Lisp family of languages are all \"strongly typed\" in the sense that typing errors are prevented at runtime. Some Lisp dialects like Common Lisp or Clojure do support various forms of type declarations and some compilers (CMU Common Lisp (CMUCL) and related) use these declarations together with type inference to enable various optimizations and limited forms of compile time type checks. Standard ML, F#, OCaml, Haskell, Go and Rust are statically type-checked, but the compiler automatically infers a precise type for most values. Assembly language and Forth can be characterized as untyped. There is no type checking; it is up to the programmer to ensure that data given to functions is of the appropriate type. See also[edit] Comparison of programming languages Data type includes a more thorough discussion of typing issues Design by contract (strong typing as implicit contract form) Latent typing Memory safety Type safety Type system Strongly-typed identifier References[edit] ^ \"What to know before debating type systems | Ovid [blogs.perl.org]\". blogs.perl.org. Retrieved 2023-06-27. ^ \"CS1130. Transition to OO programming. – Spring 2012 --self-paced version\". Cornell University, Department of Computer Science. 2005. Archived from the original on 2015-11-23. Retrieved 2015-11-23.{{cite web}}: CS1 maint: bot: original URL status unknown (link) ^ Liskov, B; Zilles, S (1974). \"Programming with abstract data types\". ACM SIGPLAN Notices. 9 (4): 50–59. CiteSeerX 10.1.1.136.3043. doi:10.1145/942572.807045. ^ Jackson, K. (1977). \"Parallel processing and modular software construction\". Design and Implementation of Programming Languages. Lecture Notes in Computer Science. Vol. 54. pp. 436–443. doi:10.1007/BFb0021435. ISBN 3-540-08360-X. ^ Aahz. \"Typing: Strong vs. Weak, Static vs. Dynamic\". Retrieved 16 August 2015. ^ \"Type-punning and strict-aliasing - Qt Blog\". Qt Blog. Retrieved 18 February 2020. ^ Luca Cardelli, \"Typeful programming\" ^ Hoare, C. A. R. 1974. Hints on Programming Language Design. In Computer Systems Reliability, ed. C. Bunyan. Vol. 20 pp. 505–534. ^ InfoWorld. 1983-04-25. Retrieved 16 August 2015. ^ Kernighan, Brian (1981). \"Why Pascal is not my favorite programming language\". Archived from the original on 2012-04-06. Retrieved 2011-10-22. ^ \"CLHS: Chapter 4\". Retrieved 16 August 2015. ^ \"CMUCL User's Manual: The Compiler\". Archived from the original on 8 March 2016. Retrieved 16 August 2015."
    },
    {
        "id": 21,
        "url": "https://en.wikipedia.org/wiki/Optional_typing",
        "title": "Type system",
        "content": "Computer science concept This article is about type systems in computer programming. For the formal study of type systems, see Type theory. This article includes a list of general references, but it lacks sufficient corresponding inline citations. Please help to improve this article by introducing more precise citations. (October 2010) (Learn how and when to remove this message) This article is written like a personal reflection, personal essay, or argumentative essay that states a Wikipedia editor's personal feelings or presents an original argument about a topic. Please help improve it by rewriting it in an encyclopedic style. (July 2016) (Learn how and when to remove this message) Type systems General concepts Type safety Strong vs. weak typing Major categories Static vs. dynamic Manifest vs. inferred Nominal vs. structural Duck typing Minor categories Abstract Dependent Flow-sensitive Gradual Intersection Latent Refinement Substructural Unique Session vte In computer programming, a type system is a logical system comprising a set of rules that assigns a property called a type (for example, integer, floating point, string) to every term (a word, phrase, or other set of symbols). Usually the terms are various language constructs of a computer program, such as variables, expressions, functions, or modules. A type system dictates the operations that can be performed on a term. For variables, the type system determines the allowed values of that term. Type systems formalize and enforce the otherwise implicit categories the programmer uses for algebraic data types, data structures, or other data types, such as \"string\", \"array of float\", \"function returning boolean\". Type systems are often specified as part of programming languages and built into interpreters and compilers, although the type system of a language can be extended by optional tools that perform added checks using the language's original type syntax and grammar. The main purpose of a type system in a programming language is to reduce possibilities for bugs in computer programs due to type errors. The given type system in question determines what constitutes a type error, but in general, the aim is to prevent operations expecting a certain kind of value from being used with values of which that operation does not make sense (validity errors). Type systems allow defining interfaces between different parts of a computer program, and then checking that the parts have been connected in a consistent way. This checking can happen statically (at compile time), dynamically (at run time), or as a combination of both. Type systems have other purposes as well, such as expressing business rules, enabling certain compiler optimizations, allowing for multiple dispatch, and providing a form of documentation. Usage overview[edit] An example of a simple type system is that of the C language. The portions of a C program are the function definitions. One function is invoked by another function. The interface of a function states the name of the function and a list of parameters that are passed to the function's code. The code of an invoking function states the name of the invoked, along with the names of variables that hold values to pass to it. During a computer program's execution, the values are placed into temporary storage, then execution jumps to the code of the invoked function. The invoked function's code accesses the values and makes use of them. If the instructions inside the function are written with the assumption of receiving an integer value, but the calling code passed a floating-point value, then the wrong result will be computed by the invoked function. The C compiler checks the types of the arguments passed to a function when it is called against the types of the parameters declared in the function's definition. If the types do not match, the compiler throws a compile-time error or warning. A compiler may also use the static type of a value to optimize the storage it needs and the choice of algorithms for operations on the value. In many C compilers the float data type, for example, is represented in 32 bits, in accord with the IEEE specification for single-precision floating point numbers. They will thus use floating-point-specific microprocessor operations on those values (floating-point addition, multiplication, etc.). The depth of type constraints and the manner of their evaluation affect the typing of the language. A programming language may further associate an operation with various resolutions for each type, in the case of type polymorphism. Type theory is the study of type systems. The concrete types of some programming languages, such as integers and strings, depend on practical issues of computer architecture, compiler implementation, and language design. Fundamentals[edit] Formally, type theory studies type systems. A programming language must have the opportunity to type check using the type system whether at compile time or runtime, manually annotated or automatically inferred. As Mark Manasse concisely put it: The fundamental problem addressed by a type theory is to ensure that programs have meaning. The fundamental problem caused by a type theory is that meaningful programs may not have meanings ascribed to them. The quest for richer type systems results from this tension. Assigning a data type, termed typing, gives meaning to a sequence of bits such as a value in memory or some object such as a variable. The hardware of a general purpose computer is unable to discriminate between for example a memory address and an instruction code, or between a character, an integer, or a floating-point number, because it makes no intrinsic distinction between any of the possible values that a sequence of bits might mean.[note 1] Associating a sequence of bits with a type conveys that meaning to the programmable hardware to form a symbolic system composed of that hardware and some program. A program associates each value with at least one specific type, but it also can occur that one value is associated with many subtypes. Other entities, such as objects, modules, communication channels, and dependencies can become associated with a type. Even a type can become associated with a type. An implementation of a type system could in theory associate identifications called data type (a type of a value), class (a type of an object), and kind (a type of a type, or metatype). These are the abstractions that typing can go through, on a hierarchy of levels contained in a system. When a programming language evolves a more elaborate type system, it gains a more finely grained rule set than basic type checking, but this comes at a price when the type inferences (and other properties) become undecidable, and when more attention must be paid by the programmer to annotate code or to consider computer-related operations and functioning. It is challenging to find a sufficiently expressive type system that satisfies all programming practices in a type safe manner. A programming language compiler can also implement a dependent type or an effect system, which enables even more program specifications to be verified by a type checker. Beyond simple value-type pairs, a virtual \"region\" of code is associated with an \"effect\" component describing what is being done with what, and enabling for example to \"throw\" an error report. Thus the symbolic system may be a type and effect system, which endows it with more safety checking than type checking alone. Whether automated by the compiler or specified by a programmer, a type system renders program behavior illegal if it falls outside the type-system rules. Advantages provided by programmer-specified type systems include: Abstraction (or modularity) – Types enable programmers to think at a higher level than the bit or byte, not bothering with low-level implementation. For example, programmers can begin to think of a string as a set of character values instead of as an array of bytes. Higher still, types enable programmers to think about and express interfaces between two of any-sized subsystems. This enables more levels of localization so that the definitions required for interoperability of the subsystems remain consistent when those two subsystems communicate. Documentation – In more expressive type systems, types can serve as a form of documentation clarifying the intent of the programmer. For example, if a programmer declares a function as returning a timestamp type, this documents the function when the timestamp type can be explicitly declared deeper in the code to be an integer type. Advantages provided by compiler-specified type systems include: Optimization – Static type-checking may provide useful compile-time information. For example, if a type requires that a value must align in memory at a multiple of four bytes, the compiler may be able to use more efficient machine instructions. Safety – A type system enables the compiler to detect meaningless or invalid code. For example, we can identify an expression 3 / \"Hello, World\" as invalid, when the rules do not specify how to divide an integer by a string. Strong typing offers more safety, but cannot guarantee complete type safety. Type errors[edit] A type error occurs when an operation receives a different type of data than it expected. For example, a type error would happen if a line of code divides two integers, and is passed a string of letters instead of an integer. It is an unintended condition[note 2] which might manifest in multiple stages of a program's development. Thus a facility for detection of the error is needed in the type system. In some languages, such as Haskell, for which type inference is automated, lint might be available to its compiler to aid in the detection of error. Type safety contributes to program correctness, but might only guarantee correctness at the cost of making the type checking itself an undecidable problem (as in the Halting problem). In a type system with automated type checking, a program may prove to run incorrectly yet produce no compiler errors. Division by zero is an unsafe and incorrect operation, but a type checker which only runs at compile time does not scan for division by zero in most languages; that division would surface as a runtime error. To prove the absence of these defects, other kinds of formal methods, collectively known as program analyses, are in common use. Alternatively, a sufficiently expressive type system, such as in dependently typed languages, can prevent these kinds of errors (for example, expressing the type of non-zero numbers). In addition, software testing is an empirical method for finding errors that such a type checker would not detect. Type checking[edit] The process of verifying and enforcing the constraints of types—type checking—may occur at compile time (a static check) or at run-time (a dynamic check). If a language specification requires its typing rules strongly, more or less allowing only those automatic type conversions that do not lose information, one can refer to the process as strongly typed; if not, as weakly typed. The terms are not usually used in a strict sense. Static type checking[edit] See also: Category:Statically typed programming languages Static type checking is the process of verifying the type safety of a program based on analysis of a program's text (source code). If a program passes a static type checker, then the program is guaranteed to satisfy some set of type safety properties for all possible inputs. Static type checking can be considered a limited form of program verification (see type safety), and in a type-safe language, can also be considered an optimization. If a compiler can prove that a program is well-typed, then it does not need to emit dynamic safety checks, allowing the resulting compiled binary to run faster and to be smaller. Static type checking for Turing-complete languages is inherently conservative. That is, if a type system is both sound (meaning that it rejects all incorrect programs) and decidable (meaning that it is possible to write an algorithm that determines whether a program is well-typed), then it must be incomplete (meaning there are correct programs, which are also rejected, even though they do not encounter runtime errors). For example, consider a program containing the code: if <complex test> then <do something> else <signal that there is a type error> Even if the expression <complex test> always evaluates to true at run-time, most type checkers will reject the program as ill-typed, because it is difficult (if not impossible) for a static analyzer to determine that the else branch will not be taken. Consequently, a static type checker will quickly detect type errors in rarely used code paths. Without static type checking, even code coverage tests with 100% coverage may be unable to find such type errors. The tests may fail to detect such type errors, because the combination of all places where values are created and all places where a certain value is used must be taken into account. A number of useful and common programming language features cannot be checked statically, such as downcasting. Thus, many languages will have both static and dynamic type checking; the static type checker verifies what it can, and dynamic checks verify the rest. Many languages with static type checking provide a way to bypass the type checker. Some languages allow programmers to choose between static and dynamic type safety. For example, historically C# declares variables statically,: 77, Section 3.2 but C# 4.0 introduces the dynamic keyword, which is used to declare variables to be checked dynamically at runtime.: 117, Section 4.1 Other languages allow writing code that is not type-safe; for example, in C, programmers can freely cast a value between any two types that have the same size, effectively subverting the type concept. Dynamic type checking and runtime type information[edit] See also: Dynamic programming language, Interpreted language, and Category:Dynamically typed programming languages Dynamic type checking is the process of verifying the type safety of a program at runtime. Implementations of dynamically type-checked languages generally associate each runtime object with a type tag (i.e., a reference to a type) containing its type information. This runtime type information (RTTI) can also be used to implement dynamic dispatch, late binding, downcasting, reflective programming (reflection), and similar features. Most type-safe languages include some form of dynamic type checking, even if they also have a static type checker. The reason for this is that many useful features or properties are difficult or impossible to verify statically. For example, suppose that a program defines two types, A and B, where B is a subtype of A. If the program tries to convert a value of type A to type B, which is known as downcasting, then the operation is legal only if the value being converted is actually a value of type B. Thus, a dynamic check is needed to verify that the operation is safe. This requirement is one of the criticisms of downcasting. By definition, dynamic type checking may cause a program to fail at runtime. In some programming languages, it is possible to anticipate and recover from these failures. In others, type-checking errors are considered fatal. Programming languages that include dynamic type checking but not static type checking are often called \"dynamically typed programming languages\". Combining static and dynamic type checking[edit] Some languages allow both static and dynamic typing. For example, Java and some other ostensibly statically typed languages support downcasting types to their subtypes, querying an object to discover its dynamic type and other type operations that depend on runtime type information. Another example is C++ RTTI. More generally, most programming languages include mechanisms for dispatching over different 'kinds' of data, such as disjoint unions, runtime polymorphism, and variant types. Even when not interacting with type annotations or type checking, such mechanisms are materially similar to dynamic typing implementations. See programming language for more discussion of the interactions between static and dynamic typing. Objects in object-oriented languages are usually accessed by a reference whose static target type (or manifest type) is equal to either the object's run-time type (its latent type) or a supertype thereof. This is conformant with the Liskov substitution principle, which states that all operations performed on an instance of a given type can also be performed on an instance of a subtype. This concept is also known as subsumption or subtype polymorphism. In some languages subtypes may also possess covariant or contravariant return types and argument types respectively. Certain languages, for example Clojure, Common Lisp, or Cython are dynamically type checked by default, but allow programs to opt into static type checking by providing optional annotations. One reason to use such hints would be to optimize the performance of critical sections of a program. This is formalized by gradual typing. The programming environment DrRacket, a pedagogic environment based on Lisp, and a precursor of the language Racket is also soft-typed. Conversely, as of version 4.0, the C# language provides a way to indicate that a variable should not be statically type checked. A variable whose type is dynamic will not be subject to static type checking. Instead, the program relies on runtime type information to determine how the variable may be used.: 113–119 In Rust, the dyn std::any::Any type provides dynamic typing of 'static types. Static and dynamic type checking in practice[edit] The choice between static and dynamic typing requires certain trade-offs. Static typing can find type errors reliably at compile time, which increases the reliability of the delivered program. However, programmers disagree over how commonly type errors occur, resulting in further disagreements over the proportion of those bugs that are coded that would be caught by appropriately representing the designed types in code. Static typing advocates[who?] believe programs are more reliable when they have been well type-checked, whereas dynamic-typing advocates[who?] point to distributed code that has proven reliable and to small bug databases.[citation needed] The value of static typing increases as the strength of the type system is increased. Advocates of dependent typing,[who?] implemented in languages such as Dependent ML and Epigram, have suggested that almost all bugs can be considered type errors, if the types used in a program are properly declared by the programmer or correctly inferred by the compiler. Static typing usually results in compiled code that executes faster. When the compiler knows the exact data types that are in use (which is necessary for static verification, either through declaration or inference) it can produce optimized machine code. Some dynamically typed languages such as Common Lisp allow optional type declarations for optimization for this reason. By contrast, dynamic typing may allow compilers to run faster and interpreters to dynamically load new code, because changes to source code in dynamically typed languages may result in less checking to perform and less code to revisit.[clarification needed] This too may reduce the edit-compile-test-debug cycle. Statically typed languages that lack type inference (such as C and Java prior to version 10) require that programmers declare the types that a method or function must use. This can serve as added program documentation, that is active and dynamic, instead of static. This allows a compiler to prevent it from drifting out of synchrony, and from being ignored by programmers. However, a language can be statically typed without requiring type declarations (examples include Haskell, Scala, OCaml, F#, Swift, and to a lesser extent C# and C++), so explicit type declaration is not a necessary requirement for static typing in all languages. Dynamic typing allows constructs that some (simple) static type checking would reject as illegal. For example, eval functions, which execute arbitrary data as code, become possible. An eval function is possible with static typing, but requires advanced uses of algebraic data types. Further, dynamic typing better accommodates transitional code and prototyping, such as allowing a placeholder data structure (mock object) to be transparently used in place of a full data structure (usually for the purposes of experimentation and testing). Dynamic typing typically allows duck typing (which enables easier code reuse). Many[specify] languages with static typing also feature duck typing or other mechanisms like generic programming that also enable easier code reuse. Dynamic typing typically makes metaprogramming easier to use. For example, C++ templates are typically more cumbersome to write than the equivalent Ruby or Python code since C++ has stronger rules regarding type definitions (for both functions and variables). This forces a developer to write more boilerplate code for a template than a Python developer would need to. More advanced run-time constructs such as metaclasses and introspection are often harder to use in statically typed languages. In some languages, such features may also be used e.g. to generate new types and behaviors on the fly, based on run-time data. Such advanced constructs are often provided by dynamic programming languages; many of these are dynamically typed, although dynamic typing need not be related to dynamic programming languages. Strong and weak type systems[edit] Main article: Strong and weak typing Languages are often colloquially referred to as strongly typed or weakly typed. In fact, there is no universally accepted definition of what these terms mean. In general, there are more precise terms to represent the differences between type systems that lead people to call them \"strong\" or \"weak\". Type safety and memory safety[edit] Main articles: Type safety and Memory safety A third way of categorizing the type system of a programming language is by the safety of typed operations and conversions. Computer scientists use the term type-safe language to describe languages that do not allow operations or conversions that violate the rules of the type system. Computer scientists use the term memory-safe language (or just safe language) to describe languages that do not allow programs to access memory that has not been assigned for their use. For example, a memory-safe language will check array bounds, or else statically guarantee (i.e., at compile time before execution) that array accesses out of the array boundaries will cause compile-time and perhaps runtime errors. Consider the following program of a language that is both type-safe and memory-safe: var x := 5; var y := \"37\"; var z := x + y; In this example, the variable z will have the value 42. Although this may not be what the programmer anticipated, it is a well-defined result. If y were a different string, one that could not be converted to a number (e.g. \"Hello World\"), the result would be well-defined as well. Note that a program can be type-safe or memory-safe and still crash on an invalid operation. This is for languages where the type system is not sufficiently advanced to precisely specify the validity of operations on all possible operands. But if a program encounters an operation that is not type-safe, terminating the program is often the only option. Now consider a similar example in C: int x = 5; char y[] = \"37\"; char* z = x + y; printf(\"%c\\n\", *z); In this example z will point to a memory address five characters beyond y, equivalent to three characters after the terminating zero character of the string pointed to by y. This is memory that the program is not expected to access. In C terms this is simply undefined behaviour and the program may do anything; with a simple compiler it might actually print whatever byte is stored after the string \"37\". As this example shows, C is not memory-safe. As arbitrary data was assumed to be a character, it is also not a type-safe language. In general, type-safety and memory-safety go hand in hand. For example, a language that supports pointer arithmetic and number-to-pointer conversions (like C) is neither memory-safe nor type-safe, because it allows arbitrary memory to be accessed as if it were valid memory of any type. Variable levels of type checking[edit] Some languages allow different levels of checking to apply to different regions of code. Examples include: The use strict directive in JavaScript and Perl applies stronger checking. The declare(strict_types=1) in PHP on a per-file basis allows only a variable of exact type of the type declaration will be accepted, or a TypeError will be thrown. The Option Strict On in VB.NET allows the compiler to require a conversion between objects. Additional tools such as lint and IBM Rational Purify can also be used to achieve a higher level of strictness. Optional type systems[edit] It has been proposed, chiefly by Gilad Bracha, that the choice of type system be made independent of choice of language; that a type system should be a module that can be plugged into a language as needed. He believes this is advantageous, because what he calls mandatory type systems make languages less expressive and code more fragile. The requirement that the type system does not affect the semantics of the language is difficult to fulfill. Optional typing is related to, but distinct from, gradual typing. While both typing disciplines can be used to perform static analysis of code (static typing), optional type systems do not enforce type safety at runtime (dynamic typing). Polymorphism and types[edit] Main article: Polymorphism (computer science) The term polymorphism refers to the ability of code (especially, functions or classes) to act on values of multiple types, or to the ability of different instances of the same data structure to contain elements of different types. Type systems that allow polymorphism generally do so in order to improve the potential for code re-use: in a language with polymorphism, programmers need only implement a data structure such as a list or an associative array once, rather than once for each type of element with which they plan to use it. For this reason computer scientists sometimes call the use of certain forms of polymorphism generic programming. The type-theoretic foundations of polymorphism are closely related to those of abstraction, modularity and (in some cases) subtyping. Specialized type systems[edit] Many type systems have been created that are specialized for use in certain environments with certain types of data, or for out-of-band static program analysis. Frequently, these are based on ideas from formal type theory and are only available as part of prototype research systems. The following table gives an overview over type theoretic concepts that are used in specialized type systems. The names M, N, O range over terms and the names σ , τ {\\displaystyle \\sigma ,\\tau } range over types. The following notation will be used: M : σ {\\displaystyle M:\\sigma } means that M {\\displaystyle M} has type σ {\\displaystyle \\sigma } ; M ( N ) {\\displaystyle M(N)} is that application of M {\\displaystyle M} on N {\\displaystyle N} ; τ [ α := σ ] {\\displaystyle \\tau [\\alpha :=\\sigma ]} (resp. τ [ x := N ] {\\displaystyle \\tau [x:=N]} ) describes the type which results from replacing all occurrences of the type variable α (resp. term variable x) in τ {\\displaystyle \\tau } by the type σ (resp. term N). Type notion Notation Meaning Function σ → τ {\\displaystyle \\sigma \\to \\tau } If M : σ → τ {\\displaystyle M:\\sigma \\to \\tau } and N : σ {\\displaystyle N:\\sigma } , then M ( N ) : τ {\\displaystyle M(N):\\tau } . Product σ × τ {\\displaystyle \\sigma \\times \\tau } If M : σ × τ {\\displaystyle M:\\sigma \\times \\tau } , then M = ( N , O ) {\\displaystyle M=(N,O)} is a pair s.t. N : σ {\\displaystyle N:\\sigma } and O : τ {\\displaystyle O:\\tau } . Sum σ + τ {\\displaystyle \\sigma +\\tau } If M : σ + τ {\\displaystyle M:\\sigma +\\tau } , then M = ι 1 ( N ) {\\displaystyle M=\\iota _{1}(N)} is the first injection s.t. N : σ {\\displaystyle N:\\sigma } , or M = ι 2 ( N ) {\\displaystyle M=\\iota _{2}(N)} is the second injection s.t. N : τ {\\displaystyle N:\\tau } . Intersection σ ∩ τ {\\displaystyle \\sigma \\cap \\tau } If M : σ ∩ τ {\\displaystyle M:\\sigma \\cap \\tau } , then M : σ {\\displaystyle M:\\sigma } and M : τ {\\displaystyle M:\\tau } . Union σ ∪ τ {\\displaystyle \\sigma \\cup \\tau } If M : σ ∪ τ {\\displaystyle M:\\sigma \\cup \\tau } , then M : σ {\\displaystyle M:\\sigma } or M : τ {\\displaystyle M:\\tau } . Record ⟨ x : τ ⟩ {\\displaystyle \\langle x:\\tau \\rangle } If M : ⟨ x : τ ⟩ {\\displaystyle M:\\langle x:\\tau \\rangle } , then M has a member x : τ {\\displaystyle x:\\tau } . Polymorphic ∀ α . τ {\\displaystyle \\forall {}\\alpha .\\tau } If M : ∀ α . τ {\\displaystyle M:\\forall {}\\alpha .\\tau } , then M : τ [ α := σ ] {\\displaystyle M:\\tau [\\alpha :=\\sigma ]} for any type σ. Existential ∃ α . τ {\\displaystyle \\exists {}\\alpha .\\tau } If M : ∃ α . τ {\\displaystyle M:\\exists {}\\alpha .\\tau } , then M : τ [ α := σ ] {\\displaystyle M:\\tau [\\alpha :=\\sigma ]} for some type σ. Recursive μ α . τ {\\displaystyle \\mu \\alpha .\\tau } If M : μ α . τ {\\displaystyle M:\\mu \\alpha .\\tau } , then M : τ [ α := μ α . τ ] {\\displaystyle M:\\tau [\\alpha :=\\mu \\alpha .\\tau ]} . Dependent function[a] ( x : σ ) → τ {\\displaystyle (x:\\sigma )\\to \\tau } If M : ( x : σ ) → τ {\\displaystyle M:(x:\\sigma )\\to \\tau } and N : σ {\\displaystyle N:\\sigma } , then M ( N ) : τ [ x := N ] {\\displaystyle M(N):\\tau [x:=N]} . Dependent pair[b] ( x : σ ) × τ {\\displaystyle (x:\\sigma )\\times \\tau } If M : ( x : σ ) × τ {\\displaystyle M:(x:\\sigma )\\times \\tau } , then M = ( N , O ) {\\displaystyle M=(N,O)} is a pair s.t. N : σ {\\displaystyle N:\\sigma } and O : τ [ x := N ] {\\displaystyle O:\\tau [x:=N]} . Dependent intersection ( x : σ ) ∩ τ {\\displaystyle (x:\\sigma )\\cap \\tau } If M : ( x : σ ) ∩ τ {\\displaystyle M:(x:\\sigma )\\cap \\tau } , then M : σ {\\displaystyle M:\\sigma } and M : τ [ x := M ] {\\displaystyle M:\\tau [x:=M]} . Familial intersection ⋂ x : σ τ {\\displaystyle \\bigcap _{x:\\sigma }\\tau } If M : ⋂ x : σ τ {\\textstyle M:\\bigcap _{x:\\sigma }\\tau } , then M : τ [ x := N ] {\\displaystyle M:\\tau [x:=N]} for any term N : σ {\\displaystyle N:\\sigma } . Familial union ⋃ x : σ τ {\\displaystyle \\bigcup _{x:\\sigma }\\tau } If M : ⋃ x : σ τ {\\textstyle M:\\bigcup _{x:\\sigma }\\tau } , then M : τ [ x := N ] {\\displaystyle M:\\tau [x:=N]} for some term N : σ {\\displaystyle N:\\sigma } . ^ Also referred to as dependent product type, since ( x : σ ) → τ = ∏ x : σ τ {\\textstyle (x:\\sigma )\\to \\tau =\\prod _{x:\\sigma }\\tau } . ^ Also referred to as dependent sum type, since ( x : σ ) × τ = ∑ x : σ τ {\\textstyle (x:\\sigma )\\times \\tau =\\sum _{x:\\sigma }\\tau } . Dependent types[edit] Main article: Dependent type Dependent types are based on the idea of using scalars or values to more precisely describe the type of some other value. For example, m a t r i x ( 3 , 3 ) {\\displaystyle \\mathrm {matrix} (3,3)} might be the type of a 3 × 3 {\\displaystyle 3\\times 3} matrix. We can then define typing rules such as the following rule for matrix multiplication: m a t r i x m u l t i p l y : m a t r i x ( k , m ) × m a t r i x ( m , n ) → m a t r i x ( k , n ) {\\displaystyle \\mathrm {matrix} _{\\mathrm {multiply} }:\\mathrm {matrix} (k,m)\\times \\mathrm {matrix} (m,n)\\to \\mathrm {matrix} (k,n)} where k, m, n are arbitrary positive integer values. A variant of ML called Dependent ML has been created based on this type system, but because type checking for conventional dependent types is undecidable, not all programs using them can be type-checked without some kind of limits. Dependent ML limits the sort of equality it can decide to Presburger arithmetic. Other languages such as Epigram make the value of all expressions in the language decidable so that type checking can be decidable. However, in general proof of decidability is undecidable, so many programs require hand-written annotations that may be very non-trivial. As this impedes the development process, many language implementations provide an easy way out in the form of an option to disable this condition. This, however, comes at the cost of making the type-checker run in an infinite loop when fed programs that do not type-check, causing the compilation to fail. Linear types[edit] Main article: Linear type Linear types, based on the theory of linear logic, and closely related to uniqueness types, are types assigned to values having the property that they have one and only one reference to them at all times. These are valuable for describing large immutable values such as files, strings, and so on, because any operation that simultaneously destroys a linear object and creates a similar object (such as str = str + \"a\") can be optimized \"under the hood\" into an in-place mutation. Normally this is not possible, as such mutations could cause side effects on parts of the program holding other references to the object, violating referential transparency. They are also used in the prototype operating system Singularity for interprocess communication, statically ensuring that processes cannot share objects in shared memory in order to prevent race conditions. The Clean language (a Haskell-like language) uses this type system in order to gain a lot of speed (compared to performing a deep copy) while remaining safe. Intersection types[edit] Main article: Intersection type Intersection types are types describing values that belong to both of two other given types with overlapping value sets. For example, in most implementations of C the signed char has range -128 to 127 and the unsigned char has range 0 to 255, so the intersection type of these two types would have range 0 to 127. Such an intersection type could be safely passed into functions expecting either signed or unsigned chars, because it is compatible with both types. Intersection types are useful for describing overloaded function types: for example, if \"int → int\" is the type of functions taking an integer argument and returning an integer, and \"float → float\" is the type of functions taking a float argument and returning a float, then the intersection of these two types can be used to describe functions that do one or the other, based on what type of input they are given. Such a function could be passed into another function expecting an \"int → int\" function safely; it simply would not use the \"float → float\" functionality. In a subclassing hierarchy, the intersection of a type and an ancestor type (such as its parent) is the most derived type. The intersection of sibling types is empty. The Forsythe language includes a general implementation of intersection types. A restricted form is refinement types. Union types[edit] Main article: Union type Union types are types describing values that belong to either of two types. For example, in C, the signed char has a -128 to 127 range, and the unsigned char has a 0 to 255 range, so the union of these two types would have an overall \"virtual\" range of -128 to 255 that may be used partially depending on which union member is accessed. Any function handling this union type would have to deal with integers in this complete range. More generally, the only valid operations on a union type are operations that are valid on both types being unioned. C's \"union\" concept is similar to union types, but is not typesafe, as it permits operations that are valid on either type, rather than both. Union types are important in program analysis, where they are used to represent symbolic values whose exact nature (e.g., value or type) is not known. In a subclassing hierarchy, the union of a type and an ancestor type (such as its parent) is the ancestor type. The union of sibling types is a subtype of their common ancestor (that is, all operations permitted on their common ancestor are permitted on the union type, but they may also have other valid operations in common). Existential types[edit] Main article: Existential quantifier Existential types are frequently used in connection with record types to represent modules and abstract data types, due to their ability to separate implementation from interface. For example, the type \"T = ∃X { a: X; f: (X → int); }\" describes a module interface that has a data member named a of type X and a function named f that takes a parameter of the same type X and returns an integer. This could be implemented in different ways; for example: intT = { a: int; f: (int → int); } floatT = { a: float; f: (float → int); } These types are both subtypes of the more general existential type T and correspond to concrete implementation types, so any value of one of these types is a value of type T. Given a value \"t\" of type \"T\", we know that \"t.f(t.a)\" is well-typed, regardless of what the abstract type X is. This gives flexibility for choosing types suited to a particular implementation, while clients that use only values of the interface type—the existential type—are isolated from these choices. In general it's impossible for the typechecker to infer which existential type a given module belongs to. In the above example intT { a: int; f: (int → int); } could also have the type ∃X { a: X; f: (int → int); }. The simplest solution is to annotate every module with its intended type, e.g.: intT = { a: int; f: (int → int); } as ∃X { a: X; f: (X → int); } Although abstract data types and modules had been implemented in programming languages for quite some time, it wasn't until 1988 that John C. Mitchell and Gordon Plotkin established the formal theory under the slogan: \"Abstract [data] types have existential type\". The theory is a second-order typed lambda calculus similar to System F, but with existential instead of universal quantification. Gradual typing[edit] Main article: Gradual typing In a type system with Gradual typing, variables may be assigned a type either at compile-time (which is static typing), or at run-time (which is dynamic typing). This allows software developers to choose either type paradigm as appropriate, from within a single language. Gradual typing uses a special type named dynamic to represent statically unknown types; gradual typing replaces the notion of type equality with a new relation called consistency that relates the dynamic type to every other type. The consistency relation is symmetric but not transitive. Explicit or implicit declaration and inference[edit] Further information: Type inference Many static type systems, such as those of C and Java, require type declarations: the programmer must explicitly associate each variable with a specific type. Others, such as Haskell's, perform type inference: the compiler draws conclusions about the types of variables based on how programmers use those variables. For example, given a function f(x, y) that adds x and y together, the compiler can infer that x and y must be numbers—since addition is only defined for numbers. Thus, any call to f elsewhere in the program that specifies a non-numeric type (such as a string or list) as an argument would signal an error. Numerical and string constants and expressions in code can and often do imply type in a particular context. For example, an expression 3.14 might imply a type of floating-point, while [1, 2, 3] might imply a list of integers—typically an array. Type inference is in general possible, if it is computable in the type system in question. Moreover, even if inference is not computable in general for a given type system, inference is often possible for a large subset of real-world programs. Haskell's type system, a version of Hindley–Milner, is a restriction of System Fω to so-called rank-1 polymorphic types, in which type inference is computable. Most Haskell compilers allow arbitrary-rank polymorphism as an extension, but this makes type inference not computable. (Type checking is decidable, however, and rank-1 programs still have type inference; higher rank polymorphic programs are rejected unless given explicit type annotations.) Decision problems[edit] Main article: Type theory § Decision problems A type system that assigns types to terms in type environments using typing rules is naturally associated with the decision problems of type checking, typability, and type inhabitation. Given a type environment Γ {\\displaystyle \\Gamma } , a term e {\\displaystyle e} , and a type τ {\\displaystyle \\tau } , decide whether the term e {\\displaystyle e} can be assigned the type τ {\\displaystyle \\tau } in the type environment. Given a term e {\\displaystyle e} , decide whether there exists a type environment Γ {\\displaystyle \\Gamma } and a type τ {\\displaystyle \\tau } such that the term e {\\displaystyle e} can be assigned the type τ {\\displaystyle \\tau } in the type environment Γ {\\displaystyle \\Gamma } . Given a type environment Γ {\\displaystyle \\Gamma } and a type τ {\\displaystyle \\tau } , decide whether there exists a term e {\\displaystyle e} that can be assigned the type τ {\\displaystyle \\tau } in the type environment. Unified type system[edit] Some languages like C# or Scala have a unified type system. This means that all C# types including primitive types inherit from a single root object. Every type in C# inherits from the Object class. Some languages, like Java and Raku, have a root type but also have primitive types that are not objects. Java provides wrapper object types that exist together with the primitive types so developers can use either the wrapper object types or the simpler non-object primitive types. Raku automatically converts primitive types to objects when their methods are accessed. Compatibility: equivalence and subtyping[edit] A type checker for a statically typed language must verify that the type of any expression is consistent with the type expected by the context in which that expression appears. For example, in an assignment statement of the form x := e, the inferred type of the expression e must be consistent with the declared or inferred type of the variable x. This notion of consistency, called compatibility, is specific to each programming language. If the type of e and the type of x are the same, and assignment is allowed for that type, then this is a valid expression. Thus, in the simplest type systems, the question of whether two types are compatible reduces to that of whether they are equal (or equivalent). Different languages, however, have different criteria for when two type expressions are understood to denote the same type. These different equational theories of types vary widely, two extreme cases being structural type systems, in which any two types that describe values with the same structure are equivalent, and nominative type systems, in which no two syntactically distinct type expressions denote the same type (i.e., types must have the same \"name\" in order to be equal). In languages with subtyping, the compatibility relation is more complex: If B is a subtype of A, then a value of type B can be used in a context where one of type A is expected (covariant), even if the reverse is not true. Like equivalence, the subtype relation is defined differently for each programming language, with many variations possible. The presence of parametric or ad hoc polymorphism in a language may also have implications for type compatibility. See also[edit] Computer programming portal Comparison of type systems Covariance and contravariance (computer science) Polymorphism in object-oriented programming Type signature Type theory Notes[edit] ^ The Burroughs ALGOL computer line determined a memory location's contents by its flag bits. Flag bits specify the contents of a memory location. Instruction, data type, and functions are specified by a 3 bit code in addition to its 48 bit contents. Only the MCP (Master Control Program) could write to the flag code bits. ^ For example, a leaky abstraction might surface during development, which may show that more type development is needed. —\"The evaluation of a well-typed program always terminates\".—B. Nordström, K. Petersson, and J. M. Smith A systematic change in variables to avoid capture of a free variable can introduce error, in a functional programming language where functions are first class citizens. —From the lambda calculus article. References[edit] ^ Pierce 2002, p. 1: \"A type system is a tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute.\" ^ Cardelli 2004, p. 1: \"The fundamental purpose of a type system is to prevent the occurrence of execution errors during the running of a program.\" ^ Pierce 2002, p. 208. ^ a b Sethi, R. (1996). Programming languages: Concepts and constructs (2nd ed.). Addison-Wesley. p. 142. ISBN 978-0-201-59065-4. OCLC 604732680. ^ Nordström, B.; Petersson, K.; Smith, J.M. (2001). \"Martin-Löf's Type Theory\". Algebraic and Logical Structures. Handbook of Logic in Computer Science. Vol. 5. Oxford University Press. p. 2. ISBN 978-0-19-154627-3. ^ Turner, D.A. (12 June 2012). \"Some History of Functional Programming Languages\" (PDF). invited lecture at TFP12, at St Andrews University. See the section on Algol 60. ^ \"... any sound, decidable type system must be incomplete\" —D. Remy (2017). p. 29, Remy, Didier. \"Type systems for programming languages\" (PDF). Archived from the original (PDF) on 14 November 2017. Retrieved 26 May 2013. ^ Pierce 2002. ^ a b c Skeet, Jon (2019). C# in Depth (4 ed.). Manning. ISBN 978-1617294532. ^ Miglani, Gaurav (2018). \"Dynamic Method Dispatch or Runtime Polymorphism in Java\". Archived from the original on 2020-12-07. Retrieved 2021-03-28. ^ Wright, Andrew K. (1995). Practical Soft Typing (PhD). Rice University. hdl:1911/16900. ^ \"dynamic (C# Reference)\". MSDN Library. Microsoft. Retrieved 14 January 2014. ^ \"std::any — Rust\". doc.rust-lang.org. Retrieved 2021-07-07. ^ Meijer, Erik; Drayton, Peter. \"Static Typing Where Possible, Dynamic Typing When Needed: The End of the Cold War Between Programming Languages\" (PDF). Microsoft Corporation. ^ Laucher, Amanda; Snively, Paul (2012). \"Types vs Tests\". InfoQ. ^ Xi, Hongwei (1998). Dependent Types in Practical Programming (PhD). Department of Mathematical Sciences, Carnegie Mellon University. CiteSeerX 10.1.1.41.548.Xi, Hongwei; Pfenning, Frank (1999). \"Dependent Types in Practical Programming\". Proceedings of the 26th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. ACM. pp. 214–227. CiteSeerX 10.1.1.69.2042. doi:10.1145/292540.292560. ISBN 1581130953. S2CID 245490. ^ Visual Basic is an example of a language that is both type-safe and memory-safe. ^ \"4.2.2 The Strict Variant of ECMAScript\". ECMAScript® 2020 Language Specification (11th ed.). ECMA. June 2020. ECMA-262. ^ \"Strict mode – JavaScript\". MDN. Developer.mozilla.org. 2013-07-03. Retrieved 2013-07-17. ^ \"Strict Mode (JavaScript)\". MSDN. Microsoft. Retrieved 2013-07-17. ^ \"Strict typing\". PHP Manual: Language Reference: Functions. ^ a b Bracha, G. \"Pluggable Types\" (PDF). ^ \"Sure. It's called \"gradual typing\", and I would qualify it as trendy. ...\" Is there a language that allows both static and dynamic typing?. stackoverflow. 2012. ^ a b c Kopylov, Alexei (2003). \"Dependent intersection: A new way of defining records in type theory\". 18th IEEE Symposium on Logic in Computer Science. LICS 2003. IEEE Computer Society. pp. 86–95. CiteSeerX 10.1.1.89.4223. doi:10.1109/LICS.2003.1210048. ^ Mitchell, John C.; Plotkin, Gordon D. (July 1988). \"Abstract Types Have Existential Type\" (PDF). ACM Trans. Program. Lang. Syst. 10 (3): 470–502. doi:10.1145/44501.45065. S2CID 1222153. ^ a b Siek, Jeremy (24 March 2014). \"What is gradual typing?\". ^ Siek, Jeremy; Taha, Walid (September 2006). Gradual Typing for Functional Languages (PDF). Scheme and Functional Programming 2006. University of Chicago. pp. 81–92. ^ Barendregt, Henk; Dekkers, Wil; Statman, Richard (20 June 2013). Lambda Calculus with Types. Cambridge University Press. p. 66. ISBN 978-0-521-76614-2. ^ \"8.2.4 Type system unification\". C# Language Specification (5th ed.). ECMA. December 2017. ECMA-334. ^ \"Native Types\". Perl 6 Documentation. ^ \"Numerics, § Auto-boxing\". Perl 6 Documentation. Further reading[edit] Cardelli, Luca; Wegner, Peter (December 1985). \"On Understanding Types, Data Abstraction, and Polymorphism\" (PDF). ACM Computing Surveys. 17 (4): 471–523. CiteSeerX 10.1.1.117.695. doi:10.1145/6041.6042. S2CID 2921816. Pierce, Benjamin C. (2002). Types and Programming Languages. MIT Press. ISBN 978-0-262-16209-8. Cardelli, Luca (2004). \"Type systems\" (PDF). In Allen B. Tucker (ed.). CRC Handbook of Computer Science and Engineering (2nd ed.). CRC Press. ISBN 978-1584883609. Tratt, Laurence (July 2009). \"5. Dynamically Typed Languages\". Advances in Computers. Vol. 77. Elsevier. pp. 149–184. doi:10.1016/S0065-2458(09)01205-4. ISBN 978-0-12-374812-6. External links[edit] The Wikibook Ada Programming has a page on the topic of: Types The Wikibook Haskell has a page on the topic of: Class declarations Media related to Type systems at Wikimedia Commons Smith, Chris (2011). \"What to Know Before Debating Type Systems\". vteData typesUninterpreted Bit Byte Trit Tryte Word Bit array Numeric Arbitrary-precision or bignum Complex Decimal Fixed point Floating point Reduced precision Minifloat Half precision bfloat16 Single precision Double precision Quadruple precision Octuple precision Extended precision Long double Integer signedness Interval Rational Pointer Address physical virtual Reference Text Character String null-terminated Composite Algebraic data type generalized Array Associative array Class Dependent Equality Inductive Intersection List Object metaobject Option type Product Record or Struct Refinement Set Union tagged Other Boolean Bottom type Collection Enumerated type Exception Function type Opaque data type Recursive data type Semaphore Stream Strongly typed identifier Top type Type class Empty type Unit type Void Relatedtopics Abstract data type Boxing Data structure Generic Kind metaclass Parametric polymorphism Primitive data type Interface Subtyping Type constructor Type conversion Type system Type theory Variable"
    },
    {
        "id": 22,
        "url": "https://en.wikipedia.org/wiki/Operating_system",
        "title": "Operating system",
        "content": ""
    },
    {
        "id": 23,
        "url": "https://en.wikipedia.org/wiki/Linux",
        "title": "Linux",
        "content": ""
    },
    {
        "id": 24,
        "url": "https://en.wikipedia.org/wiki/MacOS",
        "title": "macOS",
        "content": ""
    },
    {
        "id": 25,
        "url": "https://en.wikipedia.org/wiki/Windows",
        "title": "Microsoft Windows",
        "content": ""
    },
    {
        "id": 26,
        "url": "https://en.wikipedia.org/wiki/WebAssembly",
        "title": "WebAssembly",
        "content": "Assembly language and bytecode for web browsers WebAssemblyParadigmstructured; stack machineDesigned byW3CDeveloperW3CMozillaMicrosoftGoogleAppleFirst appearedMarch 2017; 7 years ago (2017-03)OSPlatform independentLicenseApache License 2.0Filename extensions.wat (text format).wasm (binary format)Websitewebassembly.orgInfluenced byasm.jsPNaClLisp WebAssembly (Wasm) defines a portable binary-code format and a corresponding text format for executable programs as well as software interfaces for facilitating communication between such programs and their host environment. The main goal of WebAssembly is to facilitate high-performance applications on web pages, but it is also designed to be usable in non-web environments. It is an open standard intended to support any language on any operating system, and in practice many of the most popular languages already have at least some level of support. Announced in 2015 (2015) and first released in March 2017 (2017-03), WebAssembly became a World Wide Web Consortium recommendation on 5 December 2019 and it received the Programming Languages Software Award from ACM SIGPLAN in 2021. The World Wide Web Consortium (W3C) maintains the standard with contributions from Mozilla, Microsoft, Google, Apple, Fastly, Intel, and Red Hat. History[edit] The name WebAssembly is intended to seem synonymous with that of the assembly language. The name suggests bringing assembly-like programming to the Web, where it will be executed client-side — by the website-user's computer via the user's web browser. To accomplish this, WebAssembly must be much more hardware-independent than a true assembly language. WebAssembly was first announced in 2015, and the first demonstration was executing Unity's Angry Bots in Firefox, Google Chrome, and Microsoft Edge [Legacy]. The precursor technologies were asm.js from Mozilla and Google Native Client, and the initial implementation was based on the feature set of asm.js.[note 1] In March 2017, the design of the minimum viable product (MVP) was declared to be finished and the preview phase ended. In late September 2017, Safari 11 was released with support. In February 2018, the WebAssembly Working Group published three public working drafts for the Core Specification, JavaScript Interface, and Web API. In June 2019, Chrome 75 was released with WebAssembly threads enabled by default. Since April 2022,[update] WebAssembly 2.0 has been in draft status, which added many SIMD-related instructions and a new v128 datatype, with the ability for functions to return multiple values, and mass memory initialize/copy. Implementations[edit] While WebAssembly was initially designed to permit near-native code execution speed in the web browser, it has been considered valuable outside of such, in more generalized contexts. Since WebAssembly's runtime environments (RE) are low-level virtual stack machines (akin to JVM or Flash VM) that may be embedded into host applications, some implementations create standalone runtime environments like Wasmtime [Wikidata] and Wasmer [Wikidata]. WebAssembly runtime environments are embedded in application servers to host \"server-side\" WebAssembly applications and in other applications to support plug-in-based software extension architectures, e.g., \"WebAssembly for Proxies\" (proxy-wasm) which specifies a WebAssembly-based ABI for extending proxy servers. Web browsers[edit] In November 2017, Mozilla declared support \"in all major browsers\", after WebAssembly was enabled by default in Edge [Legacy] 16. This support also includes mobile web browsers for iOS and Android. As of March 2024,[update] 99% of tracked web browsers support WebAssembly (version 1.0), more than for its predecessor asm.js. For some extensions, from the 2.0 draft standard, support may be lower, but still more than 90% of web browsers may already support, e.g. the reference types extension. Compilers[edit] WebAssembly implementations usually use either ahead-of-time (AOT) or just-in-time (JIT) compilation, but may also use an interpreter. While the first implementations have landed in web browsers, there are also non-browser implementations for general-purpose use, including Wasmer, Wasmtime or WAMR, wasm3, WAVM, and many others. Because WebAssembly executables are precompiled, it is possible to use a variety of programming languages to make them. This is achieved either through direct compilation to Wasm, or through an implementation of their corresponding virtual machines in Wasm. Some 40 programming languages are reported to support Wasm as a compilation target. Emscripten compiles C and C++ to Wasm using Clang as a frontend, replacing LLVM as backend and using Binaryen [Wikidata] as an optimizer. The Emscripten SDK can compile any LLVM-supported languages (such as C, C++ or Rust, among others) source code into a binary file which runs in the same sandbox as JavaScript code.[note 2] Emscripten provides bindings for several commonly used environment interfaces like WebGL. As of version 8, a standalone Clang can compile C and C++ to Wasm. Its initial aim was to support compilation from C and C++, though support for other source languages such as Rust, .NET languages and AssemblyScript (TypeScript-like) is also emerging. After the MVP release, WebAssembly added support for multithreading and garbage collection (WasmGC, and web browsers including Safari have added support for it), which allowed more efficient compilation for garbage-collecting programming languages like C# (supported via Blazor), F# (supported via Bolero with help of Blazor) and Python. A number of other languages have some support, including Python, Julia, Ruby and Ring. A number of systems can compile Java and other JVM languages to JavaScript and WebAssembly. These include CheerpJ, JWebAssembly and TeaVM. Kotlin supports WebAssembly directly. Limitations[edit] Web browsers do not permit WebAssembly code to directly manipulate the Document Object Model. Wasm code must defer to JavaScript for this.[note 3] In an October 2023 survey of developers, less than half of the 303 participants were satisfied with the state of WebAssembly. A large majority cited the need for improvement in four areas: WASI, debugging support, integration with JavaScript and browser APIs, and build tooling. For memory-intensive allocations in WebAssembly, there are \"grave limitations that make many applications infeasible to be reliably deployed on mobile browsers [..] Currently allocating more than ~300MB of memory is not reliable on Chrome on Android without resorting to Chrome-specific workarounds, nor in Safari on iOS.\" All major browsers allow WebAssembly if Content-Security-Policy is not specified, or if \"unsafe-eval\" is used, but behave differently otherwise. Chrome requires \"unsafe-eval\", though a worker thread can be a workaround. Security considerations[edit] In June 2018, a security researcher presented the possibility of using WebAssembly to circumvent browser mitigations for Spectre and Meltdown security vulnerabilities once support for threads with shared memory is added. Due to this concern, WebAssembly developers put the feature on hold. However, in order to explore these future language extensions, Google Chrome added experimental support for the WebAssembly thread proposal in October 2018. WebAssembly has been criticized for allowing greater ease of hiding the evidence for malware writers, scammers and phishing attackers; WebAssembly is present on the user's machine only in its compiled form, which \"[makes malware] detection difficult\". Speed and the easy ability to conceal in WebAssembly have led to its use in hidden crypto mining within the website visitor's device. Coinhive, a now defunct service facilitating cryptocurrency mining in website visitors' browsers, claims their \"miner uses WebAssembly and runs with about 65% of the performance of a native Miner.\" A June 2019 study from the Technische Universität Braunschweig analyzed the usage of WebAssembly in the Alexa top 1 million websites and found the prevalent use was for malicious crypto mining, and that malware accounted for more than half of the WebAssembly-using websites studied. An April 2021 study from Universität Stuttgart found that since then crypto mining has been marginalized, falling to below 1% of all WebAssembly modules gathered from a wide range of sources, also including the Alexa top 1 million websites. As WebAssembly supports only structured control flow, it is amenable toward security verification techniques including symbolic execution. Performance[edit] Benchmark results vary between implementations and between themselves. Performance was benchmarked early to be around 91% (i.e., 10% slower) for running code, not including load/instantiation time or more recently between 100% and 33% of native rates, and 120% of JavaScript (i.e. 20% faster).[note 4] A 2021 study suggested that WebAssembly, in the versions they tested at that time, was well faster than JavaScript in certain cases and browsers only, such as running a complex function on a small file, e.g. processing a graphics file, but that JavaScript had some optimizations available, e.g. JIT, that WebAssembly did not. Benchmarking has revealed several other pain-points for WebAssembly, such as poor performance because of no direct access to the DOM,[note 5] which are being addressed or may be addressed in the future. WASI[edit] WebAssembly System Interface (WASI) is a simple interface (ABI and API) designed by Mozilla intended to be portable to any platform. It provides POSIX-like features like file I/O constrained by capability-based security. There are additional proposed ABI/APIs. WASI is influenced by CloudABI and Capsicum.[according to whom?] Solomon Hykes [fr], a co-founder of Docker, wrote in 2019, \"If WASM+WASI existed in 2008, we wouldn't have needed to create Docker. That's how important it is. WebAssembly on the server is the future of computing.\" Specification[edit] Host environment[edit] The general standard provides core specifications for the JavaScript API and details on embedding. Virtual machine[edit] Wasm code (binary code, i.e. bytecode) is intended to be run on a portable virtual stack machine (VM). The VM is designed to be faster to parse and execute than JavaScript and to have compact code representation. Any external functionality (like syscalls) that may be expected by Wasm binary code is not stipulated by the standard. It rather provides a way to deliver interfacing via modules by the host environment that the VM runs in. Wasm program[edit] A Wasm program is designed as a separate module containing collections of various Wasm-defined values and program type definitions. These are provided in either binary or textual format (see below) that have a common structure. Such a module may provide a start function that is executed upon instantiation of a wasm binary. Instruction set[edit] The core standard for the binary format of a Wasm program defines an instruction set architecture (ISA) consisting of specific binary encodings of types of operations which are executed by the VM (without specifying how exactly they must be executed). The list of instructions includes standard memory load/store instructions, numeric, parametric, control of flow instruction types and Wasm-specific variable instructions. The number of opcodes used in the original standard (MVP) was a bit fewer than 200 of the 256 possible opcodes. Subsequent versions of WebAssembly pushed the number of opcodes a bit over 200. The WebAssembly SIMD proposal (for parallel processing) introduces an alternate opcode prefix (0xfd) for 128-bit SIMD. The concatenation of the SIMD prefix, plus an opcode that is valid after the SIMD prefix, forms a SIMD opcode. The SIMD opcodes bring an additional 236 instructions for the \"minimum viable product\" (MVP) SIMD capability (for a total of around 436 instructions). Those instructions, the \"finalized opcodes\" are enabled by default across Google's V8 (in Google Chrome), the SpiderMonkey engine in Mozilla Firefox, and the JavaScriptCore engine in Apple's Safari and there are also some additional proposal for instructions for later \"post SIMD MVP\", and there's also a separate \"relaxed-simd\" proposal on the table. These SIMD opcodes are also portable and translate to native instruction sets like x64 and ARM. In contrast, neither Java's JVM nor CIL support SIMD, at their opcode level, i.e. in the standard; both do have some parallel APIs which provide SIMD speedup. There is an extension for Java adding intrinsics for x64 SIMD, that isn't portable, i.e. not usable on ARM or smartphones. Smartphones can support SIMD by calling assembly code with SIMD, and C# has similar support. Code representation[edit] In March 2017, the WebAssembly Community Group reached consensus on the initial (MVP) binary format, JavaScript API, and reference interpreter. It defines a WebAssembly binary format (.wasm), which is not designed to be used by humans, as well as a human-readable WebAssembly text format (.wat) that resembles a cross between S-expressions and traditional assembly languages. The table below shows an example of a factorial function written in C and its corresponding WebAssembly code after compilation, shown both in .wat text format (a human-readable textual representation of WebAssembly) and in .wasm binary format (the raw bytecode, expressed below in hexadecimal), that is executed by a Web browser or run-time environment that supports WebAssembly. C source code and corresponding WebAssembly C source code WebAssembly .wat text format WebAssembly .wasm binary format int factorial(int n) { if (n == 0) return 1; else return n * factorial(n-1); } (func (param i64) (result i64) local.get 0 i64.eqz if (result i64) i64.const 1 else local.get 0 local.get 0 i64.const 1 i64.sub call 0 i64.mul end) 00 61 73 6D 01 00 00 00 01 06 01 60 01 7E 01 7E 03 02 01 00 0A 17 01 15 00 20 00 50 04 7E 42 01 05 20 00 20 00 42 01 7D 10 00 7E 0B 0B All integer constants are encoded using a space-efficient, variable-length LEB128 encoding. The WebAssembly text format is more canonically written in a folded format using S-expressions. For instructions and expressions, this format is purely syntactic sugar and has no behavioral differences with the linear format. Through wasm2wat, the code above decompiles to: (module (type $t0 (func (param i64) (result i64))) (func $f0 (type $t0) (param $p0 i64) (result i64) (if $I0 (result i64) ;; $I0 is an unused label name (i64.eqz (local.get $p0)) ;; the name $p0 is the same as 0 here (then (i64.const 1)) (else (i64.mul (local.get $p0) (call $f0 ;; the name $f0 is the same as 0 here (i64.sub (local.get $p0) (i64.const 1)))))))) A module is implicitly generated by the compiler. The function is referenced by an entry of the type table in the binary, hence a type section and the type emitted by the decompiler. The compiler and decompiler can be accessed online. See also[edit] Architecture Neutral Distribution Format (ANDF) UNCOL Java bytecode Common Language Runtime LLVM Compilation Software portability Notes[edit] ^ The asm.js file already provides near-native code execution speeds: \"Even discarding the one score where asm.js did better, it executes at around 70% of the speed (i.e. slower) of native C++ code. and can be considered a viable alternative for browsers that do not support WebAssembly or have it disabled for security reasons. ^ According to official documentation, the Emscripten SDK may be used to create .wasm files which then may be executed in a web browser. Even though Emscripten can consume various languages when using Clang, some problems may arise. ^ For Rust/Wasm development, third-party libraries can provide some of the necessary JavaScript I/O. ^ A personal web page of 2024 reported a benchmark of a simple game application on a mobile phone found between 110% and 190% (i.e. faster) of native rates depending on the browser. ^ \"WebAssembly provides no access to the surrounding environment other than via the JavaScript API described in the JS API specification.\" References[edit] ^ \"WebAssembly/design/Semantics.md\". GitHub. Retrieved 23 February 2021. WebAssembly code can be considered a structured stack machine; a machine where most computations use a stack of values, but control flow is expressed in structured constructs such as blocks, ifs, and loops. In practice, implementations need not maintain an actual value stack, nor actual data structures for control; they need only behave as if they did so. ^ Mozilla. \"Understanding WebAssembly text format\". MDN Web Docs. Retrieved 9 December 2019. ^ \"Introduction — WebAssembly 1.0\". webassembly.github.io. Retrieved 18 June 2019. WebAssembly is an open standard... ^ \"Introduction — WebAssembly 1.0\". webassembly.github.io. Retrieved 18 June 2019. WebAssembly is a ... code format ^ a b \"Conventions — WebAssembly 1.0\". webassembly.github.io. Retrieved 17 May 2019. WebAssembly is a programming language that has multiple concrete representations (its binary format and the text format). Both map to a common structure. ^ \"Introduction — WebAssembly 1.0\". webassembly.github.io. Retrieved 18 June 2019. ... this specification is complemented by additional documents defining interfaces to specific embedding environments such as the Web. These will each define a WebAssembly application programming interface (API) suitable for a given environment. ^ \"Introduction — WebAssembly 1.1\". webassembly.github.io. Retrieved 19 February 2021. Its main goal is to enable high performance applications on the Web, but it does not make any Web-specific assumptions or provide Web-specific features, so it can be employed in other environments as well. ^ Haas, Andreas; Rossberg, Andreas; Schuff, Derek L.; Titzer, Ben L.; Holman, Michael; Gohman, Dan; Wagner, Luke; Zakai, Alon; Bastien, JF (14 June 2017). \"Bringing the Web Up to Speed with WebAssembly\". SIGPLAN Notices. 52 (6): 185–200. doi:10.1145/3140587.3062363. ISSN 0362-1340. While the Web is the primary motivation for WebAssembly, nothing in its design depends on the Web or a JavaScript environment. It is an open standard specifically designed for embedding in multiple contexts, and we expect that stand-alone implementations will become available in the future. ^ a b c \"Outside the web: standalone WebAssembly binaries using Emscripten · V8\". v8.dev. Retrieved 28 July 2020. ^ a b c \"Wasmer - The Universal WebAssembly Runtime\". wasmer.io. Retrieved 19 February 2021. Compile everything to WebAssembly. Run it on any OS or embed it into other languages. ^ World Wide Web Consortium. \"WebAssembly Core Specification\". World Wide Web Consortium (W3). Retrieved 9 December 2019. ^ Couriol, Bruno. \"WebAssembly 1.0 Becomes a W3C Recommendation and the Fourth Language to Run Natively in Browsers\". infoq.com. Retrieved 9 December 2019. ^ \"WebAssembly Specification — WebAssembly 1.1\". webassembly.github.io. Retrieved 22 March 2021. ^ \"Programming Languages Software Award\". www.sigplan.org. ^ Bright, Peter (18 June 2015). \"The Web is getting its bytecode: WebAssembly\". Ars Technica. Condé Nast. ^ a b \"New Bytecode Alliance Brings the Security, Ubiquity, and Interoperability of the Web to the World of Pervasive Computing\". Mozilla. 12 November 2019. Retrieved 27 May 2019. ^ \"Launch bug\". GitHub / WebAssembly / design. 11 June 2015. ^ Wagner, Luke (14 March 2016). \"A WebAssembly Milestone: Experimental Support in Multiple Browsers\". Mozilla Hacks. ^ Thompson, Seth (15 March 2016). \"Experimental support for WebAssembly in V8\". V8 Blog. ^ Zhu, Limin (15 March 2016). \"Previewing WebAssembly experiments in Microsoft Edge\". Microsoft Edge dev blog. ^ Lardinois, Frederic (17 June 2015). \"Google, Microsoft, Mozilla And Others Team Up To Launch WebAssembly, A New Binary Format For The Web\". TechCrunch. Retrieved 24 December 2017. ^ Avram, Abel (31 May 2017). \"Google Is to Remove Support for PNaCl\". InfoQ. Retrieved 22 December 2017. ^ \"WebAssembly: a binary format for the web\". ②ality – JavaScript and more. 18 June 2015. ^ \"Staring at the Sun: Dalvik vs. ASM.js vs. Native\". blog.mozilla.org. August 2013. Retrieved 7 December 2019. ^ a b Krill, Paul (6 March 2017). \"WebAssembly is now ready for browsers to use\". InfoWorld. Retrieved 23 December 2017. ^ \"WebAssembly First Public Working Drafts\". W3C. 15 February 2018. Retrieved 20 April 2018. ^ \"WebAssembly Core Specification\". W3C. 15 February 2018. Retrieved 20 April 2018. ^ \"WebAssembly JavaScript Interface\". W3C. 15 February 2018. Retrieved 20 April 2018. ^ \"WebAssembly Web API\". W3C. 15 February 2018. Retrieved 20 April 2018. ^ \"WebAssembly Worker Based Threads - Chrome Platform Status\". chromestatus.com. Retrieved 19 February 2022. ^ \"WebAssembly Specification — WebAssembly 2.0 (Draft 2022-09-01)\". webassembly.github.io. Retrieved 9 September 2022. ^ \"WebAssembly 2.0 First Public Working Drafts | W3C News\". 19 April 2022. Retrieved 9 September 2022. ^ \"Non-Web Embeddings\". WebAssembly. Retrieved 15 May 2019. ^ \"Non-Web Embeddings\". GitHub / WebAssembly. Retrieved 15 May 2019. ^ Freese, Danny (October 3, 2023). \"Proxy-Wasm: It's WebAssembly for Proxies\". Blog. Kong. Retrieved 2024-05-06. ^ \"proxy-wasm/spec: WebAssembly for Proxies (ABI specification)\". GitHub. Retrieved 6 May 2024. ^ \"WebAssembly support now shipping in all major browsers\". The Mozilla Blog. Retrieved 21 November 2017. ^ \"Introducing new JavaScript optimizations, WebAssembly, SharedArrayBuffer, and Atomics in EdgeHTML 16\". Microsoft Edge Dev Blog. 31 October 2017. Retrieved 21 November 2017. ^ \"WebAssembly | Can I use... Support tables for HTML5, CSS3, etc\". canIuse.com. Retrieved 1 March 2024. ^ \"asm.js | Can I use... Support tables for HTML5, CSS3, etc\". caniuse.com. Retrieved 29 September 2024. ^ \"WebAssembly Reference Types | Can I use... Support tables for HTML5, CSS3, etc\". caniuse.com. Retrieved 3 March 2024. ^ \"Wasmtime — a small and efficient runtime for WebAssembly & WASI\". wasmtime.dev. Retrieved 18 December 2020. ^ \"Roadmap\". Retrieved 7 December 2021. ^ Ball, Kevin (26 June 2018). \"How WebAssembly is Accelerating the Future of Web Development\". Archived from the original on 12 February 2019. Retrieved 22 October 2018. ^ a b \"Awesome WebAssembly Languages\". GitHub. 26 June 2018. Retrieved 15 February 2022. ^ Zakai, Alon [@kripken] (21 October 2019). \"Emscripten has switched to the upstream LLVM wasm backend by default! / Details:https://groups.google.com/forum/#!topic/emscripten-discuss/NpxVAOirSl4\" (Tweet). Retrieved 22 October 2019 – via Twitter. ^ \"Developer's Guide - WebAssembly\". webassembly.org. Retrieved 10 June 2019. ^ \"Compiling a New C/C++ Module to WebAssembly\". MDN Web Docs. Retrieved 10 June 2019. ^ \"Building to WebAssembly — Emscripten 1.38.33 documentation\". emscripten.org. Retrieved 10 June 2019. ^ \"Emscripting a C library to Wasm | Web\". Google Developers. Retrieved 10 June 2019. ^ \"LLVM 8.0.0 Release Notes — LLVM 8 documentation\". releases.llvm.org. Retrieved 22 October 2019. ^ a b \"WebAssembly High-Level Goals\". GitHub / WebAssembly / design. 11 December 2015. ^ Krill, Paul (29 November 2017). \"Direct WebAssembly compilation comes to Rust language\". InfoWorld. Retrieved 24 December 2017. ^ \"Frequently asked questions (FAQ) about Blazor\". blazor.net. Retrieved 18 June 2018. ^ \"AssemblyScript/assemblyscript\". The AssemblyScript Project. 9 September 2020. Retrieved 9 September 2020. ^ \"WebAssembly Garbage Collection (WasmGC) now enabled by default in Chrome | Blog\". Chrome for Developers. Retrieved 11 December 2023. ^ \"Bolero: F# in WebAssembly\". fsbolero.io. Retrieved 25 July 2019. ^ \"A new way to bring garbage collected programming languages efficiently to WebAssembly · V8\". v8.dev. Retrieved 11 December 2023. ^ \"Pyodide: Bringing the scientific Python stack to the browser – Mozilla Hacks - the Web developer blog\". Mozilla Hacks – the Web developer blog. Retrieved 9 September 2020. ^ \"Julia in the Browser\". nextjournal.com. Retrieved 9 April 2019. ^ \"WebAssembly platform by tshort · Pull Request #2 · JuliaPackaging/Yggdrasil\". GitHub. Retrieved 9 April 2019. ^ Fischer, Keno (22 July 2019). \"GitHub - Keno/julia-wasm: Running julia on wasm\". GitHub. Retrieved 25 July 2019. ^ \"MRuby in Your Browser\". ruby.dj. Retrieved 25 July 2019. ^ Paul Krill (24 August 2020). \"Ring language upgrade focuses on WebAssembly\". InfoWorld. ^ \"Ring in web browser\". Retrieved 17 August 2024. ^ \"Java to WebAssembly Compiler - CheerpJ\". Retrieved 27 April 2023. ^ \"JWebAssembly\". 27 April 2023 – via GitHub. ^ \"TeaVM — Overview\". www.teavm.org. Retrieved 27 April 2023. ^ \"Bringing Kotlin to the Web\". Retrieved 11 December 2023. ^ Deleuze, Sébastien (13 February 2023). \"The huge potential of Kotlin/Wasm\". seb.deleuze.fr. Retrieved 11 December 2023. ^ \"stdweb - Rust\". docs.rs. Retrieved 5 June 2019. The goal of this crate is to provide Rust bindings to the Web APIs and to allow a high degree of interoperability between Rust and JavaScript. ^ \"web_sys - Rust\". docs.rs. Retrieved 5 June 2019. Raw API bindings for Web APIs. This is a procedurally generated crate from browser WebIDL which provides a binding to all APIs that browser provide on the web. ^ \"The State of WebAssembly 2023\". Scott Logic. 18 October 2023. Retrieved 14 March 2024. ^ \"Wasm needs a better memory management story · Issue #1397 · WebAssembly/design\". GitHub. Retrieved 15 February 2021. ^ \"WebAssembly/content-security-policy\". GitHub. Retrieved 17 February 2021. ^ \"948834 - chromium - An open-source project to help move the web forward. - Monorail\". bugs.chromium.org. Retrieved 17 February 2021. ^ a b \"No way to use WebAssembly on Chrome without 'unsafe-eval' · Issue #7 · WebAssembly/content-security-policy\". GitHub. Retrieved 17 February 2021. ^ a b c Neumann, Robert; Toro, Abel (19 April 2018). \"In-browser mining: Coinhive and WebAssembly\". Forcepoint. Retrieved 8 June 2019. ^ Cimpanu, Catalin (24 June 2018). \"Changes in WebAssembly Could Render Meltdown and Spectre Browser Patches Useless\". Bleeping Computer. Retrieved 8 June 2019. ^ Sanders, James (25 June 2018). \"How opaque WebAssembly code could increase the risk of Spectre attacks online\". Tech Republic. Retrieved 9 June 2019. ^ R, Bhagyashree (30 October 2018). \"Google Chrome 70 now supports WebAssembly threads to build multi-threaded web applications\". Packt Pub. Retrieved 9 June 2019. ^ a b Lonkar, Aishwarya; Chandrayan, Siddhesh (October 2018). \"The dark side of WebAssembly\". Virus Bulletin. Retrieved 8 June 2019. ^ Segura, Jérôme (29 November 2017). \"Persistent drive-by cryptomining coming to a browser near you\". Malwarebytes. Retrieved 8 June 2019. ^ \"Recent Study Estimates That 50% of Websites Using WebAssembly Apply It for Malicious Purposes\". InfoQ. Retrieved 3 November 2019. ^ Musch, Marius; Wressnegger, Christian; Johns, Martin; Rieck, Konrad (June 2019). \"New Kid on the Web: A Study on the Prevalence of WebAssembly in the Wild\". Detection of Intrusions and Malware, and Vulnerability Assessment (PDF). Lecture Notes in Computer Science. Vol. 11543. Detection of Intrusions and Malware, and Vulnerability Assessment. pp. 23–42. doi:10.1007/978-3-030-22038-9_2. ISBN 978-3-030-22037-2. S2CID 184482682. Archived from the original (PDF) on 26 July 2022. Retrieved 15 February 2022. Slides (PDF) Archived 3 November 2019 at the Wayback Machine ^ Aaron Hilbig, Daniel Lehmann, and Michael Pradel (April 2021). \"An Empirical Study of Real-World WebAssembly Binaries: Security, Languages, Use Cases.\" (Archived April 2021) https://software-lab.org/publications/www2021.pdf ^ Watt, Conrad (8 January 2018). \"Mechanising and verifying the WebAssembly specification\". Proceedings of the 7th ACM SIGPLAN International Conference on Certified Programs and Proofs. CPP 2018. Los Angeles CA USA: ACM. pp. 53–65. doi:10.1145/3167082. ISBN 978-1-4503-5586-5. S2CID 9401691. ^ Arjun, Jangda, Abhinav Powers, Bobby Berger, Emery Guha (25 January 2019). Not So Fast: Analyzing the Performance of WebAssembly vs. Native Code. OCLC 1106328738.{{cite book}}: CS1 maint: multiple names: authors list (link) ^ Denis, Frank. \"Performance of WebAssembly runtimes in 2023\". 00f.net. Retrieved 6 December 2024. ^ De Macedo, Joao; Abreu, Rui; Pereira, Rui; Saraiva, Joao (June 2022). \"WebAssembly versus JavaScript: Energy and Runtime Performance\". 2022 International Conference on ICT for Sustainability (ICT4S). pp. 24–34. doi:10.1109/ICT4S55073.2022.00014. hdl:1822/90291. ISBN 978-1-6654-8286-8. ^ Turner, Aaron. \"WebAssembly Is Fast: A Real-World Benchmark of WebAssembly vs. ES6\". ^ Yan, Yutian; Tu, Tengfei; Zhao, Lijian; Zhou, Yuchen; Wang, Weihang (2 November 2021). \"Understanding the performance of webassembly applications\". Proceedings of the 21st ACM Internet Measurement Conference. pp. 533–549. doi:10.1145/3487552.3487827. ISBN 978-1-4503-9129-0. ^ \"WebAssembly Web API\". webassembly.github.io. ^ Kambale, Enoch. \"WebAssembly in 2024: Promises, Challenges, and the Road Ahead\". blog.enkambale.com. Retrieved 6 December 2024. ^ \"WebAssembly System Interface Repo\". GitHub / WebAssembly. 10 February 2020. ^ \"Additional background on Capabilities\". GitHub. bytecodealliance. 4 March 2022. ^ \"Standardizing WASI: A system interface to run WebAssembly outside the web – Mozilla Hacks - the Web developer blog\". Mozilla Hacks – the Web developer blog. ^ \"reference-sysroot Repo\". GitHub / WebAssembly. 12 January 2020. ^ \"wasm-c-api Repo\". GitHub / WebAssembly. 3 February 2020. ^ Hykes, Solomon (27 March 2019). \"Solomon Hykes on X\". Twitter. Retrieved 29 September 2024. ^ \"Design Rationale\". GitHub / WebAssembly / design. 1 October 2016. ^ \"Portability - WebAssembly\". webassembly.org. Retrieved 28 July 2020. ^ \"Conventions — WebAssembly 1.0\". webassembly.github.io. Retrieved 12 November 2019. ^ \"Introduction — WebAssembly 1.0\". webassembly.github.io. Retrieved 17 May 2019. ^ \"Instructions — WebAssembly 1.0\". webassembly.github.io. Retrieved 12 November 2019. ^ Lively, Thomas (19 February 2021) [Pull Request opened on 2021-02-05]. \"Final opcodes by tlively · Pull Request #452 · WebAssembly/simd · GitHub\". Bytecode Alliance. Retrieved 12 May 2021 – via GitHub. ^ Delendik, Yury (19 February 2021) [SIMD changes committed on 2021-02-19]. \"File wasm-tools/expr.rs at b5c3d98e40590512a3b12470ef358d5c7b983b15 · bytecodealliance/wasm-tools · GitHub\". Bytecode Alliance. Retrieved 12 May 2021 – via GitHub. ^ \"Update interpreter and text with finalized opcodes by ngzhian · Pull Request #486 · WebAssembly/simd\". GitHub. Retrieved 14 May 2021. ^ \"WebAssembly/simd\". GitHub. Retrieved 14 May 2021. ^ WebAssembly/relaxed-simd, WebAssembly, 3 May 2021, retrieved 14 May 2021 ^ \"How we made the JVM 40x faster\". astojanov.github.io. Retrieved 17 February 2021. ^ \"Roadmap\". WebAssembly. March 2017. ^ WebAssembly Community Group (January 2020). \"WebAssembly Specification Release 1.0\". Retrieved 13 January 2020. ^ \"Folded instructions\". GitHub. / WebAssembly / spec ^ \"Modules (Binary)\". WebAssembly 1.0. ^ \"WebAssembly Binary Toolkit (wabt) demos\". webassembly.github.io. This article incorporates text from a free content work. Licensed under Apache License 2.0 (license statement/permission). Text taken from Text Format​, jfbastien; rossberg-chromium; kripken; titzer; s3ththompson; sunfishcode; lukewagner; flagxor; enricobacis; c3d; binji; andrewosh, GitHub. WebAssembly/design. External links[edit] WebAssembly at Wikipedia's sister projects Media from CommonsData from Wikidata Official website W3C Community Group WebAssembly Specification WebAssembly Design Documents \"WebAssembly\", MDN Web Docs, 16 April 2024 – with info on browser compatibility and specifications (WebAssembly JavaScript API) vteWorld Wide Web Consortium (W3C)Products andstandardsRecommendations ActivityPub Activity Streams ARIA Canonical XML CDF CSS Animations Flexbox Grid DOM EXI EmotionML Geolocation API HTML HTML5 IndexedDB ITS JSON-LD Linked Data Notifications MathML Micropub OWL PLS RDF Schema RDFa SISR SKOS SMIL SOAP SRGS SRI SSML SVG Filter Effects SCXML SHACL SPARQL Timed text VoiceXML WebAssembly WoT TD Web storage WSDL Webmention WebSub WebVTT WOFF XHTML +RDFa XML Base Encryption Events Information Set Namespace Schema Signature XForms XInclude XLink XOP XPath 2.0 3.x XPointer XProc XQuery XSL XSL-FO XSLT elements Notes IndieAuth XAdES XBL XHTML+SMIL XUP Working drafts CCXML CURIE EME InkML MSE RIF SMIL Timesheets sXBL WebGPU WebXR XFDL XFrames XMLHttpRequest Guidelines Web Content Accessibility Guidelines Initiative Markup Validation Service Web Accessibility Initiative Web Components Deprecated C-HTML HDML JSSS PGML VML WebPlatform Obsoleted P3P XHTML+MathML+SVG Organizations World Wide Web Foundation WHATWG Elected groups AB Board TAG Working groups CSS SVG WebAssembly WebAuthn Community & business groups Web Advertising BG WebAssembly CG Closed groups Device Description (DDWG) HTML Multimodal Interaction Activity (MMI) Software CERN httpd Libwww Browsers Line Mode (1990–) Arena (1993–98) Agora (1994–97) Argo (1994–97) Amaya (browser/editor, 1996–2012) Conferences International World Wide Web Conference (IW3C) Steering Committee (IW3C2) First conference (\"WWW1\", 1994) vteWeb browsers Features standards protocols Features Bookmarks Extensions Privacy mode Web standards HTML v5 CSS DOM JavaScript WebAssembly Web storage IndexedDB WebGL WebGPU Protocols HTTP Encryption Cookies third-party OCSP WebRTC WebSocket ActiveBlink-basedProprietary Google Chrome Arc Avast Coc Coc Comodo Epic Maxthon Microsoft Edge Opera (Mobile) Puffin QQ Samsung Silk Sleipnir SRWare UC Vivaldi Whale Yandex FOSS Chromium Brave Dooble Falkon Otter Supermium ungoogled Gecko-based Firefox Floorp GNU IceCat LibreWolf Midori SlimBrowser Tor Zen Gecko forks Basilisk K-Meleon Pale Moon SeaMonkey Waterfox WebKit-based Safari GNOME Web iCab Orion Multi-engine 360 DuckDuckGo Konqueror Lunascape NetFront qutebrowser Other eww Flow Ladybird Links Lynx NetSurf Opera Mini w3m DiscontinuedBlink-based Beaker Citrio Flock Redcore Rockmelt SalamWeb Sputnik Torch Gecko-based Beonex Camino Classilla Conkeror Firefox Lite Galeon Ghostzilla IceDragon Kazehakase Kylo Lotus MicroB Minimo Mozilla suite PirateBrowser Pogo Strata Swiftfox Swiftweasel TenFourFox Timberwolf xB MSHTML-based Internet Explorer AOL Deepnet GreenBrowser MediaBrowser NeoPlanet NetCaptor SpaceTime ZAC WebKit-based Arora BOLT Dolphin Fluid Google TV Iris Mercury Nokia Symbian OmniWeb Opera Coast Origyn QtWeb Shiira Steel surf Uzbl WebPositive xombrero Other abaco Amaya Arachne Arena Blazer Cake Charon CM Deepfish Dillo Edge Legacy ELinks Gazelle HotJava IBM Home Page Reader IBM WebExplorer IBrowse Internet Explorer for Mac KidZui Line Mode Mosaic MSN TV NetPositive Netscape Skweezer Skyfire ThunderHawk Vision WinWAP WorldWideWeb Category Comparisons List vteWeb interfacesServer-sideProtocols HTTP v2 v3 Encryption WebDAV CGI SCGI FCGI AJP WSRP WebSocket Server APIs C NSAPI C ASAPI C ISAPI COM ASP Jakarta Servlet container CLI OWIN ASP.NET Handler Python WSGI Python ASGI Ruby Rack JavaScript JSGI Perl PSGI Portlet container Apache modules mod_include mod_jk mod_lisp mod_mono mod_parrot mod_perl mod_php mod_proxy mod_python mod_wsgi mod_ruby Phusion Passenger Topics Web service vs. Web resource WOA vs. ROA Open API Webhook Application server comparison Scripting Client-sideBrowser APIs C NPAPI LiveConnect XPConnect C NPRuntime C PPAPI NaCl ActiveX BHO XBAP Web APIsWHATWG Audio Canvas DOM SSE Video WebSockets Web messaging Web storage Web worker XMLHttpRequest W3C DOM events EME File Geolocation IndexedDB MSE SVG WebAssembly WebAuthn WebGPU WebRTC WebXR Khronos WebCL WebGL Others Gears Web SQL Database (formerly W3C) WebUSB Topics Ajax and Remote scripting vs. DHTML Browser extension Cross-site scripting and CORS Hydration Mashup Persistent data Web IDL Scripting Related topics Frontend and backend Microservices REST GraphQL Push technology Solution stack Web page Static Dynamic Web standards Web API security Web application Rich Single-page Progressive Web framework vteJavaScriptCode analysis ESLint JSHint JSLint Supersets JS++ TypeScript ArkTS Transpilers AtScript Babel ClojureScript CoffeeScript Dart Elm Emscripten Google Closure Compiler Google Web Toolkit Haxe LiveScript Morfik Nim Opa PureScript Reason WebSharper Concepts JavaScript library JavaScript syntax Debuggers Chrome DevTools Firefox Inspector Komodo IDE Microsoft Edge DevTools Opera DevTools Safari Web Inspector Doc generators JSDoc Editors (comparison) Ace Cloud9 IDE Atom CodeMirror Brackets Light Table PhpStorm Orion Visual Studio Visual Studio Express Visual Studio Code Visual Studio Team Services Vim Engines List of ECMAScript engines Frameworks Comparison of JavaScript frameworks List of JavaScript libraries Related technologies Ajax AssemblyScript asm.js Cascading Style Sheets Document Object Model HTML HTML5 JSON WebAssembly WebAuthn Package managers npm pnpm yarn Module bundlers Webpack Vite esbuild Server-side Active Server Pages Bun CommonJS Deno JSGI Node.js Unit testing frameworks (list) Jasmine Mocha QUnit People Douglas Crockford Ryan Dahl Brendan Eich John Resig"
    },
    {
        "id": 27,
        "url": "https://en.wikipedia.org/wiki/Android_(operating_system)",
        "title": "Android (operating system)",
        "content": ""
    },
    {
        "id": 28,
        "url": "https://en.wikipedia.org/wiki/IOS",
        "title": "iOS",
        "content": ""
    },
    {
        "id": 29,
        "url": "https://en.wikipedia.org/wiki/FreeBSD",
        "title": "FreeBSD",
        "content": "Free and open-source Unix-like operating system Not to be confused with OpenBSD. Not to be confused with NetBSD. Operating system FreeBSDFreeBSD 13.0 bootloader with ASCII art logoDeveloperThe FreeBSD ProjectWritten inC (C11)OS familyUnix-like (BSD)Working stateCurrentSource modelOpen sourceInitial release1 November 1993; 31 years ago (1993-11-01)Latest release14.2 (3 December 2024; 37 days ago (2024-12-03)) [±] 13.4 (17 September 2024; 3 months ago (2024-09-17)) [±]Repositorycgit.freebsd.org Marketing targetServers, workstations, embedded systems, network firewallsPackage managerpkgPlatformsIA-32, x86-64, ARM64, ARM32, PowerPC, RISC-VKernel typeMonolithic with dynamically loadable modulesUserlandBSDDefaultuser interfaceUnix shells: sh or tcsh (user-selectable)LicenseFreeBSD License, FreeBSD Documentation LicenseOfficial websitewww.freebsd.org FreeBSD is a free and open-source Unix-like operating system descended from the Berkeley Software Distribution (BSD) which currently runs on IA-32, x86-64, ARM, PowerPC and RISC-V based computers. The first version was released in 1993 developed from 386BSD—the first fully functional and free Unix clone—and has since continuously been the most commonly used BSD-derived operating system. FreeBSD maintains a complete system, delivering a kernel, device drivers, userland utilities, and documentation, as opposed to Linux only delivering a kernel and drivers, and relying on third-parties such as GNU for system software. The FreeBSD source code is generally released under a permissive BSD license, as opposed to the copyleft GPL used by Linux. The project includes a security team overseeing all software shipped in the base distribution. Third-party applications may be installed using the pkg package management system or from source via FreeBSD Ports. The project is supported and promoted by the FreeBSD Foundation. Much of FreeBSD's codebase has become an integral part of other operating systems such as Darwin (the basis for macOS, iOS, iPadOS, watchOS, and tvOS), TrueNAS (an open-source NAS/SAN operating system), and the system software for the PlayStation 3, PlayStation 4, PlayStation 5, PlayStation Vita and Nintendo Switch game consoles. The other current BSD systems (OpenBSD, NetBSD, and DragonFly BSD) also contain a large amount of FreeBSD code, and vice-versa.[citation needed] History[edit] Main article: FreeBSD version history Background[edit] In 1974, Professor Bob Fabry of the University of California, Berkeley, acquired a Unix source license from AT&T. Supported by funding from DARPA, the Computer Systems Research Group started to modify and improve AT&T Research Unix. The group called this modified version \"Berkeley Unix\" or \"Berkeley Software Distribution\" (BSD), implementing features such as TCP/IP, virtual memory, and the Berkeley Fast File System. The BSD project was founded in 1976 by Bill Joy. But since BSD contained code from AT&T Unix, all recipients had to first get a license from AT&T in order to use BSD. In June 1989, \"Networking Release 1\" or simply Net-1 – the first public version of BSD – was released. After releasing Net-1, Keith Bostic, a developer of BSD, suggested replacing all AT&T code with freely-redistributable code under the original BSD license. Work on replacing AT&T code began and, after 18 months, much of the AT&T code was replaced. However, six files containing AT&T code remained in the kernel. The BSD developers decided to release the \"Networking Release 2\" (Net-2) without those six files. Net-2 was released in 1991. Birth of FreeBSD[edit] In 1992, several months after the release of Net-2, William and Lynne Jolitz wrote replacements for the six AT&T files, ported BSD to Intel 80386-based microprocessors, and called their new operating system 386BSD. They released 386BSD via an anonymous FTP server. The development flow of 386BSD was slow, and after a period of neglect, a group of 386BSD users including Nate Williams, Rod Grimes and Jordan Hubbard decided to branch out on their own so that they could keep the operating system up to date. On 19 June 1993, the name FreeBSD was chosen for the project. The first version of FreeBSD was released in November 1993. In the early days of the project's inception, a company named Walnut Creek CDROM, upon the suggestion of the two FreeBSD developers, agreed to release the operating system on CD-ROM. In addition to that, the company employed Jordan Hubbard and David Greenman, ran FreeBSD on its servers, sponsored FreeBSD conferences and published FreeBSD-related books, including The Complete FreeBSD by Greg Lehey. By 1997, FreeBSD was Walnut Creek's \"most successful product\". The company later renamed itself to The FreeBSD Mall and later iXsystems. Today, FreeBSD is used by many IT companies such as IBM, Nokia, Juniper Networks, and NetApp to build their products. Certain parts of Apple's Mac OS X operating system are based on FreeBSD. Both the PlayStation 3 and Nintendo Switch operating system also borrow certain components from FreeBSD, while the PlayStation 4 operating system is derived from FreeBSD 9. Netflix, WhatsApp, and FlightAware are also examples of large, successful and heavily network-oriented companies which are running FreeBSD. Lawsuit[edit] 386BSD and FreeBSD were both derived from BSD releases. In January 1992, Berkeley Software Design Inc. (BSDi) started to release BSD/386, later called BSD/OS, an operating system similar to FreeBSD and based on 4.3BSD Net/2. AT&T filed a lawsuit against BSDi and alleged distribution of AT&T source code in violation of license agreements. The lawsuit was settled out of court and the exact terms were not all disclosed. The only one that became public was that BSDi would migrate its source base to the newer 4.4BSD-Lite2 sources. Although not involved in the litigation, it was suggested to FreeBSD that it should also move to 4.4BSD-Lite2. FreeBSD 2.0, which was released in November 1994, was the first version of FreeBSD without any code from AT&T. Features[edit] FreeBSD 14 console after login Use cases[edit] FreeBSD contains a significant collection of server-related software in the base system and the ports collection, allowing FreeBSD to be configured and used as a mail server, web server, firewall, FTP server, DNS server and a router, among other applications. FreeBSD can be installed on a regular desktop or a laptop. The X Window System is not installed by default, but is available in the FreeBSD ports collection. Though not officially supported,[citation needed] Wayland is also available for FreeBSD. A number of desktop environments such as Lumina, GNOME, KDE, and Xfce, as well as lightweight window managers such as Openbox, Fluxbox, dwm, and bspwm, are also available for FreeBSD. Major web browsers such as Firefox and Chromium are available unofficially on FreeBSD. As of FreeBSD 12, support for a modern graphics stack is available via drm-kmod. A large number of wireless adapters are supported. FreeBSD releases installation images for supported platforms. Since FreeBSD 13 the focus has been on x86-64 and aarch64 platforms which have Tier 1 support. IA-32 is a Tier 1 platform in FreeBSD 12 but is a Tier 2 platform in FreeBSD 13. 32 bit ARM processors using armv6 or armv7 also have Tier 2 support. 64 bit versions of PowerPC and RISC-V are also supported. Interest in the RISC-V architecture has been growing. The MIPS architecture port has been marked for deprecation and there is no image for any currently supported version. FreeBSD 12 supports SPARC but there is no image for FreeBSD 13. Networking[edit] FreeBSD's TCP/IP stack is based on the 4.2BSD implementation of TCP/IP which greatly contributed to the widespread adoption of these protocols. FreeBSD also supports IPv6, SCTP, IPSec, and wireless networking (Wi-Fi). The IPv6 and IPSec stacks were taken from the KAME project. Prior to version 11.0, FreeBSD supported IPX and AppleTalk protocols, but they are considered old and have now been dropped. As of FreeBSD 5.4, support for the Common Address Redundancy Protocol (CARP) was imported from the OpenBSD project. CARP allows multiple nodes to share a set of IP addresses, so if one of the nodes goes down, other nodes can still serve the requests. Storage[edit] FreeBSD has several unique features related to storage. Soft updates can protect the consistency of the UFS filesystem (widely used on the BSDs) in the event of a system crash. Filesystem snapshots allow an image of a UFS filesystem at an instant in time to be efficiently created. Snapshots allow reliable backup of a live filesystem. GEOM is a modular framework that provides RAID (levels 0, 1, 3 currently), full disk encryption, journaling, concatenation, caching, and access to network-backed storage. GEOM allows building of complex storage solutions combining (\"chaining\") these mechanisms. FreeBSD provides two frameworks for data encryption: GBDE and Geli. Both GBDE and Geli operate at the disk level. GBDE was written by Poul-Henning Kamp and is distributed under the two-clause BSD license. Geli is an alternative to GBDE that was written by Pawel Jakub Dawidek and first appeared in FreeBSD 6.0. From 7.0 onward, FreeBSD supports the ZFS filesystem. ZFS was previously an open-source filesystem that was first developed by Sun Microsystems, but when Oracle acquired Sun, ZFS became a proprietary product. However, the FreeBSD project is still developing and improving its ZFS implementation via the OpenZFS project. The currently supported version of OpenZFS is 2.2.2 which contains an important fix for a data corruption bug. This version is compatible with releases starting from 12.2-RELEASE. Security[edit] FreeBSD ships with three different firewall packages: IPFW, pf and IPFilter. IPFW is FreeBSD's native firewall. pf was taken from OpenBSD and IPFilter was ported to FreeBSD by Darren Reed. Taken from OpenBSD, the OpenSSH program was included in the default install. OpenSSH is a free implementation of the SSH protocol and is a replacement for telnet. Unlike telnet, OpenSSH encrypts all information (including usernames and passwords). In November 2012, The FreeBSD Security Team announced that hackers gained unauthorized access on two of the project's servers. These servers were turned off immediately. More research demonstrated that the first unauthorized access by hackers occurred on 19 September. Apparently hackers gained access to these servers by stealing SSH keys from one of the developers, not by exploiting a bug in the operating system itself. These two hacked servers were part of the infrastructure used to build third-party software packages. The FreeBSD Security Team checked the integrity of the binary packages and determined that no unauthorized changes were made to the binary packages, but stated that it could not guarantee the integrity of packages that were downloaded between 19 September and 11 November. TrustedBSD[edit] FreeBSD provides several security-related features including access-control lists (ACLs), security event auditing, extended file system attributes, mandatory access controls (MAC) and fine-grained capabilities. These security enhancements were developed by the TrustedBSD project. The project was founded by Robert Watson with the goal of implementing concepts from the Common Criteria for Information Technology Security Evaluation and the Orange Book. This project is ongoing[timeframe?] and many of its extensions have been integrated into FreeBSD. The project is supported by a variety of organizations, including the DARPA, NSA, Network Associates Laboratories, Safeport Network Services, the University of Pennsylvania, Yahoo!, McAfee Research, SPARTA, Apple Computer, nCircle Network Security, Google, the University of Cambridge Computer Laboratory, and others. The project has also ported the NSA's FLASK/TE implementation from SELinux to FreeBSD. Other work includes the development of OpenBSM, an open-source implementation of Sun's Basic Security Module (BSM) API and audit log file format, which supports an extensive security audit system. This was shipped as part of FreeBSD 6.2. Other infrastructure work in FreeBSD performed as part of the TrustedBSD Project has included GEOM and OpenPAM. Most components of the TrustedBSD project are eventually folded into the main sources for FreeBSD. In addition, many features, once fully matured, find their way into other operating systems. For example, OpenPAM has been adopted by NetBSD. Moreover, the TrustedBSD MAC Framework has been adopted by Apple for macOS. Portability[edit] FreeBSD has been ported to a variety of instruction set architectures. The FreeBSD project organizes architectures into tiers that characterize the level of support provided. Tier 1 architectures are mature and fully supported, e.g. it is the only tier \"supported by the security officer\". Tier 2 architectures are under active development but are not fully supported. Tier 3 architectures are experimental or are no longer under active development. As of December 2023[update], FreeBSD has been ported to the following architectures: Architecture Support level in 14.x Notes x86-64 Tier 1 referred to as \"amd64\" x86 (IA-32) Tier 2 referred to as \"i386\", unsupported in 15.x 64-bit ARMv8 Tier 1 referred to as \"aarch64\" 32-bit ARMv7 Tier 2 referred to as \"armv7\" 32-bit ARMv6 Tier 3 referred to as \"armv6\", unsupported in 15.x MIPS unsupported referred to as \"mips\", \"mipsel\", \"mipshf\", \"mipselhf\", \"mipsn32\", \"mips64\", \"mips64el\", \"mips64hf\", \"mips64elhf\", tier 2 until 12.x 32-bit and 64-bit PowerPC Tier 2 referred to as \"powerpc\", \"powerpcspe\", \"powerpc64\", \"powerpc64le\". 32 bit will not be supported from 15.x 64-bit RISC-V Tier 2 referred to as \"riscv64\" The 32-bit ARM (including OTG) and MIPS support is mostly aimed at embedded systems (ARM64 is also aimed at servers), however FreeBSD/ARM runs on a number of single-board computers, including the BeagleBone Black, Raspberry Pi and Wandboard. Hardware compatibility[edit] Supported devices are listed in the FreeBSD 12.1-RELEASE Hardware Notes. The document describes the devices currently known to be supported by FreeBSD. Other configurations may also work, but simply have not been tested yet. Rough automatically extracted lists of supported device ids are available in a third party repository. In 2020, a new project was introduced to automatically collect information about tested hardware configurations. Third-party software[edit] Further information: FreeBSD Ports FreeBSD has a software repository of over 30,000 applications that are developed by third parties. Examples include windowing systems, web browsers, email clients, office suites and so forth. In general, the project itself does not develop this software, only the framework to allow these programs to be installed, which is known as the Ports collection. Applications may either be compiled from source (\"ports\"), provided their licensing terms allow this, or downloaded as precompiled binaries (\"packages\"). The Ports collection supports the current and stable branches of FreeBSD. Older releases are not supported and may or may not work correctly with an up-to-date Ports collection. Ports use Makefiles to automatically fetch the desired application's source code, either from a local or remote repository, unpack it on the system, apply patches to it and compile it. Depending on the size of the source code, compiling can take a long time, but it gives the user more control over the process and its result. Most ports also have package counterparts (i.e. precompiled binaries), giving the user a choice. Although this method is faster, the user has fewer customization options. FreeBSD version 10.0 introduced the package manager pkg as a replacement for the previously used package tools. It is functionally similar to apt and yum in Linux distributions. It allows for installation, upgrading and removal of both ports and packages. In addition to pkg, PackageKit can also be used to access the Ports collection. Jails[edit] Main article: FreeBSD jail First introduced in FreeBSD version 4, jails are a security mechanism and an implementation of operating-system-level virtualization that enables the user to run multiple instances of a guest operating system on top of a FreeBSD host. It is an enhanced version of the traditional chroot mechanism. A process that runs within such a jail is unable to access the resources outside of it. Every jail has its own hostname and IP address. It is possible to run multiple jails at the same time, but the kernel is shared among all of them. Hence only software supported by the FreeBSD kernel can be run within a jail. Virtualization[edit] Main article: bhyve bhyve, a new virtualization solution, was introduced in FreeBSD 10.0. bhyve allows a user to run a number of guest operating systems (FreeBSD, OpenBSD, Linux, and Microsoft Windows) simultaneously. Other operating systems such as Illumos are planned. bhyve was written by Neel Natu and Peter Grehan and was announced in the 2011 BSDCan conference for the first time. The main difference between bhyve and FreeBSD jails is that jails are an operating system-level virtualization and therefore limited to only FreeBSD guests; but bhyve is a type 2 hypervisor and is not limited to only FreeBSD guests. For comparison, bhyve is a similar technology to KVM whereas jails are closer to LXC containers or Solaris Zones. Amazon EC2 AMI instances are also supported via amazon-ssm-agent Since FreeBSD 11.0, there has been support for running as the Dom0 privileged domain for the Xen type 1 hypervisor. Support for running as DomU (guest) has been available since FreeBSD 8.0. VirtualBox (without the closed-source Extension Pack) and QEMU are available on FreeBSD. OS compatibility layers[edit] Most software that runs on Linux can run on FreeBSD using an optional built-in compatibility layer. Hence, most Linux binaries can be run on FreeBSD, including some proprietary applications distributed only in binary form. This compatibility layer is not an emulation; Linux's system call interface is implemented in the FreeBSD's kernel and hence, Linux executable images and shared libraries are treated the same as FreeBSD's native executable images and shared libraries. Additionally, FreeBSD provides compatibility layers for several other Unix-like operating systems, in addition to Linux, such as BSD/OS and SVR4, however, it is more common for users to compile those programs directly on FreeBSD. No noticeable performance penalty over native FreeBSD programs has been noted when running Linux binaries, and, in some cases, these may even perform more smoothly than on Linux. However, the layer is not altogether seamless, and some Linux binaries are unusable or only partially usable on FreeBSD. There is support for system calls up to version 4.4.0, available since FreeBSD 14.0. As of release 10.3, FreeBSD can run 64-bit Linux binaries. FreeBSD has implemented a number of Microsoft Windows native NDIS kernel interfaces to allow FreeBSD to run (otherwise) Windows-only network drivers. The Wine compatibility layer, which allows the running of many Windows applications, especially games, without a (licensed) copy of Microsoft Windows, is available for FreeBSD. Kernel[edit] FreeBSD's kernel provides support for some essential tasks such as managing processes, communication, booting and filesystems. FreeBSD has a monolithic kernel, with a modular design. Different parts of the kernel, such as drivers, are designed as modules. The user can load and unload these modules at any time. ULE is the default scheduler in FreeBSD since version 7.1, it supports SMP and SMT. The FreeBSD kernel has also a scalable event notification interface, named kqueue. It has been ported to other BSD-derivatives such as OpenBSD and NetBSD. Kernel threading was introduced in FreeBSD 5.0, using an M:N threading model. This model works well in theory, but it is hard to implement and few operating systems support it. Although FreeBSD's implementation of this model worked, it did not perform well, so from version 7.0 onward, FreeBSD started using a 1:1 threading model, called libthr. Documentation and support[edit] FreeBSD's documentation consists of its handbooks, manual pages, mailing list archives, FAQs and a variety of articles, mainly maintained by The FreeBSD Documentation Project. FreeBSD's documentation is translated into several languages. All official documentation is released under the FreeBSD Documentation License, \"a permissive non-copyleft free documentation license that is compatible with the GNU FDL\". FreeBSD's documentation is described as \"high-quality\". The FreeBSD project maintains a variety of mailing lists. Among the most popular mailing lists are FreeBSD-questions (general questions) and FreeBSD-hackers (a place for asking more technical questions). Since 2004, the New York City BSD Users Group database provides dmesg information from a collection of computers (laptops, workstations, single-board computers, embedded systems, virtual machines, etc.) running FreeBSD. Installers[edit] From version 2.0 to 8.4, FreeBSD used the sysinstall program as its main installer. It was written in C by Jordan Hubbard. It uses a text user interface, and is divided into a number of menus and screens that can be used to configure and control the installation process. It can also be used to install Ports and Packages as an alternative to the command-line interface. The sysinstall utility is now considered deprecated in favor of bsdinstall, a new installer which was introduced in FreeBSD 9.0. bsdinstall is \"a lightweight replacement for sysinstall\" that was written in sh. According to OSNews, \"It has lost some features while gaining others, but it is a much more flexible design, and will ultimately be significant improvement\". Shell[edit] Prior to 14.0, the default login shell was tcsh for root and the Almquist shell (sh) for regular users. Starting with 14.0, the default shell is sh for both root and regular users. The default scripting shell is the Almquist shell. Development[edit] FreeBSD is developed by a volunteer team located around the world. The developers use the Internet for all communication and many have not met each other in person. In addition to local user groups sponsored and attended by users, an annual conference, called BSDcon, is held by USENIX. BSDcon is not FreeBSD-specific so it deals with the technical aspects of all BSD-derived operating systems, including OpenBSD and NetBSD. In addition to BSDcon, three other annual conferences, EuroBSDCon, AsiaBSDCon and BSDCan take place in Europe, Japan and Canada respectively. Governance structure[edit] Main article: FreeBSD Core Team The FreeBSD Project is run by around 500 committers or developers who have commit access to the master source code repositories and can develop, debug or enhance any part of the system. Most of the developers are volunteers and few developers are paid by some companies. There are several kinds of committers, including source committers (base operating system), doc committers (documentation and website authors) and ports (third-party application porting and infrastructure). Every two years the FreeBSD committers select a 9-member FreeBSD Core Team, which is responsible for overall project direction, setting and enforcing project rules and approving new committers, or the granting of commit access to the source code repositories. A number of responsibilities are officially assigned to other development teams by the FreeBSD Core Team, for example, responsibility for managing the ports collection is delegated to the Ports Management Team. In addition to developers, FreeBSD has thousands of \"contributors\". Contributors are also volunteers outside of the FreeBSD project who submit patches for consideration by committers, as they do not have commit access to FreeBSD's source code repository. Committers then evaluate contributors' submissions and decide what to accept and what to reject. A contributor who submits high-quality patches is often asked to become a committer. Branches[edit] FreeBSD developers maintain at least two branches of simultaneous development. The -CURRENT branch always represents the \"bleeding edge\" of FreeBSD development. A -STABLE branch of FreeBSD is created for each major version number, from which -RELEASE is cut about once every 4–6 months. If a feature is sufficiently stable and mature it will likely be backported (MFC or Merge from CURRENT in FreeBSD developer slang) to the -STABLE branch. Foundation[edit] Main article: FreeBSD Foundation FreeBSD development is supported in part by the FreeBSD Foundation. The foundation is a non-profit organization that accepts donations to fund FreeBSD development. Such funding has been used to sponsor developers for specific activities, purchase hardware and network infrastructure, provide travel grants to developer summits, and provide legal support to the FreeBSD project. In November 2014, the FreeBSD Foundation received US$1 million donation from Jan Koum, co-founder and CEO of WhatsApp – the largest single donation to the Foundation since its inception. In December 2016, Jan Koum donated another $500,000. Jan Koum himself is a FreeBSD user since the late 1990s and WhatsApp uses FreeBSD on its servers. License[edit] FreeBSD is released under a variety of open-source licenses. The kernel code and most newly created code are released under the two-clause BSD license which allows everyone to use and redistribute FreeBSD as they wish. This license was approved by Free Software Foundation and Open Source Initiative as a Free Software and Open Source license respectively. Free Software Foundation described this license as \"a lax, permissive non-copyleft free software license, compatible with the GNU GPL\". There are parts released under three- and four-clause BSD licenses, as well as the Beerware license. Some device drivers include a binary blob, such as the Atheros HAL of FreeBSD versions before 7.2.[failed verification] Some of the code contributed by other projects is licensed under GPL, LGPL, CDDL and ISC. All the code licensed under GPL and CDDL is clearly separated from the code under liberal licenses, to make it easy for users such as embedded device manufacturers to use only permissive free software licenses. ClangBSD aims to replace some GPL dependencies in the FreeBSD base system by replacing the GNU compiler collection with the BSD-licensed LLVM/Clang compiler. ClangBSD became self-hosting on 16 April 2010. Logo[edit] For many years FreeBSD's logo was the generic BSD Daemon, also called Beastie, a distorted pronunciation of BSD. However, Beastie was not unique to FreeBSD. Beastie first appeared in 1976 on Unix T-shirts of comic artist Phil Foglio art, for Mike O'Brien, with some purchased by Bell Labs. More popular versions of the BSD daemon were drawn by animation director John Lasseter beginning in 1984. Several FreeBSD-specific versions were later drawn by Tatsumi Hosokawa. In lithographic terms, the Lasseter graphic is not line art and often requires a screened, four-color photo offset printing process for faithful reproduction on physical surfaces such as paper. Also, the BSD daemon was thought to be too graphically detailed for smooth size scaling and aesthetically over-dependent on multiple color gradations, making it hard to reliably reproduce as a simple, standardized logo in only two or three colors, much less in monochrome. Because of these worries, a competition was held and a new logo designed by Anton K. Gural, still echoing the BSD daemon, was released on 8 October 2005. However, it was announced by Robert Watson that the FreeBSD project is \"seeking a new logo, but not a new mascot\" and that the FreeBSD project would continue to use Beastie as its mascot. The name \"FreeBSD\" was coined by David Greenman on 19 June 1993, other suggested names were \"BSDFree86\" and \"Free86BSD\". FreeBSD's slogan, \"The Power to Serve\", is a trademark of The FreeBSD Foundation. Derivatives[edit] Further information: List of products based on FreeBSD PC-BSD version 10, the operating system that was later known as TrueOS FreeBSD-based distributions[edit] There are a number of software distributions based on FreeBSD. All these distributions have no or only minor changes when compared with the original FreeBSD base system. The main difference to the original FreeBSD is that they come with pre-installed and pre-configured software for specific use cases. This can be compared with Linux distributions, which are all binary compatible because they use the same kernel and also use the same basic tools, compilers, and libraries while coming with different applications, configurations, and branding. Active[edit] Name Focused on Purpose, comments Started First rel Latest rel GhostBSD End-users MATE-based distribution, which also offers other desktop environments 2010 2024 NomadBSD End-users Live USB system (installation to hard drive also available) 2018 2024 helloSystem End-users Started in 2020, aims to bring a FreeBSD adaptation to end-users coming from macOS and disappointed by Apple strategy 2020 2021 2023 MidnightBSD End-users German project to adapt freebsd to desktop usage 2007 2023 OPNsense servers or network equipment Focused on firewall, routing and network freebsd adaptation 2015 2024 pfSense servers or network equipment Focused on firewall, routing and networks equipments operating system 2004 2006 2023 TrueNAS servers or network equipment for network-attached storage devices 2015 2016 2024 XigmaNAS servers or network equipment for network-attached storage devices 2011 2012 2024 Abandoned[edit] Name Focused on Purpose, comments Started First rel Last rel DesktopBSD End-users Desktop-oriented operating system, originally based on KDE 2009 2010 2015 FreeSBIE End-users provide various tools and software in a LiveCD 2003 2004 2007 IntelliStar servers or network equipment satellite system that runs TV programs such as Weatherscan and Local On The 8s 2003 2013 m0n0wall servers or network equipment firewall-focused 2015 OpenServer servers or network equipment servers-usage focused 2011 2015 2023 PicoBSD servers or network equipment for lightweight or low-specs computing operations TrueOS End-users based on FreeBSD (or TrueOS pico for ARM32 embedded) for home-users 2005 2006 2015 Additional developments added to FreeBSD[edit] NanoBSD TrustedBSD Products-specific developments[edit] Juniper's JUNOS router operating system. EMC Isilon's OneFS operating system. NS-BSD, a freebsd-based adaptation to Stormshield (fr) UTM network devices NetApp's Data ONTAP 8.x and the now-superseded ONTAP GX (only as a loader for proprietary kernel-space module). Netflix's Open Connect Appliance to handle content delivery. The PlayStation 4 (\"Orbis OS\") The PlayStation 5 Panasas' PanFS parallel file system Some online services that are directly based on FreeBSD[edit] WhatsApp – processes 2 million concurrent TCP connections per server. Independent operating systems[edit] Besides these distributions, there are some independent operating systems based on FreeBSD. DragonFly BSD is a fork from FreeBSD 4.8 aiming for a different multiprocessor synchronization strategy than the one chosen for FreeBSD 5 and development of some microkernel features. It does not aim to stay compatible with FreeBSD and has huge differences in the kernel and basic userland. MidnightBSD is a fork of FreeBSD 6.1 borrowing heavily from NeXTSTEP, particularly in the user interface department. Darwin, the core of Apple's macOS, includes a virtual file system and network stack derived from those of FreeBSD, and components of its userspace are also FreeBSD-derived. Version history[edit] Main article: FreeBSD version history Version Release date Supported until Significant changes Old version, no longer maintained: 1.x November 1993 ? The first official release. The Ports Collection. Fixed some outstanding bugs from import of 386BSD Addition of some ported applications (XFree86, XView, InterViews, elm, nntp) Old version, no longer maintained: 2.x 22 November 1994 ? Replaced code base with BSD-Lite 4.4 (to satisfy terms of the USL v. BSDi lawsuit settlement) New installer and new boot manager Loadable filesystems support for more filesystems (MS-DOS, unionfs, kernfs) Imported loadable kernel modules from NetBSD Replaced BSD malloc with phkmalloc Full Linux emulation with ELF Dummynet traffic shaping Old version, no longer maintained: 3.x 16 October 1998 ? symmetric multiprocessing (SMP) CAM (Common Access Method) SCSI system VESA video modes Initial USB device support Pluggable Authentication Modules (PAM) Netgraph RAID-5 support in vinum Old version, no longer maintained: 4.x 14 March 2000 31 January 2007 IPv6 support and IPsec with KAME (applications were also updated to support IPv6) OpenSSH integrated into the base system Emulator for SVR4 binary files New jail(2) system call and jail(8) admin command added Kqueue event notification interface Basic Firewire Basic HyperThreading support In-kernel cryptographic framework imported from OpenBSD USB2 support Added ports/CHANGES and ports/UPDATING to FreeBSD Ports Old version, no longer maintained: 5.x 14 January 2003 31 May 2008 Support for UltraSPARC and IA-64 processors SMP support via changes to kernel locking (release most of kernel from the Giant lock) GEOM Kernel Scheduled Entities Mandatory Access Control imported from TrustedBSD Bluetooth ACPI Experimental support for AMD64 Experimental 1:1 and M:N thread libraries for multithreaded processing Experimental ULE scheduler ALTQ Addition of new debugging framework KDB Import pf from OpenBSD Binary compatibility interface for native execution of NDIS drivers Replaced XFree86 with X.Org 6.7 Cryptography enabled by default in base Import Common Address Redundancy Protocol from OpenBSD Old version, no longer maintained: 6.x 1 November 2005 30 November 2010 Performance monitoring counters support New Wi-Fi stack GELI Network bridging NanoBSD utility NDIS driver support Keyboard multiplexer UFS filesystem stability Bluetooth autoconfiguration Additional Ethernet and RAID drivers Support for Xbox architecture OpenBSM audit subsystem freebsd-update (binary updates for security fixes and errata patches) Old version, no longer maintained: 7.x 27 February 2008 28 February 2013 ZFS DTrace GPT Reference implementation of SCTP Added support for ARM architecture, and dropped support for DEC Alpha Support for Intel High Definition Audio (HDA) Replacing phkmalloc with jemalloc tmpfs ULE scheduler made default scheduler for i386 and AMD64 platforms Old version, no longer maintained: 8.x 26 November 2009 1 August 2015 SATA NCQ support Xen guest support High Availability Storage Native NFSv4 ACL support USB 3.0 support Old version, no longer maintained: 9.x 12 January 2012 31 December 2016 Capsicum capability-based security mechanism UFS SoftUpdates+Journal ZFS updated to version 28 bsdconfig, system configuration utility bsdinstall, the new system installation program RCTL, a flexible resource limits mechanism GRAID, flexible software RAID implementation virtio drivers pkgng vt, the new virtual terminal implementation Old version, no longer maintained: 10.x 20 January 2014 31 October 2018 bhyve hypervisor Clang replaced GCC on supported architectures New iSCSI stack Added support for Raspberry Pi UEFI boot for amd64 ZFS booting via UEFI ZFS on root file system ZFS reliability and performance improvements Implementation of pkg, a new FreeBSD package manager, also referred to as pkgng Support for UDP Lite protocol (RFC 3828) SMP support for armv6 New autofs-based automounter DRM code updated to match Linux 3.8.13, allowing multiple simultaneous X servers Support for 64-bit Linux binaries through the compatibility layer Old version, no longer maintained: 11.x 10 October 2016 30 September 2021 New version of NetMap Support for the 64-bit ARM Architecture umount(8) -N new flag which is used to forcefully unmount an NFS mounted filesystem crontab -f new flag added The ZFS filesystem has been updated to implement parallel mounting. The trim(8) utility has been added, which deletes content for blocks on flash-based storage devices that use wear-leveling algorithms. Old version, no longer maintained: 12.x 11 December 2018 31 December 2023 The ext2fs(5) filesystem has been updated to support full read/write support for ext4 FreeBSD has changed the way graphics drivers are handled on amd64 and i386. Graphics drivers for modern ATI-AMD and Intel graphics cards are now available in the Ports Collection. The UFS/FFS filesystem has been updated to support check hashes to cylinder-group maps. Old version, yet still maintained: 13.x 13 April 2021 30 April 2026 The clang, lld, and lldb utilities and compiler-rt, llvm, libunwind, and libc++ libraries have been updated to version 11.0.1. Removed the obsolete binutils 2.17 and gcc(1) 4.2.1 from the tree. All supported architectures now use the LLVM/clang toolchain. The kernel now supports in-kernel framing and encryption of Transport Layer Security (TLS) data on TCP sockets for TLS versions 1.0 through 1.3. Transmit offload via in-kernel crypto drivers is supported for MtE cipher suites using AES-CBC as well as AEAD cipher suites using AES-GCM. Receive offload via in-kernel crypto drivers is supported for AES-GCM cipher suites for TLS 1.2. Using KTLS requires the use of a KTLS-aware userland SSL library. The OpenSSL library included in the base system does not enable KTLS support by default, but support can be enabled by building with the WITH_OPENSSL_KTLS option The 64-bit ARM architecture known as arm64 or AArch64 is promoted to Tier-1 status for FreeBSD 13. Current stable version: 14.x 20 November 2023 30 November 2028 OpenSSH has been updated to version 9.5p1. OpenSSL has been updated to version 3.0.12, a major upgrade from OpenSSL 1.1.1t in FreeBSD 13.2-RELEASE. The bhyve hypervisor now supports TPM and GPU passthrough. FreeBSD supports up to 1024 cores on the amd64 and arm64 platforms. ZFS has been upgraded to OpenZFS release 2.2, providing significant performance improvements. It is now possible to perform background filesystem checks on UFS file systems running with journaled soft updates. Experimental ZFS images are now available for AWS and Azure. The default congestion control mechanism for TCP is now CUBIC. Future release: 15.x December 2025 ? Drop support for all 32-bit CPU instruction set architectures except armv7 Future release: 16.x December 2027 ? No information has been given yet. Version Release date Supported until Significant changes Legend:Old version, not maintainedOld version, still maintainedLatest versionLatest preview versionFuture release See also[edit] Free and open-source software portal BAPP, a set of commonly used software with FreeBSD Comparison of BSD operating systems Comparison of operating system kernels Comparison of operating systems Comparison of router software projects Computer Systems Research Group List of BSD adopters List of router and firewall distributions List of router firmware projects Marshall Kirk McKusick References[edit] Citations[edit] ^ \"FreeBSD 14.2-RELEASE Announcement\". FreeBSD.org. 3 December 2024. Retrieved 3 December 2024. ^ \"FreeBSD 13.4-RELEASE Announcement\". FreeBSD.org. 17 September 2024. Retrieved 17 September 2024. ^ \"FreeBSD History\". people.freebsd.org. Archived from the original on 24 November 2023. Retrieved 24 November 2023. ^ BSD Usage Survey Report (PDF) (Report). The BSD Certification Group. 31 October 2005. Archived (PDF) from the original on 22 October 2013. Retrieved 5 December 2010. ^ \"The return of BSD - SunWorld - January 1999\". sunsite.uakom.sk. Retrieved 21 November 2024. ^ By (28 October 2024). \"FreeBSD At 30: The History And Future Of The Most Popular BSD-Based OS\". Hackaday. Retrieved 21 November 2024. ^ a b c Chisnall, David (20 January 2006). BSD: The Other Free UNIX Family. informit.com. Archived from the original on 5 January 2014. Retrieved 13 December 2013. ^ \"Chapter 4. Installing Applications: Packages and Ports\". FreeBSD Handbook. The FreeBSD Project. Archived from the original on 22 September 2021. Retrieved 16 June 2021. ^ a b \"Licenses of software used on PlayStation®3 console\". Archived from the original on 26 March 2016. Retrieved 11 August 2010. ^ a b Rosenberg, Alex (17 December 2013). \"FreeBSD Handbook and PS3\". freebsd-doc (Mailing list). Archived from the original on 2 February 2017. Retrieved 22 January 2016. ^ \"Open Source Software used in PlayStation 3\". Archived from the original on 11 November 2017. Retrieved 8 December 2022. ^ \"Open Source Software used in PlayStation®4\". Sony Interactive Entertainment. Archived from the original on 12 December 2017. Retrieved 4 January 2019. ^ \"Kernel\". PlayStation 5 Dev Wiki. ^ \"Open Source Software used in PlayStation Vita\". Archived from the original on 12 December 2017. Retrieved 8 December 2022. ^ \"任天堂製品に関連するオープンソースソフトウェアのソースコード配布ページ｜サポート情報｜Nintendo\". www.nintendo.co.jp. Archived from the original on 26 July 2020. Retrieved 26 July 2020. ^ Cao (8 March 2017). \"Nintendo Switch runs FreeBSD\". FreeBSDNews.com. Archived from the original on 26 July 2020. Retrieved 26 July 2020. ^ Leonard, Andrew (16 May 2000). \"BSD Unix: Power to the people, from the code\". Salon. Retrieved 3 December 2024. ^ a b c d \"Open Sources: Voices from the Open Source Revolution\". O'Reilly Media. 29 March 1999. Archived from the original on 7 October 2014. Retrieved 15 June 2022. ^ \"A Brief History of FreeBSD\". Archived from the original on 7 March 2023. Retrieved 13 October 2023. ^ \"June 19 is National FreeBSD Day!\". FreeBSD Foundation. 6 June 2017. Archived from the original on 16 September 2018. Retrieved 13 November 2017. ^ Lucas 2007, pp. 4–5. ^ \"A Brief History of FreeBSD\". FreeBSD.org. Archived from the original on 23 December 2013. Retrieved 31 January 2009. ^ Bruce, Bob. \"Company History\". FreeBSD Mall. Archived from the original on 14 December 2013. Retrieved 6 August 2014. ^ Johnson, Dwight. \"Report from Comdex—Walnut Creek CDROM, FreeBSD and Slackware\". Linux Today. Archived from the original on 13 August 2014. Retrieved 6 August 2014. ^ a b c Lucas 2007, p. 5. ^ Pohlmann, Frank (19 July 2005). \"Why FreeBSD\". IBM DeveloperWorks. Archived from the original on 11 September 2013. ^ a b \"Kernel Programming Guide: BSD Overview\". Apple Inc. Archived from the original on 29 May 2016. Retrieved 24 August 2014. ^ a b Michael Larabel (23 June 2013). \"Sony's PlayStation 4 Is Running Modified FreeBSD 9\". Phoronix. Archived from the original on 24 June 2013. Retrieved 17 August 2013. ^ a b Long, Scott (5 June 2012). \"Netflix's New Peering Appliance Uses FreeBSD\". freebsd-stable (Mailing list). Archived from the original on 10 June 2012. Retrieved 5 June 2012. ^ \"FreeBSD Foundation Semi-Annual Newsletter, August 2013\". 5 August 2013. WhatsApp, Inc. Testimonial. Archived from the original on 11 August 2020. Retrieved 22 July 2019. ^ \"FreeBSD High Capacity Server Performance Tuning ✈ FlightAware\". FlightAware. Archived from the original on 16 July 2023. Retrieved 5 February 2024. ^ Lehey 2003, p. 8. ^ \"Release Information\". The FreeBSD Project. Archived from the original on 27 November 2017. Retrieved 11 September 2014. ^ \"How to install Wayland?\". The FreeBSD Forums. 26 September 2020. Archived from the original on 27 October 2021. Retrieved 2 March 2021. ^ \"FreeBSD port of Firefox\". freshports.org. Archived from the original on 5 October 2014. Retrieved 10 June 2024. ^ \"FreeBSD port of Chromium\". freshports.org. Archived from the original on 25 April 2024. Retrieved 10 June 2024. ^ a b \"FreeBSD Platforms\". FreeBSD. Archived from the original on 1 January 2011. Retrieved 22 December 2023. ^ \"FreeBSD Downloads\". FreeBSD. Archived from the original on 1 October 2021. Retrieved 1 October 2021. ^ \"License to thrill: Ahead of v13.0 article\". FreeBSD. Archived from the original on 25 June 2024. Retrieved 1 October 2021. ^ \"Mark mips as unsupported for 14.x.\" FreeBSD. Archived from the original on 1 October 2021. Retrieved 1 October 2021. ^ McKusick, Marshall (2005). \"Section 2.13\". The Design and Implementation of the FreeBSD Operating System. Addison-Wesley. ISBN 0-201-70245-2. ^ Farrokhi, Babak (16 October 2009). \"Network Configuration—IPv6 with FreeBSD\". Packt. Archived from the original on 26 December 2013. Retrieved 26 December 2013. ^ Sam Leffler. \"FreeBSD Wireless Networking Support\" (PDF). BSDCan. Archived (PDF) from the original on 1 July 2022. Retrieved 15 June 2022. ^ \"Overview of the KAME Project\". KAME project. Archived from the original on 9 February 2014. Retrieved 11 August 2014. ^ Smirnoff, Gleb (28 October 2013). \"[heads up] axing AppleTalk and IPX/SPX\". freebsd-stable (Mailing list). Archived from the original on 12 August 2014. Retrieved 12 August 2014. ^ \"CARP(4)\". The FreeBSD documentation Project. Archived from the original on 29 October 2013. Retrieved 25 October 2013. ^ McKusick, Marshall; Neville-Neil, George V. (2005). \"8.6. Soft Updates\". The Design and Implementation of the FreeBSD Operating System. Addison-Wesley. ISBN 0-201-70245-2. ^ Lucas 2007, p. 220. ^ Lucas 2007, 18. DISK TRICKS WITH GEOM. ^ \"geli(8)\". The FreeBSD Project. Archived from the original on 28 June 2014. Retrieved 12 August 2014. ^ Kamp, Poul-Henning. \"GBDE—GEOM Based Disk Encryption\" (PDF). USENIX. Archived (PDF) from the original on 15 June 2022. Retrieved 15 June 2022. ^ Sean Michael Kerner (25 February 2011). \"FreeBSD 8.2 Expands ZFS Support -- Without Oracle\". Datamation. Archived from the original on 26 May 2022. Retrieved 15 June 2022. ^ \"Releases · openzfs/zfs\". GitHub. Archived from the original on 6 August 2023. Retrieved 29 January 2024. ^ Lucas 2007, p. 273. ^ Lucas 2007, p. 440. ^ \"Hackers obtained access to FreeBSD servers\". H-Online. Archived from the original on 8 December 2013. Retrieved 9 August 2014. ^ \"Hackers break into two FreeBSD Project servers using stolen SSH keys\". 19 November 2012. Archived from the original on 5 February 2024. Retrieved 4 February 2024. ^ \"FreeBSD servers hacked\". Techeye. Archived from the original on 24 October 2013. Retrieved 9 August 2014. ^ Daniel Harris (14 August 2003). \"FreeBSD Access Control Lists\". ONLamp. Archived from the original on 19 October 2013. Retrieved 15 December 2013. ^ \"The TrustedBSD MAC Framework: Extensible Kernel Access Control for FreeBSD 5.0\". USENIX. Archived from the original on 13 September 2014. Retrieved 12 September 2014. ^ a b \"TrustedBSD: Adding Trusted Operating System Features to FreeBSD\" (PDF). Archived (PDF) from the original on 22 September 2013. Retrieved 12 September 2014. ^ TrustedBSD project homepage http://www.trustedbsd.org/home.html ^ \"TrustedBSD: Adding Trusted Operating System Features to FreeBSD\". USENIX. Archived from the original on 13 September 2014. Retrieved 12 September 2014. ^ \"TrustedBSD Project\". TrustedBSD Project. Archived from the original on 24 December 2013. Retrieved 9 August 2014. ^ \"OPENPAM(3)\". The NetBSD Project. Archived from the original on 18 November 2018. Retrieved 12 September 2014. ^ \"Authentication, Authorization, and Permissions Guide\". developer.apple.com. Apple Inc. Archived from the original on 25 June 2024. Retrieved 13 September 2014. ^ \"21. Support for Multiple Architectures\". docs.freebsd.org. Retrieved 4 February 2024. ^ \"Committer's Guide\". The FreeBSD Documentation Project. Archived from the original on 19 December 2013. Retrieved 23 April 2013. ^ \"arm64 – FreeBSD Wiki\". wiki.freebsd.org. Archived from the original on 8 March 2021. Retrieved 2 March 2021. ^ \"FreeBSD – Raspberry Pi\". Archived from the original on 24 October 2012. Retrieved 10 January 2013., see also Raspbian#Software build ^ \"Raspberry Pi Software Is Rapidly Maturing\". OSNews. Archived from the original on 18 October 2013. Retrieved 12 November 2013. ^ \"FreeBSD/arm\". Archived from the original on 29 September 2018. Retrieved 30 November 2014. ^ \"FreeBSD 12.1-RELEASE Hardware Notes\". The FreeBSD Documentation Project. Archived from the original on 14 July 2020. Retrieved 11 June 2020. ^ \"FreeBSD 12.1: ids of supported devices\". BSD Hardware Project. Archived from the original on 25 February 2021. Retrieved 11 June 2020. ^ \"FreeBSD Hardware\". BSD Hardware Project. Archived from the original on 3 October 2020. Retrieved 11 June 2020. ^ \"About FreeBSD Ports\". freebsd.org. Archived from the original on 19 April 2015. Retrieved 18 January 2021. ^ a b Lucas 2007, p. 317. ^ \"Chapter 4 Installing Applications: Packages and Ports\". FreeBSD.org. Archived from the original on 21 May 2018. Retrieved 30 January 2009. ^ Asami, Satoshi. \"The FreeBSD Ports Collection\" (PDF). USENIX. Archived (PDF) from the original on 20 October 2013. Retrieved 13 December 2013. ^ Larabel, Michael. \"FreeBSD Still Working On Next-Gen Package Manager\". Phoronix. Archived from the original on 25 June 2024. Retrieved 9 August 2014. ^ a b \"FreeBSD 4.0 Announcement\". www.freebsd.org. Archived from the original on 26 June 2018. Retrieved 26 June 2018. ^ a b \"The BSD family, pt. 1: FreeBSD 9.1\". OSNews. Archived from the original on 18 October 2013. Retrieved 9 August 2014. ^ \"What's new for FreeBSD 11\". wiki.freebsd.org. Archived from the original on 29 September 2015. Retrieved 28 September 2015. ^ Schenkeveld, Paul. \"The BSD Hypervisor\" (PDF). FOSDEM. Retrieved 9 August 2014. ^ Larabel, Michael. \"The State Of FreeBSD's Bhyve Virtualization\". Phoronix. Archived from the original on 10 August 2014. Retrieved 9 August 2014. ^ Grehan, Peter. \"Introduction to bhyve\" (PDF). Archived (PDF) from the original on 28 March 2014. Retrieved 9 August 2014. ^ \"Xen – FreeBSD Wiki\". wiki.freebsd.org. Archived from the original on 25 June 2024. Retrieved 5 March 2021. ^ a b McEwen, Gordon. \"Setting up Linux compatibility on FreeBSD 6\". Archived from the original on 14 November 2006. Retrieved 15 December 2013. ^ Lehey 2003, p. 162. ^ Tiemann, Brian (2006). \"How FreeBSD Compares to Other Operating Systems\". FreeBSD 6 Unleashed. ISBN 0-672-32875-5. ^ Michael, Larabel. \"FreeBSD: A Faster Platform For Linux Gaming Than Linux?\". Phoronix. Archived from the original on 2 July 2014. Retrieved 5 August 2014. ^ \"Linuxulator (Linux Emulation) - FreeBSD Wiki\". 22 December 2023. Archived from the original on 25 June 2024. Retrieved 22 December 2023. ^ \"FreeBSD 10.3-RELEASE Announcement\". The FreeBSD Project. 4 April 2016. Archived from the original on 6 April 2016. Retrieved 5 April 2016. ^ Bill Paul (24 January 2004). \"Project Evil: The Evil Continues\". freebsd-current (Mailing list). Archived from the original on 2 July 2017. Retrieved 9 September 2014. ^ Chisnall, David (15 July 2005). \"Project Evil: Windows network drivers on FreeBSD\". Ping Wales. Archived from the original on 4 November 2005. Retrieved 23 October 2013. ^ McKusick & Neville-Neil 2004, Chapter 2. Design Overview of FreeBSD. ^ Lucas 2007, p. 118. ^ Roberson, Jeff. \"ULE: A Modern Scheduler for FreeBSD\" (PDF). USENIX. Archived (PDF) from the original on 29 August 2008. Retrieved 5 August 2014. ^ Lemon, Jonathan. \"KQueue–A Generic and Scalable Event Notification Facility\" (PDF). USENIX. Archived (PDF) from the original on 29 August 2008. Retrieved 5 August 2014. ^ \"Thread models semantics: Solaris and Linux M:N to 1:1 thread model\" (PDF). Department of computer Science and Engineering, Air University Multan Pakistan. Archived from the original (PDF) on 16 September 2014. Retrieved 16 September 2014. ^ a b Lucas 2007, p. 359. ^ Lucas 2007, p. 25. ^ \"Various Licenses and Comments about Them\". GNU Project. Archived from the original on 24 July 2010. Retrieved 12 August 2014. ^ Lehey 2003, p. 16. ^ \"BSD: The Other Free UNIX Family\". InformIT. 20 January 2006. Archived from the original on 28 March 2014. Retrieved 12 August 2014. ^ \"lists.freebsd.org Mailing Lists\". Archived from the original on 4 February 2024. Retrieved 4 February 2024. ^ Lehey 2003, p. 17. ^ \"dmesgd\". dmesgd.nycbug.org. NYC*BUG. Archived from the original on 25 June 2024. Retrieved 16 December 2015. ^ \"SYSINSTALL(8)\". FreeBSD Man Pages. Archived from the original on 25 June 2024. Retrieved 11 September 2014. ^ \"2012: a BSD year in retrospective\". OSNews. Archived from the original on 19 October 2013. Retrieved 9 August 2014. ^ a b \"FreeBSD Quickstart Guide for Linux® Users\". FreeBSD Documentation Portal. Archived from the original on 1 March 2024. Retrieved 4 February 2024. ^ \"2. Default Shell\". www.freebsd.org. Archived from the original on 16 February 2018. Retrieved 29 June 2018. ^ \"sh(1)\". FreeBSD Manual Pages. The FreeBSD Project. Archived from the original on 25 June 2024. Retrieved 14 March 2024. ^ Lehey 2003, p. 20. ^ \"EuroBSDcon 2014\". EuroBSDcon. Archived from the original on 3 February 2014. Retrieved 9 August 2014. ^ \"AsiaBSDCon 2014\". AsiaBSDCon. Archived from the original on 28 August 2014. Retrieved 9 August 2014. ^ \"BSDCan – The BSD Conference\". BSDCan. Archived from the original on 19 February 2015. Retrieved 19 February 2015. ^ a b Lucas 2007, p. 6. ^ Lucas 2007, pp. 372–375. ^ \"Overview\". The FreeBSD Foundation. 16 December 2015. Archived from the original on 10 June 2016. Retrieved 20 May 2016. ^ \"Foundation Announces New Uranium Donor\". FreeBSD Foundation. December 2016. Archived from the original on 25 March 2022. Retrieved 29 December 2016. ^ \"Updated! – FreeBSD Foundation Announces Generous Donation and Fundraising Milestone\". FreeBSD Foundation. 17 November 2014. Archived from the original on 19 November 2014. Retrieved 20 November 2014. ^ \"Various Licenses and Comments about Them\". The GNU Project. Archived from the original on 24 July 2010. Retrieved 9 August 2014. ^ \"The BSD 2-Clause License\". Open Source Initiative. 31 October 2006. Archived from the original on 12 February 2023. Retrieved 9 August 2014. ^ Watson, Robert (22 October 2006). \"binary blobs in freebsd\". freebsd-questions (Mailing list). Archived from the original on 15 April 2014. Retrieved 20 October 2013. ^ \"FreeBSD Copyright and Legal Information\". FreeBSD.org. Archived from the original on 18 April 2010. Retrieved 23 April 2013. ^ \"Contents of /stable/9/cddl/contrib/opensolaris/OPENSOLARIS.LICENSE\". The FreeBSD Project. Retrieved 28 August 2014.[permanent dead link‍] ^ \"ClangBSD Is Selfhosting, We Need Testers Now\". osnews.com. 17 April 2010. Archived from the original on 2 May 2013. Retrieved 23 April 2013. ^ \"USENIX\". Archived from the original on 23 February 2024. Retrieved 18 January 2024. ^ \"What's that daemon?\". Archived from the original on 3 August 2001. Retrieved 18 January 2024. ^ \"UNIX Methods and Concepts: Putting the Genie Back in the Bottle, by Salus & Toomey\". Archived from the original on 18 January 2024. Retrieved 18 January 2024. ^ \"UNIX News, Number 5\" (PDF). 30 April 1976. Archived (PDF) from the original on 28 May 2023. Retrieved 18 January 2024. ^ \"USENIX notes\" (PDF). ;login:. 30 (1). February 2005. Archived (PDF) from the original on 19 January 2024. Retrieved 18 January 2024. ^ \"login: The UNIX Newsletter Volume 2, Number 7, August 1977\" (PDF). ;login:. 40 (6). December 2015. Archived (PDF) from the original on 18 January 2024. Retrieved 18 January 2024. ^ \"Usenix\". mckusick.com. Archived from the original on 17 October 2018. Retrieved 15 December 2007. ^ \"Saving UNIX from /dev/null\". minnie.tuhs.org. Archived from the original on 30 May 2018. Retrieved 15 December 2007. ^ \"The BSD Daemon\". FreeBSD.org. Archived from the original on 15 May 2019. Retrieved 15 December 2007. ^ a b \"FreeBSD logo design competition\". OSNews. Archived from the original on 15 December 2013. Retrieved 1 November 2013. ^ Kuriyama, Jun (22 February 2005). \"FreeBSD logo design competition\". FreeBSD-Announce (Mailing list). Archived from the original on 3 November 2013. Retrieved 1 November 2013. ^ \"Final result for the FreeBSD logo design competition\". FreeBSD.org. 2005. Archived from the original on 16 October 2012. Retrieved 1 March 2007. ^ Greenman, David. \"FreeBSD Archives\". The FreeBSD Project. Archived from the original on 24 August 2014. Retrieved 6 August 2014. ^ \"FreeBSD Logo\". The FreeBSD Project. Archived from the original on 3 July 2014. Retrieved 6 August 2014. ^ \"hello — helloSystem documentation\". hellosystem.github.io. Archived from the original on 24 January 2023. Retrieved 26 May 2024. ^ helloSystem/hello, helloSystem, 22 May 2024, archived from the original on 25 June 2024, retrieved 26 May 2024 ^ Monmarché, Karine (20 December 2016). \"FreeBSD, Next-Generation Firewalls & open source\". Stormshield. Archived from the original on 25 May 2024. Retrieved 25 May 2024. ^ Netflix (29 May 2012). \"Open Connect Appliance Deployment Guide\" (PDF). Archived (PDF) from the original on 17 June 2012. Retrieved 5 June 2012. ^ Matthew Humphries (24 June 2013). \"PS4 runs modified version of the FreeBSD 9.0 operating system\". Archived from the original on 28 June 2013. Retrieved 19 October 2013. ^ Clark, Jack. \"Sony's new PlayStation 4 and open source FreeBSD: The TRUTH\". theregister.co.uk. Archived from the original on 4 July 2017. Retrieved 16 November 2013. ^ \"Kernel - PS5 Developer wiki\". www.psdevwiki.com. Retrieved 27 November 2024. ^ Smith, Lyle (8 November 2017). \"Panasas Announces Next-Gen ActiveStor Scale-out NAS Solution\". Storage Reviews. Archived from the original on 1 February 2022. Retrieved 1 February 2022. ^ a b \"1 million is so 2011\". WhatsApp Blog. Archived from the original on 20 September 2020. Retrieved 27 August 2014. ^ Dillon, Matthew (16 July 2003). \"Announcing DragonFly BSD!\". freebsd-current (Mailing list). Archived from the original on 2 October 2018. Retrieved 26 July 2007. ^ \"Porting UNIX/Linux Applications to OS X: Overview of OS X\". Apple Inc. Archived from the original on 4 March 2016. Retrieved 24 August 2014. ^ FreeBSD Security Officer. \"FreeBSD 4.x EoL\". freebsd-security (Mailing list). Archived from the original on 27 March 2019. Retrieved 26 June 2018. ^ \"FreeBSD 4.0 Release Notes\". The FreeBSD Project. Archived from the original on 26 June 2018. Retrieved 26 June 2018. ^ \"Using pkgng for Binary Package Management\". FreeBSD 9.2 Handbook. FreeBSD Project. Archived from the original on 22 June 2018. Retrieved 22 June 2018. ^ \"FreeBSD Security Information — End of Life\". The FreeBSD Project. Archived from the original on 12 October 2017. Retrieved 3 October 2017. ^ \"FreeBSD 10.0-RELEASE Release Notes\". The FreeBSD Project. Archived from the original on 22 June 2018. Retrieved 22 June 2018. ^ \"FreeBSD 11.0-RELEASE Announcement\". The FreeBSD Project. Archived from the original on 7 November 2017. Retrieved 10 October 2016. ^ \"FreeBSD Security Information\". The FreeBSD Project. Archived from the original on 27 November 2017. Retrieved 22 June 2018. ^ a b \"What's new for FreeBSD 11\". The FreeBSD Project. Archived from the original on 2 April 2015. Retrieved 24 March 2015. ^ \"FreeBSD 12.0 Release Process\". The FreeBSD Project. 18 September 2017. Archived from the original on 16 February 2018. Retrieved 26 January 2018. ^ \"FreeBSD 12.0-RELEASE Release Notes\". The FreeBSD Project. 9 October 2019. Archived from the original on 21 December 2019. Retrieved 26 January 2018. ^ \"FreeBSD 13.0-RELEASE Release Process\". The FreeBSD Project. 21 July 2020. Archived from the original on 10 August 2020. Retrieved 2 August 2020. ^ \"The FreeBSD Project | FreeBSD 13.0-RELEASE Release Notes\". www.freebsd.org. Archived from the original on 13 April 2021. Retrieved 13 April 2021. ^ \"FreeBSD 14.0-RELEASE Announcement\". The FreeBSD Project. 20 November 2023. Archived from the original on 20 May 2024. Retrieved 20 November 2023. ^ \"The FreeBSD Project | FreeBSD 14.0-RELEASE Release Notes\". www.freebsd.org. Archived from the original on 22 May 2024. Retrieved 20 November 2023. ^ \"Release Engineering Information\". The FreeBSD Project. Retrieved 1 October 2024. ^ \"FreeBSD 14.0-RELEASE Release Notes -> General Notes Regarding Future FreeBSD Releases\". 30 November 2023. Archived from the original on 22 May 2024. Retrieved 15 April 2024. Sources[edit] Negus, Christopher; Caen, Francois (5 May 2008), BSD UNIX Toolbox: 1000+ Commands for FreeBSD, OpenBSD and NetBSD (First ed.), Wiley, p. 309, ISBN 978-0-470-37603-4, archived from the original on 2 May 2009, retrieved 30 April 2009 Lavigne, Dru (24 May 2004), BSD Hacks (First ed.), O'Reilly Media, p. 448, ISBN 0-596-00679-9, archived from the original on 25 June 2024, retrieved 23 April 2013 Lucas, Michael W. (14 November 2007), Absolute FreeBSD (Second ed.), No Starch Press, p. 744, ISBN 978-1-59327-151-0, archived from the original on 17 February 2018, retrieved 30 April 2009 Lavigne, Dru; Lehey, Greg; Reed, Jeremy C. (20 December 2007), The Best of FreeBSD Basics (First ed.), Reed Media Services, p. 596, ISBN 978-0-9790342-2-0, archived from the original on 5 January 2008, retrieved 9 January 2008 Hong, Bryan J. (1 April 2008), Building a Server with FreeBSD 7 (First ed.), No Starch Press, p. 288, ISBN 978-1-59327-145-9, archived from the original on 7 April 2008, retrieved 2 April 2008 Tiemann, Brian; Urban, Michael (15 June 2006), FreeBSD 6 Unleashed (First ed.), Sams, p. 912, ISBN 0-672-32875-5 Korff, Yanek; Hope, Paco; Potter, Bruce (March 2005), Mastering FreeBSD and OpenBSD Security (First ed.), O'Reilly Media, p. 464, ISBN 0-596-00626-8, archived from the original on 25 June 2024, retrieved 23 April 2013 Lehey, Greg (April 2003), The Complete FreeBSD (Fourth ed.), O'Reilly Media, p. 720, ISBN 0-596-00516-4, archived from the original on 13 March 2020, retrieved 23 April 2013 McKusick, Marshall K.; Neville-Neil, George V. (2 August 2004), The Design and Implementation of the FreeBSD Operating System (First ed.), Addison–Wesley, p. 720, ISBN 0-201-70245-2 Mittelstaedt, Ted (15 December 2000), The FreeBSD Corporate Networker's Guide (First ed.), Addison–Wesley, p. 432, ISBN 0-201-70481-1 Stokely, Murray; Lee, Chern (1 March 2004), The FreeBSD Handbook, Volume 1: User Guide (Third ed.), FreeBSD Mall, p. 408, ISBN 1-57176-327-9, archived from the original on 25 June 2024, retrieved 18 August 2013 Stokely, Murray (1 September 2004), The FreeBSD Handbook, Volume 2: Admin Guide (Third ed.), FreeBSD Mall, p. 537, ISBN 1-57176-328-7, archived from the original on 9 May 2013, retrieved 18 August 2013 External links[edit] Wikimedia Commons has media related to FreeBSD. Wikiquote has quotations related to FreeBSD. Official website FreeBSD on DistroWatch vteThe FreeBSD ProjectFreeBSD FreeBSD Core Team FreeBSD Documentation License FreeBSD Foundation FreeBSD Ports Version History Kernel Normal Form SubsystemsScheduling ALTQ ULE scheduler Virtualisation chroot jail bhyve Storage GEOM raid5 GBDE geli LVM2 vinum disklabel fdisk UFS Soft updates VFS ZFS Highly Available STorage Networking 802.11 drivers ALTQ Bluetooth BPF IPFilter ipfw Netgraph NDIS pf CARP pfsync SCTP Other busdma DTrace OpenPAM OpenBSM portsnap kqueue KLD moused systat People Matthew Dillon Jordan Hubbard Poul-Henning Kamp Mike Karels Ben Laurie Sam Leffler Marshall Kirk McKusick Diomidis Spinellis Robert Watson Dru Lavigne Derivativesopen-source XNU Darwin DesktopBSD DragonFly BSD FreeNAS FreeSBIE GhostBSD MidnightBSD m0n0wall OPNsense pfSense TrueOS GNU/kFreeBSD Gentoo/FreeBSD XigmaNAS proprietary Junos macOS, iOS, tvOS, and watchOS Nintendo Switch OS OpenServer 10 PlayStation 3 OS PlayStation 4 OS PlayStation Vita OS vteBerkeley Software DistributionPeople Bob Fabry Keith Bostic Marshall Kirk McKusick Michael J. Karels Bill Joy Samuel Leffler Jordan Hubbard Theo de Raadt Poul-Henning Kamp Matthew Dillon Ozalp Babaoglu Lynne and William Jolitz DerivativesActive FreeBSD GhostBSD OpenBSD NetBSD DragonFly BSD MidnightBSD MirOS BSD Junos OS Darwin macOS iOS audioOS iPadOS tvOS watchOS bridgeOS PS3/PS4/PS Vita operating system Full list Discontinued 386BSD BSD/OS SunOS TrueOS Ultrix Companies Sleepycat Software Walnut Creek CDROM Berkeley Software Design iXsystems Other topics Comparison History Licensing BSD Daemon Lumina Computer Systems Research Group Category Commons vteUnix and Unix-like operating systems and compatibility layers Architecture Filesystem History Philosophy Security Shell OperatingsystemsBSD 386BSD FreeBSD NetBSD OpenBSD DragonFly BSD Darwin macOS iOS audioOS iPadOS tvOS watchOS bridgeOS DYNIX NeXTSTEP SunOS Ultrix Linux Android Arch ChromeOS Debian Fedora Gentoo Red Hat SUSE Ubuntu Other distributions System V A/UX AIX HP-UX IRIX OpenServer Solaris OpenSolaris Illumos Tru64 UNIX UnixWare Other Coherent Domain/OS GNU Hurd LynxOS Minix MOS OSF/1 QNX BlackBerry 10 Research Unix SerenityOS Xenix more... Compatibilitylayers Cygwin Darling Eunice GNV Interix MachTen Microsoft POSIX subsystem MKS Toolkit PASE P.I.P.S. PWS/VSE-AF UNIX System Services UserLAnd Technologies Windows Services for UNIX Windows Subsystem for Linux Italics indicate discontinued systems. Category Commons Authority control databases InternationalVIAFNationalGermanyUnited StatesCzech RepublicIsrael"
    },
    {
        "id": 30,
        "url": "https://en.wikipedia.org/wiki/Raspberry_Pi_OS",
        "title": "Raspberry Pi OS",
        "content": "Debian-based operating system for Raspberry Pi Linux distribution Raspberry Pi OSDeveloperRaspberry Pi FoundationOS familyLinux (Unix-like)Working stateCurrentSource modelOpen sourceInitial release15 July 2012 (32-bit); 2 Feb 2022 (64-bit)Latest release2024-11-19 / 19 November 2024; 52 days ago (19 November 2024)Marketing targetRaspberry PiAvailable inEnglish, and other languages.Update methodAPTPackage managerdpkgPlatformsaarch64, armhfKernel typeMonolithicUserlandGNUDefaultuser interfacePIXELLicenseFree and open-source software licenses (mainly GPL)Official websiteraspberrypi.com/software/Support statusSupported Raspberry Pi OS is a Unix-like operating system based on the Debian Linux distribution for the Raspberry Pi family of compact single-board computers. Raspbian was developed independently in 2012, became the primary operating system for these boards since 2013, was originally optimized for the Raspberry Pi 1 and distributed by the Raspberry Pi Foundation. In 2020, the Raspberry Pi Foundation renamed Raspbian to Raspberry Pi OS. Raspberry Pi OS runs on every Raspberry Pi except the Pico microcontroller. Raspberry Pi OS uses a modified LXDE desktop environment with the Openbox stacking window manager, along with a unique theme. The default distribution is shipped with a copy of the computer algebra system Wolfram Mathematica, VLC, and a lightweight version of the Chromium web browser. History[edit] Raspberry Pi OS was first developed by Mike Thompson and Peter Green as Raspbian, an independent and unofficial port of Debian to the Raspberry Pi. The first build was released on July 15, 2012. As the Raspberry Pi had no officially provided operating system at the time, the Raspberry Pi Foundation built on the work by the Raspbian project and began producing and releasing their own version of the software. The Foundation's first release of Raspbian, which now referred both to the community project as well as the official operating system, was announced on September 10, 2013. On May 28, 2020, the Raspberry Pi Foundation announced a beta 64-bit version. However, this version was not based on Raspbian, instead taking its user space software from Debian GNU/Linux. When the Foundation did not want to use the name Raspbian to refer to software that was not based on the Raspbian project, the name of the officially provided operating system was changed to Raspberry Pi OS. This change was also carried over to the 32-bit version, though it continued to be based on Raspbian. The 64-bit version of Raspberry Pi OS was officially released on February 2, 2022. Features[edit] User interface[edit] Raspberry Pi OS has a desktop environment, PIXEL (short for Pi Improved Xwindows Environment, Lightweight), based on LXDE, which looks similar to many common desktops, such as macOS and Microsoft Windows. The desktop has a background image. A menu bar is positioned at the top and contains an application menu and shortcuts to a web browser (Chromium), file manager, and terminal. The other end of the menu bar shows a Bluetooth menu, Wi-Fi menu, volume control, and clock. The desktop can also be changed from its default appearance, such as repositioning the menu bar. Package management[edit] Packages can be installed via APT, the Recommended Software app, and by using the Add/Remove Software tool, a GUI wrapper for APT. Components[edit] PCManFM is a file browser allowing quick access to all areas of the computer, and was redesigned in the first Raspberry Pi OS Buster release (2019-06-20). Raspberry Pi OS originally distributed the web browser Epiphany, but switched to Chromium with the launch of its redesigned desktop. The built-in browser comes preinstalled with uBlock Origin and h264ify. Raspberry Pi OS comes with many beginner IDEs, such as Thonny Python IDE, Mu Editor, and Greenfoot. It also ships with educational software, such as Scratch and Bookshelf. Reception[edit] The download statistics from the Raspberry Pi Imager indicate that Raspberry Pi OS is by far the most used operating system on the Raspberry Pi, accounting for 68.44% of all OS downloads in the month preceding 24 February 2022. It is also the choice of distro used by Ken Thompson, one of the original developers of the UNIX operating system. Jesse Smith from DistroWatch reviewed Raspbian in 2015: Though I did not intend to run the Raspberry Pi as a desktop computer, the Raspbian operating system does provide users with the LXDE desktop environment. The Pi does not have a great deal of processor speed or memory, but it does have enough resources to run LXDE and a handful of applications. So long as the user does not wish to do a lot at once, the Pi offers a fairly responsive desktop interface. I probably would not run heavier programs such as LibreOffice or Firefox on the Pi, but Raspbian does provide the Epiphany web browser and a few other desktop programs. Microsoft repository controversy[edit] In late January 2021, the Raspberry Pi OS package raspberrypi-sys-mods added a trusted GPG key and configuration entry in the APT package manager. This addition made it easier to install Visual Studio Code, a source code editor developed by Microsoft. This change initiated a query to Microsoft's package servers every time the system checked for updates. Given Microsoft's once-adversarial history with Linux, this form of telemetry upset some users. The changes were later removed. Versions[edit] Raspberry Pi OS is produced in three installation versions: Raspberry Pi OS Lite (32-bit & 64-bit) Raspberry Pi OS with desktop (32-bit & 64-bit) Raspberry Pi OS with desktop and recommended software (32-bit & 64-bit) Two legacy versions are recognized: Raspberry Pi OS Lite (Legacy) (32-bit) Raspberry Pi OS (Legacy) with desktop (32-bit) Raspberry Pi OS Lite is the smallest version, and does not include a desktop environment. The desktop version includes the Pixel desktop environment. Raspberry Pi OS with desktop and recommended software comes pre-installed with additional productivity software, such as Libre Office. On December 2, 2021, the Raspberry Pi Foundation released Raspberry Pi OS (Legacy), a branch of the operating system that continued to receive security and hardware compatibility updates but was based on Buster, an older version of Debian. All versions are distributed as disk image files, having the file extension img, intended to be flashed to microSD cards from which Raspberry Pi OS is booted. In March 2020, the Raspberry Pi Foundation published the Raspberry Pi Imager, a custom disk installer for Raspberry Pi OS, as well as other operating systems designed for the Raspberry Pi, including RetroPie, and Kodi OS, The Raspberry Pi documentation recommends at least a 4 GiB microSD card for Raspberry Pi OS Lite, and at least an 8 GiB microSD card for all other versions. Releases[edit] Release date Debian version Linux kernel GCC APT X Server / Labwc since 2024-07-04 Pi 1/1+ Pi 2 Pi 3 Pi Zero W Pi 3+ Pi 4 Pi Zero 2 W Pi 5 2013-09-27 7 (Wheezy) 3.6 4.7.2 0.9.7 7.7 2013-10-07 2013-12-24 3.10 2014-01-09 2014-06-22 3.12 2014-07-08 2014-09-12 2014-10-08 2014-12-25 2015-02-02 3.18 2015-02-17 2015-02-18 2015-05-07 2015-05-12 2015-09-28 8 (Jessie) 4.1 4.9 1.0.9.8.1 2015-11-24 2016-02-08 2016-02-09 2016-02-29 2016-03-18 2016-05-13 4.4 2016-05-31 2016-09-28 2016-11-29 2017-02-27 4.9 2017-03-03 2017-04-10 2017-06-23 2017-07-05 2017-08-17 9 (Stretch) 6.3 1.4.6 2017-09-08 2017-11-29 2018-03-13 2018-04-18 4.14 1.4.8 2018-06-29 2018-10-09 2018-11-13 2019-04-08 1.4.9 2019-06-24 10 (Buster) 4.19 8.3 1.8.2 2019-07-10 2019-09-30 2020-02-07 2020-02-14 2020-05-27 2020-08-20 5.4.51 2020-12-02 5.4.79 1.8.2.1 2021-01-11 5.4.83 1.8.2.2 2021-03-04 5.10.17 2021-05-07 1.8.2.3 2021-10-30 5.10.63 2021-12-03 11 (Bullseye) 10.2.1 2.2.4 1.20.11 2022-01-28 5.10.92 2022-03-08 5.10.103 2022-04-04 5.15.30 2022-09-06 5.15.61 2022-09-22 2023-02-21 5.15.84 2023-05-03 6.1.21 2023-12-05 2024-03-12 2023-10-10 12 (Bookworm) 12.2.0 2.6.1 1.21.1 2023-12-05 6.1.69 12.2.4 2024-03-15 6.6.20 12.2.0 1.21.1.7 2024-05-29 6.6.31 2024-07-04 6.6.51 0.7.2 Release date Debian version Linux Kernel GCC APT X Server / Labwc since 2024-07-04 Pi 1/1+ Pi 2 Pi 3 Pi Zero W Pi 3+ Pi 4 Pi Zero 2 W Pi 5 References[edit] Free and open-source software portalLinux portal ^ https://www.raspberrypi.com/software/operating-systems/. Retrieved 9 January 2025. {{cite web}}: Missing or empty |title= (help) ^ Introducing PIXEL - Raspberry Pi ^ a b \"Raspbian release notes\". Retrieved 24 February 2022. ^ a b \"Download Raspberry Pi OS for Raspberry Pi\". RaspberryPi.com. Mathematica and the Wolfram Language are included in this release under license and with permission of Wolfram Research, Inc. and may be used for non-commercial purposes only. ^ \"RaspbianAbout - Raspbian\". www.raspbian.org. Retrieved 2016-06-05. ^ \"Index of /raspbian/images/2012-07-15-wheezy-raspbian\". downloads.raspberrypi.com. Retrieved 2021-12-09. ^ \"RaspbianImages - Raspbian\". www.raspbian.org. Retrieved 2022-02-24. ^ a b c Piltch, Avram (2020-05-30). \"Raspberry Pi OS: Why It's No Longer Called 'Raspbian'\". Tom's Hardware. The official Pi operating system is now called 'Raspberry Pi OS.' ^ \"Raspberry Pi OS (64-bit)\". Raspberry Pi. 2022-02-02. Retrieved 2022-02-24. ^ Long, Simon (September 28, 2016). \"Introducing PIXEL - Raspberry Pi\". ^ Kabade, Rajat (2016-09-30). \"Raspberry Pi gets LXDE-based PIXEL desktop environment\". Open Source For You. Retrieved 2021-11-16. ^ \"Customise your Raspberry Pi desktop\". Raspberry Pi Foundation. Retrieved 26 April 2022. ^ Long, Simon (2016-09-28). \"Introducing PIXEL\". Raspberry Pi Blog. Retrieved 2021-01-20. ^ \"rpi-imager Stats\". rpi-imager-stats.raspberrypi.com. Retrieved 2021-02-21. ^ \"Unix Pioneer Ken Thompson Announces He's Switching From Mac To Linux - The FreeBSD Forums\". FreeBSD Forums. 2023-03-21. Retrieved 2024-10-30. ^ Smith, Jesse (22 June 2015). \"DistroWatch Weekly, Issue 615, 22 June 2015\". DistroWatch. Retrieved 19 June 2018. ^ a b Salter, Jim (2021-02-08). \"Raspberry Pi OS added a Microsoft repo. No, it's not an evil secret\". Ars Technica. Retrieved 2022-02-24. ^ \"Raspberry Pi | Microsoft Visual Studio Code APT repository automatically added · Issue #4083 · MichaIng/DietPi\". GitHub. Retrieved 2022-02-24. ^ \"Remove MS repo · RPi-Distro/raspberrypi-sys-mods@ed96790\". GitHub. Retrieved 2021-09-06. ^ \"\"New\" old functionality with Raspberry Pi OS (Legacy)\". Raspberry Pi. 2021-12-02. Retrieved 2022-02-24. ^ Hollingworth, Gordon (2020-03-05). \"Introducing Raspberry Pi Imager, our new imaging utility\". Raspberry Pi Blog. Retrieved 2021-02-02. ^ RetroPie ^ \"Raspberry Pi Documentation - Getting Started\". www.raspberrypi.com. Retrieved 2022-02-24. External links[edit] Official website Raspberry Pi OS on DistroWatch vteLinux distributionsAndroidLineageOS /e/ CalyxOS CrDroid iodéOS Replicant Other Android-x86 Celadon ColorOS EMUI Fire OS GrapheneOS One UI Paranoid Android Resurrection Remix OS OmniROM Arch ArchBang Artix BlackArch EndeavourOS Frugalware Garuda Hyperbola GNU LinHES Manjaro Parabola GNU SteamOS (3.0 onwards) SystemRescue DebianUbuntu Official: Edubuntu Kubuntu Lubuntu Ubuntu Budgie Ubuntu Cinnamon Ubuntu Kylin Ubuntu MATE Ubuntu Studio Ubuntu Unity Xubuntu Derivatives: BackBox Bodhi Linux elementary OS Emmabuntüs KDE neon Freespire Linux Lite Linux Mint LXLE Linux Nova OS Peppermint OS Pop! OS Trisquel Ubuntu Touch Uruk Wubuntu Zorin OS Other antiX Astra Bharat Operating System Solutions BlankOn Linux Commodore OS Damn Small Linux deepin Devuan Elive Endless OS FreedomBox Kaisen Kali Kanotix Knoppix MX Linux Parrot OS PureOS Raspberry Pi OS Q4OS Slax SparkyLinux SolydXK Tails Tizen UOS Whonix FedoraCentOS Stream AlmaLinux EulerOS MIRACLE LINUX Oracle Linux Red Hat Enterprise Linux Rocky Linux Other Asahi Linux Network Security Toolkit Nobara Qubes OS Red Star OS Sailfish OS Gentoo Calculate Linux ChromiumOS ChromeOS Pentoo Mandrake ALT Linux PCLinuxOS Mandriva Mageia OpenMandriva Lx ROSA Linux Slackware Austrumi Linux Porteus Salix OS Slax Zenwalk SUSE openSUSE SUSE Linux Enterprise Open Enterprise Server GeckoLinux Other 4MLinux Alpine CHAOS Chimera Linux Clear Linux OS CRUX Kwort GoboLinux Guix SD KaiOS KaOS NixOS Puppy Source Mage Solus T2 SDE Tiny Core Linux Void DiscontinuedAndroid CyanogenMod DivestOS MIUI PixelExperience Remix OS Arch ArchLabs Antergos Chakra Debian Ubuntu: Asturix Black Lab Linux Cub Linux Gobuntu gOS Linux Caixa Mágica LinuxTLE Pinguy OS Sabily Ubuntu GNOME Other derivatives: BackTrack Corel Linux CrunchBang Linux DoudouLinux Dreamlinux Feather Linux gNewSense HandyLinux Libranet Musix GNU+Linux Parsix SteamOS (1.0–2.0) Sunwah Linux Gentoo Container Linux Sabayon Linux xB Machine Red Hat/Fedora BLAG Linux and GNU CentOS ClearOS Linpus Linux Korora Linux for PlayStation 2 Scientific Linux Red Hat Linux Rocks Cluster Distribution Think Blue Linux Turbolinux Vine Linux Yellow Dog Linux Slackware Absolute Linux BioSLAX Damn Vulnerable Linux KateOS Kongoni NimbleX Platypux TopologiLinux VectorLinux SUSE SUSE Studio Express Other Caldera OpenLinux DemoLinux Familiar Linux Firefox OS B2G OS Floppyfw Foresight Linux Immunix Jurix Linux Router Project MCC Interim Linux MeeGo Mer Mobilinux Nitix OpenELEC Softlanding Linux System Splashtop OS Turkix List Linux portal Comparison Category"
    }
]