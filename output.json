[
    {
        "id": 1,
        "url": "https://el.wikipedia.org/wiki/Python",
        "title": "Python",
        "content": "Το λογότυπο της Python Η Python είναι διερμηνευόμενη (interpreted), γενικού σκοπού (general-purpose) και υψηλού επιπέδου, γλώσσα προγραμματισμού. Ανήκει στις γλώσσες προστακτικού προγραμματισμού (Imperative programming) και υποστηρίζει τόσο το διαδικαστικό (procedural programming) όσο και το αντικειμενοστρεφές (object-oriented programming) προγραμματιστικό υπόδειγμα (programming paradigm). Είναι δυναμική γλώσσα προγραμματισμού (dynamically typed) και υποστηρίζει συλλογή απορριμμάτων (garbage collection ή GC). Δημιουργήθηκε από τον Ολλανδό Γκίντο βαν Ρόσσουμ (Guido van Rossum) στο ερευνητικό κέντρο Centrum Wiskunde & Informatica (CWI) το 1989 και κυκλοφόρησε για πρώτη φορά το 1991. Ο κύριος στόχος της είναι η αναγνωσιμότητα του κώδικά της και η ευκολία χρήσης της. Το συντακτικό της επιτρέπει στους προγραμματιστές να εκφράσουν έννοιες σε λιγότερες γραμμές κώδικα από ό,τι θα ήταν δυνατόν σε γλώσσες όπως η C++ ή η Java. Διακρίνεται λόγω του ότι έχει πολλές βιβλιοθήκες που διευκολύνουν ιδιαίτερα αρκετές συνηθισμένες εργασίες και για την ταχύτητα εκμάθησης της. Μειονεκτεί στο ότι επειδή είναι διερμηνευόμενη είναι πιο αργή από τις μεταγλωττιζόμενες (compiled) γλώσσες όπως η C και η C++. Για αυτόν τον λόγο δεν είναι κατάλληλη για γραφή λειτουργικών συστημάτων. Οι διερμηνευτές της Python είναι διαθέσιμοι για εγκατάσταση σε πολλά λειτουργικά συστήματα, επιτρέποντας στην Python την εκτέλεση κώδικα σε ευρεία γκάμα συστημάτων. Χρησιμοποιώντας εργαλεία τρίτων, όπως το Py2exe ή το Pyinstaller, ο κώδικας της Python μπορεί να πακεταριστεί σε αυτόνομα εκτελέσιμα προγράμματα για μερικά από τα πιο δημοφιλή λειτουργικά συστήματα, επιτρέποντας τη διανομή του βασισμένου σε Python λογισμικού για χρήση σε αυτά τα περιβάλλοντα χωρίς να απαιτείται εγκατάσταση του διερμηνευτή της Python. Η Python αναπτύσσεται ως ανοιχτό λογισμικό (open source) και η διαχείρισή της γίνεται από τον μη κερδοσκοπικό οργανισμό Python Software Foundation. Ο κώδικας διανέμεται με την άδεια Python Software Foundation License η οποία είναι συμβατή με την GPL. Το όνομα της γλώσσας προέρχεται από την ομάδα των Άγγλων κωμικών Μόντυ Πάιθον και δεν έχει καμιά σχέση με το φίδι πύθωνα, παρότι το λογότυπό της παραπέμπει σε κάτι τέτοιο. Ιστορικό[Επεξεργασία | επεξεργασία κώδικα] Η Python δημιουργήθηκε από τον Γκίντο βαν Ρόσσουμ στο ερευνητικό κέντρο Centrum Wiskunde & Informatica (CWI) το 1989. Αρχικά, η Python ήταν γλώσσα σεναρίων που χρησιμοποιήθηκε στο κατανεμημένο λειτουργικό σύστημα Amoeba, ικανή και για κλήσεις συστήματος. Θεωρείται διάδοχος της γλώσσας προγραμματισμού ABC, μια και αυτή υπήρξε η βασική πηγή έμπνευσης για τον Γκίντο βαν Ρόσσουμ. Η Python 2.0 κυκλοφόρησε στις 16 Οκτωβρίου του 2000. Στις 3 Δεκεμβρίου 2008 κυκλοφόρησε η έκδοση 3.0 (γνωστή και ως py3k ή python 3000). Πολλά από τα καινούργια χαρακτηριστικά αυτής της έκδοσης έχουν μεταφερθεί στις εκδόσεις 2.6 και 2.7 που είναι προς τα πίσω συμβατές. Η Python 3.0 είναι ιστορικά η πρώτη γλώσσα προγραμματισμού που σπάει την προς τα πίσω συμβατότητα με προηγούμενες εκδόσεις ώστε να διορθωθούν κάποια λάθη που υπήρχαν σε προγενέστερες εκδόσεις και να καταστεί ακόμα πιο σαφής ο απλός τρόπος με τον οποίο μπορούν να γίνουν κάποια πράγματα. Η Python 3.0 συνοδεύεται με το πρόγραμμα 2to3.py, που επιτρέπει την μετατροπή κώδικα της έκδοσης 2.0 σε 3.0. Ο Γκίντο βαν Ρόσσουμ, πρωτοστατούσε στην κοινότητα της Python μέχρι τον Ιούλιο του 2018, οπότε και παραιτήθηκε, για να συνεχίσει μόνο ως μέλος του Διοικητικού Συμβουλίου. Η πιο πρόσφατη έκδοση είναι η 3.13 και δημοσιεύτηκε στις 8 Μαΐου 2024 Διερμηνευτής[Επεξεργασία | επεξεργασία κώδικα] Για να εκτελεστούν διαδραστικά (interactively) μεμονωμένες εντολές ή προγράμματα είναι απαραίτητη η εγκατάσταση του διερμηνευτή της Python, ο οποίος είναι ελεύθερα διαθέσιμος για «κατέβασμα» (download) από τον επίσημο ιστότοπό της (www.python.org). Για Microsoft Windows υπάρχουν εκδόσεις των 32 ή 64 bits. Στα λειτουργικά συστήματα Linux και Mac OS X συνηθίζεται να είναι προεγκατεστημένη, πιθανότατα όμως να είναι μια παλαιότερη έκδοσή της. IDLE[Επεξεργασία | επεξεργασία κώδικα] Κύριο λήμμα: IDLE (Python) Για τη συγγραφή προγραμμάτων είναι απαραίτητος ένας κειμενογράφος ή ακόμα καλύτερα ένα ολοκληρωμένο περιβάλλον ανάπτυξης (Integrated Development Environment - IDE), το οποίο είναι ένα ειδικό λογισμικό για την ανάπτυξη εφαρμογών. Η Python έρχεται μαζί με ένα εύχρηστο και απλό περιβάλλον ανάπτυξης με την ονομασία ΙDLE. Τα αρχικά του προέρχονται από τις λέξεις Interactive DeveLopment Environment και είναι γραμμένο σε Python από τον Γκίντο βαν Ρόσσουμ. Χρησιμοποιεί τη βιβλιοθήκη γραφικών Tkinter, οπότε μπορεί να εκτελεσθεί σε περιβάλλον Linux, Windows και Mac OS X. Το IDLE μας δίνει τη δυνατότητα να χρησιμοποιήσουμε διαδραστικά τον διερμηνευτή της γλώσσας, να γράψουμε και να επεξεργαστούμε προγράμματα, να τα αποθηκεύσουμε σε αρχεία, να τα εκτελέσουμε, να κάνουμε αποσφαλμάτωση (debugging). Δομή και σύνταξη[Επεξεργασία | επεξεργασία κώδικα] Η γλώσσα χρησιμοποιεί διερμηνέα (interpreter) για την δημιουργία του εκτελέσιμου κώδικα. Ονοματοδοσία μεταβλητών[Επεξεργασία | επεξεργασία κώδικα] Τα ονόματα που λαμβάνουν οι μεταβλητές υπόκεινται στους εξής κανόνες: Είναι λέξεις που αποτελούνται από αλφαριθμητικούς χαρακτήρες (γράμματα και αριθμούς) και την κάτω παύλα (underscore, \"_\"). Μπορεί να αρχίζει με αλφαβητικό χαρακτήρα ή κάτω παύλα (_). Δεν επιτρέπεται να αρχίζει με αριθμό (π.χ. var4_1 είναι σωστό, αλλά το 4var_1 είναι λάθος). Υπάρχει διάκριση πεζών και κεφαλαίων γραμμάτων (case sensitivity), οπότε και οι μεταβλητές διαφοροποιούνται λόγω πεζών ή κεφαλαίων (π.χ. άλλη η μεταβλητή Var και άλλη η var). Δεν επιτρέπονται δεσμευμένες λέξεις (λέξεις-κλειδιά, keywords), δηλαδή λέξεις με ιδιαίτερη σημασία (idetifiers), όπως print, type, False, float, None, κλπ. Η Python έχει 33 λέξεις-κλειδιά. Μπορούν να χρησιμοποιηθούν και ελληνικά ή άλλης γλώσσας γράμματα, αλλά δεν συνίσταται γιατί δημιουργείται δυσανάγνωστος κώδικας. Τύποι δεδομένων[Επεξεργασία | επεξεργασία κώδικα] Οι τύποι δεδομένων της Python διακρίνονται στους αρχέγονους (primitive data type), στις πιο σύνθετες δομές δεδομένων (λίστες, πλειάδες, σύνολα, λεξικά) και, λόγω των αντικειμενοστρεφών δυνατοτήτων της, στις κλάσεις (classes). Λόγω του ότι η Python είναι δυναμική γλώσσα δεν δηλώνονται οι τύποι των μεταβλητών πριν χρησιμοποιηθούν. Ο τύπος που τους αποδίδεται εξαρτάται από την τιμή που θα πάρουν κατά την διάρκεια της εκτέλεσης του προγράμματος. Όταν χρησιμοποιηθεί (π.χ. σε έκφραση ή συνάρτηση) πρέπει να έχει πάρει τιμή γιατί ο διερμηνευτής (interpreter) δίνει λάθος που το ονομάζει NameError. Για αυτόν τον λόγο η Python υποστηρίζει τον ιδιαίτερο τύπο NoneType (βλ. παρακάτω). Αρχέγονοι (primitive) τύποι δεδομένων[Επεξεργασία | επεξεργασία κώδικα] Οι αρχέγονοι τύποι είναι: int (ακέραιος). Στην Python οι ακέραιοι μπορούν να είναι οσοδήποτε μεγάλοι. float (κινητής υποδιαστολής) str(συμβολοσειρά ή string). Είναι ακολουθία χαρακτήρων που περικλείονται από μονά ή διπλά εισαγωγικά. Σε ειδικές περιπτώσεις μπορεί να γίνει χρήση τριπλών εισαγωγικών (μονών :''' ή διπλών: \"\"\"). bool. Ο λογικός τύπος (Boolean) μεταβλητής με τιμές True ή False. NoneType . Αυτός ο τύπος μεταβλητής παίρνει την τιμή None με ανάθεση (assignment, = None) και αντιμετωπίζεται, στον σχεδιασμό του προγράμματος, σαν μεταβλητή που δεν έχει τιμή. None επιστρέφουν και οι συναρτήσεις που δεν επιστρέφουν τιμή (δεν έχουν return <έκφραση>), όπως για παράδειγμα η print(). Δεν έχει μεταβλητή τύπου Character (όπως για παράδειγμα η C/C++). Σε αυτή την περίπτωση χρησιμοποιείται η μεταβλητή String με ένα χαρακτήρα. Η συνάρτηση type() μας επιστρέφει τον τύπο της μεταβλητής. Αν η μεταβλητή δεν έχει πάρει τιμή μας επιστρέφει NoneType. Ενσωματωμένες δομές δεδομένων[Επεξεργασία | επεξεργασία κώδικα] Οι ενσωματωμένες δομές δεδομένων στην Python είναι η Λίστα (List), η Πλειάδα (Tuple), τo Σύνολo (Set) και το Λεξικό (Dictionary). Λίστα (list)[Επεξεργασία | επεξεργασία κώδικα] Η λίστα υλοποιεί τον γνωστό αφηρημένο τύπο δεδομένων. Μοιάζει με την δομή του πίνακα (array), αλλά σε αντίθεση με αυτόν μπορεί να περιέχει ανομοιογενή αντικείμενα (items) ή αλλιώς στοιχεία (elements), τα οποία μπορεί να είναι οποιαδήποτε δομή δεδομένων (ακόμα και λίστα). Όπως στους πίνακες τα στοιχεία είναι διατεταγμένα σε συγκεκριμένη σειρά, προσπελάσιμα με δείκτες και επιτρέπεται η επανάληψη τους. Ορίζεται με ένα ζευγάρι τετραγωνισμένων αγκύλων [] και με τα στοιχεία να χωρίζονται μεταξύ τους με κόμμα, π.χ. η ακολουθία [ <στοιχείο1>, ..., <στοιχείοΝ> ] ορίζει μια λίστα Ν στοιχείων. Μπορεί να οριστεί μια κενή λίστα μόνο με τις αγκύλες και χωρίς περιεχόμενο. Επειδή η συμβολοσειρά (string) αποτελεί μια διατεταγμένη ακολουθία χαρακτήρων μοιάζει με λίστα και χρησιμοποιεί παρόμοιους τελεστές (operators) και συναρτήσεις (methods). Η μεγάλη διαφορά τους είναι ότι η λίστα είναι δυναμικός ή αλλιώς μεταβλητός (mutable) τύπος δεδομένων, ενώ η συμβολοσειρά στατικός ή αλλιώς αμετάβλητος (immutable) τύπος δεδομένων. Στη λίστα μπορούμε να αλλάξουμε τα στοιχεία που περιέχει. Στη συμβολοσειρά η αλλαγή των χαρακτήρων που περιέχει γίνεται μόνο με αντικατάσταση (overwriting) μέσω ανάθεσης (assignment) από νέα συμβολοσειρά. Πλειάδα (tuple)[Επεξεργασία | επεξεργασία κώδικα] Η πλειάδα υλοποιεί την αντίστοιχη μαθηματική έννοια της πλειάδας. Είναι μια πεπερασμένη ακολουθία στοιχείων διατεταγμένων σε συγκεκριμένη σειρά και μοιάζει πολύ με την λίστα (list). Ορίζεται με ένα ζευγάρι παρενθέσεων () και με τα στοιχεία να χωρίζονται μεταξύ τους με κόμμα, π.χ. η ακολουθία ( <στοιχείο1>, ..., <στοιχείοΝ> ) ορίζει μια πλειάδα Ν στοιχείων. Αν το επιτρέπουν τα συμφραζόμενα μπορούν να παραληφθούν οι παρενθέσεις. Διαφέρει από την δομή της λίστας στο ότι η πλειάδα είναι στατική ή αλλιώς αμετάβλητη (immutable) δομή δεδομένων. Αφού δημιουργηθεί δεν μπορεί να μεταβληθεί. Η χρήση της πλειάδας είναι προτιμότερη από της λίστας όταν δεν χρειάζεται να αλλάξουμε τα στοιχεία της γιατί θεωρητικά είναι αποτελεσματικότερη σε ταχύτητα στις διάφορες λειτουργίες της. Η πλειάδα που περιέχει ένα στοιχείο ορίζεται πάντα με ένα κόμμα μετά το στοιχείο, π.χ. ( <στοιχείο>, ), διότι οι παρενθέσεις χρησιμοποιούνται και στην ομαδοποίηση των εκφράσεων (expressions) και η γραφή χωρίς κόμμα, π.χ. = ( <στοιχείο> ) λαμβάνεται από τον διερμηνευτής (interpreter) ως ανάθεση (assignment), δηλαδή = <στοιχείο>. Λεξικό (dictionary)[Επεξεργασία | επεξεργασία κώδικα] To λεξικό (dictionary) είναι μια δομή δεδομένων για την αποθήκευση ζευγαριών τιμών της μορφής κλειδί : τιμή (key : value). Ορίζεται με ένα ζευγάρι αγκύλων {} και με τα ζευγάρια να χωρίζονται μεταξύ τους με κόμμα, π.χ. η ακολουθία { κλειδί1 : τιμή1, ..., κλειδίΝ : τιμήΝ } ορίζει ένα λεξικό Ν ζευγαριών. Ανάμεσα στο κλειδί και την τιμή υπάρχει η άνω-κάτω τελεία (:). Τα κλειδιά πρέπει να είναι μοναδικά γιατί χρησιμεύουν στην προσπέλαση της αντίστοιχης τιμής. Τα κλειδιά πρέπει να είναι στατικοί ή αλλιώς αμετάβλητοι (immutable) τύποι δεδομένων, όπως ακέραιοι αριθμοί, συμβολοσειρές, αμετάβλητες πλειάδες (όταν όλα τα στοιχεία της πλειάδας είναι αμετάβλητα). Ανάθεση τιμών (assignment)[Επεξεργασία | επεξεργασία κώδικα] Επειδή η Python είναι δυναμική γλώσσα προγραμματισμού (dynamically typed) διαφέρει από τις άλλες παραδοσιακές γλώσσες προστακτικού προγραμματισμού (Imperative programming) στον τρόπο που γίνεται η ανάθεση τιμών στις μεταβλητές της. Συνήθως οι μεταβλητές δηλώνονται πριν τους ανατεθούν τιμές και μαζί δηλώνεται και ο τύπος τους (interer, floating point, character, κλπ.). Στην Python οι μεταβλητές δηλώνονται μαζί με την ανάθεση των τιμών σε αυτές (ακόμα και όταν τους δοθεί η τιμή None) και δεν είναι δεσμευμένες σε κάποιο συγκεκριμένο τύπο δεδομένων. Μία μεταβλητή μπορεί να είναι ακεραία (integer) και η ίδια στη συνέχεια να γίνει συμβολοσειρά (string) αν της ανατεθεί τιμή συμβολοσειράς. Στην Python, όταν κατά την εκτέλεση ενός προγράμματος, αναθέτουμε τιμή σε μια μεταβλητή x, π.χ. x = 2, η τιμή 2 αντιγράφεται σε χώρο μνήμης πού δεσμεύεται (memory allocation), μαζί με άλλες ιδιότητες, όπως π.χ. ότι ο τύπος της είναι ακέραιος (integer). Στην μεταβλητή x αποδίδεται η διεύθυνση (memory address) αυτής της θέσης στην μνήμη. Η μεταβλητή λειτουργεί σαν δείκτης (pointer). Η ίδια η μεταβλητή δεν έχει κάποια τιμή ή τύπο δεδομένων, αλλά έχει τη θέση της μνήμης που «αντιπροσωπεύει». Σε ένα πρόγραμμα μετά την ανάθεση x = 2 (η μεταβλητή είναι τύπου integer), στην συνέχεια της εκτέλεσης μπορεί να εκτελεστεί η ανάθεση x = \"hellow world\", οπότε η μεταβλητή «αντιπροσωπεύει» την συμβολοσειρά \"hellow world\" (είναι τύπου string). Στην δεύτερη ανάθεση η τιμή 2 δεν «αντιπροσωπεύεται» από κάποια μεταβλητή (δεν χρειάζεται πλέον στο πρόγραμμα) και ο συλλέκτης απορριμμάτων (garbage collector), της Python, αναλαμβάνει «αυτόματα» να αποδεσμεύσει (memory de-allocation) τον χώρο της μνήμης που αυτή κατέχει. Εσοχές (indentation)[Επεξεργασία | επεξεργασία κώδικα] Η στοίχιση στα αριστερά ή αλλιώς οι αριστερές εσοχές (indentation) έχουν μεγάλη σημασία γιατί ορίζουν τα block (ομαδοποίηση) του κώδικα. Αυτό σε άλλες γλώσσες, όπως C και Java επιτυγχάνεται με την χρήση των αγκύλων { }. Στην Python το block κώδικα αρχίζει εκεί που η αριστερή εσοχή αυξάνεται προς τα δεξιά και τελειώνει εκεί που καταργείται η εσοχή. Εσοχή μέσα σε εσοχή σημαίνει block μέσα σε block (nested blocks). Η εσοχή μπορεί να είναι οσοδήποτε μεγάλη ή μικρή - του ίδιου πάντα μεγέθους - αλλά συνίσταται η χρήση 4 κενών χαρακτήρων (spacebars) για ευκολότερη αναγνωσιμότητα του κώδικα. Για παράδειγμα μια εμφωλιασμένη εντολή if ορίζεται ως εξής:if <λογική έκφραση1> : εντολή1 εντολή2 if <λογική έκφραση2> : εντολή3 εντολή4 ενολή5 εντολή6 Το block της πρώτης if περιέχει τις εντολή1, εντολή2, την δεύτερη if και τελειώνει με την εντολή5. Η εντολή6 είναι εκτός block (δεν ανήκει στην εξωτερική if). Η εσωτερική if (εμφωλιασμένη) με την δική της εσοχή ορίζει ένα block (που περιέχει την εντολή3 και εντολή4) μέσα στο block της εξωτερικής if. Τελεστές[Επεξεργασία | επεξεργασία κώδικα] Τελεστές πράξεων[Επεξεργασία | επεξεργασία κώδικα] Υποστηρίζει τους γνωστούς, με τις άλλες γλώσσες προγραμματισμού, τελεστές (operators), όπως τους +, -, *, /,**, %, που όμως έχουν κάποιες διαφοροποιήσεις ανάλογα με τους τελεστέους (operands), δηλαδή τον τύπο των μεταβλητών, όπου εφαρμόζονται (πολυμορφισμός). Ο τελεστής της πρόσθεσης + όταν οι τελεστέοι είναι Strings εκτελεί την πράξη της συνένωσης (concatenation) και ο πολλαπλασιασμός * την πράξη της αναπαραγωγής (replication) του String όταν αυτό πολλαπλασιάζεται με ακέραιο (integer). Δηλαδή η έκφραση (expression): \"abc\" + \"def\" έχει ως αποτέλεσμα \"abcdef\" και η \"abc\" * 3 ή 3 * \"abc\" έχει ως αποτέλεσμα \"abcabcabc\" αντίστοιχα. Τελεστές λογικής[Επεξεργασία | επεξεργασία κώδικα] Υποστηρίζει τους λογικούς τελεστές and, or και not για μεταβλητές τύπου Boolean. Τα εμφωλιασμένα (nested) not αποδίδονται ως διπλή άρνηση (άρνηση στην άρνηση). Η σειρά (προτεραιότητα) εκτέλεσης είναι not, and, or. Εμβέλεια ονομάτων οντοτήτων (scope)[Επεξεργασία | επεξεργασία κώδικα] Στις οντότητες ή αντικείμενα (μεταβλητές, συναρτήσεις, κλάσεις, κλπ.), που δημιουργούνται σε ένα πρόγραμμα, για να μπορούν να χρησιμοποιηθούν (προσπελαστούν), αποδίδονται ονόματα (name binding). Για παράδειγμα στην Python μια οντότητα, όπως είναι μια μεταβλητή, δεν δηλώνεται, αλλά δημιουργείται και ονοματίζεται όταν της γίνει ανάθεση (assignment) κάποιας τιμής. Οντότητες που δημιουργούνται μέσα σε ένα block κώδικα, όπως το σώμα μιας συνάρτησης, μιας εντολής if ή for, κλπ., έχουν περιορισμένη εμβέλεια και μπορούν να χρησιμοποιηθούν μόνο μέσα στο block που έχουν ονομαστεί. Ένα τέτοιο όνομα δεν είναι προσπελάσιμο εκτός του block ακόμα και αν έχει την ίδια ονομασία και λέγεται ότι είναι τοπικής εμβέλειας (local scope). Ένα όνομα που δηλώνεται στο κύριο σώμα (block) του προγράμματος μπορεί να προσπελαστεί σε ολόκληρο το πρόγραμμα, ακόμα και στα block που έχουν οριστεί μέσα στο πρόγραμμα και λέγεται ότι είναι καθολικής εμβέλειας (global scope). Μέσα σε ένα block ο διερμηνευτής (interpreter) χρησιμοποιεί την τοπική ονομασία μιας οντότητας ακόμα και αν υπάρχει άλλη με την ίδια ονομασία και καθολική εμβέλεια. Συγκεκριμένα ο διερμηνευτής όταν συναντήσει ένα όνομα (π.χ. μεταβλητής) μέσα σε ένα block ελέγχει πρώτα αν έχει δημιουργηθεί αυτό το όνομα μέσα στο block (οπότε είναι τοπικής εμβέλειας) και το χρησιμοποιεί, έστω και αν υπάρχει ίδια ονομασία εκτός του block (καθολικής εμβέλειας). Αν δεν το βρει μέσα στο block τότε και μόνο τότε ελέγχει αν υπάρχει τέτοια ονομασία που να έχει δημιουργηθεί στο κύριο μέρος του προγράμματος (είναι καθολικής εμβέλειας) και χρησιμοποιεί αυτήν. Δηλαδή μια καθολικής εμβέλειας μεταβλητή χρησιμοποιείται μέσα σε ένα block, μόνο αν δεν υπάρχει τοπικής εμβέλειας μεταβλητή με το ίδιο όνομα, μέσα στο block. Δήλωση global[Επεξεργασία | επεξεργασία κώδικα] Όταν μέσα σε ένα block γίνει η ανάθεση num = 123, τότε δημιουργείται (αναγκαστικά) η τοπικής εμβέλειας μεταβλητή num ακόμα και αν υπάρχει καθολικής εμβέλειας num. Στην περίπτωση που δεν είναι επιθυμητό να δημιουργηθεί η τοπική num, αλλά η τιμή 123 να ανατεθεί στην καθολική num γίνεται χρήση της δήλωσης global. Δηλώνοντας global num, πριν από την num = 123, ο διερμηνευτής δεν δημιουργεί τοπική num, αλλά δίνει την τιμή 123, στην καθολική που ήδη υπάρχει. Παράδειγμα προγράμματος[Επεξεργασία | επεξεργασία κώδικα] Ένα από τα πιο απλά προγράμματα στην γλώσσα Python είναι η εμφάνιση ενός γραπτού αποτελέσματος (π.χ. Hello, world!): >>> print(\"Hello, world!\") Hello, world! Ένα ιδιαίτερο χαρακτηριστικό της γλώσσας είναι η χρήση κενών διαστημάτων σαν εσοχές (whitespace) για τον διαχωρισμό των συντακτικών δομών (block of code) του προγράμματος, σε αντίθεση με την πρακτική σε άλλες γλώσσες όπου για τον ίδιο σκοπό χρησιμοποιούνται ειδικά σύμβολα (π.χ. αγκύλες). Αυτό, σε συνδυασμό με το ότι χρησιμοποιεί πλήρεις αγγλικές λέξεις στη θέση συμβόλων, καθιστούν τον κώδικα της Python ευανάγνωστο από όσους έχουν βασική γνώση των αγγλικών. age = 21 if age >= 18: print(\"You vote\") else: print(\"You don't vote\") Διαδικαστικός προγραμματισμός[Επεξεργασία | επεξεργασία κώδικα] Για παράδειγμα, ο παρακάτω γεννήτορας (generator) generate_primes παράγει πρώτους αριθμούς: from itertools import count def generate_primes(stop_at=None): primes = [] for n in count(2): if stop_at is not None and n > stop_at: return composite = False for p in primes: if not n % p: composite = True break elif p**2 > n: break if not composite: primes.append(n) yield n Και για να καλέσουμε τη συνάρτηση, υπολογίζοντας τους πρώτους αριθμούς από το 1 στο 100: for i in generate_primes(): if i > 100: break print(i) Αντικειμενοστρεφής προγραμματισμός[Επεξεργασία | επεξεργασία κώδικα] Παράδειγμα αντικειμενοστρεφούς προγράμματος γραμμένο σε Python, το οποίο παρουσιάζει μια κλάση Υπάλληλος: class Employee: def __init__(self, id, name, position): self.id = id; self.name = name; self.position = position; def printEmployee(self): print(self.id, \"|\", self.name, \"|\", self.position); e1 = Employee(1230, \"Νικόλαος Παπαγεωργού\", \"Βοηθός Προγραμματιστή\"); e1.printEmployee(); Εκπαίδευση[Επεξεργασία | επεξεργασία κώδικα] Η Python ενδείκνυται ως γλώσσα εισαγωγική στον προγραμματισμό και στην επιστήμη των υπολογιστών γενικότερα, με δεδομένη την απλότητα στη σύνταξή της. Διεθνώς πολλά πανεπιστήμια αλλά και η δευτεροβάθμια εκπαίδευση σε πολλές χώρες, υιοθετούν μια python first προσέγγιση εισαγωγής στον προγραμματισμό. Στη δευτεροβάθμια εκπαίδευση της χώρας μας το πρώτο βήμα έγινε με τα Επαγγελματικά Λύκεια στα οποία έχει εισαχθεί στο σχετικό μάθημα (πηγή: Αράπογλου, κ.α.2017). Επίσης, η Python χρησιμοποιείται ως εργαλείο για εισαγωγή σε βασικές έννοιες των υπολογιστών, (βλέπε για παράδειγμα: Avouris et al. 2017), ενώ η Python έχει υποστηρίξει με επιτυχία οικοδομιστικές προσεγγίσεις στη μάθηση, σε επί μέρους αντικείμενα, όπως σε media studies (βλέπε Guzdial, 2004). Άλλες προτεινόμενες προσεγγίσεις είναι η χρήση της Python για διαχείριση δεδομένων, για μελέτες σε ανθρωπιστικές σπουδές, για γεωγραφικά συστήματα πληροφοριών, κλπ. Υπάρχει διαθέσιμο πλούσιο υλικό και στην Ελληνική γλώσσα, πέραν της διεθνούς βιβλιογραφίας και πηγών. Για παράδειγμα στις ιστοσελίδες διαδικτυακών μαθημάτων mathesis.cup.gr και coursity.gr υπάρχουν διαδικτυακά μαθήματα εισαγωγής στον προγραμματισμό με Python, το περιεχόμενο των οποίων διατίθεται ελεύθερα. Στο mathesis.cup.gr υπάρχει μάθημα προχωρημένου προγραμματισμού με Python. Επίσης οργανώνονται από σύμπραξη Ελληνικών Πανεπιστημίων και την υποστήριξη της ΕΛΛΑΚ θερινά σχολεία στην Python. Παραπομπές[Επεξεργασία | επεξεργασία κώδικα] ↑ «Programming Language Trends - O'Reilly Radar». Radar.oreilly.com. 2 Αυγούστου 2006. Ανακτήθηκε στις 17 Ιουλίου 2013. ↑ «The RedMonk Programming Language Rankings: January 2013 – tecosystems». Redmonk.com. 28 Φεβρουαρίου 2013. Ανακτήθηκε στις 17 Ιουλίου 2013. ↑ 3,0 3,1 Αγγελιδάκης, Ν., βλ. πηγές σελ. 5 (σελ. 14 του pdf) ↑ 4,0 4,1 4,2 4,3 4,4 4,5 4,6 Αγγελιδάκης, Ν., βλ. πηγές σελ. 7 (σελ. 16 του pdf) ↑ (Αγγλικά) «The Making of Python: A Conversation with Guido van Rossum, Part I by Bill Venners» στο artima.com. Δημοσιεύθηκε 13/01/2003. Αρχειοθετήθηκε 19/02/2019. Ανακτήθηκε 27/04/2019. ↑ Summerfield, Mark. Rapid GUI Programming with Python and Qt. Python is a very expressive language, which means that we can usually write far fewer lines of Python code than would be required for an equivalent application written in, say, C++ or Java ↑ McConnell, Steve (30 Νοεμβρίου 2009). Code Complete, p. 100. ISBN 9780735636972. ↑ 8,0 8,1 Αγγελιδάκης, Ν., βλ. πηγές, σελ. 6 (σελ. 15 του pdf) ↑ «PyInstaller Home Page». Αρχειοθετήθηκε από το πρωτότυπο στις 8 Ιουλίου 2014. Ανακτήθηκε στις 27 Ιανουαρίου 2014. ↑ (Αγγλικά) «History of Python» από python-course.eu. Αρχειοθετήθηκε 29/08/2017. Ανακτήθηκε 27/04/2019. ↑ «2to3 - Automated Python 2 to 3 code translation — Python 3.7.4 documentation». docs.python.org (στα Αγγλικά). Ανακτήθηκε στις 14 Σεπτεμβρίου 2019. ↑ (Αγγλικά) «Python 2to3 windows CMD» στο stackoverflow.com. Ανακτήθηκε 2019-09-14. ↑ (Αγγλικά) Carlie Fairchild. «Guido van Rossum Stepping Down from Role as Python's Benevolent Dictator For Life» στο www.linuxjournal.com. Δημοσιεύθηκε 12/07/2018. Αρχειοθετήθηκε 27/03/2019. Ανακτήθηκε 15/04/2019. ↑ (Αγγλικά) «Python boss Guido van Rossum steps down after 30 years» στο www.theinquirer.net. Αρχειοθετήθηκε 19/02//2019. Ανακτήθηκε 15/04/2019. ↑ Αγγελιδάκης, Ν., βλ. πηγές σελ. 11 (σελ. 20 του pdf) ↑ Αγγελιδάκης, Ν., βλ. πηγές σελ. 13 (σελ. 22 του pdf) ↑ 17,0 17,1 17,2 «Μαθήματα Προγραμματισμού Python. Μάθημα 2ο» του Γιάννη Φυτίλη στο pcsteps.gr. Δημοσιεύθηκε 27/09/2017. Αρχειοθετήθηκε 23/04/2019. Ανακτήθηκε 23/04/2019. ↑ 18,0 18,1 18,2 18,3 18,4 Μιχάλης Πλεξουσάκης, 2016. «Γλώσσα προγραμματισμού python3 - Μεταβλητές - Ονόματα μεταβλητών - Λέξεις κλειδιά» από users.tem.uoc.gr. Αρχειοθετήθηκε 20/04/2019. Ανακτήθηκε 23/04/2019. ↑ 19,0 19,1 19,2 Αγγελιδάκης, Ν., βλ. πηγές, Κεφάλαιο 3, σελ. 17-23 (σελ. 26-32 του pdf) ↑ Αγγελιδάκης, Ν., βλ. πηγές σελ. 22 (σελ. 31 του pdf) ↑ Αγγελιδάκης, Ν., βλ. πηγές σελ. 21 (σελ. 30 του pdf) ↑ Αγγελιδάκης, Ν., βλ. πηγές, σελ. 27 (σελ. 36 του pdf) ↑ 23,0 23,1 23,2 «Μαθήματα Προγραμματισμού Python. Μάθημα 3ο» του Γιάννη Φυτίλη στο pcsteps.gr. Δημοσιεύθηκε 04/10/2017. Αρχειοθετήθηκε 23/04/2019. Ανακτήθηκε 23/04/2019. ↑ Αγγελιδάκης, Ν., βλ. πηγές, σελ. 34-37 (σελ. 43-46 του pdf) ↑ «Μαθήματα Προγραμματισμού Python. Μάθημα 4ο» του Γιάννη Φυτίλη στο pcsteps.gr. Δημοσιεύθηκε 11/10/2017. Αρχειοθετήθηκε 24/04/2019. Ανακτήθηκε 23/04/2019. ↑ Αράπογλου, Βραχνός, κλπ, βλ. πηγές, σελ. 32 (σελ. 33 του pdf) ↑ «Μαθήματα Προγραμματισμού Python. Μάθημα 6ο» του Γιάννη Φυτίλη στο pcsteps.gr. Δημοσιεύθηκε 25/10/2017. Αρχειοθετήθηκε 25/04/2019. Ανακτήθηκε 23/04/2019. ↑ 28,0 28,1 «Μαθήματα Προγραμματισμού Python. Μάθημα 7ο» του Γιάννη Φυτίλη στο pcsteps.gr. Δημοσιεύθηκε 01/11/2017. Αρχειοθετήθηκε 25/04/2019. Ανακτήθηκε 23/04/2019. ↑ Αγγελιδάκης, Ν., βλ. πηγές, σελ. 86-98 (σελ. 95-107 του pdf) ↑ Αγγελιδάκης, Ν., βλ. πηγές, σελ. 103-106 (σελ. 112-115 του pdf) ↑ 31,0 31,1 Αράπογλου, Βραχνός, κλπ, βλ. πηγές, σελ. 36-38 (σελ. 37-39 του pdf) ↑ Αγγελιδάκης, Ν., βλ. πηγές, σελ. 22 (σελ. 31 του pdf) ↑ Μιχάλης Πλεξουσάκης, 2016. «Γλώσσα προγραμματισμού python3 - Λογικές εκφράσεις και μεταβλητές» από users.tem.uoc.gr. Αρχειοθετήθηκε 30/03/2018. Ανακτήθηκε 23/04/2019. ↑ 34,0 34,1 Αγγελιδάκης, Ν., βλ. πηγές, σελ. 38 (σελ. 47 του pdf) ↑ (Αγγλικά) Συνίσταται η χρήση 4 κενών στις εσοχές. «PEP 8 -- Style Guide for Python Code -> Indentation» από python.org. Δημοσιεύθηκε 05/07/2001. Αρχειοθετήθηκε 17/04/2019. Ανακτήθηκε 22/04/2019. ↑ Αράπογλου, Βραχνός, κλπ., βλ. πηγές, σελ. 33 (σελ. 34 του pdf) ↑ 37,0 37,1 37,2 «Μαθήματα Προγραμματισμού Python. Μάθημα 5ο», του Γιάννη Φυτίλη στο pcsteps.gr. Δημοσιεύθηκε 18/10/2017. Αρχειοθετήθηκε 25/04/2019. Ανακτήθηκε 23/04/2019. ↑ 38,0 38,1 Αγγελιδάκης, Ν., βλ. πηγές, σελ. 58-60 (σελ. 67-69 του pdf) ↑ Αναστάσιος Χατζηπαπαδόπουλος, Δρ. Βασίλης Σ. Μπελεσιώτης, 2018. «Πέτρα-Ψαλίδι-Χαρτί. Από το Δομημένο στον Αντικειμενοστρεφή προγραμματισμό Αρχειοθετήθηκε 2019-04-12 στο Wayback Machine.», Τμήμα Πληροφορικής, Ιόνιο Πανεπιστήμιο Αρχειοθετήθηκε 2019-01-29 στο Wayback Machine., σελ. 14 (σελ. 2 του pdf). Αρχειοθετήθηκε 12/04/2019. Ανακτήθηκε 12/04/2019. ↑ Avouris, Nikolaos; Sgarbas, Kyriakos; Paliouras, Vassilis; Koukias, Michalis (2017-04). «Work in progress: An introduction to computing course using a Python-based experiential approach». 2017 IEEE Global Engineering Education Conference (EDUCON) (IEEE). doi:10.1109/educon.2017.7943071. ISBN 9781509054671. http://dx.doi.org/10.1109/educon.2017.7943071. Πηγές[Επεξεργασία | επεξεργασία κώδικα] Αγγελιδάκης, Νικόλαος Α., Εκπαιδευτικός Πληροφορικής, Μ.Δ.Ε. (M.Sc.) στην Επιστήμη Υπολογιστών (Ηράκλειο, Αύγουστος 2015). \"Εισαγωγή στον προγραμματισμό με την Python\". Αρχειοθετήθηκε 12/06/2018 Ανακτήθηκε 07/04/2019. (ISBN 978-960-93-7364-7). Ηλεκτρονικό βιβλίο 150 σελίδων, για αρχάριους και με άδεια: CC BY-SA 4.0. Αράπογλου Α.,Βραχνός Ε.,Λέκκα Δ.,Κανίδης Ε.,Μακρυγιάννης Π., Μπελεσιώτης Β., Τζήμας Δ., Παπαδάκης Σπ., «Προγραμματισμός Υπολογιστών Γ΄ Τάξη ΕΠΑ.Λ.» με χρήση Python 2, Διδακτικό Υλικό, Εκδόσεις Διόφαντος. (ISBN 978-960-06-5309-0). Αρχειοθετήθηκε 14/09/2019. (Αγγλικά) Dave Kuhlman, (December 15, 2013). «A Python Book: Beginning Python, AdvancedPython, and Python Exercises». Αρχειοθετήθηκε 19/06/2018. Ανακτήθηκε 15/04/2019. Abstract:This document is a self-learning document for a course in Python programming. This course contains (1) a part for beginners, (2) a discussion of several advanced topics that are of interest to Python programmers, and (3) a Python workbook with lots of exercises. Βιβλία[Επεξεργασία | επεξεργασία κώδικα] Ελληνικά[Επεξεργασία | επεξεργασία κώδικα] Αβούρης Ν., Μ. Κουκιάς, Β. Παλιουράς, Κ. Σγάρμπας, \"PYTHON Εισαγωγή στους υπολογιστές Αρχειοθετήθηκε 2017-05-09 στο Wayback Machine.\". 3η αναθεωρημένη έκδοση, Πανεπιστημιακές Εκδόσεις Κρήτης, 2016. Καρολίδης Δ., \"Μαθαίνετε εύκολα Python\", 2η έκδοση, Εκδόσεις Άβακας, 2018. J. Guttag, \"Υπολογισμοί και προγραμματισμός με την Python\", Εκδόσεις Κλειδάριθμος, 2015. T. Gaddis, \"Ξεκινώντας με την Python\", Εκδόσεις DaVinci Αρχειοθετήθηκε 2019-10-15 στο Wayback Machine., 2015. Αναστάσιος Χατζηπαπαδόπουλος, Εκπαιδευτικός Πληροφορικής, (2018). «Ανάπτυξη Εφαρμογών σε Προγραμματιστικό Περιβάλλον με Python» από users.sch.gr/chatzipap/. Αρχειοθετήθηκε 17/04/2018. Ανακτήθηκε 16/04/2019. Από τον πρόλογο: «Στο βιβλίο αυτό περιέχονται προτεινόμενες/ενδεικτικές λύσεις στα πανελλαδικά θέματα Γ & Δ(έτη 2000 –2017) του μαθήματος της Ανάπτυξης Εφαρμογών σε Προγραμματιστικό Περιβάλλον με τη χρήση όμως όχι ψευδο-γλώσσας αλλά της Python(έκδοση 2.7.10) με τον τρόπο που αυτή παρουσιάζεται στα διδακτικά εγχειρίδια της Β’ και Γ’ Τάξης του Τομέα Πληροφορικής των ΕΠΑΛ.». (ISBN 978-960-93-9926-5) Χατζηγιαννάκης Νίκος, «Η γλώσσα Python σε βάθος», Εκδόσεις Κλειδάριθμος, 2023, ISBN 978-960-645-471, Κωδικός Ευδόξου: 122075004 Αγγλικά[Επεξεργασία | επεξεργασία κώδικα] (Αγγλικά) Guzdial, M. (2004). Introduction to media computation: A multimedia cookbook in Python. Pearson/Custom Pub. Δείτε επίσης[Επεξεργασία | επεξεργασία κώδικα] Ruby Εξωτερικοί σύνδεσμοι[Επεξεργασία | επεξεργασία κώδικα] Η επίσημη ιστοσελίδα για τη γλώσσα (Αγγλικά) Ελληνική Κοινότητα Προγραμματιστών Python Εισαγωγή στην Python Αρχειοθετήθηκε 2010-09-15 στο Wayback Machine. Άμεση Python Τεκμηρίωση και περισσότερες πληροφορίες (Αγγλικά) Βιβλίο για την Python μεταφρασμένο από την ελληνική κοινότητα Ubuntu. Αρχειοθέτηση 2013-06-05. Python for Informatics στο P2PU Google's Python Class Python Programming στο en.wikibooks.org Python στο Curlie Διαδικτυακό μάθημα \"Εισαγωγή στην Python\" στην πλατφόρμα mathesis.cup.gr Αρχειοθετήθηκε 2019-04-16 στο Wayback Machine. Διαδικτυακό μάθημα \"Προχωρημένος Προγραμματισμός με την Python\" στην πλατφόρμα mathesis.cup.gr Αρχειοθετήθηκε 2019-04-16 στο Wayback Machine. Θερινό σχολείο Power Python (εισαγωγικό και προχωρημένο επίπεδο) Ελεύθερο Διαδικτυακό μάθημα για το πανελλαδικά εξεταζόμενο μάθημα του τομέα Πληροφορικής των ΕΠΑΛ \"Προγραμματισμός Υπολογιστών\" με Python στην πλατφόρμα moodle.sepchiou.gr Wikibooks logo Τα αγγλικά Βικιβιβλία έχουν βιβλία που έχουν σχέση με την: Python Commons logo Τα Wikimedia Commons έχουν πολυμέσα σχετικά με το θέμα Python πσεΓλώσσες προγραμματισμού Ada ALGOL APL Applescript Assembly BASIC C C++ C# COBOL Erlang Forth Fortran Go Haskell Java JavaScript Kotlin Lisp Logo Lua ML Objective-C Pascal Perl PHP Prolog Python R Ruby Rust SQL Shell Simula Smalltalk Swift Visual Basic πσεΕλεύθερο λογισμικό και λογισμικό ανοικτού κώδικαΓενικάCopyleft · Γεγονότα και βραβεία · Ελεύθερο λογισμικό · Ορισμός του Ελεύθερου Λογισμικού · Δωρεάν και ελεύθερο · Κατάλογος ελεύθερου λογισμικού και λογισμικού ανοιχτού κώδικα · Λογισμικό ανοικτού κώδικαΛειτουργικά συστήματαAROS · BSD · Darwin · eCos · FreeDOS · GNU · Haiku · Inferno · Linux · Mach · MINIX · OpenSolaris · Plan 9 · ReactOS · SymbianΑνάπτυξη λογισμικούEclipse · Free Pascal · GCC · Gambas · Java · LLVM · Lua · NetBeans · Open64 · Perl · PHP · Python · ROSE · Ruby · TclΙστορίαGNU ·Haiku ·Linux · Mozilla (Application Suite · Firefox · Thunderbird)ΟργανισμοίApache Software Foundation · Ίδρυμα Blender · Eclipse Foundation · freedesktop.org · Ίδρυμα Ελεύθερου Λογισμικού (Ευρώπη · India ·Latin America) · FSMI ·GNOME Foundation · GNU Project · Google Code ·KDE e.V. · Linux Foundation · Mozilla Foundation · Open Source Geospatial Foundation · Open Source Initiative · Python Software Foundation - Software Freedom Conservancy · SourceForge · Symbian Foundation · The Document Foundation · Xiph.Org Foundation · XMPP Standards Foundation · X.Org FoundationΆδειες ελεύθερου λογισμικούApache · Artistic · BSD · GNU GPL · GNU LGPL · ISC · MIT · MPL · Ms-PL/RL · zlib · FSF approved licensesΠρότυπα αδειών λογισμικούΟρισμός του Λογισμικού Ανοιχτού Κώδικα · Ορισμός του Ελεύθερου Λογισμικού · Debian Free Software GuidelinesΣημαντικά θέματαBinary blob · Canonical's contributor agreement · Digital rights management · Συμβατότητα καρτών γραφικών · License proliferation · Mozilla software rebranding · Proprietary software · Διαμάχη SCO-Linux · Ασφάλεια · Πατέντες λογισμικού · Περιορισμοί υλικού · Trusted Computing · Viral licenseΆλλα θέματαΕναλλακτικοί όροι · Κοινότητα · Διανομή Linux · Forking · Κίνημα · Microsoft Open Specification Promise · Revolution OS · Σύγκριση με λογισμικό κλειστού κώδικα Καθιερωμένοι όροι LCCN: sh96008834 GND: 4434275-5 SUDOC: 051626225 BNF: cb13560465c (data) NKC: ph170668 Πύλη:Προγραμματισμός ↑ «PYTHON». Πανεπιστημιακές Εκδόσεις Κρήτης. 2016-10-01. Αρχειοθετήθηκε από το πρωτότυπο στις 2017-05-09. https://web.archive.org/web/20170509131811/http://www.cup.gr/book/python. Ανακτήθηκε στις 2018-07-06."
    },
    {
        "id": 2,
        "url": "https://el.wikipedia.org/wiki/%CE%94%CE%B9%CE%B5%CF%81%CE%BC%CE%B7%CE%BD%CE%B5%CF%85%CE%BC%CE%AD%CE%BD%CE%B7_%CE%B3%CE%BB%CF%8E%CF%83%CF%83%CE%B1",
        "title": "Διερμηνέας (υπολογιστές)",
        "content": "Το λήμμα παραθέτει τις πηγές του αόριστα, χωρίς παραπομπές. Βοηθήστε συνδέοντας το κείμενο με τις πηγές χρησιμοποιώντας παραπομπές, ώστε να είναι επαληθεύσιμο. Η σήμανση τοποθετήθηκε στις 06/02/2020. Στην πληροφορική διερμηνέας ή διερμηνευτής (interpreter) συνήθως σημαίνει ένα πρόγραμμα που εκτελεί ή ερμηνεύει εντολές σε κάποια γλώσσα προγραμματισμού. Η διερμήνευση και η μεταγλώττιση είναι τα δύο βασικά μέσα με τα οποία υλοποιούνται οι γλώσσες προγραμματισμού, αν και δεν αποτελούν εντελώς διακριτές κατηγορίες, καθώς οι λειτουργίες τους επικαλύπτονται σε κάποιον βαθμό. Διερμηνέας είναι ένα πρόγραμμα που είτε: εκτελεί τον πηγαίο κώδικα απευθείας μεταφράζει τον πηγαίο κώδικα σε μια περισσότερο αποδοτική μορφή (κώδικα) που αμέσως εκτελεί σαφώς εκτελεί προ-μεταγλωττισμένο κώδικα που έχει δημιουργήσει κάποιος μεταγλωττιστής που είναι μέρος του συστήματος διερμήνευσης. Με την τελευταία έννοια, ο επεξεργαστής είναι μιας μορφής διερμηνέας εντολών κώδικα μηχανής σε συνδυασμό με τον μεταγλωττιστή που τις παράγει. Η Perl, η Python, η MATLAB, και η Ruby είναι παραδείγματα γλωσσών που μεταφράζουν τον κώδικα σε αποδοτική μορφή, στο νούμερο 2 παραπάνω, ενώ η UCSD Pascal και η εικονική μηχανή της Java ανήκουν στο νούμερο 3 παραπάνω: τα προγράμματα Java μεταγλωττίζονται και αποθηκεύονται ως κώδικας bytecode, που στη συνέχεια συνδέεται κατά την ώρα της εκτέλεσης και εκτελείται από ένα διερμηνέα (εικονική μηχανή). Μερικά συστήματα όπως η Smalltalk συνδυάζουν τη δεύτερη και τρίτη κατηγορία. Ο όρος διερμηνευμένη γλώσσα σημαίνει ότι η κανονική υλοποίηση της γλώσσας είναι διερμηνέας ή μεταγλωττιστής. Μια γλώσσα υψηλού επιπέδου είναι βασικά μια αφαίρεση, που (ιδανικά) δεν εξαρτάται από κάποια συγκεκριμένη υλοποίηση. Θεωρητικά, οποιαδήποτε γλώσσα μπορεί να είναι είτε μεταγλωττισμένη είτε διερμηνευμένη, έτσι ο διαχωρισμός αυτός εφαρμόζεται μόνο με βάση την συνήθη πρακτική υλοποίησης, και όχι κάποια συγκεκριμένη ιδιότητα μιας γλώσσας. Πολλές γλώσσες έχουν υλοποιηθεί τόσο με χρήση μεταγλωττιστών όσο και με διερμηνείς, όπως η Lisp, η Pascal, η C, η BASIC και η Python. Η γλώσσα Java μεταφράζεται σε μια μορφή που προορίζεται συνήθως για διερμήνευση, αν και συχνά χρησιμοποιείται η μεταγλώττιση ακριβώς-στην-ώρα (just-in-time compilation) για να παράγει κώδικα μηχανής πριν την εκτέλεση. Οι γλώσσες .Net της Microsoft μεταγλωττίζονται στην CIL από την οποία συνήθως μεταγλωττίζονται στη συνέχεια σε κώδικα μηχανής, αν και υπάρχει εικονική μηχανή που μπορεί να διερμηνεύσει τη CIL. Αυτό το λήμμα σχετικά με την Πληροφορική χρειάζεται επέκταση. Μπορείτε να βοηθήσετε την Βικιπαίδεια επεκτείνοντάς το."
    },
    {
        "id": 3,
        "url": "https://el.wikipedia.org/wiki/%CE%93%CE%BB%CF%8E%CF%83%CF%83%CE%B1_%CF%85%CF%88%CE%B7%CE%BB%CE%BF%CF%8D_%CE%B5%CF%80%CE%B9%CF%80%CE%AD%CE%B4%CE%BF%CF%85",
        "title": "Γλώσσα προγραμματισμού υψηλού επιπέδου",
        "content": "Το λήμμα δεν περιέχει πηγές ή αυτές που περιέχει δεν επαρκούν. Μπορείτε να βοηθήσετε προσθέτοντας την κατάλληλη τεκμηρίωση. Υλικό που είναι ατεκμηρίωτο μπορεί να αμφισβητηθεί και να αφαιρεθεί. Η σήμανση τοποθετήθηκε στις 24/10/2016. Ως υψηλού επιπέδου γλώσσα προγραμματισμού (high-level programming language) ορίζεται αυτή που επιτρέπει τη μεταφερσιμότητα ενός προγράμματος από έναν υπολογιστή σε έναν άλλο. Αποτελείται από εντολές εύκολα κατανοητές στον προγραμματιστή, καθώς μοιάζουν με -περιορισμένη- φυσική γλώσσα. Για την εκτέλεση του προγράμματος από τον υπολογιστή, απαιτείται η χρήση μεταγλωττιστή για την παραγωγή του προγράμματος σε γλώσσα μηχανής. Ανάλογα με το σκοπό τους, οι γλώσσες προγραμματισμού υψηλού επιπέδου διακρίνονται σε γλώσσες ειδικού σκοπού -όπως η FORTRAN, η COBOL, η LISP και σε γλώσσες γενικής χρήσης -όπως η Python, η C η Visual Basic και η Java. Αυτό το λήμμα σχετικά με την Πληροφορική χρειάζεται επέκταση. Μπορείτε να βοηθήσετε την Βικιπαίδεια επεκτείνοντάς το."
    },
    {
        "id": 4,
        "url": "https://el.wikipedia.org/wiki/%CE%93%CE%BB%CF%8E%CF%83%CF%83%CE%B1_%CF%80%CF%81%CE%BF%CE%B3%CF%81%CE%B1%CE%BC%CE%BC%CE%B1%CF%84%CE%B9%CF%83%CE%BC%CE%BF%CF%8D",
        "title": "Γλώσσα προγραμματισμού",
        "content": "Το λήμμα παραθέτει τις πηγές του αόριστα, χωρίς παραπομπές. Βοηθήστε συνδέοντας το κείμενο με τις πηγές χρησιμοποιώντας παραπομπές, ώστε να είναι επαληθεύσιμο. Το πρότυπο τοποθετήθηκε χωρίς ημερομηνία. Για τη σημερινή ημερομηνία χρησιμοποιήστε: {{χωρίς παραπομπές|9|01|2025}} Γλώσσα προγραμματισμού λέγεται μια τεχνητή γλώσσα που μπορεί να χρησιμοποιηθεί για τον έλεγχο μιας μηχανής, συνήθως ενός υπολογιστή. Οι γλώσσες προγραμματισμού (όπως άλλωστε και οι ανθρώπινες γλώσσες) ορίζονται από ένα σύνολο συντακτικών και εννοιολογικών κανόνων, που ορίζουν τη δομή και το νόημα, αντίστοιχα, των προτάσεων της γλώσσας. Οι γλώσσες προγραμματισμού χρησιμοποιούνται για να διευκολύνουν την οργάνωση και διαχείριση πληροφοριών, αλλά και για την ακριβή διατύπωση αλγορίθμων. Ορισμένοι ειδικοί χρησιμοποιούν τον όρο γλώσσα προγραμματισμού μόνο για τυπικές γλώσσες που μπορούν να εκφράσουν όλους τους πιθανούς αλγορίθμους. Μη-υπολογιστικές γλώσσες όπως η HTML ή τυπικές γραμματικές όπως η BNF δεν λέγονται συνήθως γλώσσες προγραμματισμού. Υπάρχουν περίπου 9000 διαφορετικές γλώσσες προγραμματισμού και κάθε χρόνο δημιουργούνται περισσότερες. Χαρακτηριστικά των γλωσσών προγραμματισμού[Επεξεργασία | επεξεργασία κώδικα] Κάθε γλώσσα προγραμματισμού έχει το δικό της σύνολο τυπικών προδιαγραφών (ή κανόνων) που αφορούν το συντακτικό, το λεξιλόγιο και το νόημα της. Για πολλές γλώσσες που χρησιμοποιούνται ευρέως και έχουν χρησιμοποιηθεί για αρκετό χρονικό διάστημα (π.χ. C, C++, Java, Scheme), υπάρχουν ειδικοί φορείς τυποποίησης, οι οποίοι μέσα από τακτές συναντήσεις δημιουργούν, τροποποιούν ή επεκτείνουν τις τυπικές προδιαγραφές που διέπουν τη χρήση μιας γλώσσας προγραμματισμού. Άλλες γλώσσες δεν περιγράφονται σε κάποιο επίσημο πρότυπο αλλά ορίζονται μόνο με βάση κάποια υλοποίησή τους (που αποτελεί το ντε φάκτο πρότυπο), όπως η Python που περιγράφεται από την υλοποίηση CPython. Ιστορία γλωσσών προγραμματισμού[Επεξεργασία | επεξεργασία κώδικα] Βλέπε Ιστορία γλωσσών προγραμματισμού. Κατηγοριοποίηση γλωσσών προγραμματισμού[Επεξεργασία | επεξεργασία κώδικα] Δεν υπάρχει απλός τρόπος να κατηγοριοποιηθούν οι γλώσσες προγραμματισμού. Αυτό συμβαίνει γιατί συνήθως κάθε γλώσσα προγραμματισμού περιέχει επιρροές από πολλές προηγούμενες γλώσσες, συνδυάζοντας θετικά στοιχεία και προσθέτοντας νέα. Χαρακτηριστικά που εμφανίζονται σε μια γλώσσα και έχουν θετική αποδοχή, συνήθως υιοθετούνται από μεταγενέστερες γλώσσες ακόμα και αν πρόκειται για γλώσσες που ανήκουν σε διαφορετική κατηγορία. Η κατηγοριοποίηση είναι ακόμα πιο περίπλοκη για το λόγο ότι πολλές γλώσσες συνήθως ανήκουν σε παραπάνω από μία κατηγορίες. Για παράδειγμα, η Java είναι τόσο αντικειμενοστρεφής όσο και παράλληλη γλώσσα, δεδομένου ότι υποστηρίζει την οργάνωση των δεδομένων και υπολογισμών σε αντικείμενα, αλλά επιτρέπει επίσης και την δημιουργία προγραμμάτων με ταυτόχρονα νήματα (threads) που εκτελούνται παράλληλα. Δεδομένης της δυσκολίας στην κατηγοριοποίηση, μπορούμε να κατηγοριοποιήσουμε τις γλώσσες προγραμματισμού με διάφορους τρόπους. Οι συνηθέστεροι τρόποι είναι: με βάση τον τρόπο οργάνωσης του προγράμματος με βάση τον στόχο που έχει η γλώσσα με βάση τον τρόπο που περιγράφουν το ζητούμενο αποτέλεσμα Στην πρώτη περίπτωση προκύπτουν κατηγορίες όπως: Διαδικαστικές γλώσσες (procedural) όπου το πρόγραμμα είναι οργανωμένο σε διαδικασίες, που αποτελούνται από σειρές εντολών που περιγράφουν αλγορίθμους. Παραδείγματα γλωσσών που ανήκουν σε αυτή την κατηγορία είναι η Pascal ή η C. Αντικειμενοστρεφείς γλώσσες (object-oriented) όπου το πρόγραμμα είναι οργανωμένο σε αντικείμενα. Ένα αντικείμενο είναι μια μονάδα που αποτελείται από την περιγραφή κάποιων δεδομένων και την περιγραφή των αλγορίθμων που τα επεξεργάζονται. Ένα αντικειμενοστρεφές πρόγραμμα αποτελείται από διάφορα αντικείμενα που αλληλεπιδρούν μεταξύ τους. Παραδείγματα αντικειμενοστρεφών γλωσσών είναι η Java ή η C++. Συναρτησιακές γλώσσες (functional) όπου οι υπολογισμοί εκφράζονται ως εφαρμογές μαθηματικών συναρτήσεων, σε αντίθεση με τα άλλα είδη προγραμματισμού όπου οι υπολογισμοί εκφράζονται ως σειρές εντολών, όπου η κάθε μία αλλάζει με κάποιο τρόπο την κατάσταση του συστήματος. Θεωρητικό τους υπόβαθρο είναι ο λ-λογισμός. Χαρακτηριστικές συναρτησιακές γλώσσες είναι η Lisp, η Haskell και η OCaml. Στην περίπτωση που η κατηγοριοποίηση των γλωσσών προγραμματισμού γίνει με βάση το στόχο που έχει η γλώσσα, υπάρχουν οι παρακάτω κατηγορίες: Γλώσσες γενικής χρήσης. Σε αυτήν την κατηγορία ταξινομούνται γλώσσες που δημιουργήθηκαν για τον προγραμματισμό γενικών εφαρμογών, καθώς και πολλές εκπαιδευτικές γλώσσες που αποδείχτηκαν χρήσιμες για την ανάπτυξη γενικών εφαρμογών, όπως η Pascal. Γλώσσες προγραμματισμού συστημάτων, που χρησιμοποιούνται συνήθως για τον προγραμματισμό λειτουργικών συστημάτων ή οδηγών (drivers) υλικού, όπου χρειάζεται πολλές φορές ο προγραμματιστής να έχει έλεγχο και γνώση του πως λειτουργεί το υλικό. Η πιο συχνά χρησιμοποιούμενη γλώσσα προγραμματισμού συστημάτων είναι η C. Γλώσσες σεναρίων (scripting). Αυτές οι γλώσσες χρησιμοποιούνται συνήθως για τη γρήγορη ανάπτυξη μικρών προγραμμάτων, σε περιπτώσεις που ο χρόνος του προγραμματιστή είναι πιο πολύτιμος από την ταχύτητα εκτέλεσης του προγράμματος, όπως για παράδειγμα συμβαίνει όταν το πρόγραμμα απλά αυτοματοποιεί απλές λειτουργίες. Παραδείγματα γλωσσών σεναρίων (scripting) είναι η Perl, η Python, η Ruby ή τα κελύφη του λειτουργικού συστήματος Unix (shells). Γλώσσες ειδικών εφαρμογών. Σε αυτή την κατηγορία ανήκουν γλώσσες που αναπτύχθηκαν ειδικά για μια συγκεκριμένη εφαρμογή. Για παράδειγμα, η γλώσσα PostScript είναι σχεδιασμένη ειδικά για να περιγράφονται με λεπτομέρεια κείμενα προς εκτύπωση, ενώ η γλώσσα Matlab είναι σχεδιασμένη για την επεξεργασία πινάκων από αριθμητικά δεδομένα. Παράλληλες ή κατανεμημένες γλώσσες. Στη συγκεκριμένη κατηγορία ταξινομούνται γλώσσες που επιτρέπουν τη ανάπτυξη παράλληλων προγραμμάτων, όπου πολλές εντολές εκτελούνται ταυτόχρονα σε πολλούς υπολογιστές, έτσι ώστε το τελικό αποτέλεσμα να προκύψει γρηγορότερα. Οι παράλληλες γλώσσες προσφέρουν συνήθως εύκολους τρόπους επικοινωνίας μεταξύ των νημάτων που εκτελούνται παράλληλα, καθώς και τρόπους ώστε να δημιουργούνται καινούριες παράλληλες εκτελέσεις. Παραδείγματα γλωσσών που ανήκουν (και) σε αυτή την κατηγορία είναι η Go, η Java, η Erlang, η MultiLisp ή η Cilk. Εκπαιδευτικά προγραμματιστικά περιβάλλοντα. Σε αυτή την κατηγορία ανήκουν εκπαιδευτικές; γλώσσες προγραμματισμού οι οποίες απευθύνονται σε αρχάριους προγραμματιστές για την κατασκευή μικροεφαρμογών. Είναι κατάλληλες για την εκμάθηση προγραμματισμού σε μικρές ηλικίες. Παραδείγματα τέτοιων γλωσσών είναι η LOGO, το Game Maker και το App Inventor. Τέλος, στην περίπτωση που η κατηγοριοποίηση γίνεται με βάση τον τρόπο που περιγράφεται το ζητούμενο, υπάρχουν οι παρακάτω κατηγορίες: Προστακτικές γλώσσες προγραμματισμού (imperative) είναι οι γλώσσες που περιγράφουν το ζητούμενο αποτέλεσμα κατασκευαστικά, δίνοντας μια σειρά εντολών που όταν εκτελεστούν παράγουν το ζητούμενο αποτέλεσμα. Τέτοιες γλώσσες είναι η C, η Java αλλά και η OCaml. Δηλωτικές γλώσσες προγραμματισμού (declarative) είναι οι γλώσσες που περιγράφουν το ζητούμενο αποτέλεσμα χρησιμοποιώντας τις ιδιότητες που έχει, και όχι τον τρόπο με τον οποίο υπολογίζεται. Παραδείγματα δηλωτικών γλωσσών είναι η Haskell, η SQL και η Prolog. Γλώσσες προγραμματισμού[Επεξεργασία | επεξεργασία κώδικα] κατ' αλφαβητική σειρά: Ada Algol Applescript AWK BASIC C C++ C# Cilk Clojure COBOL Datalog Delphi Erlang Forth FORTRAN Go Haskell Java JavaScript Kotlin Lisp Logo Lua Lucid Mathematica Matlab Miranda ML OBJ / Σύστημα Maude Objective-C OCaml Pascal Perl PHP Prolog Python R Ruby Scala Scheme Simula Smalltalk SQL Tcl TypeScript Visual Basic ΓΛΩΣΣΑ Η παραπάνω λίστα είναι ενδεικτική και σε καμία περίπτωση δεν εξαντλεί το εύρος και την ποικιλία των χιλιάδων γλωσσών που χρησιμοποιούνται στην πράξη. Πηγές[Επεξεργασία | επεξεργασία κώδικα] \"Εφαρμογές Πληροφορικής\",ΙΤΥΕ ΔΙΟΦΑΝΤΟΣ, σελ 52-53, ISBN 978-960-06-4894-2 Δείτε επίσης[Επεξεργασία | επεξεργασία κώδικα] Γλώσσες χαμηλού επιπέδου[Επεξεργασία | επεξεργασία κώδικα] Γλώσσα μηχανής Συμβολική γλώσσα Θεωρητικές γλώσσες[Επεξεργασία | επεξεργασία κώδικα] λ-λογισμός Ψευδοκώδικας Γλώσσες με εξαρτώμενους τύπους[Επεξεργασία | επεξεργασία κώδικα] Agda Coq Άλλα θέματα[Επεξεργασία | επεξεργασία κώδικα] Οπτική γλώσσα προγραμματισμού Σύστημα τύπων Plankalkül Παραπομπές[Επεξεργασία | επεξεργασία κώδικα] ↑ «How Many Coding Languages Are There?». Περαιτέρω διάβασμα[Επεξεργασία | επεξεργασία κώδικα] Fundamental Concepts in Programming Languages (βασικές έννοιες των γλωσσών προγραμματισμού) (Αγγλικά) Εφαρμογές Πληροφορικής (Διαδραστικά σχολικά βιβλία) Καθιερωμένοι όροι LCCN: sh85107313 GND: 4047409-4 BNF: cb13318353n (data) NDL: 00569224 NKC: ph115890 Πύλη:Προγραμματισμός"
    },
    {
        "id": 5,
        "url": "https://el.wikipedia.org/wiki/%CE%A0%CF%81%CE%BF%CF%83%CF%84%CE%B1%CE%BA%CF%84%CE%B9%CE%BA%CF%8C%CF%82_%CF%80%CF%81%CE%BF%CE%B3%CF%81%CE%B1%CE%BC%CE%BC%CE%B1%CF%84%CE%B9%CF%83%CE%BC%CF%8C%CF%82",
        "title": "Προστακτικός προγραμματισμός",
        "content": "Στην πληροφορική καλούμε προστακτικό προγραμματισμό (Αγγλικά: Imperative programming), σε αντίθεση με το δηλωτικό προγραμματισμό, ένα προγραμματιστικό υπόδειγμα όπου το ζητούμενο κατασκευάζεται / υπολογίζεται αλλάζοντας την κατάσταση του υπολογιστή μέσω εντολών. Η ιδέα είναι ότι έχουμε εντολές/statements που συνήθως μοιράζονται κοινές μεταβλητές. Το υπόδειγμα αυτό ακολουθούν οι διαδικαστικές γλώσσες προγραμματισμού, όπως η Pascal, η C , η Fortran, κ.α., αλλά και πολλές αντικειμενοστρεφείς γλώσσες όπως η Java, η C++, η C#, κ.α. Η ιδέα του προστακτικού προγραμματισμού απορρέει από την αρχιτεκτονική φον Νόιμαν η οποία σχεδιάστηκε την δεκαετία 1940. Κατά την αρχιτεκτονική αυτή η κάθε εντολή (γλώσσας μηχανής) εκτελείται διαδοχικά (σε κάθε κύκλο λειτουργίας του επεξεργαστή). Η μετέπειτα ανάπτυξη των γλωσσών προγραμματισμού υψηλού επιπέδου (όπως για παράδειγμα η Pascal ή η C) βασίστηκαν στην αρχιτεκτονική φον Νόιμαν και υλοποίησαν το υπόδειγμα του προστατικού προγραμματισμό όπου ο προγραμματισμός γίνεται σε γλώσσα υψηλού επιπέδου. Σε μια γλώσσα προστακτινού προγραμματισμού (σε σύγκριση με μια γλώσσα συναρτησιακού προγραμματισμού) έχουμε πολύπλοκη σημασιολογία, πολύπλοκο συντακτικό και η αποδοτική εκτέλεση του προγράμματος είναι ευθύνη του προγραμματιστή. Στην περίπτωση που θέλουμε το πρόγραμμα να εκτελεστεί ταυτόχρονα σε περισσότερους πυρήνες ο προγραμματιστής πρέπει να το σχεδιάσει το πρόγραμμα και την ταυτόχρονη εκτέλεση, σε αντίθεση σε ένα πρόγραμμα συναρτησιακού προγραμματισμού το οποίο μπορεί να εκτελεστεί ταυτόχρονα χωρίς παραπάνω σχεδίαση από τον προγραμματιστή (λόγω των αναδρομικών κλήσεων συναρτήσεων κλπ). Παράδειγμα[Επεξεργασία | επεξεργασία κώδικα] Αν θέλουμε να υπολογίσουμε το άθροισμα ακέραιων αριθμών από το 1 μέχρι ένα αριθμό n σε κάποια προστακτική γλώσσα προγραμματισμού θα χρησιμοποιούσαμε 2 μεταβλητές οι οποίες θα αλλάζανε τιμές κατά την εκτέλεση του προγράμματος όπως φαίνεται στο παρακάτω ψευδοκώδικα: count := 0 total := 0 repeat count := count + 1 total := total + count until count = n ή υλοποιημένο στην γλώσσα C++: int count=0; int total=0; do { count++; total+=count; } while (count!=n); Στο παράδειγμα αυτό οι τιμές των μεταβλητών count και total κατά την διάρκεια εκτέλεσης του κώδικα αλλάζουν τιμές μέχρι να υπολογιστεί το άθροισμα και αυτό ο τύπος προγραμματισμού λέγεται προστακτικός. Το πρόβλημα αυτό θα μπορούσε να λυθεί με μια αναδρομική συνάρτηση πάνω σε μια λίστα με τιμές 1..n μεθοδολογία η οποία δεν συνηθίζεται στον προστακτικό προγραμματισμό αλλά στον δηλωτικό προγραμματισμό όπως φαίνεται στην αναδρομική κλίση λίστας με 3 αριθμούς: sum [1,2,3] = 1 + sum[2,3] = 1 + (2 + sum) = 1 + (2 + (3 + sum[])) = 1 + (2 + (3 + 0)) = 6 Δείτε επίσης[Επεξεργασία | επεξεργασία κώδικα] Δηλωτικός προγραμματισμός Παραπομπές[Επεξεργασία | επεξεργασία κώδικα] ↑ Haridi, Peter Van Roy; Seif (2004). Concepts, techniques, and models of computer programming. Cambridge, Mass. [u.a.]: MIT Press. σελ. 406. ISBN 0-262-22069-5. ↑ Tucker, Allen B., επιμ. (2004). Computer science handbook (2η έκδοση). Boca Raton, Flor.: Chapman & Hall/CRC. σελίδες 90–1, 90–2. ISBN 158488360X. ↑ Σαγώνας, Κωστής. «Γλώσσες Συναρτησιακού Προγραμματισμού» (PDF). Σημειώσεις από μάθημα πληροφορικής στο Εθνικό Μετσόβιο Πολυτεχνείο. Ανακτήθηκε στις 1 Δεκεμβρίου 2014. [νεκρός σύνδεσμος] ↑ Hutton, Graham (2007). Programming in Haskell (5. print. έκδοση). Cambridge [u.a.]: Cambridge Univ. Press. σελ. 3. ISBN 978-0-521-69269-4."
    },
    {
        "id": 6,
        "url": "https://el.wikipedia.org/wiki/%CE%94%CE%B9%CE%B1%CE%B4%CE%B9%CE%BA%CE%B1%CF%83%CF%84%CE%B9%CE%BA%CF%8C%CF%82_%CF%80%CF%81%CE%BF%CE%B3%CF%81%CE%B1%CE%BC%CE%BC%CE%B1%CF%84%CE%B9%CF%83%CE%BC%CF%8C%CF%82",
        "title": "Δομημένος προγραμματισμός",
        "content": "Στην πληροφορική δομημένος προγραμματισμός (structured programming) ή διαδικαστικός προγραμματισμός (procedural programming) είναι μία προσέγγιση στον προγραμματισμό, η οποία βασίζεται στην έννοια της κλήσης διαδικασίας. Η διαδικασία, γνωστή επίσης και ως ρουτίνα, υπορουτίνα, μέθοδος ή συνάρτηση (δεν σχετίζεται άμεσα με τη μαθηματική έννοια της συνάρτησης), είναι απλά ένα αυτοτελές σύνολο εντολών προς εκτέλεση. Ο δομημένος προγραμματισμός βασίζεται στην αρχή του διαίρει και βασίλευε, καθώς διασπά το βασικό πρόβλημα σε μικρότερα υποπροβλήματα (γνωστά επίσης και ως εργασίες). Κάθε εργασία με πολύπλοκη περιγραφή διαιρείται σε μικρότερες, έως ότου οι εργασίες να είναι αρκετά μικρές, περιεκτικές και εύκολες προς κατανόηση. Ιστορική διαδρομή[Επεξεργασία | επεξεργασία κώδικα] Ιστορικά ο δομημένος προγραμματισμός αναπτύχθηκε ύστερα από έρευνα κατά τη δεκαετία του 1960, ως βελτίωση του ήδη υπάρχοντος διαδικαστικού προγραμματισμού. Ένα από τα πιο σημαντικά αποτελέσματα αυτής της έρευνας ήταν η ανάπτυξη της γλώσσας Pascal (γλώσσα προγραμματισμού), από τον Νίκλαους Βιρτ (Niklaus Wirth) το 1971, η οποία σύντομα έγινε η προτιμώμενη γλώσσα διδασκαλίας σε πολλά πανεπιστήμια. Η έννοια της διαδικασίας επομένως ήταν προϋπάρχουσα αλλά δεν έπαιζε τόσο σημαντικό ρόλο στη δομή των υπό συγγραφή εφαρμογών, καθώς τα δεδομένα ήταν αρκετά διαχωρισμένα από τις διαδικασίες και έπρεπε ο προγραμματιστής να θυμάται για κάθε διαδικασία ποια άλλη καλούσε, αλλά και ποια δεδομένα διαφοροποιούνταν. Καθώς όμως οι περισσότερες διαδικαστικές γλώσσες γρήγορα υιοθέτησαν στοιχεία ώστε να υποστηρίζουν δομημένο προγραμματισμό, οι δύο όροι σήμερα έχουν πρακτικώς ταυτιστεί. Με τον καιρό οι δομημένες γλώσσες έφτασαν να μην επαρκούν για τη συγγραφή προγραμμάτων, επεκτάθηκαν και ως λύση υιοθετήθηκε ο αντικειμενοστρεφής προγραμματισμός. Πλεονεκτήματα[Επεξεργασία | επεξεργασία κώδικα] Ο δομημένος προγραμματισμός βοηθάει την ευκολότερη συγγραφή πολύπλοκων προγραμμάτων. Με τον δομημένο προγραμματισμό γίνεται πιο εύκολη και ταχύτερη η διαχείριση, η συντήρηση και η αποσφαλμάτωση, καθώς βασίζεται σε μεγαλύτερες, πολυπλοκότερες και περιεκτικότερες μονάδες, όπως οι διαδικασίες, αντί για μεμονωμένες εντολές. Παράδειγμα[Επεξεργασία | επεξεργασία κώδικα] Παράδειγμα δομημένου προγραμματισμού σε γλώσσα C: #include <stdio.h> int sum(int,int); int main() { int x,y; puts(\"Δύο ακέραιοι με κενό ενδιάμεσα:\"); scanf(\"%d %d\",&x,&y); printf(\"Sum is %d\\n\", sum(x,y)); return 0; } int sum(int k, int l) { return k+l; } Παραπομπές[Επεξεργασία | επεξεργασία κώδικα] ↑ 1,0 1,1 1,2 Jesse Liberty, Bradley Jones, Sams Teach Yourself C++ in 21 Days, Sams Publishing, 2004, σελ. 8, ISBN 978-0-672-32711-7 ↑ Σταματόπουλος, Παναγιώτης, 2015. «Κεφάλαιο 1. Διαδικαστικός και δηλωτικός προγραμματισμός Αρχειοθετήθηκε 2019-04-13 στο Wayback Machine.» σελ.8 (σελ. 1 του pdf) από Λογικός και συναρτησιακός προγραμματισμός (ISBN 978-960-603-335-3). Δημοσιεύθηκε 19/10/2015. Αρχειοθετήθηκε 13/04/2019. Ανακτήθηκε 14/04/2019. ↑ Harvey M. Deitel, C++ How to Program: how to program, Pearson Prentice Hall 2005, σελ 10, ISBN 978-0-13-185757-5 Πύλη:Προγραμματισμός"
    },
    {
        "id": 7,
        "url": "https://el.wikipedia.org/wiki/%CE%91%CE%BD%CF%84%CE%B9%CE%BA%CE%B5%CE%B9%CE%BC%CE%B5%CE%BD%CE%BF%CF%83%CF%84%CF%81%CE%B5%CF%86%CE%AE%CF%82_%CF%80%CF%81%CE%BF%CE%B3%CF%81%CE%B1%CE%BC%CE%BC%CE%B1%CF%84%CE%B9%CF%83%CE%BC%CF%8C%CF%82",
        "title": "Αντικειμενοστρεφής προγραμματισμός",
        "content": "Στην πληροφορική αντικειμενοστρεφή προγραμματισμό (object-oriented programming) ή ΑΠ, ονομάζουμε ένα προγραμματιστικό υπόδειγμα το οποίο εμφανίστηκε στα τέλη της δεκαετίας του 1970 και καθιερώθηκε κατά τη δεκαετία του 1990, αντικαθιστώντας σε μεγάλο βαθμό το παραδοσιακό υπόδειγμα του δομημένου προγραμματισμού. Πρόκειται για μία μεθοδολογία ανάπτυξης προγραμμάτων, υποστηριζόμενη από κατάλληλες γλώσσες προγραμματισμού, όπου ο χειρισμός σχετιζόμενων δεδομένων και των διαδικασιών που επενεργούν σε αυτά γίνεται από κοινού, μέσω μίας δομής δεδομένων που τα περιβάλλει ως αυτόνομη οντότητα με ταυτότητα και δικά της χαρακτηριστικά. Αυτή η δομή δεδομένων καλείται αντικείμενο και αποτελεί πραγματικό στιγμιότυπο στη μνήμη ενός σύνθετου, και πιθανώς οριζόμενου από τον χρήστη, τύπου δεδομένων που ονομάζεται κλάση (class). Η κλάση προδιαγράφει τόσο δεδομένα όσο και τις διαδικασίες οι οποίες επιδρουζν επάνω τους· αυτή υπήρξε η πρωταρχική καινοτομία του ΑΠ. Έτσι μπορεί να οριστεί μία προδιαγραφή δομής αποθήκευσης (π.χ. μία κλάση «τηλεόραση») η οποία να περιέχει τόσο ιδιότητες (π.χ. μία μεταβλητή (variable) «τρέχον κανάλι») όσο και πράξεις ή χειρισμούς επί αυτών των ιδιοτήτων (π.χ. μία διαδικασία (method/function) «άνοιγμα της τηλεόρασης»). Στο εν λόγω παράδειγμα κάθε υλική τηλεόραση (κάθε αντικείμενο αποθηκευμένο πραγματικά στη μνήμη) αναπαρίσταται ως ξεχωριστό, «φυσικό» στιγμιότυπο αυτής της πρότυπης, ιδεατής κλάσης. Επομένως μόνο τα αντικείμενα καταλαμβάνουν χώρο στη μνήμη του υπολογιστή ενώ οι κλάσεις αποτελούν απλώς «καλούπια». Οι αιτίες που ώθησαν στην ανάπτυξη του ΑΠ ήταν οι ίδιες με αυτές που οδήγησαν στην ανάπτυξη του δομημένου προγραμματισμού (ευκολία συντήρησης, οργάνωσης, χειρισμού και επαναχρησιμοποίησης κώδικα μεγάλων και πολύπλοκων εφαρμογών), όμως τελικώς η αντικειμενοστρέφεια επικράτησε καθώς μπορούσε να ανταπεξέλθει σε προγράμματα πολύ μεγαλύτερου όγκου και πολυπλοκότητας. Ιστορικό[Επεξεργασία | επεξεργασία κώδικα] Οι περισσότερες αντικειμενοστρεφείς έννοιες εμφανίστηκαν αρχικά στη γλώσσα προγραμματισμού Simula 67, η οποία ήταν προσανατολισμένη στην εκτέλεση προσομοιώσεων του πραγματικού κόσμου. Οι ιδέες της Simula 67 επηρέασαν κατά τη δεκαετία του '70 την ανάπτυξη της Smalltalk, της γλώσσας που εισήγαγε τον όρο αντικειμενοστρεφής προγραμματισμός. Η Smalltalk αναπτύχθηκε από τον Άλαν Κέι (Alan Key) της εταιρείας Xerox στο πλαίσιο μίας εργασίας με στόχο τη δημιουργία ενός χρήσιμου, αλλά και εύχρηστου, προσωπικού υπολογιστή. Όταν η τελική έκδοση της Smalltalk έγινε διαθέσιμη το 1980 η έρευνα για την αντικατάσταση του δομημένου προγραμματισμού με ένα πιο σύγχρονο υπόδειγμα ήταν ήδη εν εξελίξει. Στη γλώσσα αυτή όλοι οι τύποι δεδομένων ήταν κλάσεις (δεν υπήρχαν δηλαδή πια παραδοσιακές δομές δεδομένων παρά μόνο αντικείμενα). Την ίδια περίπου εποχή, και επίσης με επιρροές από τη Simula, ολοκληρωνόταν η ανάπτυξη της C++ ως μίας ισχυρής επέκτασης της δημοφιλούς γλώσσας προγραμματισμού C στην οποία είχαν \"μεταμοσχευθεί\" αντικειμενοστρεφή χαρακτηριστικά. Η επιρροή της C++ καθ' όλη της δεκαετία του '80 ήταν καταλυτική με αποτέλεσμα τη σταδιακή κυκλοφορία αντικειμενοστρεφών εκδόσεων πολλών γνωστών διαδικαστικών γλωσσών προγραμματισμού. Κατά το πρώτο ήμισυ της δεκαετίας του '90 η βαθμιαία καθιέρωση στους μικροϋπολογιστές των γραφικών διασυνδέσεων χρήστη (GUI), για την ανάπτυξη των οποίων ο ΑΠ φαινόταν ιδιαιτέρως κατάλληλος, και η επίδραση της C++ οδήγησαν στην επικράτηση της αντικειμενοστρέφειας ως βασικού προγραμματιστικού υποδείγματος. Το 1995 η εμφάνιση της Java, μίας ιδιαίτερα επιτυχημένης, πλήρως αντικειμενοστρεφούς γλώσσας που έμοιαζε συντακτικώς με τη C/C++ και προσέφερε πρωτοποριακές για την εποχή δυνατότητες, έδωσε νέα ώθηση στον ΑΠ. Παράλληλα εμφανίστηκαν ποικίλες άτυπες βελτιώσεις στο βασικό προγραμματιστικό υπόδειγμα, όπως οι αντικειμενοστρεφείς γλώσσες μοντελοποίησης λογισμικού, τα σχεδιαστικά πρότυπα κ.λπ. Το 2001 η Microsoft εστίασε την προσοχή της στην πλατφόρμα .NET, μία ανταγωνιστική της Java πλατφόρμα ανάπτυξης και εκτέλεσης λογισμικού, η οποία ήταν εξ ολοκλήρου προσανατολισμένη στην αντικειμενοστρέφεια. Έννοιες[Επεξεργασία | επεξεργασία κώδικα] Κεντρική ιδέα στον αντικειμενοστρεφή προγραμματισμό είναι η κλάση (class), μία αυτοτελής και αφαιρετική αναπαράσταση κάποιας κατηγορίας αντικειμένων, είτε φυσικών αντικειμένων του πραγματικού κόσμου είτε νοητών, εννοιολογικών αντικειμένων, σε ένα περιβάλλον προγραμματισμού. Πρακτικώς είναι ένας τύπος δεδομένων, ή αλλιώς το προσχέδιο μιας δομής δεδομένων με δικά της περιεχόμενα, τόσο μεταβλητές όσο και διαδικασίες. Τα περιεχόμενα αυτά δηλώνονται είτε ως δημόσια (public) είτε ως ιδιωτικά (private), με τα ιδιωτικά να μην είναι προσπελάσιμα από κώδικα εκτός της κλάσης. Οι διαδικασίες των κλάσεων συνήθως καλούνται μέθοδοι (methods) και οι μεταβλητές τους γνωρίσματα (attributes) ή πεδία (fields). Μία κλάση πρέπει ιδανικά να είναι εννοιολογικά αυτοτελής, να περιέχει δηλαδή μόνο πεδία τα οποία περιγράφουν μία κατηγορία αντικειμένων και δημόσιες μεθόδους οι οποίες επενεργούν σε αυτά όταν καλούνται από το εξωτερικό πρόγραμμα, χωρίς να εξαρτώνται από άλλα δεδομένα ή κώδικα εκτός της κλάσης, και επαναχρησιμοποιήσιμη, να αποτελεί δηλαδή μαύρο κουτί δυνάμενο να λειτουργήσει χωρίς τροποποιήσεις ως τμήμα διαφορετικών προγραμμάτων. Αντικείμενο (object) είναι το στιγμιότυπο μίας κλάσης, δηλαδή αυτή καθαυτή η δομή δεδομένων (με αποκλειστικά δεσμευμένο χώρο στη μνήμη) βασισμένη στο «καλούπι» που προσφέρει η κλάση. Παραδείγματος χάριν, σε μία αντικειμενοστρεφή γλώσσα προγραμματισμού θα μπορούσαμε να ορίσουμε κάποια κλάση ονόματι BankAccount, η οποία αναπαριστά έναν τραπεζικό λογαριασμό, και να δηλώσουμε ένα αντικείμενο της με όνομα MyAccount. Το αντικείμενο αυτό θα έχει δεσμεύσει χώρο στη μνήμη με βάση τις μεταβλητές και τις μεθόδους που περιγράψαμε όταν δηλώσαμε την κλάση. Έτσι, στο αντικείμενο θα μπορούσε να περιέχεται ένα γνώρισμα Balance (=υπόλοιπο) και μία μέθοδος GetBalance (=επίστρεψε το υπόλοιπο). Ακολούθως, θα μπορούσαμε να δημιουργήσουμε ακόμα ένα ή περισσότερα αντικείμενα της ίδιας κλάσης, τα οποία θα είναι διαφορετικές δομές δεδομένων (διαφορετικοί τραπεζικοί λογαριασμοί στο παράδειγμα). Τα αντικείμενα μιας κλάσης μπορούν να προσπελάσουν τα ιδιωτικά περιεχόμενα άλλων αντικειμένων της ίδιας κλάσης. Ενθυλάκωση δεδομένων (data encapsulation) καλείται η ιδιότητα που προσφέρουν οι κλάσεις να «κρύβουν» τα ιδιωτικά δεδομένα τους από το υπόλοιπο πρόγραμμα και να εξασφαλίζουν πως μόνο μέσω των δημόσιων μεθόδων τους θα μπορούν αυτά να προσπελαστούν. Αυτή η τακτική παρουσιάζει μόνο οφέλη καθώς εξαναγκάζει κάθε εξωτερικό πρόγραμμα να φιλτράρει το χειρισμό που επιθυμεί να κάνει στα πεδία μίας κλάσης μέσω των ελέγχων που μπορούν να περιέχονται στις δημόσιες μεθόδους της κλάσης. Αφαίρεση δεδομένων καλείται η ιδιότητα των κλάσεων να αναπαριστούν αφαιρετικά πολύπλοκες οντότητες στο προγραμματιστικό περιβάλλον. Μία κλάση αποτελεί ένα αφαιρετικό μοντέλο κάποιας κατηγορίας αντικειμένων. Επίσης, οι κλάσεις προσφέρουν και αφαίρεση ως προς τον υπολογιστή, εφόσον η καθεμία μπορεί να θεωρηθεί ένας μικρός και αυτάρκης υπολογιστής (με δική του κατάσταση, μεθόδους και μεταβλητές). Κληρονομικότητα ονομάζεται η ιδιότητα των κλάσεων να επεκτείνονται σε νέες κλάσεις, ρητά δηλωμένες ως κληρονόμους (υποκλάσεις ή 'θυγατρικές κλάσεις'), οι οποίες μπορούν να επαναχρησιμοποιήσουν τις μεταβιβάσιμες μεθόδους και ιδιότητες της γονικής τους κλάσης αλλά και να προσθέσουν δικές τους. Στιγμιότυπα των θυγατρικών κλάσεων μπορούν να χρησιμοποιηθούν όπου απαιτούνται στιγμιότυπα των γονικών (εφόσον η θυγατρική είναι κατά κάποιον τρόπο μία πιο εξειδικευμένη εκδοχή της γονικής), αλλά το αντίστροφο δεν ισχύει. Παράδειγμα κληρονομικότητας είναι μία γονική κλάση Vehicle (=Όχημα) και οι δύο πιο εξειδικευμένες υποκλάσεις της Car (=Αυτοκίνητο) και Bicycle (=Ποδήλατο), οι οποίες λέμε ότι \"κληρονομούν\" από αυτήν. Πολλαπλή κληρονομικότητα είναι η δυνατότητα που προσφέρουν ορισμένες γλώσσες προγραμματισμού μία κλάση να κληρονομεί ταυτόχρονα από περισσότερες από μία γονικές. Από μία υποκλάση μπορούν να προκύψουν νέες υποκλάσεις που κληρονομούν από αυτήν, με αποτέλεσμα μία ιεραρχία κλάσεων που συνδέονται μεταξύ τους \"ανά γενιά\" με σχέσεις κληρονομικότητας. Υπερφόρτωση μεθόδου (method overloading) είναι η κατάσταση κατά την οποία υπάρχουν, στην ίδια ή σε διαφορετικές κλάσεις, μέθοδοι με το ίδιο όνομα και πιθανώς διαφορετικά ορίσματα. Αν πρόκειται για μεθόδους της ίδιας κλάσης διαφοροποιούνται μόνο από τις διαφορές τους στα ορίσματα και στον τύπο επιστροφής. Υποσκέλιση μεθόδου (method overriding) είναι η κατάσταση κατά την οποία μία θυγατρική κλάση και η γονική της έχουν μία μέθοδο ομώνυμη και με τα ίδια ορίσματα. Χάρη στη δυνατότητα του πολυμορφισμού ο μεταγλωττιστής «ξέρει» πότε να καλέσει ποια μέθοδο, βασισμένος στον τύπο του τρέχοντος αντικειμένου. Δηλαδή πολυμορφισμός είναι η δυνατότητα των αντικειμενοστρεφών μεταγλωττιστών να αποφασίζουν δυναμικά ποια είναι η κατάλληλη να κληθεί μέθοδος σε συνθήκες υποσκέλισης. Αφηρημένη κλάση (abstract class) είναι μία κλάση που ορίζεται μόνο για να κληρονομηθεί σε θυγατρικές υποκλάσεις και δεν υπάρχουν δικά της στιγμιότυπα (αντικείμενα). Η αφηρημένη κλάση ορίζει απλώς ένα \"συμβόλαιο\" το οποίο θα πρέπει να ακολουθούν οι υποκλάσεις της όσον αφορά τις υπογραφές των μεθόδων τους (όπου ως υπογραφή ορίζεται το όνομα, τα ορίσματα και η τιμή επιστροφής μίας διαδικασίας). Μία αφηρημένη κλάση μπορεί να έχει και μη αφηρημένες μεθόδους οι οποίες υλοποιούνται στην ίδια την κλάση (αν και φυσικά μπορούν να υποσκελίζονται σε υποκλάσεις). Αντιθέτως, οι αφηρημένες μέθοδοί της είναι απλώς ένας ορισμός της υπογραφής τους και εναπόκειται στις υποκλάσεις να τις υλοποιήσουν. Μία αφηρημένη κλάση που δεν έχει γνωρίσματα και όλες οι μέθοδοί της είναι αφηρημένες και δημόσιες καλείται διασύνδεση (interface). Οι κλάσεις που κληρονομούν από μία διασύνδεση λέγεται ότι την \"υλοποιούν\". Ακολουθεί ένα απλό παράδειγμα σε γλώσσα προγραμματισμού Java: interface Logger { public void log(String msg); } class ConsoleLogger implements Logger { public void log(String msg) { System.err.println(\"\\nConsole logging...\" + msg + \"\\n\"); } } class FileLogger implements Logger { public void log(String msg) { System.out.println(\"\\nFile logging...\" + msg + \"\\n\"); } } public class LogTest { public static void main(String[] args) { if (args.length != 1) { System.out.println(\"\\nError. Exiting...\"); return; } Logger logg; String choice = args; if (choice.equals(\"FileLogger\")) { logg = new FileLogger(); } else if (choice.equals(\"ConsoleLogger\")) { logg = new ConsoleLogger(); } else { System.err.println(\"\\nError. Exiting...\"); return; } logg.log(\"Log This!\"); } } Στο παραπάνω παράδειγμα ορίζουμε μία διασύνδεση Logger η οποία παρέχει την υπογραφή μίας μεθόδου log, που υποθέτουμε πως πρέπει να καταγράφει κάπου πληροφορίες για τα σφάλματα που συναντά η εφαρμογή όταν εκτελείται (οι πληροφορίες αυτές τής μεταβιβάζονται με το αλφαριθμητικό όρισμα msg). Η κλάση ConsoleLogger και η κλάση FileLogger είναι δύο διαφορετικές κλάσεις που υλοποιούν τη διασύνδεση Logger και υποσκελίζουν, η καθεμία με διαφορετικό τρόπο, τη μέθοδο log ώστε η μία να καταγράφει πληροφορίες στην οθόνη και η άλλη σε κάποιο αρχείο. Το πρόγραμμα LogTest είναι ένα μικρό δοκιμαστικό πρόγραμμα το οποίο δέχεται ως όρισμα γραμμής εντολών το πού επιθυμεί ο χρήστης να γίνεται η καταγραφή και δημιουργεί ένα στιγμιότυπο της αντίστοιχης κλάσης: της ConsoleLogger ή της FileLogger. Το στιγμιότυπο αυτό δηλώνεται με τον γενικότερο τύπο Logger, τον τύπο δηλαδή της διασύνδεσης που υλοποιούν και οι δύο κλάσεις, αλλά χάρη στον πολυμορφισμό καλείται αυτομάτως η κατάλληλη εκδοχή της μεθόδου log. Αρχές αντικειμενοστρεφούς σχεδίασης[Επεξεργασία | επεξεργασία κώδικα] Με το πέρασμα του χρόνου κωδικοποιήθηκαν κάποιες ανεπίσημες αρχές για την ορθή σχεδίαση αντικειμενοστρεφών συστημάτων λογισμικού. Οι αρχές αυτές παρουσιάστηκαν κατά καιρούς σε βιβλία και άρθρα ακαδημαϊκών και αναγνωρισμένων μηχανικών λογισμικού. Οι σπουδαιότερες αρχές είναι οι παρακάτω: Αρχή ανοιχτότητας-κλειστότητας (open-closed principle), του δημιουργού της γλώσσας προγραμματισμού Eiffel Μπέρτραντ Μέιερ. Η αρχή αυτή δηλώνει πως τα συστατικά ενός προγράμματος πρέπει να είναι \"ανοιχτά\" ως προς την επέκταση των δυνατοτήτων του συστήματος αλλά \"κλειστά\" ως προς αλλαγές στην υλοποίηση του. Πρακτικώς αυτό σημαίνει οι διάφορες κλάσεις και τα υπόλοιπα τμήματα λογισμικού να μη χρειάζεται να τροποποιηθούν σε περίπτωση που προστεθεί νέα λειτουργικότητα στο σύστημα (π.χ. μία νέα κλάση) προκειμένου να την αξιοποιήσουν. Βεβαίως είναι αδύνατο να μη χρειάζεται να τροποποιηθεί τίποτα, οπότε αυτό που επιτάσσει στην πραγματικότητα η εν λόγω αρχή είναι η ελαχιστοποίηση και η συγκέντρωση, κατά προτίμηση σε ένα μικρό τμήμα του κώδικα, των γραμμών που θα πρέπει να αλλάξουν. Αυτό συνήθως επιτυγχάνεται μέσω αφαίρεσης (με αφηρημένες κλάσεις ή διασυνδέσεις και πραγματικές κλάσεις που κληρονομούν από αυτές) και με χρήση του πολυμορφισμού. Έτσι, στο παράδειγμα της προηγούμενης ενότητας αν προσθέσουμε και μία τρίτη υλοποίηση της διασύνδεσης Logger, την PrinterLogger η οποία \"καταγράφει\" σφάλματα αποστέλλοντας τα προς εκτύπωση, ο κώδικας του προγράμματος γίνεται: public class LogTest { public static void main(String[] args) { if (args.length != 1) { System.out.println(\"\\nError. Exiting...\"); return; } Logger logg; String choice = args; if (choice.equals(\"FileLogger\")) { logg = new FileLogger(); } else if(choice.equals(\"ConsoleLogger\")) { logg = new ConsoleLogger(); } else if(choice.equals(\"PrinterLogger\")) { logg = new PrinterLogger(); } else { System.err.println(\"\\nError. Exiting...\"); return; } logg.log(\"Log This!\"); } } Όπως φαίνεται μόνη αλλαγή είναι η προσθήκη μίας ακόμα δήλωσης else if. Η εντολή logg.log(\"Log This!\"); μπορεί να λειτουργήσει και με αντικείμενα του νέου τύπου χωρίς καμία τροποποίηση. Μία συνηθισμένη τακτική για διασφάλιση της κλειστότητας του ολικού προγράμματος ως προς την υλοποίηση μίας κλάσης, είναι η συνειδητή προσπάθεια για δήλωση όλων των γνωρισμάτων της ως ιδιωτικών. Έτσι η προσπέλαση των πεδίων της κλάσης μπορεί να ελεγχθεί εξ ολοκλήρου μέσω ειδικών δημόσιων μεθόδων της, γεγονός που διευκολύνει κατά πολύ την αποσφαλμάτωση: στις μεθόδους αυτές συγκεντρώνονται οι έλεγχοι επιτρεπτών τιμών για τα πεδία, έλεγχοι κατάλληλων συνθηκών κλπ. Αρχή υποκατάστασης Λίσκοφ (Liskov substitution principle), της επιστήμονα υπολογιστών Μπάρμπαρα Λίσκοφ. Η αρχή αυτή συμπυκνώνεται στον παρακάτω κανόνα για σχηματισμό μίας ορθής ιεραρχίας κλάσεων: μία κλάση Κ1 μπορεί να υλοποιηθεί ως υποκλάση μίας κλάσης Κ2 αν κάθε πρόγραμμα Π το οποίο λειτουργεί με αντικείμενα Κ2 συμπεριφέρεται με τον ίδιο τρόπο και με αντίστοιχα αντικείμενα Κ1. Έτσι με την αρχή υποκατάστασης Λίσκοφ φαίνεται πως για να οριστεί μία κλάση ως θυγατρική μίας άλλης δεν αρκεί να έχουν διαισθητικά μία ανάλογη εννοιολογική σχέση (π.χ. μία κλάση που αναπαριστά όχημα και μία που αναπαριστά αυτοκίνητο) αλλά, στο πλαίσιο του υπό εξέταση προγράμματος, τα αντικείμενα της υποκλάσης να έχουν πάντα την ίδια προγραμματιστική συμπεριφορά με τα αντικείμενα της υπερκλάσης υπό τις ίδιες συνθήκες. Αρχή αντιστροφής εξαρτήσεων (dependency inversion principle), του γνωστού μηχανικού λογισμικού Ρόμπερτ Σέσιλ Μάρτιν. Η αρχή αυτή πρακτικά αποτελεί εκλέπτυνση της αρχής ανοιχτότητας-κλειστότητας, προϋποθέτοντας όμως χρήση και της αρχής υποκατάστασης Λίσκοφ. Αφορά ιεραρχίες κληρονομικότητας κλάσεων και τη χρήση αντικειμένων αυτών των ιεραρχιών από εξωτερικά προγράμματα. Στα πλαίσια της αρχής αντιστροφής εξαρτήσεων ένα τμήμα λογισμικού Α (π.χ. μία κλάση) το οποίο χρησιμοποιεί τις υπηρεσίες που παρέχει ένα άλλο τμήμα λογισμικού Β, καλώντας για παράδειγμα μία μέθοδό του, θεωρείται στοιχείο \"υψηλότερου επιπέδου\" σε σχέση με το Β. Η αρχή λέει πως τα υψηλού επιπέδου στοιχεία δεν πρέπει να εξαρτώνται από την υλοποίηση χαμηλότερου επιπέδου στοιχείων, αλλά πως και τα δύο πρέπει να βασίζονται σε ενδιάμεσα επίπεδα αφαίρεσης. Στην πράξη αυτή η αφαίρεση είναι μία διασύνδεση (ή αφηρημένη κλάση) την οποία γνωρίζει το υψηλού επιπέδου στοιχείο Α και υλοποιεί το χαμηλού επιπέδου στοιχείο Β. Ακόμα και αν το Β αλλαχθεί με μία κλάση Γ η οποία επίσης υλοποιεί την ίδια διασύνδεση, το Α θα πρέπει να συνεχίσει να λειτουργεί χωρίς καμία τροποποίηση. Η αρχή αντιστροφής εξαρτήσεων δεν είναι παρά ένα απτό παράδειγμα χρήσης ιεραρχικών επιπέδων με τη βοήθεια ενδιάμεσων αφαιρέσεων, μίας πρακτικής που εφαρμόζεται κατά κόρον στην επιστήμη υπολογιστών (για ένα άλλο παράδειγμα βλέπε δίκτυα υπολογιστών). Αρχή διαχωρισμού διασυνδέσεων (interface segregation principle), του μηχανικού λογισμικού Ρόμπερτ Σέσιλ Μάρτιν. Η εν λόγω αρχή σημαίνει ότι σε περιπτώσεις όπου διαφορετικά υποσύνολα μεθόδων μίας κλάσης αφορούν διαφορετικές περιπτώσεις χρήσης της κλάσης, σκόπιμο είναι να ορίζουμε επιμέρους διασυνδέσεις τις οποίες η κλάση θα υλοποιεί. Κάθε τέτοια διασύνδεση θα ορίζει μόνο το αντίστοιχο υποσύνολο των μεθόδων. Αρχή μοναδικής αρμοδιότητας (single responsibility principle), των Τομ Ντε Μάρκο και Μέιρ Πέιτζ Τζόουνς. Σύμφωνα με την αρχή αυτή κάθε κλάση θα πρέπει να έχει μόνο μία, καλά ορισμένη και διαχωρισμένη από το υπόλοιπο πρόγραμμα αρμοδιότητα, η ύπαρξη της οποίας να εξυπηρετεί έναν συγκεκριμένο σκοπό. Αν μπορούμε να εντοπίσουμε σε μία κλάση Α δύο διαφορετικές αρμοδιότητες, τότε η καλύτερη λύση είναι η διάσπαση της σε δύο κλάσεις Β' και Γ', καθεμία από τις οποίες θα λάβει ένα υποσύνολο των πεδίων και των μεθόδων της Α. Τα υποσύνολα αυτά θα είναι ξένα μεταξύ τους, οπότε με το ανάποδο σκεπτικό αν μπορούμε να διασπάσουμε μία κλάση Α σε δύο άλλες κλάσεις (π.χ. σε περίπτωση που κάποιες μέθοδοι δε χρησιμοποιούν κάποια γνωρίσματα, οπότε οι μεν μπορούν να καταλήξουν στη μία κλάση Β' και τα πεδία στην άλλη κλάση Γ') τότε πιθανώς η κλάση να παραβιάζει την αρχή μοναδικής αρμοδιότητας. Έτσι έχουν προταθεί κάποιες μετρικές οι οποίες επιχειρούν να προσδιορίσουν την έλλειψη συνοχής (cohesion) σε μία κλάση, δηλαδή το κατά πόσον οι μέθοδοι της δε σχετίζονται με τα γνωρίσματα της. Συνήθως η συνοχή αντιπαραβάλλεται με τη σύζευξη (coupling), δηλαδή το βαθμό στον οποίον μία κλάση εξαρτάται από κάποια/ες άλλη/ες, και τα δύο αυτά μεγέθη είναι αντιστρόφως ανάλογα. Μετρικές ποιότητας[Επεξεργασία | επεξεργασία κώδικα] Κατά καιρούς έχουν οριστεί κάποιες μετρικές για την εκτίμηση της περιπλοκότητας και της ποιότητας μίας αντικειμενοστρεφούς σχεδίασης λογισμικού. Σε αυτές συμπεριλαμβάνονται και οι μετρικές έλλειψης συνοχής (LCOM). Ακολουθεί μία σύνοψη των σπουδαιότερων: Weighted Methods per Class (WMC)[Επεξεργασία | επεξεργασία κώδικα] Το ακέραιο πλήθος των μεθόδων που ορίζονται σε μία κλάση. Δεν υπάρχει ένα καθιερωμένο εύρος βέλτιστου WMC αλλά είναι γενικώς αποδεκτό ότι υπερβολικά μεγάλο WMC οδηγεί σε μεγαλύτερη πιθανότητα σφαλμάτων και προβλημάτων συντήρησης. Depth of Inheritance Tree (DIT)[Επεξεργασία | επεξεργασία κώδικα] Το μήκος του μέγιστου μονοπατιού κληρονομικότητας από την τρέχουσα κλάση έως τη ρίζα μιας ιεραρχίας κλάσεων. Μεγάλες τιμές DIT αυξάνουν την πολυπλοκότητα της σχεδίασης, την πιθανότητα σφαλμάτων αλλά και την επαναχρησιμοποίηση κώδικα λόγω της κληροδότησης μεθόδων. Μία βέλτιστη τιμή DIT θεωρείται το 5. Number of Children (NOC)[Επεξεργασία | επεξεργασία κώδικα] Το πλήθος των κλάσεων που κληρονομούν άμεσα από την τρέχουσα. Υψηλό NOC σημαίνει υψηλή επαναχρησιμοποίηση κώδικα αλλά πιθανόν να υποδεικνύει εννοιολογικά εσφαλμένη χρήση της κληρονομικότητας. Δεν υπάρχει κάποιο γενικώς αποδεκτό βέλτιστο NOC, αφού αυτό εξαρτάται από την εκάστοτε κλάση, αλλά εν γένει οι κλάσεις οι ευρισκόμενες υψηλότερα στην ιεραρχία κληρονομικότητας είναι θεμιτό να έχουν υψηλότερο NOC από όσες τοποθετούνται χαμηλότερα αφού είναι λιγότερο εξειδικευμένες. Coupling Between Object Classes (CBO)[Επεξεργασία | επεξεργασία κώδικα] Το πλήθος των κλάσεων από τις οποίες εξαρτάται η τρέχουσα κλάση. Κάθε τέτοια εξάρτηση μπορεί να είναι αμφίδρομη ή μονόδρομη οποιασδήποτε κατεύθυνσης. Επομένως υψηλό CBO σημαίνει υψηλή σύζευξη (coupling) και δεν είναι επιθυμητό, καθώς αποτρέπει την επαναχρησιμοποίηση κώδικα και ζημιώνει τον αρθρωτό σχεδιασμό του προγράμματος. Όσο χαμηλότερο είναι το CBO μίας κλάσης τόσο πιθανότερο είναι να μπορεί η τελευταία να επαναχρησιμοποιηθεί ως μαύρο κουτί. Υπερβολικά υψηλές θεωρούνται οι τιμές CBO > 14. Response for a Class (RFC και RFC’)[Επεξεργασία | επεξεργασία κώδικα] Η μετρική αυτή ισούται με το πλήθος των μεθόδων που μπορεί να εκτελεστούν ως απάντηση στη λήψη ενός μηνύματος / συμβάντος από την τρέχουσα κλάση (έστω Α), τόσο τοπικών της μεθόδων όσο και «απομακρυσμένων» μεθόδων άλλων κλάσεων οι οποίες καλούνται άμεσα από την Α. Η μετρική RFC’ συμπεριλαμβάνει επιπλέον και τις απομακρυσμένες μεθόδους που καλούνται εμμέσως (π. χ. από άμεσα καλούμενες απομακρυσμένες μεθόδους ή, αναδρομικά, από άλλες έμμεσα καλούμενες απομακρυσμένες μεθόδους). Κάθε μέθοδος μετράται μόνο μία φορά στον υπολογισμό του RFC, ανεξαρτήτως του πόσες φορές καλείται. Υψηλή τιμή RFC υποδεικνύει υψηλές πιθανότητες σφάλματος και δυσκολία συντήρησης. LCOM1[Επεξεργασία | επεξεργασία κώδικα] Μετρική έλλειψης συνοχής. Ισχύει LCOM1 = P - Q αν P > Q, διαφορετικά LCOM1 = 0. Τα P, Q υπολογίζονται με τον ακόλουθο αλγόριθμο (σε ψευδοκώδικα): P = 0; Q = 0; Για κάθε ζεύγος μεθόδων της κλάσης do { Αν τα σύνολα των πεδίων που χρησιμοποιούν οι δύο τρέχουσες μέθοδοι είναι ξένα μεταξύ τους P = P + 1; Διαφορετικά Q = Q + 1; } Μία τιμή LCOM1 = 0 υποδεικνύει συνεκτική κλάση, ενώ αν LCOM1 > 0 η κλάση καλό είναι να διασπαστεί. Η μετρική LCOM1 παρουσιάζει κάποια προβλήματα, όπως π.χ. ότι δίνει τιμή 0 για κλάσεις πολύ διαφορετικές μεταξύ τους. LCOM2[Επεξεργασία | επεξεργασία κώδικα] Βελτιωμένη μετρική έλλειψης συνοχής. Ισχύει LCOM2 = 1 - sum(mA)/(m*a), όπου m το πλήθος των μεθόδων της κλάσης, a το πλήθος των πεδίων της, mA το πλήθος των μεθόδων που προσπελαύνουν ένα γνώρισμα και sum(mA) το άθροισμα των mA για όλα τα πεδία μίας κλάσης. Η μετρική LCOM2 αποτελεί τον μέσο όρο των ποσοστών των μεθόδων που δε χρησιμοποιούν κάθε γνώρισμα. LCOM2 = 0 (υψηλή συνοχή) σημαίνει πως όλες οι μέθοδοι της κλάσης χρησιμοποιούν όλα τα πεδία της, ενώ LCOM2 = 1 (καμία συνοχή) σημαίνει πως καμία μέθοδος δεν προσπελαύνει κανένα πεδίο. LCOM3[Επεξεργασία | επεξεργασία κώδικα] Εναλλακτική μετρική έλλειψης συνοχής. Ισχύει LCOM3 = (m - sum(mA)/a) / (m-1). Η μετρική LCOM3 λαμβάνει τιμές από 0 (υψηλή συνοχή) έως 2 (καμία συνοχή). Τιμές μεγαλύτερες του 1 σημαίνουν πως με βεβαιότητα υπάρχει τουλάχιστον ένα \"νεκρό γνώρισμα\", δηλαδή γνώρισμα το οποίο δεν προσπελαύνεται από καμία μέθοδο της κλάσης. UML[Επεξεργασία | επεξεργασία κώδικα] Κύριο λήμμα: Γλώσσες μοντελοποίησης λογισμικού Μετά την ευρεία διάδοση του ΑΠ κατά τη δεκαετία του '90, το αντικειμενοστρεφές μοντέλο σχεδίασης (με κλάσεις, κληρονομικότητα, αντικείμενα και τυποποιημένες αλληλεπιδράσεις μεταξύ τους) επικράτησε ακόμη και για μοντελοποίηση που δεν περιελάμβανε καν προγραμματισμό (π. χ. σχήματα βάσεων δεδομένων). Έτσι αναπτύχθηκαν διάφορες πρότυπες γλώσσες μοντελοποίησης λογισμικού οι οποίες τυποποιούσαν οπτικά σύμβολα και συμπεριφορές με στόχο την αφαιρετική περιγραφή της λειτουργίας και της δομής ενός υπολογιστικού συστήματος. Οι γλώσσες αυτές είχαν εξαρχής έναν εμφανή αντικειμενοστρεφή προσανατολισμό. Τελικά οι πιο δημοφιλείς από αυτές ενοποιήθηκαν στο κοινό πρότυπο UML που η πρώτη του έκδοση οριστικοποιήθηκε το 1997. Η UML πλέον είναι η πρότυπη γλώσσα μοντελοποίησης στη μηχανική λογισμικού. Χρησιμοποιείται για τη γραφική απεικόνιση, προσδιορισμό, κατασκευή και τεκμηρίωση των στοιχείων ενός συστήματος λογισμικού. Μπορεί να χρησιμοποιηθεί σε διάφορες φάσεις ανάπτυξης, από την ανάλυση απαιτήσεων ως τον έλεγχο ενός ολοκληρωμένου συστήματος, και αποτελείται από ένα σύνολο προσυμφωνημένων όρων, συμβόλων και διαγραμμάτων. Σχεδιαστικά πρότυπα[Επεξεργασία | επεξεργασία κώδικα] Κύριο λήμμα: Σχεδιαστικά πρότυπα Κατά τα τέλη της δεκαετίας του '70 ένας αρχιτέκτονας ονόματι Κρίστοφερ Αλεξάντερ επιχείρησε να βρει και να καταγράψει αποδεδειγμένα ποιοτικούς σχεδιασμούς στον τομέα των κατασκευών. Έτσι μελέτησε πολλές διαφορετικές κατασκευές που εξυπηρετούσαν τον ίδιο σκοπό και προσπάθησε να ανακαλύψει κοινά στοιχεία, τα οποία κατηγοριοποίησε σε σχεδιαστικά πρότυπα (design patterns). Το 1987 η ιδέα της εύρεσης σχεδιαστικών προτύπων εφαρμόστηκε για πρώτη φορά στη μηχανική λογισμικού και μέχρι τα μέσα της δεκαετίας του '90 η εν λόγω έννοια είχε καθιερωθεί και εξαπλωθεί, στραμμένη πλέον στον κόσμο της αντικειμενοστρέφειας. Ένα πρότυπο σχεδίασης ορίζεται ως μία αποδεδειγμένα καλή λύση που έχει εφαρμοστεί με επιτυχία στην επίλυση ενός επαναλαμβανόμενου προβλήματος σχεδίασης συστημάτων λογισμικού. Τα πρότυπα σχεδίασης ορίζονται τόσο σε επίπεδο μακροσκοπικής σχεδίασης όσο και σε επίπεδο υλοποίησης, ενώ με τη χρήση τους ένας προγραμματιστής αντικαθιστά πρακτικώς μεγάλα τμήματα του κώδικα του με μαύρα κουτιά. Πρόκειται για αφαιρέσεις υψηλού επιπέδου που αποτελούν πλήρη υποσυστήματα, κατάλληλα ρυθμισμένα για την επίλυση συγκεκριμένων προβλημάτων και έτοιμα για χρήση. Έχουν οριστεί διάφορες κατηγορίες προτύπων, για διαφορετικά προβλήματα, και κάθε κατηγορία περιλαμβάνει πολλαπλά στοιχεία. Έτσι υπάρχουν κατασκευαστικά πρότυπα, δομικά πρότυπα, συμπεριφορικά πρότυπα κλπ. Δείτε επίσης[Επεξεργασία | επεξεργασία κώδικα] Αντικειμενοστρεφείς βάσεις δεδομένων Αντικειμενοστρεφής προγραμματισμός στη C Παραπομπές[Επεξεργασία | επεξεργασία κώδικα] ↑ Ο όρος object-oriented αποδόθηκε από τις ορολογικές ομάδες ΜΟΤΟ και ΕΛΟΤ/ΤΕ48/ΟΕ1 στα ελληνικά ως αντικειμενοστρεφής, αλλά η λέξη απαντάται στα ελληνικά και σαν «αντικειμενοστραφής». ↑ «Γιατί χρησιμοποιείτε τον όρο αντικειμενοστρεφής και όχι αντικειμενοστραφής;» από ιστοσελίδα του Διομήδη Σπινέλλη. Αρχειοθετήθηκε 13/01/2019. Ανακτήθηκε 13/01/2019. Βιβλιογραφία και Πηγές[Επεξεργασία | επεξεργασία κώδικα] Βασικές Αρχές Γλωσσών Προγραμματισμού, Ellis Horowitz, Εκδόσεις Κλειδάριθμος Σχεδιαστικά Πρότυπα, Απόστολος Ζάρρας, Λέκτορας Πανεπιστημίου Ιωαννίνων, http://www.cs.uoi.gr/~zarras/dpatts.htm Core Techniques and Algorithms in Game Programming, Daniel Sanchez-Crespo Dalmeau, Εκδόσεις New Riders Chidamber & Kemerer Object-Oriented Metrics Suite, http://www.aivosto.com/project/help/pm-oo-ck.html Αντικειμενοστραφής Προγραμματισμός στη Μ2000. https://www.ebooks4greeks.gr/antikeimenostrafhs-programmatismos-sth-m2000 Καθιερωμένοι όροι LCCN: sh87007503 GND: 4233947-9 BNF: cb12115131k (data) NDL: 00937980 NKC: ph115529 BNE: XX537453 wiktionary logo Το Βικιλεξικό έχει σχετικό λήμμα: αντικειμενοστρεφής προγραμματισμός Πύλη:Προγραμματισμός"
    },
    {
        "id": 8,
        "url": "https://el.wikipedia.org/wiki/%CE%A0%CF%81%CE%BF%CE%B3%CF%81%CE%B1%CE%BC%CE%BC%CE%B1%CF%84%CE%B9%CF%83%CF%84%CE%B9%CE%BA%CF%8C_%CF%85%CF%80%CF%8C%CE%B4%CE%B5%CE%B9%CE%B3%CE%BC%CE%B1",
        "title": "Προγραμματιστικό παράδειγμα",
        "content": "Προγραμματιστικό παράδειγμα (ή πρ. υπόδειγμα ή πρ. μεθοδολογία ή πρ. προσέγγιση) (αγγλικα: programming paradigm) καλείται η ιδιαίτερη τεχνική και οι μέθοδοι με τις οποίες ένα υπολογιστικό πρόβλημα και η αλγοριθμική λύση του προσεγγίζονται στον προγραμματισμό των υπολογιστών. Είναι δηλαδή ένα σύνολο εννοιών οι οποίες εκφράζουν έναν συγκεκριμένο τρόπο σκέψης, και κατά συνέπεια έκφρασης της υλοποίησης, διαμορφώνοντας τον τρόπο σχεδιασμού ενός προγράμματος. Μια γλώσσα προγραμματισμού μπορεί να υποστηρίξει πολλαπλά παραδείγματα. Έτσι, προγράμματα που γράφτηκαν στη γλώσσα C++ ή στην Object Pascal μπορεί να είναι αμιγώς διαδικαστικά, ή αμιγώς αντικειμενοστρεφή, ή να περιέχουν στοιχεία και από τα δύο παραδείγματα. Οι δημιουργοί λογισμικού αποφασίζουν πώς να χρησιμοποιήσουν αυτά τα στοιχεία του υποδείγματος. Τα σημαντικότερα προγραμματιστικά παραδείγματα είναι: Προστακτικός προγραμματισμός (Imperative programming) Διαδικαστικός προγραμματισμός (procedural programming), που είναι υποκατηγορία του Δομημένου προγραμματισμού (Structured programming) Αντικειμενοστρεφής προγραμματισμός (object-oriented programming) Δηλωτικός προγραμματισμός (declarative programming) Συναρτησιακός προγραμματισμός (functional programming) Λογικός προγραμματισμός (Logic programming) Παραπομπές[Επεξεργασία | επεξεργασία κώδικα] ↑ 1,0 1,1 1,2 Αναστάσιος Χατζηπαπαδόπουλος, Δρ. Βασίλης Σ. Μπελεσιώτης, 2018. «Πέτρα-Ψαλίδι-Χαρτί. Από το Δομημένο στον Αντικειμενοστρεφή προγραμματισμό Αρχειοθετήθηκε 2019-04-12 στο Wayback Machine.», Τμήμα Πληροφορικής, Ιόνιο Πανεπιστήμιο Αρχειοθετήθηκε 2019-01-29 στο Wayback Machine., σελ. 14 (σελ. 2 του pdf). Αρχειοθετήθηκε 12/04/2019. Ανακτήθηκε 12/04/2019. ↑ Αγγελιδάκης, Ν. (Ηράκλειο 2015). \"Εισαγωγή στον προγραμματισμό με την Python\", σελ. 5 (σελ. 14 του pdf). Αρχειοθετήθηκε 12/06/2018 Ανακτήθηκε 07/04/2019. (ISBN 978-960-93-7364-7). ↑ April J. Wells, Grid Application Systems Design, CRC Press 2007, σελ. 5, ISBN 978-0-8493-2997-5 ↑ 4,0 4,1 Σταματόπουλος, Παναγιώτης, 2015. «Κεφάλαιο 1. Διαδικαστικός και δηλωτικός προγραμματισμός Αρχειοθετήθηκε 2019-04-13 στο Wayback Machine.» σελ.8 (σελ. 1 του pdf) από Λογικός και συναρτησιακός προγραμματισμός (ISBN 978-960-603-335-3). Δημοσιεύθηκε 19/10/2015. Αρχειοθετήθηκε 13/04/2019. Ανακτήθηκε 14/04/2019."
    },
    {
        "id": 9,
        "url": "https://el.wikipedia.org/wiki/%CE%94%CF%85%CE%BD%CE%B1%CE%BC%CE%B9%CE%BA%CE%AE_%CE%B3%CE%BB%CF%8E%CF%83%CF%83%CE%B1_%CF%80%CF%81%CE%BF%CE%B3%CF%81%CE%B1%CE%BC%CE%BC%CE%B1%CF%84%CE%B9%CF%83%CE%BC%CE%BF%CF%8D",
        "title": "Δυναμική γλώσσα προγραμματισμού",
        "content": "Ο όρος δυναμική γλώσσα προγραμματισμού χρησιμοποιείται ευρύτατα στην επιστήμη των υπολογιστών για να περιγράψει γλώσσες προγραμματισμού υψηλού επιπέδου που παρουσιάζουν κατά το χρόνο εκτέλεσης συμπεριφορά που άλλες γλώσσες ίσως παρουσιάζουν κατά τη μετάφραση. Αυτές οι συμπεριφορές μπορεί να αποτελούν επέκταση του προγράμματος, είτε προσθέτοντας νέο κώδικα, είτε επεκτείνοντας αντικείμενα και ορισμούς, είτε τροποποιώντας το σύστημα τύπων, όλα κατά τη διάρκεια της εκτέλεσης του προγράμματος. Αυτές οι συμπεριφορές μπορούν να εφαρμοστούν σχεδόν σε οποιαδήποτε γλώσσα επαρκούς πολυπλοκότητας, αλλά οι δυναμικές γλώσσες παρέχουν εργαλεία για να διευκολύνουν τη χρήση τους. Οι περισσότερες δυναμικές γλώσσες έχουν δυναμικούς τύπους. Περιορισμοί και ασάφειες στον ορισμό[Επεξεργασία | επεξεργασία κώδικα] Ο ορισμός της δυναμικής γλώσσας προγραμματισμού είναι ασαφής γιατί προσπαθεί να κάνει διάκριση μεταξύ κώδικα και δεδομένων καθώς και μεταξύ χρόνου μετάφρασης και χρόνου εκτέλεσης, που δεν είναι όμως καθολικά. Οι εικονικές μηχανές, η μεταγλώττιση just-in-time και η δυνατότητα πολλών γλωσσών προγραμματισμού να μεταβάλλουν άμεσα τον κώδικα μηχανής σε κάποια συστήματα καθιστούν μια τέτοια διάκριση αφηρημένη. Σε γενικές γραμμές, ο ισχυρισμός ότι μια γλώσσα προγραμματισμού είναι δυναμική αναφέρεται περισσότερο την ευκολία χρήσης ορισμένων δυναμικών χαρακτηριστικών της γλώσσας παρά στις δυνατότητες της ίδιας της γλώσσας. Παραδείγματα[Επεξεργασία | επεξεργασία κώδικα] Ορισμένα παραδείγματα γλωσσών προγραμματισμού που θεωρούνται δυναμικές: BeanShell Common Lisp και μερικές άλλες διάλεκτοι της Lisp Groovy JavaScript ActionScript Perl PHP Python Ruby Smalltalk Tcl Objective-C Κάποιες από αυτές τις γλώσσες υποστηρίζονται και στο .NET Framework από το Microsoft Dynamic Language Runtime. Παραπομπές[Επεξεργασία | επεξεργασία κώδικα] ↑ http://www.eclipse.org/dltk/ ↑ «Αρχειοθετημένο αντίγραφο». Αρχειοθετήθηκε από το πρωτότυπο στις 12 Ιουνίου 2010. Ανακτήθηκε στις 15 Ιανουαρίου 2011. ↑ http://static.springsource.org/spring/docs/2.0.x/reference/dynamic-language.html ↑ <http://groovy.codehaus.org/ Αρχειοθετήθηκε 2012-02-11 στο Wayback Machine. Δείτε επίσης[Επεξεργασία | επεξεργασία κώδικα] Γλώσσα προγραμματισμού σεναρίων"
    },
    {
        "id": 10,
        "url": "https://el.wikipedia.org/wiki/%CE%A3%CF%85%CE%BB%CE%BB%CE%BF%CE%B3%CE%AE_%CE%B1%CF%80%CE%BF%CF%81%CF%81%CE%B9%CE%BC%CE%BC%CE%AC%CF%84%CF%89%CE%BD_(%CF%85%CF%80%CE%BF%CE%BB%CE%BF%CE%B3%CE%B9%CF%83%CF%84%CE%AD%CF%82)",
        "title": "Συλλογή απορριμμάτων (υπολογιστές)",
        "content": "Στην πληροφορική, η συλλογή απορριμμάτων (αγγλ. garbage collection ή GC) είναι μια μορφή αυτόματης διαχείρισης μνήμης η οποία λειτουργεί στο υπόβαθρο, κατά την εκτέλεση ενός προγράμματος. Ο συλλέκτης απορριμμάτων (garbage collector), η απλώς συλλέκτης, είναι συνήθως ένα νήμα του συστήματος (π.χ. του λειτουργικού συστήματος ή μιας εικονικής μηχανής επί της οποίας εκτελείται το βασικό πρόγραμμα) σχεδιασμένο κάθε φορά που ενεργοποιείται να απελευθερώνει τα τρέχοντα απορρίμματα: τη μνήμη την οποία καταναλώνουν τα αντικείμενα που το πρόγραμμα δεν χρησιμοποιεί πια. Η συλλογή απορριμμάτων εφευρέθηκε από τον Τζον Μακάρθι το 1959 για να λύσει προβλήματα της γλώσσας προγραμματισμού Lisp. Η συλλογή απορριμμάτων συχνά εμφανίζεται σαν το αντίθετο της χειροκίνητης διαχείρισης μνήμης, η οποία απαιτεί από τον προγραμματιστή να ορίζει ποια αντικείμενα μπορούν να απομακρυνθούν από τη μνήμη. Πολλά συστήματα όμως συνδυάζουν τις δύο προσεγγίσεις, μαζί με άλλες τεχνικές όπως η δέσμευση μνήμης στη στοίβα και η εξαγωγή περιοχών (region inference). Περιορισμένοι πόροι εκτός της μνήμης, όπως π.χ. οι δικτυακές υποδοχές, τα χειριστήρια βάσεων δεδομένων (database handles), τα παράθυρα για αλληλεπίδραση με τον χρήστη και οι περιγραφείς αρχείων και συσκευών, δεν επηρεάζονται από τη συλλογή απορριμμάτων. Υπάρχουν άλλες μέθοδοι για τη διαχείριση αυτών των πόρων, όπως οι καταστροφείς, που μπορούν να διαχειριστούν ακόμα και τη μνήμη, με αποτέλεσμα να μην χρειάζεται συλλογή απορριμμάτων. Κάποια συστήματα συλλογής απορριμμάτων επιτρέπουν σε αυτούς τους άλλους πόρους να σχετίζονται με μια περιοχή στη μνήμη, η οποία, όταν συλλεχθεί, να προκαλέσει την αποδέσμευση των πόρων, κάτι που ονομάζεται οριστικοποίηση (finalization). Αυτό όμως μπορεί να προκαλέσει περιπλοκές, όπως οι σημαντικές καθυστερήσεις μεταξύ της παύσης της χρήσης και της αποδέσμευσης σημαντικά περιορισμένων πόρων, ή η έλλειψη ελέγχου σχετικά με το ποιο νήμα θα κάνει την αποδέσμευση. Αρχές[Επεξεργασία | επεξεργασία κώδικα] Οι βασικές αρχές της συλλογής απορριμμάτων είναι: Βρες τα δεδομένα του προγράμματος που δεν πρόκειται να προσπελαστούν στο μέλλον Αποδέσμευσε τους πόρους που χρειάζονταν από τα αντικείμενα Πολλές γλώσσες προγραμματισμού χρειάζονται συλλογή απορριμμάτων, είτε σαν μέρος του ορισμού της γλώσσας (για παράδειγμα η Java, η C# και οι περισσότερες γλώσσες σεναρίων) είτε στην πράξη σαν μέρος μιας ρεαλιστικής υλοποίησης (για παράδειγμα σε τυπικές γλώσσες όπως ο λ-λογισμός) – αυτές ονομάζονται γλώσσες με συλλογή απορριμμάτων (garbage collected languages). Άλλες γλώσσες έχουν σχεδιαστεί για χρήση με χειροκίνητη διαχείριση μνήμης αλλά υπάρχουν και υλοποιήσεις με συλλογή απορριμμάτων για αυτές (όπως για τη C ή τη C++). Κάποιες γλώσσες, όπως η Ada, η Modula-3 και η C++/CLI επιτρέπουν και συλλογή απορριμμάτων και χειροκίνητη διαχείριση μνήμης στην ίδια εφαρμογή, χρησιμοποιώντας διαφορετικούς σωρούς (heaps) για αντικείμενα που είτε αποδεσμεύονται αυτόματα, είτε η διαχείρισή τους γίνεται χειροκίνητα - άλλες, όπως η D, έχουν συλλογή απορριμμάτων αλλά επιτρέπουν στον χρήστη να διαγράψει χειροκίνητα ένα αντικείμενο και να απενεργοποιήσει εντελώς τη συλλογή απορριμμάτων, όταν χρειάζεται περισσότερη ταχύτητα. Αν και η ενσωμάτωση της συλλογής απορριμμάτων στον μεταγλωττιστή και στο σύστημα χρόνου εκτέλεσης (run time system ή runtime) δίνει περισσότερες επιλογές, υπάρχουν συστήματα συλλογής απορριμμάτων τύπου post hoc, με κάποια από αυτά να μην χρειάζονται επανάληψη της μεταγλώττισης. (Η Post-hoc συλλογή απορριμμάτων συνήθως ονομάζεται litter collection.) Ο συλλέκτης απορριμμάτων σχεδόν είναι στενά συνδεδεμένος με το σύστημα δέσμευσης μνήμης. Πλεονεκτήματα[Επεξεργασία | επεξεργασία κώδικα] Η συλλογή απορριμμάτων απαλλάσσει τον προγραμματιστή από το να πρέπει να αποδεσμεύει ο ίδιος τη μνήμη. Αυτό έχει σαν αποτέλεσμα κάποιες κατηγορίες σφαλμάτων να αποκλείονται ή να είναι πιο δύσκολο να εμφανιστούν: Τα σφάλματα αιωρούμενου δείκτη (dangling pointer), που συμβαίνουν όταν μια θέση μνήμης αποδεσμεύεται αλλά εξακολουθούν να υπάρχουν δείκτες που δείχνουν σε αυτήν και ένας από αυτούς τους δείκτες χρησιμοποιείται στη συνέχεια από τον κώδικα. Τότε όμως η μνήμη μπορεί να έχει δεσμευτεί ξανά για άλλη χρήση και να περιέχει άλλα δεδομένα, με απροσδόκητα αποτελέσματα. Τα σφάλματα διπλής αποδέσμευσης (double free bugs), που συμβαίνουν όταν ένα πρόγραμμα προσπαθεί να αποδεσμεύσει μια περιοχή μνήμης που έχει ήδη αποδεσμευτεί (και πιθανόν να έχει δεσμευτεί πάλι για άλλο σκοπό). Κάποιες μορφές διαρροών μνήμης (memory leaks), στις οποίες ένα πρόγραμμα δε μπορεί να απελευθερώσει τη μνήμη που καταλαμβάνουν αντικείμενα που δεν είναι πια ορατά από τον κώδικα, με αποτέλεσμα, αν αυτό συνεχιστεί, η μνήμη να εξαντληθεί. (Η συλλογή απορριμμάτων συνήθως δεν ασχολείται με δεδομένα που είναι πολύ μεγάλα σε όγκο και το πρόγραμμα δεν τα χρησιμοποιεί αλλά μπορεί να τα δει.) Κάποια από τα σφάλματα που αντιμετωπίζει η συλλογή απορριμμάτων μπορούν επίσης να οδηγούν και σε προβλήματα ασφάλειας. Μειονεκτήματα[Επεξεργασία | επεξεργασία κώδικα] Συνήθως η συλλογή απορριμμάτων έχει κάποια μειονεκτήματα: Η συλλογή απορριμμάτων καταναλώνει υπολογιστικούς χώρους για να αποφασίσει ποια μνήμη θα αποδεσμεύσει, ανακαλύπτοντας πάλι πληροφορίες που μπορεί να είναι γνωστές στον προγραμματιστή. Αν δεν δοθεί ο χρόνος ζωής των αντικειμένων από τον προγραμματιστή, τότε το κόστος είναι μια υπολογιστική επιβάρυνση (overhead), που μπορεί να οδηγήσει σε αργή ταχύτητα εκτέλεσης. Η αλληλεπίδραση αυτής της επιβάρυνσης με τη μνήμη και την ιεραρχική δομή αυτής, μπορεί να οδηγήσει σε απαγορευτικές επιβαρύνσεις σε καταστάσεις που δεν αναμένονται ή δεν έχουν εντοπιστεί κατά τη δοκιμή του λογισμικού. Η στιγμή που γίνεται η συλλογή απορριμμάτων μπορεί να μην αναμένεται, με αποτέλεσμα να υπάρχουν καθυστερήσεις σε διάφορα χρονικά σημεία κατά την εκτέλεση του προγράμματος. Οι απρόβλεπτες καθυστερήσεις μπορεί να είναι απαράδεκτες σε περιβάλλοντα εφαρμογών πραγματικού χρόνου (real-time), στην επεξεργασία συναλλαγών ή σε προγράμματα που αλληλεπιδρούν με τον χρήστη. Ο προγραμματιστής δε μπορεί να χειρίζεται δείκτες (pointers), μόνο αναφορές (references). Η μη ντετερμινιστική συλλογή απορριμμάτων δεν είναι συμβατή με τη διαχείριση των πόρων που χρησιμοποιούνται κατά το προγραμματιστικό ιδίωμα RAII και δεν συλλέγονται αυτόματα. Αυτό έχει ως αποτέλεσμα τα αντικείμενα που δεν συλλέγονται αυτόματα να επηρεάζουν την αποδέσμευση των αντικειμένων που διαχειρίζεται η συλλογή απορριμμάτων, όταν αντικείμενα των δύο κατηγοριών συνδέονται μεταξύ τους. Ανιχνευτική συλλογή απορριμμάτων[Επεξεργασία | επεξεργασία κώδικα] Οι ανιχνευτικοί συλλέκτες απορριμμάτων (tracing garbage collectors) είναι ο συνηθέστερος τύπος συλλεκτών απορριμμάτων. Αρχικά εντοπίζουν τα αντικείμενα που είναι προσιτά (reachable) ή αυτά που θα μπορούσαν να είναι προσιτά, και στη συνέχεια αποδεσμεύουν όλα τα υπόλοιπα αντικείμενα. Προσιτότητα ενός αντικειμένου[Επεξεργασία | επεξεργασία κώδικα] Πρακτικά, ένα αντικείμενο είναι προσιτό αν αναφέρεται σε αυτό τουλάχιστον μια μεταβλητή του προγράμματος, είτε άμεσα, είτε μέσω αναφορών από άλλα προσιτά αντικείμενα. Ακριβέστερα, τα αντικείμενα μπορεί να είναι προσιτά με δύο μόνο τρόπους: Τα αντικείμενα ενός συγκεκριμένου συνόλου θεωρούνται προσιτά και ονομάζονται ρίζες (roots). Συνήθως είναι τα αντικείμενα στα οποία υπάρχουν αναφορές οπουδήποτε στη στοίβα κλήσεων (δηλαδή όλες οι τυπικές μεταβλητές και οι παράμετροι των συναρτήσεων που καλούνται), καθώς και όλες οι καθολικές (global) μεταβλητές. Κάθε αναφορά από ένα προσιτό αντικείμενο δείχνει και αυτή σε προσιτό αντικείμενο. Τυπικά, η προσιτότητα είναι μεταβατικό κλείσιμο (transitive closure). Ο ορισμός της προσιτότητας των απορριμμάτων δεν είναι ο καλύτερος, γιατί ένα πρόγραμμα μπορεί να χρησιμοποιήσει ένα αντικείμενο για τελευταία φορά και μετά να μεσολαβήσει μεγάλο χρονικό διάστημα μέχρι την αποδέσμευσή του, επειδή δεν είναι πια ορατό στο τρέχον περιβάλλον του προγράμματος. Κάποιες φορές γίνεται διάκριση μεταξύ των συντακτικών απορριμμάτων (syntactic garbage), που είναι τα αντικείμενα που το πρόγραμμα δε μπορεί να δει, και των σημασιολογικών απορριμμάτων (semantic garbage), που είναι τα αντικείμενα που το πρόγραμμα δεν πρόκειται να χρησιμοποιήσει πάλι. Για παράδειγμα: Object x = new Foo(); Object y = new Bar(); x = new Quux(); /* σε αυτό το σημείο γνωρίζουμε ότι το αντικείμενο Foo * που αρχικά δόθηκε σαν τιμή στη x δεν μπορεί πια * να χρησιμοποιηθεί: είναι συντακτικά απορρίμματα */ if(x.check_something()) { x.do_something(y); } System.exit(0); /* στην παραπάνω ενότητα, η y *θα μπορούσε* να είναι σημασιολογικά * απορρίμματα, αλλά δεν το γνωρίζουμε, μέχρι η x.check_something() * να επιστρέψει κάποια τιμή (αν τελικά επιστρέψει) */ Το πρόβλημα του ακριβούς χαρακτηρισμού των σημασιολογικών απορριμμάτων μπορεί να αποδειχτεί ότι είναι μερικώς υπολογίσιμο: ένα πρόγραμμα που δεσμεύει μνήμη για ένα αντικείμενο X, εκτελεί ένα τυχαίο πρόγραμμα εισόδου P, και χρησιμοποιεί το X αν και μόνο αν το P τερματίζει θα απαιτούσε έναν συλλέκτη απορριμμάτων που θα έλυνε το πρόβλημα τερματισμού (halting problem). Αν και οι συντηρητικές ευριστικές μέθοδοι για τον εντοπισμό σημασιολογικών απορριμμάτων εξακολουθούν να αποτελούν ενεργό ερευνητικό πεδίο, οι περισσότεροι συλλέκτες απορριμμάτων στην πράξη στοχεύουν στη συλλογή συντακτικών απορριμμάτων. Ένα άλλο θέμα είναι ότι σε γλώσσες προγραμματισμού που υπάρχουν και τύποι αναφοράς (reference types) και βασικοί τύποι τιμής (unboxed value types), ο συλλέκτης απορριμμάτων πρέπει με κάποιο τρόπο να μπορεί να ξεχωρίσει ποιες μεταβλητές της στοίβας ή ποια πεδία ενός αντικειμένου είναι τιμές και ποια είναι αναφορές: στη μνήμη μπορεί να μην υπάρχει διαφορά μεταξύ ενός ακεραίου και μιας αναφοράς. Ο συλλέκτης απορριμμάτων τότε πρέπει να γνωρίζει αν ένα στοιχείο είναι αναφοράς, ώστε να το ακολουθήσει, ή αν είναι βασική τιμή (primitive value). Μια συνηθισμένη λύση είναι η χρήση δεικτών με επιπλέον πληροφορία (tagged pointers). Ισχυρές και ασθενείς αναφορές[Επεξεργασία | επεξεργασία κώδικα] Ο συλλέκτης απορριμμάτων μπορεί να αποδεσμεύει μόνο αντικείμενα προς τα οποία δεν υπάρχουν αναφορές. Μπορούν όμως να υπάρχουν κάποιες αναφορές, οι οποίες δεν εμποδίζουν την αποδέσμευση, οι οποίες ονομάζονται ασθενείς αναφορές (weak references). Όταν οι ασθενείς αναφορές συγκρίνονται με τις συνηθισμένες αναφορές, οι τελευταίες τότε μπορεί να ονομάζονται και ισχυρές αναφορές (strong references). Ένα αντικείμενο τότε συλλέγεται όταν δεν υπάρχουν ισχυρές (δηλαδή κανονικές) αναφορές, ακόμα και αν υπάρχουν ασθενείς αναφορές σε αυτό. Μια ασθενής αναφορά δεν είναι απλά ένας οποιοσδήποτε δείκτης σε ένα αντικείμενο για το οποίο δεν ενδιαφέρεται ο συλλέκτης απορριμμάτων. Ο όρος συνήθως χρησιμοποιείται για μια ειδικά διαχειριζόμενη κατηγορία ειδικών αναφορών, που είναι ασφαλείς στη χρήση, ακόμα και όταν το αντικείμενό τους εξαφανιστεί, γιατί τότε αποκτούν κάποια ειδική και ασφαλή τιμή. Μια αναφορά που δεν είναι ασφαλής και ο συλλέτης απορριμμάτων δεν γνωρίζει για αυτήν, θα μείνει «αιωρούμενη» (dangling) γιατί θα συνεχίσει να αναφέρεται σε μια διεύθυνση μνήμης, όπου το αντικείμενο ήταν στο παρελθόν. Αυτό δεν είναι ασθενής αναφορά. Ασθενείς συλλογές[Επεξεργασία | επεξεργασία κώδικα] Υπάρχουν αντικείμενα που διατηρούν δείκτες προς συλλογές από άλλα αντικείμενα και τα παρακολουθούν με ασθενή τρόπο. Για παράδειγμα, υπάρχουν ασθενείς πίνακες κατακερματισμού (weak hash tables). Όπως και σε έναν κανονικό πίνακα κατακερματισμού, σε έναν ασθενή πίνακα κατακερματισμού διατηρείται μια σχέση μεταξύ αντικειμένων σε ζεύγη, με κάθε ζεύγος να είναι ένα κλειδί και μια τιμή. Ο πίνακας κατακερματισμού όμως δε διατηρεί κάποια ισχυρή αναφορά προς αυτά τα αντικείμενα. Όταν ένα κλειδί ή μια τιμή γίνει απόρριμμα η εγγραφή στον πίνακα διαγράφεται στιγμιαία. Υπάρχουν επίσης περιπτώσεις τέτοιων πινάκων που έχουν μόνο ασθενή κλειδιά και οι αναφορές κλειδιών είναι ισχυρές ή το αντίθετο (ισχυρά κλειδιά και ασθενείς τιμές). Οι ασθενείς πίνακες κατακερματισμού είναι σημαντικοί γιατί δίνουν τη δυνατότητα αποθήκευσης σχέσεων μεταξύ αντικειμένων, αλλά με τρόπο που τα αντικείμενα της σχέσης να μπορούν να γίνουν απορρίμματα αν τίποτα στο πρόγραμμα δεν έχει αναφορές προς αυτά (εκτός από τον ίδιο τον πίνακα). Αντίθετα, η χρήση ενός απλού πίνακα κατακερματισμού για αυτόν τον σκοπό θα οδηγούσε σε διαρροή μνήμης. Βασικός αλγόριθμος[Επεξεργασία | επεξεργασία κώδικα] Η ανιχνευτική συλλογή απορριμμάτων ονομάζεται έτσι γιατί ανιχνεύει όλον τον χώρο εργασίας στη μνήμη. Η συλλογή γίνεται σε κύκλους. Ένας κύκλος αρχίζει όταν ο συλλέκτης αποφασίζει (ή λάβει ειδοποίηση) ότι χρειάζεται να αποδεσμεύσει μνήμη, κάτι που συνήθως συμβαίνει όταν το σύστημα δεν έχει μνήμη ελεύθερη. Η αρχική μέθοδος περιλάμβανε ένα απλό «μαρκάρισμα-και-σκούπισμα» (mark-and-sweep), στο οποίο όλος ο χώρος εργασίας εξετάζεται μία ή περισσότερες φορές. Απλό μαρκάρισμα-και-σκούπισμα[Επεξεργασία | επεξεργασία κώδικα] Στο απλό μαρκάρισμα-και-σκούπισμα, κάθε αντικείμενο στη μνήμη έχει ένα πεδίο (συνήθως ένα bit) που προορίζεται για χρήση αποκλειστικά από τη συλλογή απορριμμάτων. Το πεδίο αυτό συνήθως είναι κενό, εκτός από τη διάρκεια του κύκλου συλλογής απορριμμάτων. Το πρώτο στάδιο της συλλογής διατρέχει ελεύθερα όλο το σύνολο των ριζών ('root set'), μαρκάροντας κάθε αντικείμενο προς το οποίο υπάρχει δείκτης, σαν σε χρήση ('in-use'). Επίσης μαρκάρονται και όλα τα αντικείμενα στα οποία δείχνουν τα αντικείμενα που ήδη μαρκαρίστηκαν, και ούτω καθεξής, μέχρι να μαρκαριστεί κάθε αντικείμενο στο οποίο μπορεί να φτάσει κανείς μέσω δεικτών από τις ρίζες. Στο τέλος, σκανάρεται όλη η μνήμη από την αρχή μέχρι το τέλος και εξετάζονται όλα τα ελεύθερα ή χρησιμοποιούμενα μέρη: όσα αντικείμενα εξακολουθούν να έχουν κενό το πεδίο 'σε χρήση', δεν είναι προσιτά από το πρόγραμμα ή τα δεδομένα του και η μνήμη που καταναλώνουν αποδεσμεύεται. (Στα αντικείμενα που έχουν μαρκαριστεί σαν 'σε χρήση', το πεδίο αυτό καθαρίζεται για τον επόμενο κύκλο συλλογής απορριμμάτων.) Η μέθοδος αυτή έχει διάφορα μειονεκτήματα, με το κυριότερο να είναι ότι όλο το υπόλοιπο σύστημα πρέπει να σταματήσει κατά τη διάρκεια της συλλογής επειδή απαγορεύεται κάθε αλλαγή του χώρου της μνήμης. Αυτό έχει σαν αποτέλεσμα τα προγράμματα να 'παγώνουν' περιστασιακά (και απροειδοποίητα), αποκλείοντας έτσι τις εφαρμογές πραγματικού χρόνου. Επιπλέον, πρέπει να εξεταστεί όλη η μνήμη που χρησιμοποιείται, συχνά δύο φορές, κάτι που μπορεί να προκαλέσει προβλήματα σε συστήματα με μνήμη σε σελίδες (paged memory). Μαρκάρισμα τριών χρωμάτων[Επεξεργασία | επεξεργασία κώδικα] Λόγω των προβλημάτων της προηγούμενης μεθόδου, οι περισσότεροι σύγχρονοι αλγόριθμοι ανιχνευτικής συλλογής απορριμμάτων υλοποιούν κάποια παραλλαγή του μαρκαρίσματος τριών χρωμάτων (tri-colour marking). Το μαρκάρισμα τριών χρωμάτων δουλεύει ως εξής: Αρχικά δημιουργεί άσπρα, γκρίζα και μαύρα σύνολα, τα οποία θα χρησιμοποιηθούν για να κρατείται πληροφορία για την πρόοδο ενός κύκλου. Το άσπρο σύνολο αρχικά είναι το σύνολο των αντικειμένων που είναι υποψήφια για να αποδεσμευτεί η μνήμη τους. Το μαύρο σύνολο είναι το σύνολο των αντικειμένων που μπορεί εύκολα να δειχτεί ότι δεν δείχνουν σε αντικείμενα στο άσπρο σύνολο (σε πολλές υλοποιήσεις αρχικά είναι το κενό σύνολο). Το γκρίζο σύνολο είναι όλα τα αντικείμενα που είναι προσιτά από αναφορές στις ρίζες αλλά τα αντικείμενα στα οποία δείχνουν τα γκρίζα αντικείμενα δεν έχουν ανιχνευτεί ακόμα. Τα γκρίζα αντικείμενα είναι γνωστό ότι είναι προσιτά από τις ρίζες, άρα δε μπορούν να θεωρηθούν απορρίμματα: τελικά τα γκρίζα αντικείμενα θα καταλήξουν στο μαύρο σύνολο. Το γκρίζο χρώμα σημαίνει ότι δεν έχουν ελεγχθεί ακόμα όλα τα αντικείμενα στα οποία δείχνει ένα αντικείμενο. Το γκρίζο σύνολο αρχικά περιέχει τα αντικείμενα προς τα οποία υπάρχουν αναφορές από το επίπεδο των ριζών ενώ συνήθως όλα τα υπόλοιπα αντικείμενα τοποθετούνται αρχικά στο άσπρο σύνολο. Τα αντικείμενα μπορούν να αλλάζουν χρώμα από άσπρο σε γκρίζο ή από γκρίζο σε άσπρο, ποτέ προς την άλλη κατεύθυνση. Επιλέγεται ένα αντικείμενο από το γκρίζο σύνολο. Το αντικείμενο μετακινείται στο μαύρο σύνολο και τα άσπρα αντικείμενα στα οποία αναφέρεται άμεσα γίνονται γκρίζα. Αυτό σημαίνει ότι το αντικείμενο δε μπορεί θεωρηθεί απόρριμμα και το ίδιο ισχύει και για τα αντικείμενα στα οποία δείχνει. Το προηγούμενο βήμα επαναλαμβάνεται μέχρι να αδειάσει το γκρίζο σύνολο. Όταν δεν υπάρχουν άλλα αντικείμενα στο γκρίζο σύνολο, όλα τα αντικείμενα που μένουν στο άσπρο σύνολο είναι προφανώς μη προσιτά και ο χώρος που καταλαμβάνουν αποδεσμεύεται. Τα 3 σύνολα χωρίζουν τη μνήμη, με κάθε αντικείμενο του συστήματος, συμπεριλαμβανομένων των ριζών, να ανήκει ακριβώς σε ένα από αυτά τα σύνολα. Ο αλγόριθμος του μαρκαρίσματος τριών χρωμάτων διατηρεί την εξής σημαντική αναλλοίωτη (invariant): Κανένα μαύρο αντικείμενο δεν δείχνει απευθείας σε άσπρο αντικείμενο. Αυτό εγγυάται την ασφαλή καταστροφή των άσπρων αντικειμένων όταν αδειάσει το γκρίζο σύνολο. (Υπάρχουν εκδοχές του αλγορίθμου που δεν διατηρούν την παραπάνω αναλλοίωτη αλλά εξακολουθούν να ισχύουν οι βασικές ιδιότητες.) Η μέθοδος των τριών χρωμάτων έχει ένα σημαντικό πλεονέκτημα: μπορεί να χρησιμοποιηθεί χωρίς το σύστημα να σταματά για μεγάλα χρονικά διαστήματα. Αυτό επιτυγχάνεται με το μαρκάρισμα αντικειμένων όταν αυτά δημιουργούνται και δεσμεύεται ο χώρος τους στη μνήμη, και κατά τη διάρκεια της τροποποίησής τους από το πρόγραμμα, διατηρώντας τα σύνολο. Το σύστημα μπορεί να παρακολουθεί το μέγεθος των συνόλων και να κάνει συλλογή απορριμμάτων περιοδικά, και όχι μόνο όταν χρειάζεται. Επίσης με αυτόν τον τρόπο αποτρέπεται η ανίχνευση όλου του χώρου εργασίας στη μνήμη σε κάθε κύκλο. Στρατηγικές υλοποίησης[Επεξεργασία | επεξεργασία κώδικα] Για την υλοποίηση του βασικού αλγορίθμου τριών χρωμάτων πρέπει να ληφθούν κάποιες σημαντικές σχεδιαστικές αποφάσεις, οι οποίες επηρεάζουν σημαντικά την ταχύτητα της συλλογής απορριμμάτων. Μετακίνηση[Επεξεργασία | επεξεργασία κώδικα] Όταν προσδιοριστεί το σύνολο των προσιτών αντικειμένων, η συλλογή απορριμμάτων μπορεί απλά να αποδεσμεύσει τη μνήμη που καταλαμβάνουν τα απρόσιτα αντικείμενα, και να αφήσουν όλη την υπόλοιπη μνήμη ως έχει, ή να αντιγράψει μερικά (ή όλα) τα προσιτά αντικείμενα σε έναν νέο χώρο στη μνήμη, ενημερώνοντας όλες τις αναφορές προς αυτά τα αντικείμενα. Αυτοί οι τρόποι συλλογής απορριμμάτων ονομάζονται «μη μετακινούντες» και «μετακινούντες» αντίστοιχα (\"non-moving\" και \"moving\", ή εναλλακτικά, \"non-compacting\" και \"compacting\"). Εκ πρώτης όψεως, μια στρατηγική συλλογής απορριμμάτων με μετακίνηση μπορεί να μοιάζει μη αποδοτική και αργή σε σχέση με τη στρατηγική που δεν μετακινεί, γιατί σε κάθε κύκλο κάνει παραπάνω δουλειά. Στην πράξη όμως η στρατηγική συλλογής απορριμμάτων με μετακίνηση οδηγεί σε πολλά πλεονεκτήματα όσον αφορά την ταχύτητα, τόσο κατά την ίδια τη συλλογή απορριμμάτων, όσο και κατά τη διάρκεια της εκτέλεσης του προγράμματος: Δεν χρειάζεται επιπλέον προσπάθεια για την αποδέσμευση του χώρου που καταλαμβάνουν τα νεκρά αντικείμενα: όλος ο χώρος της μνήμης, από τον οποίο μετακινήθηκαν αντικείμενα, θεωρείται ελεύθερος χώρος. Αντίθετα, η συλλογή απορριμμάτων χωρίς μετακίνηση πρέπει να επισκεφτεί κάθε απρόσιτο αντικείμενο και με κάποιον τρόπο να αποδεσμεύσει τη μνήμη του. Για τον ίδιο λόγο με παραπάνω, χώρος για νέα αντικείμενα μπορεί να δεσμευτεί πολύ γρήγορα. Επειδή η συλλογή απορριμμάτων με μετακίνηση δημιουργεί μεγάλους συνεχείς χώρους μνήμης, τα νέα αντικείμενα μπορούν να δεσμευτούν, αυξάνοντας απλά κατά ένα κάποιον δείκτη που δείχνει σε 'ελεύθερη μνήμη'. Αντίθετα, η συλλογή απορριμμάτων χωρίς μετακίνηση μπορεί μετά από κάποιο χρονικό διάστημα να οδηγήσει σε κατακερματισμό (fragmentation) του σωρού, με αποτέλεσμα να πρέπει να χρησιμοποιηθούν δαπανηρές «ελεύθερες λίστες» (\"free lists\"), που δείχνουν ποια μπλοκ μνήμης είναι διαθέσιμα για δέσμευση νέων αντικειμένων. Αν χρησιμοποιηθεί η κατάλληλη σειρά επίσκεψης των περιεχομένων της μνήμης (για παράδειγμα, στην περίπτωση των λιστών, η επίσκεψη σε κάθε κόμβο πριν τον προηγούμενο), τα αντικείμενα που αναφέρονται σε άλλα αντικείμενα συχνά μπορούν να μετακινηθούν πολύ κοντά το ένα στο άλλο στη μνήμη, αυξάνοντας την πιθανότητα να ανήκουν στην ίδια γραμμή κρυφής μνήμης (cache line), ή στην ίδια σελίδα εικονικής μνήμης (virtual memory). Αυτό μπορεί να κάνει την πρόσβαση σε αυτά τα αντικείμενα πολύ γρήγορη, μέσω αυτών των αναφορών. Ένα μειονέκτημα της συλλογής απορριμμάτων με μετακίνηση είναι ότι επιτρέπει πρόσβαση μόνο μέσω αναφορών που διαχειρίζεται το περιβάλλον της συλλογής απορριμμάτων, και δεν επιτρέπει αριθμητική δεικτών. Αυτό συμβαίνει γιατί κάθε δείκτης προς ένα αντικείμενο δεν θα είναι έγκυρος όταν πια η συλλογή απορριμμάτων έχει μετακινήσει το αντικείμενο, και γίνεται αιωρούμενος δείκτης (dangling pointer). Για την επικοινωνία με τον κώδικα μηχανής, η συλλογή απορριμμάτων πρέπει να αντιγράψει τα περιεχόμενα του αντικειμένου σε μια θέση εκτός της μνήμης που συλλέγεται. Μια άλλη προσέγγιση είναι το αντικείμενο να είναι αμετακίνητο (pin), απαγορεύοντας στη συλλογή απορριμμάτων να το μετακινήσει και επιτρέποντας στη μνήμη να μοιράζεται μέσω απλών δεικτών (πιθανόν επιτρέποντας και την αριθμητική δεικτών). Συλλογή με αντιγραφή, μαρκάρισμα-και-σκούπισμα και μαρκάρισμα-χωρίς-σκούπισμα[Επεξεργασία | επεξεργασία κώδικα] Οι συλλέκτες απορριμμάτων μπορούν να κατηγοριοποιηθούν ανάλογα με τον τρόπο που κρατούν τα τρία σύνολα αντικειμένων (άσπρα, γκρίζα και μαύρα) κατά τη διάρκεια ενός κύκλου συλλογής. Η πιο ευθεία προσέγγιση είναι αυτή του συλλέκτη αντιγραφής (semi-space collector), η οποία ανάγεται στο 1969. Σε αυτόν τον τρόπο συλλογής απορριμμάτων με μετακίνηση, η μνήμη χωρίζεται σε δύο χώρους, στον χώρο-από (\"from space\") και στον χώρο-προς (\"to space\"). Αρχικά τα αντικείμενα βρίσκονται στον χώρο \"to space\" μέχρι να χρειαστεί συλλογή απορριμμάτων λόγω έλλειψης χώρου. Στην αρχή της συλλογής, ο \"to space\" γίνεται \"from space\" και αντίστροφα (εναλλάσσονται οι ρόλοι τους). Τα αντικείμενα που είναι προσιτά από το σύνολο των ριζών αντιγράφονται από τον \"from space\" στον \"to space\". Τα αντικείμενα αυτά σαρώνονται στη συνέχεια και όλα τα αντικείμενα στα οποία δείχνουν αντιγράφονται στον \"to space\", μέχρι όλα τα προσιτά αντικείμενα να αντιγραφούν εκεί. Όταν το πρόγραμμα συνεχίσει την εκτέλεσή του, τα νέα αντικείμενα δεσμεύονται πάλι στον \"to space\", μέχρι να γεμίσει και η διαδικασία να επαναληφθεί. Το πλεονέκτημα αυτής της προσέγγισης είναι η απλότητα (τα σύνολα των τριών χρωμάτων κατασκευάζονται έμμεσα κατά τη διαδικασία της αντιγραφής), αλλά έχει το μειονέκτημα ότι απαιτείται μια σχετικά μεγάλη και συνεχής περιοχή ελεύθερης μνήμης σε κάθε κύκλο συλλογής. Η τεχνική αυτή ονομάζεται και stop-and-copy. Ο αλγόριθμος του Cheney είναι βελτίωση του συλλέκτη αντιγραφής. Ένας συλλέκτης απορριμμάτων με μαρκάρισμα και σκούπισμα (mark and sweep) κρατά ένα ή δύο bit σε κάθε αντικείμενο, τα οποία δείχνουν αν είναι μαύρο ή άσπρο. Το γκρίζο σύνολο διατηρείται είτε σαν ξεχωριστή λίστα (όπως η στοίβα της διεργασίας), είτε χρησιμοποιώντας κάποιο άλλο bit. Καθώς διατρέχεται το δέντρο των αναφορών κατά τη διάρκεια της συλλογής (η φάση του «μαρκαρίσματος»), αυτά τα bit ενημερώνονται από τον συλλέκτη για να αντικατοπτρίζουν την τρέχουσα κατάσταση. Στη συνέχεια ένα τελικό «σκούπισμα» της μνήμης αποδεσμεύει τα άσπρα αντικείμενα. Η στρατηγική μαρκαρίσματος και σκουπίσματος έχει το πλεονέκτημα ότι, όταν καθοριστεί το σύνολο των αντικειμένων που δεν είναι προσιτά, μπορεί να ακολουθηθεί μια στρατηγική μετακίνησης ή μη μετακίνησης -- η επιλογή αυτή μάλιστα μπορεί να γίνει ακόμα και κατά τον χρόνο εκτέλεσης, ανάλογα με τη διαθέσιμη μνήμη. Από την άλλη πλευρά, έχει το μειονέκτημα ότι αυξάνεται λίγο το μέγεθος των αντικειμένων. Ένας συλλέκτης απορριμμάτων που μαρκάρει αλλά δεν σκουπίζει (mark and don't sweep) κρατά, όπως και στην προηγούμενη περίπτωση, ένα bit σε κάθε αντικείμενο για να θυμάται αν είναι άσπρο ή μαύρο -- το γκρίζο σύνολο διατηρείται είτε σαν ξεχωριστή λίστα ή με τη χρήση κάποιου άλλου bit. Υπάρχουν όμως δύο βασικές διαφορές. Τα χρώματα «μαύρο» και «άσπρο» σημαίνουν διαφορετικά πράγματα σε σχέση με τον συλλέκτη απορριμμάτων με μαρκάρισμα και σκούπισμα. Σε ένα σύστημα μαρκαρίσματος χωρίς σκούπισμα, όλα τα προσιτά αντικείμενα είναι πάντα μαύρα. Ένα αντικείμενο μαρκάρεται μαύρο όταν δεσμεύεται και μένει μαύρο, ακόμα και όταν δεν είναι πια προσιτό. Ένα άσπρο αντικείμενο είναι μνήμη που δε χρησιμοποιείται και μπορεί να δεσμευτεί. Η ερμηνεία του άσπρου/μαύρου bit μπορεί να αλλάξει. Αρχικά το άσπρο/μαύρο bit μπορεί να έχει τη σημασία (0=άσπρο, 1=μαύρο). Αν μια δέσμευση μνήμης δεν μπορέσει να βρει αρκετή (άσπρη) μνήμη, τότε αυτό σημαίνει ότι όλα τα αντικείμενα είναι μαρκαρισμένα σαν σε χρήση (μαύρα). Η σημασία του άσπρου/μαύρου bit τότε εναλλάσσεται (για παράδειγμα, 0=μαύρο, 1=άσπρο) και όλα τα αντικείμενα γίνονται άσπρα. Αυτό έχει σαν αποτέλεσμα να μην ισχύει εκείνη τη στιγμή η αναλλοίωτη ότι όλα τα προσιτά αντικείμενα είναι μαύρα, αλλά η πλήρης φάση μαρκαρίσματος που ακολουθεί τα ξανακάνει μαύρα. Όταν αυτό γίνει, όλη η μνήμη που δεν είναι προσιτή έχει γίνει άσπρη. Δεν χρειάζεται φάση «σκουπίσματος». Συλλογή απορριμμάτων σε γενεές[Επεξεργασία | επεξεργασία κώδικα] Έχει παρατηρηθεί ότι σε πολλά προγράμματα, τα πρόσφατα δημιουργημένα αντικείμενα είναι και αυτά που είναι και πιο πιθανό να μην είναι προσιτά σύντομα, κάτι που είναι γνωστό και ως βρεφική θνησιμότητα (infant mortality) ή γενεαλογική υπόθεση (generational hypothesis). Η συλλογή απορριμμάτων σε γενεές (generational garbage collection ή ephemeral garbage collection) χωρίζει τα αντικείμενα σε γενεές και, στους περισσότερους κύκλους, θα τοποθετήσει μόνο τα αντικείμενα ενός υποσυνόλου των γενεών αυτών στο αρχικό άσπρο σύνολο. Επιπλέον, το σύστημα χρόνου εκτέλεσης διατηρεί πληροφορίες για τις αναφορές μεταξύ των γενεών, παρακολουθώντας τη δημιουργία και την ενημέρωση των αναφορών. Όταν εκτελείται ο συλλέκτης απορριμμάτων, μπορεί να χρησιμοποιήσει αυτήν την πληροφορία για να αποδείξει ότι κάποια αντικείμενα στο αρχικό άσπρο σύνολο δεν είναι προσιτά χωρίς να πρέπει να διατρέξει ολόκληρο το δέντρο των αναφορών. Αν η γενεαολογική υπόθεση ισχύει, αυτό έχει σαν αποτέλεσμα πιο γρήγορους κύκλους συλλογής, ενώ συλλέγονται τα πιο πολλά προσιτά αντικείμενα. Για να υλοποιηθεί αυτή η ιδέα, πολλοί συλλέκτες απορριμμάτων αυτού του είδους χρησιμοποιούν διαφορετικές περιοχές μνήμης για αντικείμενα διαφορετικών ηλικιών. Όταν μια περιοχή γεμίσει, τα αντικείμενα στα οποία αναφέρονται περιοχές με μεγαλύτερη ηλικία αντιγράφονται στην επόμενη περιοχή, και ολόκληρη η περιοχή μπορεί τότε να χρησιμοποιηθεί για νέα αντικείμενα. Αυτή η τεχνική επιτρέπει πολύ γρήγορη σταδιακή (incremental) συλλογή απορριμμάτων, γιατί χρειάζεται μόνο συλλογή απορριμμάτων για μια περιοχή κάθε φορά. Η συλλογή απορριμμάτων σε γενεές είναι μια ευριστική προσέγγιση και κάποια μη προσιτά αντικείμενα δε μπορούν να αποδεσμευτούν κατά τη διάρκεια κάθε κύκλου. Μπορεί επομένως σποραδικά να χρειάζεται να διενεργείται ένα πλήρες μαρκάρισμα και σκούπισμα ή μια συλλογή απορριμμάτων με αντιγραφή, για την αποδέσμευση όλου του διαθέσιμου χώρου. Τα συστήματα χρόνου εκτέλεσης των σύγχρονων γλωσσών προγραμματισμού (όπως η Java και το .NET Framework) συνήθως χρησιμοποιούν κάποια υβριδική στρατηγική που συνδυάζει τις στρατηγικές που ήδη αναφέρθηκαν. Για παράδειγμα, οι περισσότεροι κύκλοι συλλογής μπορεί να εξετάζουν μόνο κάποιες γενεές, ενώ κάποιες φορές συμβαίνει μαρκάρισμα και σκούπισμα, και ακόμα πιο σπάνια μια πλήρης αντιγραφή, ώστε να ελέγχεται ο κατακερματισμός (fragmentation). Οι όροι \"minor cycle\" και \"major cycle\" χρησιμοποιούνται κάποιες φορές για να περιγράψουν αυτά τα διαφορετικά επίπεδα συλλογής. Stop-the-world, προσθετική και σύγχρονη συλλογή απορριμμάτων[Επεξεργασία | επεξεργασία κώδικα] Οι απλοί συλλέκτες απορριμμάτων σταματούν εντελώς την εκτέλεση του προγράμματος (stop-the-world) για να εκτελέσουν έναν κύκλο συλλογής, εξασφαλίζοντας ότι δεν θα δεσμευτούν νέα αντικείμενα, ούτε κάποια αντικείμενα πρόκειται να γίνουν απρόσιτα κατά τη συλλογή απορριμμάτων. Το φανερό μειονέκτημα αυτής της τεχνικής είναι ότι το πρόγραμμα δεν μπορεί να συνεχίσει τις εργασίες του όταν γίνεται η συλλογή απορριμμάτων και προκύπτει μια παύση (\"embarrassing pause\"). Αυτό έχει σαν αποτέλεσμα η συλλογή απορριμμάτων τύπου stop-the-world να είναι κατάλληλη κυρίως για προγράμματα χωρίς αλληλεπίδραση με τον χρήστη. Το πλεονέκτημά της είναι ότι είναι πιο εύκολο να υλοποιηθεί και εκτελείται πιο γρήγορα σε σχέση με την προσθετική συλλογή απορριμμάτων. Οι προσθετικοί (incremental) και οι σύγχρονοι (concurrent) συλλέκτες απορριμμάτων έχουν σχεδιαστεί έτσι ώστε να μειώνουν αυτήν την «αναστάτωση» κατά την εκτέλεση, παρεμβάλλοντας τις εργασίες τους στις δραστηριότητες του κύριου προγράμματος. Οι προσθετικοί συλλέκτες απορριμμάτων κάνουν συλλογή απορριμμάτων σε διακριτές φάσεις, επιτρέποντας την εκτέλεση του προγράμματος ανάμεσα στις φάσεις αυτές (και κάποιες φορές και κατά τη διάρκεια κάποιων από αυτές). Οι σύγχρονοι συλλέκτες απορριμμάτων δεν σταματούν καθόλου την εκτέλεση του προγράμματος, εκτός ίσως για το μικρό χρονικό διάστημα που σαρώνεται η στοίβα του προγράμματος. Όλες μαζί οι προσθετικές φάσεις όμως παίρνουν περισσότερο χρόνο για να εκτελεστούν, σε σύγκριση με ένα πέρασμα συνολικής συλλογής απορριμμάτων, επομένως οι συλλέκτες απορριμμάτων αυτού του είδους μπορεί να κάνουν λιγότερο έργο ανά μονάδα χρόνου. Οι τεχνικές αυτές απαιτούν προσεκτική σχεδίαση ώστε να μην υπάρχουν ανεπιθύμητες αλληλεπιδράσεις μεταξύ του προγράμματος και του συλλέκτη απορριμμάτων. Για παράδειγμα, όταν το πρόγραμμα θελήσει να δεσμεύσει χώρο για κάποιο νέο αντικείμενο, το σύστημα χρόνου εκτέλεσης μπορεί να το σταματήσει μέχρι να ολοκληρωθεί η εκτέλεση, ή να ειδοποιήσει με κάποιον τρόπο τον συλλέκτη απορριμμάτων ότι υπάρχει ένα νέο, προσιτό αντικείμενο. Ακριβής/συντηρητική συλλογή απορριμμάτων και εσωτερικοί δείκτες[Επεξεργασία | επεξεργασία κώδικα] Οι συλλέκτες που μπορούν να αναγνωρίσουν σωστά όλους τους δείκτες (αναφορές) σε ένα αντικείμενο ονομάζονται ακριβείς (precise, exact ή accurate), ενώ το αντίθετο είναι οι συντηρητικοί (conservative) ή μερικώς συντηρητικοί (partly conservative) συλλέκτες. Οι συντηρητικοί συλλέκτες υποθέτουν ότι κάθε αλληλουχία bit στη μνήμη μπορεί να είναι δείκτης αν, ερμηνευόμενη σαν δείκτης, θα έδειχνε σε κάποιο αντικείμενο που έχει δεσμευτεί στη μνήμη. Οι συντηρητικοί συλλέκτες μπορεί να αναγνωρίσουν σαν δείκτες λάθος δεδομένα (false positives), με αποτέλεσμα να μην αποδεσμεύεται μνήμη λόγω λάθους αναγνώρισης. Αυτό στην πράξη δεν είναι πάντα πρόβλημα, εκτός και αν το πρόγραμμα χειρίζεται πολλά δεδομένα που μπορούν να αναγνωριστούν λανθασμένα σαν δείκτες. Οι περιπτώσεις λανθασμένης αναγνώρισης προκαλούν γενικά λιγότερα προβλήματα σε συστήματα 64-bit σε σχέση με τα συστήματα 32-bit επειδή το εύρος των έγκυρων διευθύνσεων μνήμης τείνει να είναι ένα πολύ μικρό υποσύνολο του εύρους των τιμών 64-bit. Για αυτόν τον λόγο, είναι σπάνιο κάποια αλληλουχία των 64 bit να μοιάζει με κάποιον έγκυρο δείκτη. Το αν ένας ακριβής συλλέκτης απορριμμάτων εξυπηρετεί στην πράξη εξαρτάται από τις ιδιότητες ασφάλειας τύπων (type safety) της εκάστοτε γλώσσας προγραμματισμού. Ένα παράδειγμα που χρειάζεται συντηρητικός συλλέκτης απορριμμάτων είναι η γλώσσα C, η οποία επιτρέπει την μετατροπή μεταξύ δεικτών με τύπο (όχι void) και δεικτών χωρίς τύπο (void). Ένα σχετικό θέμα είναι αυτό των εσωτερικών δεικτών (internal pointers), που είναι οι δείκτες στα πεδία ενός αντικειμένου. Αν η σημασιολογία της γλώσσας επιτρέπει εσωτερικούς δείκτες, τότε μπορούν να υπάρχουν πολλές διαφορετικές διευθύνσεις που να αναφέρονται σε μέρη του ίδιου αντικειμένου, κάτι που περιπλέκει την απόφαση αν ένα αντικείμενο είναι απόρριμμα ή όχι. Ένα παράδειγμα είναι η γλώσσα C++, στην οποία η πολλαπλή κληρονομικότητα μπορεί να δημιουργήσει δείκτες προς αντικείμενα βάσης, οι οποίοι να έχουν διαφορετικές διευθύνσεις. Ακόμα και σε γλώσσες όπως η Java, μπορούν να εμφανίζονται εσωτερικοί δείκτες κατά τον υπολογισμό, για παράδειγμα, της διεύθυνσης ενός στοιχείου ενός πίνακα. Σε ένα πρόγραμμα που έχει υποστεί βελτιστοποίηση, ο αντίστοιχος δείκτης στο ίδιο το αντικείμενο μπορεί να έχει ενημερωθεί στον καταχωρητή στον οποίο βρίσκεται – αυτό σημαίνει ότι πρέπει να γίνεται σάρωση που να βρίσκει αυτούς τους δείκτες. Ταχύτητα εκτέλεσης[Επεξεργασία | επεξεργασία κώδικα] Οι ανιχνευτικοί συλλέκτες απορριμμάτων έχουν κάποια κρυμμένη επιβάρυνση κατά τον χρόνο εκτέλεσης, που δεν ελέγχεται από τον προγραμματιστή και μπορεί να οδηγήσει σε προβλήματα ταχύτητας εκτέλεσης. Για παράδειγμα, οι συλλέκτες stop-the-world που χρησιμοποιούνται συχνά, σταματούν αυθαίρετα την εκτέλεση του προγράμματος σε διάφορες χρονικές στιγμές, κάτι που μπορεί να κάνει τη συλλογή απορριμμάτων αυτού του είδους ακατάλληλη για κάποια ενσωματωμένα συστήματα, λογισμικών εξυπηρετητών υψηλής απόδοσης και εφαρμογές με απαιτήσεις πραγματικού χρόνου. Ρητή δέσμευση μνήμης στον σωρό αναζήτηση καλύτερου/πρώτου-κατάλληλου μπλοκ με επαρκές μέγεθος διατήρηση λίστας ελεύθερου χώρου (free list) Συλλογή απορριμμάτων εντοπισμός προσιτών αντικειμένων αντιγραφή προσιτών αντικειμένων στην περίπτωση των συλλεκτών αντιγραφής σύνορα ανάγνωσης/εγγραφής (read/write barriers) στην περίπτωση των προσθετικών συλλεκτών αναζήτηση καλύτερου/πρώτου-κατάλληλου μπλοκ και διατήρηση της λίστας ελεύθερου χρόνου στην περίπτωση των συλλεκτών χωρίς αντιγραφή Είναι δύσκολο να συγκριθούν οι δύο παραπάνω προσεγγίσεις απευθείας, γιατί η συμπεριφορά τους εξαρτάται από το εκάστοτε περιβάλλον εκτέλεσης. Για παράδειγμα, στην καλύτερη περίπτωση συλλογής απορριμμάτων, η δέσμευση μνήμης απλά αυξάνει έναν δείκτη, ενώ στην καλύτερη περίπτωση ρητής δέσμευσης χώρου στον σωρό, ο μηχανισμός δέσμευσης μνήμης διατηρεί λίστες ελεύθερης μνήμης διαφόρων μεγεθών, με αποτέλεσμα η δέσμευση μνήμης απλά να ακολουθεί έναν δείκτη. Η κατηγοριοποίηση όμως αυτή της μνήμης σε χώρους διαφορετικών μεγεθών συχνά προκαλεί εξωτερικό κατακερματισμό σε σημαντικό βαθμό, κάτι που μπορεί να επηρεάσει αρνητικά την συμπεριφορά της κρυφής μνήμης. Η δέσμευση μνήμης σε μια γλώσσα με συλλογή απορριμμάτων μπορεί να υλοποιηθεί με δέσμευση στον σωρό στο παρασκήνιο (και όχι με την αύξηση ενός δείκτη), επομένως τα παραπάνω πλεονεκτήματα όσον αφορά την ταχύτητα μπορεί να μην ισχύουν πια. Σε κάποιες περιπτώσεις, όπως τα ενσωματωμένα συστήματα, η επιβάρυνση της συλλογής απορριμμάτων και της διαχείρισης του σωρού μπορεί να αποφευχθεί με δέσμευση μνήμης από πριν και χρήση ενός πιο ελαφρού συστήματος για δέσμευση/αποδέσμευση. Η επιβάρυνση των συνόρων εγγραφής (write barriers) είναι πιο πιθανό να είναι εμφανής σε προγράμματα σε προστακτικό στυλ, τα οποία συχνά γράφουν δείκτες σε υπάρχουσες δομές δεδομένων, σε αντίθεση με τα προγράμματα σε συναρτησιακό στυλ, που κατασκευάζουν κάθε δεδομένο μια φορά και ποτέ δεν το αλλάζουν. Οι εξελίξεις στη συλλογή απορριμμάτων συχνά σχετίζονται με ζητήματα ταχύτητας. Οι πρώτοι συλλέκτες απορριμμάτων ήταν τύπου stop-the-world, αλλά η ταχύτητα αυτής της προσέγγισης δεν ήταν κατάλληλη για εφαρμογές που αλληλεπιδρούσαν με τον χρήστη ή το περιβάλλον. Η προσθετική συλλογή απορριμμάτων απέφυγε αυτό το πρόβλημα, με το μειονέκτημα ότι είχε μικρότερη αποδοτικότητα λόγω της χρήσης συνόρων. Οι τεχνικές γενεαλογικής συλλογής απορριμμάτων χρησιμοποιούνται στους συλλέκτες stop-the-world και στους προσθετικούς για να αυξηθεί η ταχύτητά τους, με την παραδοχή ότι κάποια απορρίμματα θα αργήσουν να εντοπιστούν. Ντετερμινισμός[Επεξεργασία | επεξεργασία κώδικα] Η ανιχνευτική συλλογή απορριμμάτων δεν είναι ντετερμινιστική όσον αφορά τον χρόνο της λήξης ζωής των αντικειμένων (finalization). Ένα αντικείμενο που θεωρείται απόρριμμα, τελικά θα εκκαθαριστεί, αλλά δεν παρέχεται καμία εγγύηση για το πότε (ή ακόμα και το αν) αυτό θα γίνει. Αυτό έχει επιπτώσεις στην ορθότητα προγράμματος, όταν τα αντικείμενα συνδέονται με πόρους που δεν ανήκουν στη μνήμη, και η αποδέσμευση των οποίων αποτελεί εξωτερική συμπεριφορά του προγράμματος, όπως η διακοπή μιας σύνδεση δικτύου, η απελευθέρωση μιας συσκευής ή το κλείσιμο ενός αρχείου. Μια τεχνική συλλογής απορριμμάτων που παρέχει ντετερμινισμό σε αυτές τις περιπτώσεις είναι το καταμέτρηση αναφορών (reference counting). Η συλλογή απορριμμάτων μπορεί να έχει μη ντετερμινιστική επίδραση στον χρόνο εκτέλεσης, εισάγοντας κάποιες φορές παύσεις στην εκτέλεση του προγράμματος, οι οποίες δεν σχετίζονται με τον αλγόριθμο που εκτελείται. Στην ανιχνευτική συλλογή απορριμμάτων, μια αίτηση για δέσμευση χώρου στη μνήμη μπορεί να επιστρέψει κάποιο αποτέλεσμα αμέσως ή να οδηγήσει σε μια χρονοβόρα συλλογή απορριμμάτων. Στην καταμέτρηση αναφορών, αν και η δέσμευση μνήμης για αντικείμενα είναι συνήθως γρήγορη, η μείωση ενός μετρητή μιας αναφοράς είναι μη ντετερμινιστική, γιατί μπορεί να γίνει μηδέν και να οδηγήσει σε αναδρομική διάσχιση της μνήμης ώστε να μειωθούν και οι μετρητές των αναφορών των άλλων αντικειμένων στα οποία δείχνει το αντικείμενο. Συλλογή απορριμμάτων σε πραγματικό χρόνο[Επεξεργασία | επεξεργασία κώδικα] Αν και η συλλογή απορριμμάτων είναι γενικά μη ντετερμινιστική, μπορεί να χρησιμοποιηθεί σε συστήματα αυστηρά πραγματικού χρόνου (hard real-time). Ένας συλλέκτης πραγματικού χρόνου μπορεί να εγγυηθεί ότι, στη χειρότερη περίπτωση, θα παραχωρήσει έναν συγκεκριμένο αριθμό υπολογιστικών πόρων στο τμήμα του προγράμματος που χρειάζεται τη μνήμη. Οι περιορισμοί που ακολουθεί ένας συλλέκτης πραγματικού χρόνου βασίζονται συνήθως είτε στον φόρτο εργασίας (work based), είτε στον χρόνο (time based). Ένας περιορισμός στον χρόνο θα μπορούσε να είναι ο εξής: σε κάθε χρονικό παράθυρο διάρκειας T, το πρόγραμμα θα πρέπει να εκτελείται τουλάχιστον για χρόνο Tm. Στην περίπτωση της ανάλυσης του φόρτου εργασίας, χρησιμοποιείται συνήθως το μέγεθος MMU (minimal mutator utilization). Μια από τις πρώτες υλοποιήσεις συλλογής απορριμμάτων πραγματικού χρόνου για την JVM αφορούσε τον αλγόριθμο Metronome. Υπάρχουν επίσης άλλες εμπορικές υλοποιήσεις. Καταμέτρηση αναφορών[Επεξεργασία | επεξεργασία κώδικα] Η καταμέτρηση αναφορών είναι μια μορφή συλλογής απορριμμάτων όπου κάθε αντικείμενο διατηρεί τον αριθμό των αντικειμένων που έχουν αναφορές προς αυτό. Τα απορρίμματα είναι όσα αντικείμενα έχουν μηδέν αναφορές. Ο μετρητής ενός αντικειμένου αυξάνεται όταν δημιουργείται μια αναφορά προς αυτό και μειώνεται όταν μια τέτοια αναφορά καταστρέφεται. Η μνήμη που καταλαμβάνει το αντικείμενο απελευθερώνεται όταν ο μετρητής φτάσει το μηδέν. Η καταμέτρηση αναφορών έχει δύο σημαντικά μειονεκτήματα: Αν δύο ή περισσότερα αντικείμενα δείχνουν το ένα στο άλλο, μπορεί να δημιουργείται κύκλος, στον οποίο κανένας μετρητής δεν πρόκειται να φτάσει το μηδέν και η μνήμη κανενός αντικειμένου δεν πρόκειται να απελευθερωθεί. Κάποια συστήματα συλλογής απορριμμάτων με καταμέτρηση αναφορών (όπως αυτό της CPython) χρησιμοποιούν ειδικούς αλγόριθμους εντοπισμού κύκλων για να αντιμετωπίσουν αυτό το πρόβλημα. Μια άλλη στρατηγική είναι η χρήση ασθενών αναφορών (weak references) για τους δείκτες προς τα πίσω, οι οποίοι δημιουργούν τους κύκλους. Στην καταμέτρηση αναφορών, μια ασθενής αναφορά λειτουργεί όπως μια ασθενής αναφορά σε έναν ανιχνευτικό συλλέκτη απορριμμάτων. Είναι ένα ιδιαίτερο αντικείμενο-αναφορά, η ύπαρξη του οποίου δεν αυξάνει τον μετρητή αναφορών ενός αντικειμένου που δείχνει σε αυτό. Επιπλέον μια ασθενής αναφορά είναι ασθενής με την έννοια ότι όταν το αντικείμενο που αναφέρεται σε αυτήν γίνεται απόρριμμα, κάθε ασθενής αναφορά σε αυτό λήγει (lapses) αντί να μείνει αιωρούμενη, παίρνει δηλαδή κάποια προβλεπόμενη τιμή, όπως η κενή αναφορά (null). Στις απλές υλοποιήσεις, κάθε ανάθεση σε αναφορά και κάθε αναφορά που βγαίνει εκτός εμβέλειας, έχουν ως αποτέλεσμα την αλλαγή ενός ή περισσότερων μετρητών αναφορών. Στην πιο συνηθισμένη περίπτωση όμως, όταν μια αναφορά αντιγράφεται από μια μεταβλητή της εξωτερικής εμβέλειας σε μια μεταβλητή εσωτερικής εμβέλειας, τέτοια ώστε ο χρόνος ζωής της εσωτερικής μεταβλητής να περιλαμβάνεται στον χρόνο ζωής της εξωτερικής, δεν χρειάζεται η αλλαγή στους μετρητές. Η εξωτερική μεταβλητή «έχει» την αναφορά. Στην γλώσσα προγραμματισμού C++, η τεχνική αυτή υλοποιείται με τις αναφορές const. Η καταμέτρηση αναφορών στη C++ συνήθως υλοποιείται με τη χρήση «έξυπνων δεικτών» (\"smart pointers\"), που έχουν συναρτήσεις κατασκευής (constructors), καταστροφής (destructors) και ανάθεσης που χειρίζονται τις αναφορές. Ένας έξυπνος δείκτης μπορεί να περαστεί με αναφορά σε μια συνάρτηση, έτσι ώστε να μην χρειαστεί να κατασκευαστεί μια νέα αναφορά με αντιγραφή (που θα αύξανε τον μετρητή αναφορών κατά την είσοδο στη συνάρτηση και θα τον μείωνε κατά την έξοδο). Αντίθετα, η συνάρτηση δέχεται μια αναφορά στον έξυπνο δείκτη, την οποία τη δημιουργεί με μικρό κόστος. Οι αλλαγές αυτές (αύξηση και μείωση κατά ένα), όταν χρησιμοποιούνται σε πολυνηματικό περιβάλλον, πρέπει να είναι ατομικές λειτουργίες, όπως η compare-and-swap, όταν εμπλέκουν αντικείμενα που μπορεί να μοιράζονται ανάμεσα σε διαφορετικά νήματα. Οι ατομικές λειτουργίες έχουν κόστος στους πολυεπεξεργαστές και είναι ακόμα πιο δαπανηρές, όταν πρέπει να προσομοιωθούν από αλγόριθμους σε λογισμικό. Υπάρχουν τρόποι να βελτιωθεί αυτή η κατάσταση, όπως η χρήση αναφορών σε δύο επίπεδα, με πολλαπλούς μετρητές. Θεωρείται συχνά λανθασμένα ότι η καταμέτρηση αναφορών έχει ντετερμινιστική συμπεριφορά όσον αφορά το χρόνο εκτέλεσής του, σε σχέση με την ανιχνευτική συλλογή απορριμμάτων. Η καταμέτρηση αναφορών παρέχει ημι-ντετερμινιστική αποδοτικότητα όσον αφορά την αποδέσμευση σε περιπτώσεις που τα αντικείμενα προφανώς ζουν λίγο (στις ίδιες συνθήκες που και οι τεχνικές γενεαλογικής συλλογής απορριμμάτων έχουν ημι-ντετερμινιστική συμπεριφορά). Στην γενική περίπτωση, όταν μειώνεται ο μετρητής της αναφοράς ενός αντικειμένου, δεν μπορεί να μετρηθεί πόσος χρόνος θα χρειαστεί για αυτό από τον επεξεργαστή. Κάθε φορά που ένας μετρητής γίνεται μηδέν, και άρα το αντίστοιχο αντικείμενο γίνεται απόρριμμα, πρέπει να μειωθούν και όλοι οι μετρητές των αντικειμένων που ανήκουν στο αντικείμενο. Κάποιοι από αυτούς τους μετρητές μπορούν επίσης να γίνουν μηδέν, επαναλαμβάνοντας αυτήν τη διαδικασία, με αποτέλεσμα η καταμέτρηση αναφορών στην γενική περίπτωση να έχει μη ντετερμινιστικές παύσεις. Escape analysis[Επεξεργασία | επεξεργασία κώδικα] Η ανάλυση διαφυγής (escape analysis) μπορεί να χρησιμοποιηθεί για να μετατρέψει τη δέσμευση χώρου στον σωρό σε δέσμευση στη στοίβα, μειώνοντας το έργο του συλλέκτη απορριμμάτων. Συλλογή απορριμμάτων κατά τη μεταγλώττιση[Επεξεργασία | επεξεργασία κώδικα] Η συλλογή απορριμμάτων κατά τη μεταγλώττιση (compile-time garbage collection) είναι μια μορφή στατικής ανάλυσης που επιτρέπει στη μνήμη να επαναχρησιμοποιείται και να απελευθερώνεται με βάση αναλλοίωτες συνθήκες που είναι γνωστές από τη φάση της μεταγλώττισης. Αυτή η μορφή συλλογής απορριμμάτων μελετήθηκε στη γλώσσα προγραμματισμού Mercury. Διαθεσιμότητα[Επεξεργασία | επεξεργασία κώδικα] Οι γλώσσες προγραμματισμού υψηλού επιπέδου είναι πιο πιθανό να έχουν σαν βασικό χαρακτηριστικό τη συλλογή απορριμμάτων. Οι γλώσσες που δεν περιλαμβάνουν συλλογή απορριμμάτων, μπορούν να την αποκτήσουν με τη βοήθεια εξωτερικών βιβλιοθηκών (όπως ο συλλέκτης απορριμμάτων του Boehm για τη C και τη C++). Αυτό δεν είναι πάντα χωρίς προβλήματα, αφού αλλάζουν οι μηχανισμοί δημιουργίας και καταστροφής των αντικειμένων. Οι περισσότερες συναρτησιακές γλώσσες προγραμματισμού, όπως η ML, η Haskell και η APL, περιλαμβάνουν συλλογή απορριμμάτων. Ο ίδιος ο μηχανισμός εμφανίστηκε για πρώτη φορά στη Lisp, η οποία και εισήγαγε τον συναρτησιακό προγραμματισμό. Άλλες δυναμικές γλώσσες, όπως η Ruby (αλλά όχι η Perl 5, ή η PHP, που χρησιμοποιούν καταμέτρηση αναφορών), τείνουν επίσης να χρησιμοποιούν συλλογή απορριμμάτων. Οι αντικειμενοστρεφείς γλώσσες όπως η Smalltalk, η Java και η ECMAScript συχνά ενσωματώνουν συλλογή απορριμμάτων. Εξαιρέσεις αποτελούν η C++ και η Delphi, οι οποίες έχουν συναρτήσεις καταστροφής (destructors). Η Objective-C στο παρελθόν δεν είχε συλλογή απορριμμάτων, αλλά η ObjC 2.0 που υλοποιήθηκε από την Apple για το Mac OS X χρησιμοποιεί έναν δικό της συλλέκτη στο χρόνο εκτέλεσης, ενώ το εγχείρημα GNUstep χρησιμοποιεί έναν συλλέκτη Boehm. Ιστορικά, οι γλώσσες που απευθύνονταν σε αρχάριους, όπως η BASIC και η Logo, συχνά χρησιμοποιούσαν συλλογή απορριμμάτων για τύπους δεδομένων μεταβλητού μήκους που αποθηκεύονταν στον σωρό, όπως οι συμβολοσειρές και οι λίστες, ώστε να μην δυσκολεύουν τον προγραμματιστή με λεπτομέρειες διαχείρισης μνήμης. Στους πρώτους μικροϋπολογιστές, που είχαν μικρές μνήμες και αργούς επεξεργαστές, η συλλογή απορριμμάτων της BASIC συχνά προκαλούσε τυχαίες και (για τον χρήστη) ανεξήγητες παύσεις κατά την εκτέλεση του προγράμματος. Κάποιοι διερμηνείς της BASIC όπως ο Applesoft BASIC της οικογένειας των Apple II, είχαν πολύ αργούς συλλέκτες απορριμμάτων για τις συμβολοσειρές, που σάρωναν συνέχεια τις συμβολοσειρές για να τοποθετήσουν αυτές με την υψηλότερη διεύθυνση, στις υψηλότερες θέσεις μνήμης (high memory). Αυτή η επανάληψη για μια συμβολοσειρά κάθε φορά είχα σαν αποτέλεσμα πολυπλοκότητα χρόνου O(N*N) όσον αφορά τον αριθμό των συμβολοσειρών, που μπορούσε να διακόψει προσωρινά την εκτέλεση προγραμμάτων που έκαναν συχνή χρήση συμβολοσειρών, ακόμα και για ένα λεπτό. Ένας άλλος συλλέκτης απορριμμάτων για την Applesoft BASIC που δημοσιεύτηκε στο Call-A.P.P.L.E. (Ιανουάριος 1981, σελ. 40–45, Randy Wiggington) έβρισκε μια ομάδα συμβολοσειρών σε κάθε πέρασμα στον σωρό, με αποτέλεσμα μια παύση των δύο λεπτών να γίνεται ενός δευτερολέπτου, ανάλογα και με το μέγεθος της ομάδας. Δημοσιεύτηκαν και άλλες προσεγγίσεις, αλλά καμία δεν έφτασε να μπει σε κάποια νεότερη έκδοση του διερμηνέα της BASIC. Περιορισμένα περιβάλλοντα[Επεξεργασία | επεξεργασία κώδικα] Η συλλογή απορριμμάτων σπάνια χρησιμοποιείται σε ενσωματωμένα συστήματα ή σε συστήματα πραγματικού χρόνου, όπου απαιτείται πολύ αυστηρός έλεγχος της χρήσης των περιορισμένων διαθέσιμων πόρων. Παρόλα αυτά, έχουν αναπτυχθεί συλλέκτες για τέτοια περιορισμένα περιβάλλοντα. Το .NET Micro Framework της Microsoft και η Java Platform, Micro Edition είναι ενσωματωμένες πλατφόρμες λογισμικού, οι οποίες, όπως και οι μεγαλύτερες εκδόσεις τους, περιλαμβάνουν συλλογή απορριμμάτων. Παραπομπές[Επεξεργασία | επεξεργασία κώδικα] ↑ «Recursive functions of symbolic expressions and their computation by machine». Portal.acm.org. Ανακτήθηκε στις 29 Μαρτίου 2009. ↑ «Recursive functions of symbolic expressions and their computation by machine, Part I». Αρχειοθετήθηκε από το πρωτότυπο στις 4 Οκτωβρίου 2013. Ανακτήθηκε στις 29 Μαΐου 2009. ↑ «Copying and Pinning». Msdn2.microsoft.com. Ανακτήθηκε στις 9 Ιουλίου 2010. ↑ «Memory allocation in embedded systems». Eros-os.org. Αρχειοθετήθηκε από το πρωτότυπο στις 6 Μαρτίου 2012. Ανακτήθηκε στις 29 Μαρτίου 2009. ↑ «A parallel, real-time garbage collector». ACM SIGPLAN Notices 36.5: 125–136. 22. doi:378795.378823. http://dl.acm.org/citation.cfm?doid=378795.378823. ↑ «The Metronome: A Simpler Approach to Garbage Collection in Real-Time Systems» (PDF). ↑ «Real-time Java, Part 4: Real-time garbage collection». ↑ «Reference Counts». Extending and Embedding the Python Interpreter. 21 Φεβρουαρίου 2008. Αρχειοθετήθηκε από το πρωτότυπο στις 23 Οκτωβρίου 2008. Ανακτήθηκε στις 13 Νοεμβρίου 2008. While Python uses the traditional reference counting implementation, it also offers a cycle detector that works to detect reference cycles. ↑ «Compile-time garbage collection for the declarative language Mercury». Αρχειοθετήθηκε από το πρωτότυπο στις 18 Ιουλίου 2008. Ανακτήθηκε στις 14 Μαρτίου 2012. ↑ «Wei Fu and Carl Hauser, \"A Real-Time Garbage Collection Framework for Embedded Systems\". ACM SCOPES '05, 2005». Portal.acm.org. Ανακτήθηκε στις 9 Ιουλίου 2010. Βιβλιογραφία[Επεξεργασία | επεξεργασία κώδικα] Jones, Richard· Hosking, Antony· Moss, Eliot (19 Αυγούστου 2011). The Garbage Collection Handbook: The Art of Automatic Memory Management. CRC Applied Algorithms and Data Structures Series. Chapman and Hall/CRC. ISBN 1420082795. Jones, Richard· Lins, Rafael D. (1996). Garbage Collection: Algorithms for Automatic Dynamic Memory Management. Wiley. ISBN 0471941484. Wilson, Paul R. (1992). «Uniprocessor Garbage Collection Techniques». IWMM '92 Proceedings of the International Workshop on Memory Management (Springer-Verlag). http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.2438. Εξωτερικοί σύνδεσμοι[Επεξεργασία | επεξεργασία κώδικα] Τεχνικές Συλλογής απορριμμάτων στη Διαχείριση Μνήμης The Garbage Collection Handbook: The Art of Automatic Memory Management (Αγγλικά) Richard Jones' Garbage Collection Page, University of Kent (Αγγλικά) The Memory Management Reference (Αγγλικά) The Very Basics of Garbage Collection, by Thomas Padron-McCarthy (Αγγλικά) Publications by the OOPS group, University of Texas at Austin (Αγγλικά) A garbage collector for C and C++ by Hans Boehm (Αγγλικά) Expensive Explicit Deallocation: An Example by Hans Boehm (Αγγλικά) On-the-fly garbage collection: an exercise in cooperation by Edsger W. Dijkstra and Leslie Lamport and A.J.Martin and C.S.Scholten and E.F.M.Steffens (Αγγλικά) A Garbage Collection Course Curriculum at MSDN Academic Alliance (Αγγλικά) A Glance at Garbage Collection in Object-Oriented Languages (Αγγλικά) Notes on the CLR Garbage Collector[νεκρός σύνδεσμος] (Αγγλικά) Understanding GC pauses in HotSpot JVM (Αγγλικά) Υλοποιήσεις A Real-Time Garbage Collector Based on the Lifetimes of Objects by H. Lieberman and C. Hewitt, MIT Artificial Intelligence Laboratory (Αγγλικά) TinyGC - an independent implementation of the BoehmGC API (Αγγλικά) Conservative Garbage Collection Implementation for C Language by Yasin Hınıslıoğlu (Αγγλικά) MeixnerGC - an incremental mark and sweep garbage collector for C++ using smart pointers (Αγγλικά)"
    },
    {
        "id": 11,
        "url": "https://el.wikipedia.org/wiki/%CE%9F%CE%BB%CE%BB%CE%B1%CE%BD%CE%B4%CE%AF%CE%B1",
        "title": "Ολλανδία",
        "content": "Συντεταγμένες: 52°19′N 5°33′E﻿ / ﻿52.317°N 5.550°E﻿ / 52.317; 5.550 Κάτω Χώρες Nederland Σημαία ΕθνόσημοΕθνικό σύνθημα: \"Je maintiendrai\" (Γαλλικά)\"Ik zal handhaven\" (Ολλανδικά)(Θα μείνω ανυποχώρητος)Εθνικός ύμνος: Het Wilhelmus (Γουλιέλμος του Νασσάου)Τοποθεσία της χώρας στον κόσμοΗ θέση της Ολλανδίας (σκούρο πράσινο)-στην Ευρωπαϊκή ήπειρο (πράσινο και σκούρο γκρι)-στην Ευρωπαϊκή Ένωση (πράσινο)Πρωτεύουσακαι μεγαλύτερη πόληΆμστερνταμ1 52°21′N 04°52′E﻿ / ﻿52.350°N 4.867°E﻿ / 52.350; 4.867﻿ (Άμστερνταμ)Επίσημες γλώσσεςΟλλανδικάΚυρίαρχο κράτος Βασίλειο των Κάτω ΧωρώνΠολίτευμαΒασιλευόμενη Κοινοβουλευτική ΔημοκρατίαΒασιλιάς ΠρωθυπουργόςΓουλιέλμος-Αλέξανδρος Ντικ ΣχόοφΑνεξαρτησία• Κηρύχθηκε • Αναγνωρίστηκε Ισχύον ΣύνταγμαΟγδοηκονταετής Πόλεμος (από την Ισπανία) 26 Ιουλίου 158130 Ιανουαρίου 1648 1815 (αναθεωρήθηκε πολλές φορές, με τελευταία το 2002)Έκταση • Σύνολο • % Νερό • ΣύνοραΑκτογραμμή41.543 km2 (133η)18,411.027 km451 kmΠληθυσμός • Εκτίμηση 7-2024 • Απογραφή 2011 • Πυκνότητα 17.981.933 (70η) 16.655.799 432,9 κατ./km2 (31η) ΑΕΠ (ΙΑΔ) • Ολικό (2016) • Κατά κεφαλή 869,365 δισ. $ 51.049 $ ΑΕΠ (ονομαστικό) • Ολικό (2016) • Κατά κεφαλή 771,163 δισ. $ 45.282 $ ΔΑΑ (2021) 0,941 (10η) – πολύ υψηλόςΝόμισμαΕυρώ2 (€ EUR)Ζώνη ώρας • Θερινή ώραCET (UTC +1) (UTC +2)ISO 3166-1NLInternet TLD.nl και .eu ως μέλος της ΕΕΟδηγούν σταδεξιάΚωδικός κλήσης+311 Έδρα της κυβέρνησης η Χάγη.2 Πριν το 2001: Φιορίνι ή Γκίλντερ. Η Ολλανδία (ολλανδικά: Nederland‎‎, προφέρεται: [ˈneːdərˌlɑnt]), επίσημα Κάτω Χώρες, είναι το ευρωπαϊκό τμήμα του Βασιλείου των Κάτω Χωρών (ολλανδικά: Koninkrijk der Nederlanden‎‎). Είναι πυκνοκατοικημένη χώρα που βρίσκεται στη Δυτική Ευρώπη, με τρεις μικρές νησιωτικές περιοχές στην Καραϊβική.[σμ 1] Το 2024, είχε συνολικό πληθυσμό 17.981.933 κατοίκους, σύμφωνα με επίσημη εκτίμηση. Η ευρέως διαδεδομένη ονομασία (Ολλανδία) προέκυψε από την περιοχή της Ολλανδίας, στην οποία περικλείονται δύο μόνο από τις δώδεκα επαρχίες του κράτους των Κάτω Χωρών. Η χώρα περιβάλλεται από τη Βόρεια Θάλασσα, το Βέλγιο και τη Γερμανία. Η χώρα, που αποκαλείται στα ολλανδικά Nederland και κυριολεκτικά σημαίνει Κάτω Χώρες, επηρεάζεται από το γεγονός ότι περίπου το 1/4 της χώρας βρίσκεται κάτω από τη στάθμη της θάλασσας, με μόνο το 50% της γης να υπερβαίνει το ένα μέτρο πάνω από την επιφάνεια της θάλασσας. Οι περισσότερες από τις περιοχές που βρίσκονται κάτω από το επίπεδο της θάλασσας είναι τεχνητές, ενώ 3.000 χιλιόμετρα φραγμάτων προστατεύουν τη χώρα. Από τα τέλη του 16ου αιώνα, μεγάλες περιοχές (πόλντερ) έχουν ανακτηθεί από τη θάλασσα και τις λίμνες, ενώ ανέρχονται σχεδόν στο 17% της τρέχουσας μάζας γης της χώρας. Με πυκνότητα πληθυσμού περί τους 510 κατοίκους ανά τετραγωνικό χιλιόμετρο (Ιούλιος 2016), χωρίς να περιλαμβάνονται οι περιοχές με νερό, η Ολλανδία είναι μια πολύ πυκνοκατοικημένη χώρα. Μόνο το Μπανγκλαντές, η Νότια Κορέα και η Ταϊβάν έχουν μεγαλύτερο πληθυσμό και υψηλότερη πυκνότητα πληθυσμού. Παρ' όλα αυτά, η Ολλανδία είναι ο δεύτερος μεγαλύτερος εξαγωγέας τροφίμων και γεωργικών προϊόντων στον κόσμο, μετά τις Ηνωμένες Πολιτείες. Αυτό οφείλεται εν μέρει στη γονιμότητα του εδάφους και στο ήπιο κλίμα. Η Ολλανδία είναι η τρίτη αρχαιότερη χώρα στον κόσμο που έχει εκλεγμένο κοινοβούλιο, ενώ από το 1848 κυβερνάται ως Βασιλευομένη Κοινοβουλευτική Δημοκρατία, οργανωμένη ως ενιαίο κράτος. Η Ολλανδία έχει μακρά ιστορία όσον αφορά την κοινωνική ανοχή και θεωρείται γενικά ως μια φιλελεύθερη χώρα, αφού νομιμοποίησε την άμβλωση, την πορνεία και την ευθανασία, διατηρώντας παράλληλα μια προοδευτική πολιτική για τα ναρκωτικά. Το 2001, έγινε η πρώτη χώρα στον κόσμο που νομιμοποίησε τον γάμο ατόμων του ίδιου φύλου. Ιστορία[Επεξεργασία | επεξεργασία κώδικα] Αψβουργικές Κάτω Χώρες (1519 - 1581)[Επεξεργασία | επεξεργασία κώδικα] Η καθημερινή ζωή κατά τη «χρυσή εποχή» της Ολλανδίας Οι ανεμόμυλοι Κίντερνταϊκ Η ευρύτερη περιοχή της σημερινής Ολλανδίας, μαζί με το σημερινό Βέλγιο, το Λουξεμβούργο και όμορα εδάφη, αναφέρεται ως μέρος των Δεκαεπτά Επαρχιών των Κάτω Χωρών, κατά τη βασιλεία του Καρόλου του Ε΄, Άγιου Ρωμαίου Αυτοκράτορα και βασιλιά της Ισπανίας κατά τον 16ο αιώνα. Το 1568 είναι η αρχή του ογδοηκονταετούς πολέμου μεταξύ των επαρχιών αυτών και της Ισπανίας για τα κυριαρχικά δικαιώματα σε αυτές. Το 1579, το βόρειο τμήμα των δεκαεπτά επαρχιών σχημάτισε την Ένωση της Ουτρέχτης, η οποία ουσιαστικά αποτέλεσε μία συμφωνία αλληλοϋποστήριξης μεταξύ τους στην άμυνα απέναντι στον ισπανικό στρατό. Η Ένωση της Ουτρέχτης αναφέρεται και ως το πρώτο ιστορικό σημείο εμφάνισης των Κάτω Χωρών ως ξεχωριστή θεσμική οντότητα. Το 1581 οι βόρειες επαρχίες υιοθέτησαν τη Δήλωση της Άρνησης, με την οποία διακήρυξαν την ανεξαρτησία τους και αποκήρυξαν τον Φίλιππο τον Β΄ της Ισπανίας. Ο αγώνας των Ολλανδών ενάντια στους Ισπανούς επηρέασε τη βασίλισσα Ελισάβετ η Α΄ της Αγγλίας, η οποία το 1585 υπέγραψε συνθήκη μαζί τους με την υπόσχεση αποστολής στρατού για την υποστήριξή τους στον πόλεμο για την ανεξαρτησία τους. Τον Δεκέμβριο του ίδιου έτους, σχεδόν 7.500 στρατιώτες έφτασαν στην Ολλανδία από την Αγγλία κάτω από τις διαταγές του Ρόμπερτ Ντάντλεϊ, πρώτου κόμη του Λέστερ. Ο αγγλικός στρατός όμως αναλώθηκε σε ανώφελες εκστρατείες στην ευρύτερη περιοχή, χωρίς να έχει κάποιο ουσιαστικό αντίκτυπο στην ολλανδική εξέγερση. Ο Ντάντλεϊ επέστρεψε το 1586 στην Ολλανδία με στρατό, αλλά ούτε και τότε συνεισέφερε σε κάποιο σημαντικό αποτέλεσμα. Ο Φίλιππος ο Β΄ της Ισπανίας, γιος του Καρόλου του Ε΄, δεν ήταν διατεθειμένος να παραδώσει τις Κάτω Χώρες και ο πόλεμος συνεχίστηκε μέχρι και το 1648, όταν ο βασιλιάς Φίλιππος ο Δ΄ τελικά αναγνώρισε την ανεξαρτησία των επτά βορειοδυτικών επαρχιών της περιοχής με τη συνθήκη ειρήνης του Μίνστερ. Τμήματα των νότιων επαρχιών παρέμειναν στην κατοχή των Ολλανδών και έτσι αποτέλεσαν και αυτά μέρος του νέου ανεξάρτητου κράτους. Ολλανδική Δημοκρατία (1581–1795)[Επεξεργασία | επεξεργασία κώδικα] Μετά την ανακήρυξη της ανεξαρτησίας τους οι επαρχίες Ολλανδία, Ζηλανδία, Χρόνινγκεν, Φρίσλαντ, Ουτρέχτη, Οφεράισσελ και Χέλντερλαντ σχημάτισαν μία συνομοσπονδία γνωστή ως η Δημοκρατία των Επτά Ενωμένων Κάτω Χωρών. Όλες οι επαρχίες παρέμειναν αυτόνομες και είχαν τη δική τους κυβέρνηση, την πολιτεία της επαρχίας, όπως έμεινε γνωστή. Η κυβέρνηση της συνομοσπονδίας και οι ύπατοι κυβερνήτες των επαρχιών είχαν έδρα τη Χάγη, ενώ αποτελούνταν από αντιπροσώπους των μελών της συνομοσπονδίας. Η αραιοκατοικημένη περιοχή Ντρέντε ήταν μέρος της δημοκρατίας, αν και δεν θεωρούνταν επαρχία. Η Ντρέντε είχε τους δικούς τους αξιωματούχους, αλλά ο κυβερνήτης της διορίζονταν από τους ύπατους κυβερνήτες. Παράλληλα, η δημοκρατία κατείχε και ορισμένες περιοχές εκτός των παραδοσιακών συνόρων των επαρχιών, γνωστές ως Γενικές Εκτάσεις, οι οποίες διοικούταν απευθείας από τους ύπατους κυβερνήτες, χωρίς δικούς τους αντιπροσώπους ή εξουσία. Η πλειοψηφία των περιοχών αυτών είχε καταληφθεί από τους Ολλανδούς κατά τη διάρκεια του ογδοηκονταετούς πολέμου και κατοικούνταν κυρίως από καθολικούς. Οι περιοχές αυτές αποτελούσαν μια ουδέτερη ζώνη ανάμεσα στη δημοκρατία και τις νότιες Κάτω Χώρες. Η ολλανδική αυτοκρατορία αναπτύχθηκε και σταδιακά εξελίχθηκε σε μια από τις μεγαλύτερες ναυτικές και οικονομικές δυνάμεις του 17ου αιώνα. Στην ονομαζόμενη ολλανδική Χρυσή Εποχή ιδρύθηκαν αποικίες και εμπορικοί σταθμοί σε όλο τον κόσμο. Η εγκατάσταση των Ολλανδών στη βόρεια Αμερική ξεκίνησε με την ίδρυση του οικισμού Νέο Άμστερνταμ στο νότιο άκρο του Μανχάταν το 1614. Οι Ολλανδοί ίδρυσαν την Αποικία του Ακρωτηρίου στη Νότια Αφρική το 1652. Μέχρι το 1650 ο ολλανδικός στόλος αριθμούσε 16.000 εμπορικά πλοία, ενώ παράλληλα ο πληθυσμός αυξήθηκε σε περίπου 2 εκατομμύρια από 1,5 μέσα στον 17ο αιώνα. Πολλοί ιστορικοί και οικονομολόγοι θεωρούν την Ολλανδία ως την πρώτη καπιταλιστική χώρα στην παγκόσμια ιστορία. Στην πρώιμη σύγχρονη Ευρώπη, η Ολλανδία είχε την πιο πλούσια εμπορική πόλη, το Άμστερνταμ, και το πρώτο πλήρως λειτουργικό χρηματιστήριο. Η εφευρετικότητα των εμπόρων οδήγησε στη θεσμοθέτηση κεφαλαίου ασφάλισης και σύνταξης, καθώς και σε λιγότερο ευχάριστα φαινόμενα, όπως στον φαύλο οικονομικό κύκλο, την πρώτη παγκόσμια πληθωριστική φούσκα, τη μανία της τουλίπας μεταξύ 1636 και 1637 και στον πρώτο παγκόσμιο τυχοδιώκτη του χρηματιστηρίου, ο οποίος κατέβαζε τις τιμές των μετοχών πουλώντας για να τις αγοράσει ξανά με χαμηλότερη τιμή. Η δημοκρατία έπεσε σε γενική παρακμή στα τέλη του 18ου αιώνα με τον έντονο οικονομικό ανταγωνισμό από την Αγγλία και συνεχείς εσωτερικές προστριβές ανάμεσα στις δύο κύριες πολιτικές ομάδες της χώρας, τους ρεπουμπλικάνους και τους βασιλικούς. Τον 17ο αιώνα συνεχίστηκαν οι διαμάχες με την Αγγλία για ανταγωνιστικές αποικίες και εμπορικούς σταθμούς σε όλο τον κόσμο. Οι Ολλανδοί είχαν ιδρύσει αποικίες φυτειών κατά μήκος των ακτών και των ποταμών της Γουιάνας στη Νότια Αμερική, παράλληλα με τους Άγγλους. Μετά από συνεχόμενες διαμάχες, οι δύο χώρες κατέληξαν σε συμφωνία αποχώρησης των Άγγλων και παραχώρησης των εκτάσεών τους στους Ολλανδούς, με τη συνθήκη της Μπρέντα. Η συμφωνία προέβλεπε την ανταλλαγή των εκτάσεων με την αποικία των Ολλανδών στη βόρεια Αμερική, το Νέο Άμστερνταμ, έναν μικρό εμπορικό σταθμό, ο οποίος μετέπειτα εξελίχθηκε στη σημερινή Νέα Υόρκη. Γαλλική κυριαρχία: 1795–1815[Επεξεργασία | επεξεργασία κώδικα] Στις 19 Ιανουαρίου του 1795, μία ημέρα μετά τη διαφυγή του κυβερνήτη Γουλιέλμου Ε΄ της Οράγγης στην Αγγλία, ανακηρύχθηκε η Δημοκρατία της Μπατάβια με στόχο την ένωση των Κάτω Χωρών σε ένα ενιαίο κράτος. Από το 1795 έως και το 1806 με το καθεστώς αυτό η Ολλανδία απέκτησε μία κρατική δομή παρόμοια με αυτή της τότε νεοσύστατης Η Πρώτη Γαλλική Δημοκρατία και η περίοδος της Γαλλικής Δημοκρατίας. Με την άνοδο του Ναπολέοντα στην εξουσία της Γαλλίας, στις Κάτω Χώρες καθιερώθηκε το Βασίλειο της Ολλανδίας από το 1806 μέχρι το 1810, υποτελές στη Γαλλία με βασιλιά τον αδελφό του Ναπολέοντα, Λουδοβίκο Βοναπάρτη, με πλήρη έλεγχο των εξουσιών από τους Γάλλους. Για την ονομασία του βασιλείου αυτού χρησιμοποιήθηκε το όνομα της κύριας επαρχίας, της Ολλανδίας, το οποίο και καθιερώθηκε από τότε και στο εξής ως ταυτόσημο των Κάτω Χωρών. Το Βασίλειο της Ολλανδίας κάλυπτε την έκταση της σημερινής χώρας εκτός από την επαρχία του Λίμπουρχ και τμήματα της επαρχίας Ζέελαντ, τα οποία άνηκαν στη Γαλλία. Το 1807 προστέθηκαν στο βασίλειο η ανατολική Φρισία, πρότερη κτήση της Πρωσίας, και η περιοχή του Γιέβερ. Το 1809 όμως, μετά από μία αποτυχημένη Βρετανική εισβολή, η Ολλανδία υποχρεώθηκε να παραχωρήσει όλα τα εδάφη της νότια του Ρήνου στη Γαλλία.Χάρτης των επτά Ηνωμένων ΕπαρχιώνΟ βασιλιάς Λουδοβίκος δεν ικανοποίησε τις προσδοκίες του Ναπολέοντα, καθώς υποστήριζε τα τοπικά συμφέροντα περισσότερο από τα γαλλικά, και υποχρεώθηκε σε παραίτηση το 1810. Τον διαδέχθηκε ο πεντάχρονος γιος του, Ναπολέοντας Λουδοβίκος Βοναπάρτης, ο οποίος βασίλεψε ως Λουδοβίκος ο Β΄ για δέκα μόλις ημέρες, αφού ο Ναπολέοντας δεν αναγνώρισε την εξουσία του στον θρόνο και κατέλαβε άμεσα την Ολλανδία, καταλύοντας το βασίλειο. Έτσι, οι Κάτω Χώρες έγιναν τμήμα της Γαλλικής Αυτοκρατορίας, στην οποία και παρέμειναν έως και το 1813, όταν, μετά την ήττα του στη μάχη της Λειψίας, ο Ναπολέοντας υποχρεώθηκε να αποσύρει τα στρατεύματά του από τη χώρα. Ηνωμένο Βασίλειο των Κάτω Χωρών[Επεξεργασία | επεξεργασία κώδικα] Χάρτης που απεικονίζει την παλαιά Ολλανδική Αυτοκρατορία, τον 18ο αιώνα. Ο Γουλιέλμος ο Α΄ των Κάτω Χωρών, γιος του τελευταίου κυβερνήτη Γουλιέλμου του Ε΄ της Οράγγης, επέστρεψε στην Ολλανδία το 1813 και ανακηρύχθηκε ισόβιος πρίγκιπας των Κάτω Χωρών, ενώ το 1815 ο τίτλος του εξελίχθηκε σε Βασιλιάς των Κάτω Χωρών. Το Συνέδριο της Βιέννης το 1815 εγκαθίδρυσε το Ηνωμένο Βασίλειο των Κάτω Χωρών με την επέκταση της επικράτειάς του στο Βέλγιο, ώστε να δημιουργήσει μία ισχυρή κρατική οντότητα στα βόρεια σύνορα της Γαλλίας. Παράλληλα, ο Γουλιέλμος έγινε κληρονόμος του τίτλου του Μεγάλου Δούκα του Λουξεμβούργου. Έτσι, το Λουξεμβούργο παραχωρήθηκε στον Γουλιέλμο ως προσωπική ιδιοκτησία σε ανταλλαγή με τις κτήσεις του στη Γερμανία, δηλαδή στο Νασσάου-Ντίλενμπουργκ, το Ζίγκεν, το Χανταμάρ και το Ντιτς. Το 1830 το Βέλγιο επαναστάτησε και τελικά κέρδισε την ανεξαρτησία του, ενώ η προσωπική ένωση μεταξύ του Λουξεμβούργου και των Κάτω Χωρών καταλύθηκε το 1890, όταν ο βασιλιάς Γουλιέλμος ο Γ΄ των Κάτω Χωρών απεβίωσε χωρίς να αφήσει πίσω του άρρενες κληρονόμους. Οι νόμοι της διαδοχής απαγόρευαν στην κόρη του Βασίλισσα Βιλελμίνα να πάρει τον τίτλο της Μεγάλης Δούκισσας, με συνέπεια ο θρόνος του Λουξεμβούργου να μεταφερθεί από τον οίκο Οράγγης-Νασσάου στον κλάδο Νασσάου-Βάιλμπουργκ, θυγατρικό του Οίκου του Νασσάου. Η μεγαλύτερη ολλανδική αποικία εκείνη την περίοδο στο εξωτερικό ήταν η Αποικία του Ακρωτηρίου, η οποία είχε ιδρυθεί από τον Γιαν βαν Ρίμπεκ για λογαριασμό της Ολλανδικής Εταιρίας των Ανατολικών Ινδιών το 1652 στην Πόλη του Ακρωτηρίου. Ο Πρίγκηπας του Οράνιε συναίνεσε στην κατάληψη και έλεγχο της αποικίας από τους Βρετανούς το 1788. Η Ολλανδία είχε και άλλες αποικίες, αλλά το Ακρωτήριο ήταν η πολυπληθέστερη, με τις Ολλανδικές Ανατολικές Ινδίες (σημερινή Ινδονησία) και το Σουρινάμ να ακολουθούν. Αυτές οι αποικίες αρχικά διοικούνταν από την Ολλανδική Εταιρεία Ανατολικών Ινδιών και αντίστοιχα την Ολλανδική Εταιρία των Δυτικών Ινδιών, οι οποίες ήταν συλλογικές ιδιωτικές επιχειρήσεις. Τρεις αιώνες αργότερα οι εταιρίες αυτές είχαν οικονομικά προβλήματα και οι περιοχές που διοικούσαν πέρασαν στον έλεγχο της Ολλανδικής κυβέρνησης το 1815 και το 1791 αντίστοιχα. Τότε μόνο έγιναν και τυπικά επίσημα αποικίες. Κατά την περίοδο της αποικιοκρατίας, η Ολλανδία εμπλεκόταν ιδιαίτερα στο εμπόριο σκλάβων. Οι Ολλανδοί άποικοι και ιδιοκτήτες φυτειών βασίζονταν στους αφρικανούς σκλάβους για τις καλλιέργειες καφέ, κακάο, ζαχαροκάλαμου και βαμβακιού κατά μήκος των διαφόρων ποταμών. Η μεταχείριση των σκλάβων ήταν ιδιαίτερα άσχημη και αρκετοί δραπέτευαν. Η δουλεία καταργήθηκε από την Ολλανδία στο Σουρινάμ το 1863, αλλά το σύνολο των σκλάβων δεν απελευθερώθηκε παρά μόνο μέχρι το 1873 μετά από μία υποχρεωτική δεκαετή περίοδο μετάβασης, κατά την οποία δούλευαν στις φυτείες για τον ελάχιστο μισθό και χωρίς βασανιστήρια. Με την επίσημη απελευθέρωση οι περισσότεροι έφυγαν από τις φυτείες και προτίμησαν να εγκατασταθούν στην κύρια πόλη του Σουρινάμ, το Παραμαρίμπο. Κατά τον 19ο αιώνα η Ολλανδία εκβιομηχανίστηκε σχετικά αργά σε σύγκριση με τις γειτονικές της χώρες, κυρίως λόγω της μεγάλης πολυπλοκότητας του εκσυγχρονισμού των υποδομών της, οι οποίες κύρια αποτελούνται από υδάτινες οδούς, αλλά και λόγω του σημαντικού ρόλου της αιολικής ενέργειας στη βιομηχανία της χώρας. Αν και η Ολλανδία παρέμεινε ουδέτερη κατά τον Α΄ Παγκόσμιο Πόλεμο, αναμείχθηκε ιδιαίτερα σε αυτόν. Ο κόμης Σλίφεν αρχικά είχε σχεδιάσει να καταλάβει την Ολλανδία κατά την προέλασή του στη Γαλλία. Το σχέδιο αυτό άλλαξε από τον Χέλμουτ φον Μόλτκε τον νεότερο, ώστε να διατηρηθεί η ολλανδική ουδετερότητα. Αργότερα, αυτή η ουδετερότητα αποδείχθηκε κρίσιμη για την επιβίωση της Γερμανίας μέχρι το εμπάργκο που ολοκληρώθηκε με την εισδοχή των ΗΠΑ και της Μεγάλης Βρετανίας το 1916, και την αδυναμία εισαγωγών από την Ολλανδία στα γερμανικά εδάφη. Παρ'όλα αυτά, οι Ολλανδοί παρέμειναν ουδέτεροι χρησιμοποιώντας τη διπλωματία τους και την ικανότητά τους στο εμπόριο. Β' Παγκόσμιος Πόλεμος[Επεξεργασία | επεξεργασία κώδικα] Το Ρότερνταμ μετά τις αεροπορικές επιδρομές της Λούφτβαφε το 1940. Η εκκλησία στο κέντρο είναι ο καθεδρικός ναός του Αγίου Λαυρεντίου Η Ολλανδία επιθυμούσε να παραμείνει ουδέτερη κατά τον Β΄ Παγκόσμιο Πόλεμο, όπως και στο παρελθόν, αλλά τα σχέδια των στρατών του Βελγίου, της Γαλλίας και της Μεγάλης Βρετανίας ήταν διαφορετικά. Χωρίς ενδοιασμούς, η ναζιστική Γερμανία εισέβαλε στην Ολλανδία λόγω της στρατηγικής της θέσης στις 10 Μαΐου του 1940, ως μέρος της εκστρατείας κατά των Συμμάχων. Η επίπεδη διαμόρφωση του εδάφους της χώρας διευκόλυνε την ανάπτυξη των γερμανικών στρατευμάτων και ο ολλανδικός στρατός υπέκυψε σε 4 μέρες, παρά την επίμονη αρχική αντίστασή του. Η κυβέρνηση της χώρας και η βασίλισσα εξορίστηκαν στο Λονδίνο. Κατά τη διάρκεια της γερμανικής κατοχής και υπό τη διοίκηση του στυγνού Άρτουρ Ζάις-Ίνκβαρτ 100.000 Ολλανδοί Εβραίοι μεταφέρθηκαν σε στρατόπεδα συγκέντρωσης. Αρκετοί ήταν επίσης οι Ολλανδοί - περίπου 50.000, που κατετάγησαν εθελοντικά στην Ες Ες. Παρά το κόστος της κατοχής σε ζωές και χρήμα, η Ολλανδία είχε πολύ καλύτερη μεταχείριση από το ναζιστικό καθεστώς σε σχέση με χώρες της Ανατολής, καθώς οι Ολλανδοί θεωρούνταν από τους Γερμανούς «τευτονικός» λαός. Επιπλέον μιας και η Γερμανία δεν είχε αρκετά ισχυρό στόλο για να «σιγουρέψει» τις ολλανδικές αποικίες, όφειλε να φερθεί ήπια ώστε να πείσει τους Ολλανδούς να συνεργαστούν. Έτσι καθ'όλη τη διάρκεια της κατοχής ο προπολεμικός κρατικός μηχανισμός παρέμεινε άθικτος και οι Ολλανδοί ανώτεροι κρατικοί υπάλληλοι διεκπεραίωναν το πραγματικό κομμάτι της διοίκησης, με σχετικά μικρό αριθμό Γερμανών να επιβλέπει τη χώρα. Η χώρα απελευθερώθηκε στις 5 Μαΐου 1945 με την παράδοση των τελευταίων γερμανικών στρατευμάτων στους Συμμάχους. Την ίδια περίοδο στην Ινδονησία, η οποία είχε τελέσει υπό ιαπωνική κατοχή κατά τη διάρκεια του Β΄ Παγκοσμίου Πολέμου, ξεκινούσε ο αγώνας για την αποτίναξη του ολλανδικού αποικιοκρατικού ζυγού. 1945 - σήμερα[Επεξεργασία | επεξεργασία κώδικα] Τις επόμενες δεκαετίες η Ολλανδία παράλληλα με την ανάπτυξη της οικονομίας της προώθησε τη σύσφιξη των σχέσεών της με τις γειτονικές χώρες. Υπήρξε ιδρυτικό μέλος της ένωσης Μπενελούξ, του ΝΑΤΟ και της Ευρωπαϊκής Κοινότητας Άνθρακα και Χάλυβα που μετεξελίχθηκε στη σημερινή ΕΕ. Το 1975 απέκτησε την ανεξαρτησία του από την Ολλανδία και το Σουρινάμ. Στις 10 Οκτωβρίου 2010 οι Ολλανδικές Αντίλλες εντάχθηκαν στην ολλανδική επικράτεια. Στις 30 Απριλίου 2013 νέος βασιλιάς έγινε ο Γουλιέλμος Αλέξανδρος, μετά την παραίτηση της μητέρας του Βεατρίκης από τον θρόνο. Γεωγραφία και κλίμα[Επεξεργασία | επεξεργασία κώδικα] Κύριο λήμμα: Γεωγραφία της ΟλλανδίαςΟι περιοχές της Ολλανδίας που είναι πάνω από το επίπεδο της θάλασσας Το φράγμα Άφσλαουτνταϊκ, αριστερά η Βόρεια Θάλασσα, δεξιά η Άισελμεερ Η Ολλανδία έχει έκταση 33.491 τ.χλμ. ξηράς και, αν ληφθεί υπ' όψιν και το 20% της θαλάσσιας έκτασης συνολική επιφάνεια: 41.526 τ.χλμ. Η μισή χώρα βρίσκεται λιγότερο από ένα μέτρο πάνω από την επιφάνεια της θάλασσας, ενώ το 1/4 κάτω από το επίπεδο της θάλασσας. Το ψηλότερο σημείο της χώρας είναι το Φάαλσερμπερχ (Vaalserberg) στα νότια της χώρας, στα σύνορα με το Βέλγιο και τη Γερμανία και έχει υψόμετρο μόλις 321 μέτρα. Το χαμηλότερο σημείο της χώρας βρίσκεται στον δήμο Νίουερκερκ αν ντεν Άισελ (ολλανδικά: Nieuwerkerk aan den IJssel‎‎) και βρίσκεται 6,76 μέτρα κάτω από την επιφάνεια της θάλασσας, αποτελώντας έτσι το χαμηλότερο σημείο της Ευρώπης. Το τοπίο είναι γενικά πιο λοφώδες στα ανατολικά και νότια της χώρας. Πολλά τμήματα της Ολλανδίας, όπως ολόκληρη η επαρχία Φλέβολαντ (ολλανδικά: Flevoland‎‎) δεν ήταν πάντα στεριά αλλά θάλασσα που οι Ολλανδοί διεκδίκησαν. Τα μέρη που διεκδικήθηκαν από τη θάλασσα ονομάζονται Πόλντερ. Το 18,4% της συνολικής έκτασης της Ολλανδίας είναι υδάτινες επιφάνειες. Η λίμνη Άισελμεερ (IJsselmeer) χωρίζεται από τη θάλασσα με το φράγμα Άφσλαουτνταϊκ μήκους 29 χιλιομέτρων, το οποίο χτίστηκε το 1932. Οι σημαντικότεροι ποταμοί της χώρας είναι ο Ρήνος, ο Μάας και ο Σχέλντε. Η Ολλανδία είναι, επί της ουσίας, το δέλτα που δημιουργούν αυτά τα τρία ευρωπαϊκά ποτάμια. Εκτός από τη γεωγραφική τους σημασία, αυτά τα ποτάμια χωρίζουν τη χώρα -σε γενικές γραμμές- πολιτιστικά και θρησκευτικά σε βόρεια και νότια. Το κλίμα είναι ωκεάνιο με δυτικούς ανέμους ως επί το πλείστον. Οι βροχές είναι άφθονες όλο τον χρόνο (εκτός του χειμώνα), ενώ οι θερμοκρασίες είναι σχετικά ήπιες τον χειμώνα και δροσερές το καλοκαίρι. Χιονοπτώσεις συμβαίνουν κυρίως από τις αρχές Δεκεμβρίου έως και τα τέλη Φεβρουαρίου. Βροχές έχει όλο τον υπόλοιπο χρόνο και κυρίως τους καλοκαιρινούς μήνες. Οι θερμοκρασίες κυμαίνονται από -1,-2 έως 4-5 βαθμούς τον χειμώνα και από 11-12 έως 20-22 βαθμούς το καλοκαίρι. Οι διαφορές θερμοκρασίας τόσο κατά το καλοκαίρι όσο και κατά και χειμώνα είναι σχετικά μικρές, και αυτό συμβαίνει διότι τον χειμώνα ένα θερμό ρεύμα, το οποίο έρχεται κάθε χρόνο από τον κόλπο του Μεξικού, επηρεάζει τη θερμοκρασία της θάλασσας, με αποτέλεσμα να μην παγώνει σχεδόν ποτέ. Εάν δεν συνέβαινε αυτό, υπολογίζεται πως το Άμστερνταμ τον χειμώνα θα είχε μέση θερμοκρασία γύρω στους -10 βαθμούς Κελσίου. Δημογραφία[Επεξεργασία | επεξεργασία κώδικα] Ο αριθμός κατοίκων στην Ολλανδία σε χιλιάδες (FAOSTAT 2005) Η Ολλανδία με συνολικό πληθυσμό, σύμφωνα με επίσημη εκτίμηση για το 2024, 17.981.933 κατοίκους, κατατάσσεται στην 31η θέση των χωρών ανά πυκνότητα πληθυσμού, με 432,9 κατοίκους ανά τετραγωνικό χιλιόμετρο (ή 510/τ.χλμ. αν δεν ληφθεί υπ' όψιν το 20% της θαλάσσιας έκτασης). Αποτελεί την πιο πυκνοκατοικημένη χώρα της Ευρωπαϊκής Ένωσης. Σύμφωνα με τα επίσημα στοιχεία της στατιστικής υπηρεσίας της χώρας, οι εθνικότητες των κατοίκων ποικίλλουν: το 80,8% του πληθυσμού είναι Ολλανδοί, το 5,6% Ευρωπαίοι (με 2,4% Γερμανούς), το 2,4% Ινδονήσιοι, το 2,2% Τούρκοι, το 2,0% από το Σουρινάμ, το 1,9% Μαροκινοί, το 0,8% από τις πάλαι ποτέ Ολλανδικές Αντίλλες και την Αρούμπα, ενώ το 4,2% είναι άλλης εθνικότητας. Η χώρα δεν διαθέτει καμία πόλη με πληθυσμό άνω του ενός εκατομμυρίου, ωστόσο οι τέσσερις μεγαλύτερες πόλεις (Άμστερνταμ, Ρότερνταμ, Χάγη και Ουτρέχτη) καθώς και άλλες περιοχές των περιχώρων, θεωρούνται συχνά ως ένα ενιαίο πολεοδομικό σύμπλεγμα, το οποίο ονομάζεται Ράντσταντ (Randstad) και περιλαμβάνει περίπου 7 εκατομμύρια κατοίκους. Το προσδόκιμο ζωής στο σύνολο του πληθυσμού, σύμφωνα με εκτιμήσεις του 2019 του Παγκόσμιου Οργανισμού Υγείας ήταν 81,8 χρόνια (80,4 χρόνια οι άνδρες και 83,1 οι γυναίκες). Γλώσσες[Επεξεργασία | επεξεργασία κώδικα] Η επίσημη και πλειοψηφική γλώσσα με 16 εκατομμύρια ομιλητές είναι τα Ολλανδικά, που είναι γερμανική γλώσσα της Δύσης από την ομάδα των κάτω Γερμανικών. Επίσημα αναγνωρισμένες τοπικές διάλεκτοι είναι τα Λιμβουργιανά, τα Κάτω-σαξονικά και τα Φριζικά, που ομιλούνται στην επαρχία Φρίσλαντ, και συνδέονται έντονα με τα Ολλανδικά αλλά και τα Αγγλικά. Από τις 10 Οκτωβρίου 2010, μετά την διάλυση των Ολλανδικών Αντίλλων, επίσημη γλώσσα αποτελούν και τα Παπιαμέντο. Στην Ολλανδία ομιλούνται επίσης κυρίως από μετανάστες τα τουρκικά και τα αραβικά από περίπου 192.000 και 100.000 κατοίκους αντίστοιχα, ακολουθούμενα από άλλες γλώσσες. Θρησκείες[Επεξεργασία | επεξεργασία κώδικα] Η Ολλανδία, από παλιά χριστιανική χώρα, είναι σήμερα μία από τις πλέον αγνωστικιστικές χώρες. Περίπου το 40% των κατοίκων της αυτοπροσδιορίζεται ως ακόλουθος καμίας θρησκείας. Υπάρχουν έτσι πολλοί άθεοι. Το υπόλοιπο 60% του πληθυσμού χωρίζεται περίπου ως εξής: στη Ρωμαιοκαθολική Εκκλησία (5 εκατομμύρια μέλη, 31%) στην Προτεσταντική Εκκλησία της Ολλανδίας (2,5 εκατομμύρια μέλη, 21%) στις διάφορες μικρές Αναμορφωμένες εκκλησίες (συνολικά περίπου 700.000 μέλη) στο Ισλάμ (εκτιμ. 900.000 μέλη, 6,1%) στον Ινδουισμό (εκτιμ. 100.000 μέλη, 1,5%) στον Βουδισμό (εκτιμ. 80.000 μέλη) στον Ιουδαϊσμό (εκτιμ. 40.000 μέλη). στους Μορμόνους της Εκκλησίας του Ιησού Χριστού των Αγίων των Τελευταίων Ημερών (9.284 μέλη) Οι καθολικοί βρίσκονται κυρίως στο νότιο τμήμα της χώρας, ενώ οι προτεστάντες στο βόρειο. Εκπαιδευτικό σύστημα[Επεξεργασία | επεξεργασία κώδικα] Δευτεροβάθμια εκπαίδευση[Επεξεργασία | επεξεργασία κώδικα] Η Δευτεροβάθμια εκπαίδευση, η οποία ξεκινά από την ηλικία των 12 ετών, είναι υποχρεωτική μέχρι την ηλικία των 16 ετών και προσφέρεται σε διάφορα επίπεδα. Τα δύο προγράμματα γενικής εκπαίδευσης που οδηγούν στην τριτοβάθμια εκπαίδευση είναι τα HAVO (πέντε χρόνια) και VWO (έξι έτη). Οι μαθητές εγγράφονται ανάλογα με τις ικανότητές τους, και αν και το VWO είναι πιο αυστηρό, τόσο το HAVO όσο και το VWO χαρακτηρίζονται ως επιλεκτικοί τύποι δευτεροβάθμιας εκπαίδευσης. Το πρόγραμμα σπουδών του VWO προετοιμάζει τους μαθητές για το πανεπιστήμιο και μόνο το δίπλωμα VWO παρέχει πρόσβαση σε WO (ερευνητικά πανεπιστήμια). Το δίπλωμα HAVO είναι η ελάχιστη προϋπόθεση για την εισαγωγή στο HBO (πανεπιστήμια επαγγελματικής εκπαίδευσης). Τα δύο τελευταία χρόνια του ΗΑVO και τα τρία τελευταία χρόνια της VWO αναφέρονται ως δεύτερη φάση («tweede fase»), ή ανώτερη δευτεροβάθμια εκπαίδευση. Κατά τη διάρκεια αυτών των ετών, οι μαθητές επικεντρώνονται σε μία από τις τέσσερις θεματικές δέσμες («profielen»), κάθε μια από τις οποίες εστιάζει σε μια συγκεκριμένη περιοχή μελέτης, επιπρόσθετα της ικανοποίησης των γενικών απαιτήσεων εκπαίδευσης. Κάθε δέσμη έχει σχεδιαστεί για να προετοιμάσει τους μαθητές για τα προγράμματα σπουδών στο τριτοβάθμιο επίπεδο. Ένας μαθητής που εγγράφονται στα VWO ή ΗΑVO μπορεί να επιλέξει από τις παρακάτω θεματικές δέσμες: 1) Επιστήμη και Τεχνολογίας («Natuur en Techniek») 2) Επιστήμη και Υγεία («Natuur en Gezondheid») 3) Οικονομικά και Κοινωνία («Economie en Maatschappij») 4) Πολιτισμός και Κοινωνία («Cultuur en Maatschappij») Ανώτερη και Ανώτατη εκπαίδευση[Επεξεργασία | επεξεργασία κώδικα] Η τριτοβάθμια εκπαίδευση στην Ολλανδία προσφέρεται σε δύο τύπους ιδρυμάτων: ερευνητικά πανεπιστήμια («universiteiten» ή «Wetenschappelijk Onderwijs») και τα πανεπιστήμια επαγγελματικής εκπαίδευσης («Hogescholen» ή «Hoger Beroepsonderwijs»). Τα πρώτα περιλαμβάνουν γενικά πανεπιστήμια και πανεπιστήμια που ειδικεύονται στον τομέα της μηχανικής και της γεωργίας. Τα δεύτερα περιλαμβάνουν γενικά ιδρύματα και ιδρύματα που ειδικεύονται σε ένα συγκεκριμένο τομέα, όπως η γεωργία, καλές τέχνες και τέχνες του θεάματος, ή η κατάρτιση των εκπαιδευτικών. Από τον Σεπτέμβριο του 2002, το σύστημα τριτοβάθμιας εκπαίδευσης στην Ολλανδία έχει οργανωθεί γύρω από ένα σύστημα τριών κύκλων σπουδών που αποτελείται από βασικό Πτυχίο, Μεταπτυχιακό και Διδακτορικό. Την ίδια στιγμή, το πιστωτικό σύστημα ECTS υιοθετήθηκε ως ένας τρόπος ποσοτικοποίησης των περιόδων σπουδών. Ωστόσο, το σύστημα τριτοβάθμιας εκπαίδευσης συνεχίζει να είναι ένα δυαδικό σύστημα με μια διάκριση μεταξύ της εκπαίδευσης με προσανατολισμό στην έρευνα και επαγγελματικής τριτοβάθμιας εκπαίδευσης. Το επίπεδο του προγράμματος σπουδών καθορίζει τόσο τον αριθμό των πιστωτικών μονάδων που απαιτούνται για την ολοκλήρωση του προγράμματος και το πτυχίο που απονέμεται. Ένα WO πρόγραμμα βασικού πτυχίου απαιτεί την ολοκλήρωση 180 πιστωτικών μονάδων (3 χρόνια) και οι απόφοιτοι αποκτούν πτυχίο του Bachelor of Arts ή Bachelor of Science (BA / BSc), ανάλογα με τον κλάδο. Ένα πρόγραμμα βασικού πτυχίου HBO απαιτεί την ολοκλήρωση 240 πιστωτικών μονάδων (4 χρόνια), και οι απόφοιτοι αποκτούν πτυχίο που αναφέρει τον τομέα των σπουδών τους, για παράδειγμα Πτυχίο Μηχανικού (Β Eng.) ή Πτυχίο Νοσηλευτικής (B. Nursing). Τα μεταπτυχιακά προγράμματα WO απαιτούν κυρίως την ολοκλήρωση 60 ή 120 μονάδων (1 ή 2 χρόνια). Ορισμένα προγράμματα απαιτούν 90 (1,5 έτη) ή πάνω από 120 μονάδες. Στη μηχανική, τη γεωργία, και τα μαθηματικά και τις φυσικές επιστήμες, οι 120 μονάδες απαιτούνται πάντοτε. Οι απόφοιτοι αποκτούν το πτυχίο Master of Arts ή Μεταπτυχιακό τίτλο ειδίκευσης (MA / MSc). Τα μεταπτυχιακά προγράμματα HBO απαιτούν την ολοκλήρωση 60 έως 120 μονάδες, και οι απόφοιτοι αποκτούν πτυχίο που δείχνει το πεδίο μελέτης, για παράδειγμα Μεταπτυχιακό Κοινωνικής Εργασίας (MSW). Ο τρίτος κύκλος της τριτοβάθμιας εκπαίδευσης προσφέρεται μόνο από τα ερευνητικά πανεπιστήμια, τα οποία έχουν το δικαίωμα να απονείμουν τον υψηλότερο ακαδημαϊκό τίτλο σπουδών της χώρας, το διδακτορικό, το οποίο επιτρέπει σε ένα πρόσωπο να χρησιμοποιεί τον τίτλου δόκτωρ (Δρ.). Η διαδικασία με την οποία επιτυγχάνεται η εκπόνηση διδακτορικής διατριβής αναφέρεται ως promotie. Το διδακτορικό είναι πρωτίστως ένα ερευνητικό πτυχίο, για το οποίο ο υποψήφιος πρέπει να γράψει και αν υπερασπίσει δημοσίως μια διατριβή βασισμένη σε πρωτότυπη έρευνα. Τέχνες και πολιτισμός[Επεξεργασία | επεξεργασία κώδικα] Η Ολλανδία είναι γνωστή παγκοσμίως για τους ζωγράφους της και τους εν γένει εικαστικούς καλλιτέχνες. Ο οικονομικός πλούτος του 17ου αιώνα γέννησε μια πλειάδα αριστουργηματικών καλλιτεχνών, όπως τον Ρέμπραντ και τον Γιοχάνες Βερμέερ, ενώ η νεότερη εποχή συνδέθηκε με τα ηχηρά ονόματα του Βίνσεντ βαν Γκογκ και του Πητ Μοντριάν. Τα έργα του χαράκτη Μαουρίτς Κορνέλις Έσερ αφήνουν ακόμη και σήμερα τα αποτυπώματά τους στα έργα άλλων καλλιτεχνών. Από τον κόσμο των γραμμάτων, τα ονόματα Έρασμος και Σπινόζα κατέχουν μια θέση στην παγκόσμια ιστορία, αμφότεροι φιλόσοφοι με έδρα την Ολλανδία. Μεγάλης αξίας είναι και το έργο του Καρτέσιου, που πραγματοποιήθηκε ως επί το πλείστον στην Ολλανδία, όπως επίσης και η εφεύρεση του εκκρεμούς ρολογιού από τον Κρίστιαν Χόυχενς. Διακυβέρνηση[Επεξεργασία | επεξεργασία κώδικα] Από το τέλος της Γαλλικής Κατοχής το 1815, η Ολλανδία αποτελεί Βασιλευόμενη Κοινοβουλευτική Δημοκρατία με τον βασιλικό οίκο Οράγγης-Νάσσαου στην εξουσία. Την εκτελεστική εξουσία ασκεί η ολλανδική κυβέρνηση. Αρχηγός κράτους[Επεξεργασία | επεξεργασία κώδικα] Αρχηγός κράτους από το 1980 ήταν η βασίλισσα Βεατρίκη. Από την 30ή Απριλίου 2013, ημέρα της εορτής της Βασίλισσας (Koninginnedag), ο γιος της Γουλιέλμος Αλέξανδρος της Ολλανδίας (Willem-Alexander) είναι ο νέος βασιλιάς της χώρας, ο πρώτος άρρην που καταλαμβάνει το ανώτατο αξίωμα μετά από 120 χρόνια. Νέα εθνική εορτή είναι η ημερομηνία γεννήσεως του Γουλιέλμου-Αλεξάνδρου, 27η Απριλίου (1967), η οποία ονομάζεται \"Ημέρα του Βασιλιά\". Κοινοβούλιο[Επεξεργασία | επεξεργασία κώδικα] Το Ολλανδικό Κοινοβούλιο αποτελείται από 2 σώματα. Η εκλογή των 150 μελών του δεύτερου σώματος (Tweedekamer) γίνεται κάθε 4 χρόνια. Αυτό το σώμα είναι ουσιαστικά το Κοινοβούλιο, η εκπροσώπηση του λαού στην κυβέρνηση. Το πρώτο σώμα, που ονομάζεται γερουσία (Eerstekamer), αποτελείται από 75 αντιπροσώπους όλων των κοινοβουλίων των επαρχιών, οι οποίοι εκλέγονται επίσης κάθε 4 χρόνια. Η δουλειά του πρώτου σώματος είναι να παρακολουθεί και να αξιολογεί τους νόμους τους οποίους έχει επεξεργαστεί το δεύτερο σώμα. Οι πιο πρόσφατες εκλογές για το πρώτο σώμα έγιναν στις 15 Μαΐου 2023, και για το δεύτερο σώμα έγιναν στις 22 Νοεμβρίου 2023. Εκλογές[Επεξεργασία | επεξεργασία κώδικα] Κύριο λήμμα: Εκλογές στην Ολλανδία Κοινωνική πολιτική[Επεξεργασία | επεξεργασία κώδικα] Η Ολλανδία φημίζεται για την πολύ ελεύθερη κοινωνική πολιτική που διατηρεί. Υπάρχει πολύ χαλαρή νομική ρύθμιση για τα ναρκωτικά, την πορνεία (οι ιερόδουλες είναι ασφαλισμένες κοινωνικά) και τον γάμο ομοφυλοφίλων, όπου η Ολλανδία ήταν η πρώτη χώρα στον κόσμο όπου έγινε νόμιμος ο γάμος ομοφυλοφίλων, την 1η Απριλίου του 2001. Ωστόσο τα τελευταία χρόνια έχουν ανακύψει ορισμένα προβλήματα στη συμβίωση των μουσουλμάνων με τον υπόλοιπο ολλανδικό πληθυσμό και σημειώθηκαν περιστατικά όπως η δολοφονία το 2004, του σκηνοθέτη Τέο Βαν Γκογκ, που ασκούσε κριτική στο Ισλάμ, από έναν νεαρό Μουσουλμάνο. Παγκοσμίως διάσημος για την ισχυρή πολεμική του ενάντια στο Ισλάμ έχει γίνει ο Ολλανδός πολιτικός Γκερτ Βίλντερς. Επαρχίες[Επεξεργασία | επεξεργασία κώδικα] Κύριο λήμμα: Επαρχίες της Ολλανδίας Η Ολλανδία είναι ένα ενιαίο κράτος με 12 επαρχίες. Σε όλη την ιστορία της χώρας υπήρχαν διοικητικές διαιρέσεις, ως επαρχίες, με τις παλαιότερες να υπάρχουν από το 1579, ενώ η νεότερη είναι το Φλέβολαντ που αναγνωρίστηκε το 1986 ως επαρχία, η οποία δημιουργήθηκε με επέκταση στη θάλασσα (IJsselmeer) κατά τη διάρκεια του 20ού αιώνα. Οι επαρχίες της Ολλανδίας Σημαία Επαρχία Πρωτεύουσα Μεγαλύτερη πόλη Έκταση (τ.χλμ.) Πληθυσμός (2021) Πυκνότητα (ανά τ.χλμ.) Ντρέντε Άσσεν Άσσεν 2.641 494.771 187,3 Φλέβολαντ Λέλυσταντ Αλμέρε 1.417 428.226 302,2 Φρίσλαντ Λέουβαρντεν Λέουβαρντεν 3.341 651.435 195 Χέλντερλαντ Άρνεμ Ναϊμέχεν 4.971 2.096.603 421,8 Χρόνινχεν Χρόνινχεν Χρόνινχεν 2.333 586.937 251,6 Λιμβουργία Μάαστριχτ Μάαστριχτ 2.150 1.115.872 519 Βόρεια Βραβάντη Ντεν Μπος Αϊντχόφεν 4.916 2.573.949 523,6 Βόρεια Ολλανδία Χάαρλεμ Άμστερνταμ 2.671 2.888.486 1.081 Οφεράισσελ Ζβόλε Ενσχέντε 3.325 1.166.533 350,8 Ουτρέχτη Ουτρέχτη Ουτρέχτη 1.385 1.361.153 982,8 Ζηλανδία Μίντελμπουρχ Μίντελμπουρχ 1.787 385.400 215,7 Νότια Ολλανδία Χάγη Ρότερνταμ 2.814 3.726.050 1.324 Οικονομία[Επεξεργασία | επεξεργασία κώδικα] Κύριο λήμμα: Οικονομία της Ολλανδίας Η Ολλανδία διαθέτει ένα καλά οργανωμένο οικονομικό σύστημα. Κυρίαρχη είναι η βιομηχανία τροφίμων, η χημική βιομηχανία και η κατασκευή ηλεκτρικών ειδών. Η σύγχρονη γεωργία είναι επίσης πολύ παραγωγική. Εκτός από δημητριακά, λαχανικά και φρούτα, η ανθοκομία παίζει μεγάλο ρόλο στην οικονομία. Ιδιαίτερα η καλλιέργεια τουλιπών είναι ευρέως διαδεδομένη. Η κτηνοτροφία και κυρίως η γαλακτοκομία χαρίζουν στη χώρα το καλό όνομα για τα περίφημα ολλανδικά τυριά. Παρόλο που η ολλανδική γεωργία απασχολεί μόνο το 4% του συνολικού πληθυσμού, παίζει μεγάλο ρόλο στις εξαγωγές. Η Ολλανδία είναι μετά τις ΗΠΑ και τη Γαλλία ο τρίτος μεγαλύτερος παγκοσμίως εξαγωγέας γεωργικών προϊόντων. Φυσικές πηγές[Επεξεργασία | επεξεργασία κώδικα] Η Ολλανδία διαθέτει πηγές με φυσικό αέριο, ιδιαίτερα στη Βόρεια Θάλασσα, οι οποίες επαρκούν για να καλύψουν ένα μέρος από τις ενεργειακές ανάγκες της χώρας. Στην παγκόσμια κλίμακα, η Ολλανδία βρίσκεται 5η στην παραγωγή φυσικού αερίου. Επιπλέον, στα σύνορα με τη Γερμανία βρίσκονται μικρές πετρελαιοπηγές. Εκτός από την κοπριά, η Ολλανδία δεν διαθέτει άλλες φυσικές πηγές ή ορυκτά. Σημειώσεις[Επεξεργασία | επεξεργασία κώδικα] ↑ Ο ISO ορίζει τις Μποναίρ, Άγιο Ευστάθιο και Σάμπα ως δήμους ISO 3166-1. Παραπομπές[Επεξεργασία | επεξεργασία κώδικα] ↑ 1,0 1,1 1,2 «Population dynamics; month and year». StatLine. 30 Ιουλίου 2024. Ανακτήθηκε στις 31 Ιουλίου 2024. ↑ Στατιστικά στοιχεία του ΟΗΕ ↑ 3,0 3,1 3,2 3,3 «Ολλανδία». ΔΝΤ. Απρίλιος 2017. Ανακτήθηκε στις 9 Μαΐου 2017. ↑ Human Development Report 2021-22: Uncertain Times, Unsettled Lives: Shaping our Future in a Transforming World (PDF). hdr.undp.org. United Nations Development Programme. 8 Σεπτεμβρίου 2022. σελίδες 272–276. ISBN 978-9-211-26451-7. Αρχειοθετήθηκε (PDF) από το πρωτότυπο στις 8 Σεπτεμβρίου 2022. Ανακτήθηκε στις 8 Σεπτεμβρίου 2022. ↑ «Netherlands Guide – Interesting facts about the Netherlands». Eupedia. 19 Απριλίου 1994. Ανακτήθηκε στις 29 Απριλίου 2010. ↑ «Netherlands: Agricultural exports top 80 billion Euros». Αρχειοθετήθηκε από το πρωτότυπο στις 22 Ιανουαρίου 2015. Ανακτήθηκε στις 15 Οκτωβρίου 2016. ↑ (RVO), Netherlands Enterprise Agency. «Agriculture and food». hollandtrade.com. Αρχειοθετήθηκε από το πρωτότυπο στις 1 Ιανουαρίου 2016. Ανακτήθηκε στις 26 Αυγούστου 2016. ↑ \"The Middle Colonies: New York \". Digital History. ↑ Georg Tessin, Verbände und Truppen der deutschen Wehrmacht und Waffen SS 1939-1945, Biblio Verlag, vol. 2 for Nederland, vol. 14 for Landstorm Nederland ↑ Mark Mazower, Η Αυτοκρατορία του Χίτλερ: Ναζιστική Εξουσία στην Κατοχική Ευρώπη, εκδόσεις Αλεξάνδρια, ISBN 978-960-221-466-4, σελ.105 ↑ W. Warmbrunn, The Dutch under German occupation, 1940-1945 (Στάνφορντ, 1963), 27-8 ↑ Antillen opgeheven op 10-10-2010 Αρχειοθετήθηκε 2009-12-24 στο Wayback Machine. ΝΟS news ↑ Het Koninklijk Huis (28 Ιανουαρίου 2013). «Koningin kondigt aftreden aan - Nieuwsbericht - Het Koninklijk Huis». www.koninklijkhuis.nl (στα Ολλανδικά). Ανακτήθηκε στις 23 Σεπτεμβρίου 2024. ↑ Παγκόσμιος Οργανισμός Υγείας, Προσδόκιμο ζωής και υγιές προσδόκιμο ζωής, Δεδομένα ανά χώρα ↑ \"Facts and Statistics\", mormonnewsroom.org ↑ Public Holidays, Επίσημη ιστοσελίδα της Ολλανδίας (Αγγλικά) ↑ Eerstekamer der Staten- General. «[[:Πρότυπο:Taalaan(\"en\")]]English[[:Πρότυπο:Taaluit]]». www.eerstekamer.nl (στα Ολλανδικά). Αρχειοθετήθηκε από το πρωτότυπο στις 23 Σεπτεμβρίου 2024. Ανακτήθηκε στις 23 Σεπτεμβρίου 2024. URL–wikilink conflict (βοήθεια) ↑ The Murder of Theo Van Gogh. Mohammed Bouyeri sentenced, TRUtv Crime Library ↑ (Αγγλικά) «Dutch Politician Plans on Global Spread of Anti-Islam Party[νεκρός σύνδεσμος]» από pattayadailynews.com Αρχειοθετήθηκε 2009-12-30 στο Wayback Machine.. Δημοσιεύθηκε 17 Ιουλ. 2010. Αρχειοθετήθηκε 12 Ιαν. 2013. Ανακτήθηκε 6 Φεβρ. 2018 ↑ «Regionale Kerncijfers Nederland» (στα Ολλανδικά). Statistics Netherlands. 2007. Ανακτήθηκε στις 13 Οκτωβρίου 2007. ↑ «Bevolking per regio naar leeftijd, geslacht en burgerlijke staat» (στα Ολλανδικά). Statistics Netherlands. 2007. Ανακτήθηκε στις 13 Οκτωβρίου 2007. Εξωτερικοί σύνδεσμοι[Επεξεργασία | επεξεργασία κώδικα] Commons logo Τα Wikimedia Commons έχουν πολυμέσα σχετικά με το θέμα Ολλανδία Commons logo Τα Wikimedia Commons έχουν πολυμέσα σχετικά με το θέμα Atlas of the Netherlands(Άτλας της Ολλανδίας) WikiVoyage logo Στο Wikivoyage υπάρχει ταξιδιωτικός οδηγός σχετικός με το λήμμα: Ολλανδία wiktionary logo Το Βικιλεξικό έχει σχετικό λήμμα: Ολλανδία Overheid.nl, επίσημος κόμβος της ολλανδικής κυβέρνησης (Ολλανδικά) Government.nl, επίσημο site της ολλανδικής κυβέρνησης (Αγγλικά) Πληροφορίες για τη διοικητική διαίρεση της χώρας (Αγγλικά) Γενικές πληροφορίες από την ιστοσελίδα της ΕΕ Πληροφορίες χώρας Αρχειοθετήθηκε 2020-05-21 στο Wayback Machine. (The World Factbook) (Αγγλικά) CBS - Στοιχεία της ολλανδικής διεύθυνσης στατιστικών (Αγγλικά) Ολλανδία στο Curlie πσεΧώρες-μέλη του ΝΑΤΟΚράτη Μέλη του NATO, που είναι επίσης και κράτη μέλη και της ΕΕ Βέλγιο Βουλγαρία Γαλλία Γερμανία Δανία Ελλάδα Εσθονία Ισπανία Ιταλία Κροατία Λετονία Λιθουανία Λουξεμβούργο Ολλανδία Ουγγαρία Πολωνία Πορτογαλία Ρουμανία Σλοβακία Σλοβενία Σουηδία Τσεχία Φινλανδία Κράτη Μέλη του ΝΑΤΟ, που είναι επίσης και κράτη μέλη και της ΕΖΕΣ Ισλανδία Νορβηγία Ευρωπαϊκά Κράτη Μέλη μόνο του ΝΑΤΟ Ηνωμένο Βασίλειο Κράτη Μέλη του ΝΑΤΟ εκτός Ευρώπης Ηνωμένες Πολιτείες Καναδάς Ευρωπαϊκά Κράτη Μέλη μόνο του ΝΑΤΟ, που είναι υποψήφια εδώ και πολλά χρόνια και για ένταξη στην ΕΕ Αλβανία Βόρεια Μακεδονία Μαυροβούνιο Τουρκία Υπερπόντια Εδάφη υπό την προστασία άλλων χωρών Γαλλική Γουιάνα Γροιλανδία Νήσοι Φερόες Σε εκκρεμότητα Βοσνία και Ερζεγοβίνη Γεωργία Ουκρανία πσεΧώρες της ΕυρώπηςΚυρίαρχα κράτη Άγιος Μαρίνος Αζερμπαϊτζάν1 Αλβανία Ανδόρρα Αρμενία2 Αυστρία Βατικανό Βέλγιο Βόρεια Μακεδονία Βοσνία και Ερζεγοβίνη Βουλγαρία Γαλλία3 Γερμανία Γεωργία1 Δανία Ελβετία Ελλάδα Εσθονία Ηνωμένο Βασίλειο3 Ιρλανδία Ισλανδία Ισπανία3 Ιταλία Καζακστάν1 Κροατία Κύπρος2 Λετονία Λευκορωσία Λιθουανία Λίχτενσταϊν Λουξεμβούργο Μάλτα Μαυροβούνιο Μολδαβία Μονακό Νορβηγία3 Ολλανδία3 Ουγγαρία Ουκρανία Πολωνία Πορτογαλία Ρουμανία Ρωσία1 Σερβία Σλοβακία Σλοβενία Σουηδία Τουρκία1 Τσεχία Φινλανδία Εξαρτημένα εδάφηΔανίαΝήσοι ΦερόεςΗνωμένο Βασίλειο Ακρωτήρι και Δεκέλεια Γιβραλτάρ Γκέρνσεϊ Νήσος του Μαν Τζέρσεϊ Νορβηγία Σβάλμπαρντ Γιαν Μάγεν Φινλανδία Ώλαντ Αμφισβητούμενα εδάφη Κριμαία Ρόκαλ Μη αναγνωρισμένα κράτη Αμπχαζία Κόσοβο Νότια Οσσετία Τ.Δ.Β.Κ.2 Υπερδνειστερία 1. Διηπειρωτικές χώρες με επικράτεια στην Ευρώπη και στην Ασία. 2. Γεωγραφικά ανήκει στην Ασία, αλλά θεωρείται ευρωπαϊκό κράτος για ιστορικούς και πολιτισμικούς λόγους. 3. Κράτη που περιλαμβάνουν υπερπόντια εδάφη και σε άλλες ηπείρους με τη μητροπολιτική περιοχή να βρίσκεται στην Ευρώπη. πσεΧώρες της Ευρωπαϊκής Ένωσης Μέλη της Ευρωζώνης Αυστρία Βέλγιο Γαλλία Γερμανία Ελλάδα Εσθονία Ιρλανδία Ισπανία Ιταλία Κροατία Κύπρος Λετονία Λιθουανία Λουξεμβούργο Μάλτα Ολλανδία Πορτογαλία Σλοβακία Σλοβενία Φινλανδία Εκτός Ευρωζώνης Βουλγαρία Δανία Ουγγαρία Πολωνία Ρουμανία Σουηδία Τσεχία Πρώην Μέλη της ΕΕ Ηνωμένο Βασίλειο Υπερπόντια Εδάφη μέλη της ΕΕ Άγιος Μαρτίνος Γαλλική Γουιάνα Γουαδελούπη Μαρτινίκα Καθιερωμένοι όροι WorldCat: E39PCjGctfqf4FkcyYvj7tDQFX VIAF: 156652814 LCCN: n78085423 ISNI: 0000 0001 2369 754X GND: 4042203-3 SELIBR: 155069 SUDOC: 026357240 BNF: cb11862083x (data) BIBSYS: 90546878 HDS: 003364 NDL: 00568908 NKC: ge128525 ICCU: CFIV048226 BNE: XX451224 CiNii: DA03480434 KulturNav: id Πύλη:ΓεωγραφίαΠύλη:ΕυρώπηΠύλη:Ευρωπαϊκή Ένωση"
    },
    {
        "id": 12,
        "url": "https://el.wikipedia.org/wiki/%CE%93%CE%BA%CE%AF%CE%BD%CF%84%CE%BF_%CE%B2%CE%B1%CE%BD_%CE%A1%CF%8C%CF%83%CF%83%CE%BF%CF%85%CE%BC",
        "title": "Γκίντο βαν Ρόσσουμ",
        "content": "Γκίντο βαν ΡόσσουμΓενικές πληροφορίεςΌνομα στημητρική γλώσσαGuido van Rossum (Ολλανδικά) Γέννηση31 Ιανουαρίου 1956ΧάαρλεμΚατοικίαBelmontΗνωμένες Πολιτείες ΑμερικήςΧώρα πολιτογράφησηςΒασίλειο των Κάτω ΧωρώνΕκπαίδευση και γλώσσεςΜητρική γλώσσαΟλλανδικάΟμιλούμενες γλώσσεςΟλλανδικάΣπουδέςΠανεπιστήμιο του Άμστερνταμ (έως 1981)Stedelijk Gymnasium HaarlemΠληροφορίες ασχολίαςΙδιότηταεπιστήμονας υπολογιστώνμηχανικόςσυγγραφέαςπρογραμματιστήςΕργοδότηςMicrosoft (από 2020)Αξιοσημείωτο έργοPythonABCΑξιώματα και βραβεύσειςΑξίωμαBenevolent Dictator for Life (έως 2018, Python)ΒραβεύσειςFSF Award for the Advancement of Free Software (16 Φεβρουαρίου 2002)ACM Distinguished Member (2006)Ιστότοποςgvanrossum.github.io Σχετικά πολυμέσαδεδομέναΟ Γκίντο βαν Ρόσσουμ (ολλανδικά: Guido van Rossum, 31 Ιανουαρίου 1956) είναι Ολλανδός προγραμματιστής κυρίως γνωστός ως ο δημιουργός της γλώσσας προγραμματισμού Python. Πρωτοστατούσε στην κοινότητα της Python μέχρι τον Ιούλιο του 2018, οπότε και αποσύρθηκε από την ενεργό δράση. Σήμερα είναι μέλος του Διοικητικού Συμβουλίου της Python. Παραπομπές[Επεξεργασία | επεξεργασία κώδικα] ↑ gayanvoice / top-github-users. ↑ gvanrossum.github.io/Resume.html. ↑ www.gnu.org/award/2001/. ↑ awards.acm.org/distinguished-members/award-winners. Ανακτήθηκε στις 29 Μαΐου 2020. ↑ 5,0 5,1 (Αγγλικά) Guido van Rossum, «Guido van Rossum - Brief Bio». Αρχειοθετήθηκε 2019-05-24. Ανακτήθηκε 2019-09-10. ↑ (Αγγλικά) Carlie Fairchild. «Guido van Rossum Stepping Down from Role as Python's Benevolent Dictator For Life» στο www.linuxjournal.com. Δημοσιεύθηκε 12/07/2018. Αρχειοθετήθηκε 27/03/2019. Ανακτήθηκε 15/04/2019. ↑ (Αγγλικά) «Python boss Guido van Rossum steps down after 30 years» στο www.theinquirer.net. Αρχειοθετήθηκε 19/02//2019. Ανακτήθηκε 15/04/2019. Εξωτερικοί σύνδεσμοι[Επεξεργασία | επεξεργασία κώδικα] Προσωπικός ιστοχώρος του Guido van Rossum Καθιερωμένοι όροι WorldCat: E39PBJqqBkFt4C9YrJyDcJQcyd VIAF: 28799390 LCCN: n96080557 ISNI: 0000 0000 3539 3853 GND: 1067604243 NDL: 01103013 CiNii: DA10288481"
    },
    {
        "id": 13,
        "url": "https://el.wikipedia.org/wiki/%CE%A0%CF%81%CE%BF%CE%B3%CF%81%CE%B1%CE%BC%CE%BC%CE%B1%CF%84%CE%B9%CF%83%CF%84%CE%AE%CF%82",
        "title": "Προγραμματιστής",
        "content": "Δύο προγραμματιστές που εργάζονται σε ένα IBM 704 στην NACA, 1954 Ο προγραμματιστής υπολογιστών, ο οποίος μερικές φορές καλείται τελευταία ως παραγωγός κώδικα (ειδικά σε πιο άτυπα κείμενα), είναι άτομο που δημιουργεί λογισμικό ηλεκτρονικών υπολογιστών. Ο όρος προγραμματιστής ηλεκτρονικών υπολογιστών μπορεί να αναφέρεται σε άτομο ειδικό σε μια κατηγορία υπολογιστών ή σε κάποιον που γράφει γενικά κώδικα για πολλά είδη λογισμικού. Η πιο συνηθισμένη γλώσσα προγραμματισμού των προγραμματιστών (π.χ. Assembly, COBOL, C, C ++, C #, JavaScript, Lisp, Python ) μπορεί να προηγείται στον τίτλο του προγραμματιστή . Μερικοί που εργάζονται με γλώσσες προγραμματισμού ιστού προηγείται η ονομασία αυτή π.χ. web developer. Μια σειρά από επαγγέλματα που απαιτούν προγραμματισμό συχνά απαιτούν επίσης μια σειρά άλλων, παρόμοιων δεξιοτήτων, για παράδειγμα: προγραμματιστής λογισμικού, προγραμματιστής ιστοσελίδων, προγραμματιστής εφαρμογών για κινητά, προγραμματιστής ενσωματωμένου υλικολογισμικού, μηχανικός λογισμικού, επιστήμονας υπολογιστών, προγραμματιστής παιχνιδιών, προγραμματιστής παιχνιδιών και αναλυτής λογισμικού . Η χρήση του όρου προγραμματιστής, όπως εφαρμόζεται σε αυτές τις θέσεις, θεωρείται μερικές φορές ως προσβλητική απλούστευση ή ακόμη και υποτιμητική. Ιστορία[Επεξεργασία | επεξεργασία κώδικα] Η Άντα Λάβλεϊς θεωρείται από πολλούς ως η πρώτη προγραμματίστρια υπολογιστών. Η βρετανίδα κόμισσα και μαθηματικός Άντα Λάβλεϊς θεωρείται συχνά ως η πρώτη προγραμματίστρια υπολογιστών, καθώς ήταν η πρώτη που δημοσίευσε μέρος ενός προγράμματος (συγκεκριμένα ενός αλγορίθμου ) που προοριζόταν για εφαρμογή στην αναλυτική μηχανή του Τσαρλς Μπάμπατζ, τον Οκτώβριο του 1842. Ο αλγόριθμος χρησιμοποιήθηκε για τον υπολογισμό των αριθμών Bernoulli . Επειδή η μηχανή του Μπάμπατζ δεν ολοκληρώθηκε ποτέ ως λειτουργικό πρότυπο στην εποχή της Λάβλεϊς, δυστυχώς δεν είχε ποτέ την ευκαιρία να δει τον αλγόριθμο σε δράση. Ο πρώτος που εκτέλεσε ένα πρόγραμμα σε λειτουργικό, σύγχρονο, ηλεκτρονικό υπολογιστή ήταν ο γνωστός επιστήμονας πληροφορικής Κόνραντ Τσούζε, το 1941. Betty Jennings και Fran Bilas, μέρος της πρώτης ομάδας προγραμματισμού ENIAC Η ομάδα προγραμματισμού ENIAC, αποτελούμενη από τους Kay McNulty, τη Betty Jennings, τη Betty Snyder, τον Marlyn Wescoff, τον Fran Bilas και τον Ruth Lichterman, ήταν οι πρώτοι προγραμματιστές που εργάζονταν τακτικά. Η Διεθνής Ημέρα Προγραμματιστών γιορτάζεται ετησίως στις 7 Ιανουαρίου. Το 2009, η κυβέρνηση της Ρωσίας αποφάσισε μια επαγγελματική ετήσια γιορτή, γνωστή ως Ημέρα Προγραμματιστών, που θα γιορτάσει στις 13 Σεπτεμβρίου (12 Σεπτεμβρίου τα δίσεκτα χρόνια). Ήταν ήδη μια ανεπίσημη γιορτή πριν από αυτό σε πολλές χώρες. Λογισμικό[Επεξεργασία | επεξεργασία κώδικα] Η λέξη λογισμικό χρησιμοποιήθηκε ήδη από το 1953, αλλά δεν εμφανίστηκε τακτικά στις εκδόσεις μέχρι τη δεκαετία του 1960. Πριν από τότε, οι υπολογιστές προγραμματίζονταν είτε από πελάτες είτε από τους λίγους εμπορικούς κατασκευαστές ηλεκτρονικών υπολογιστών της εποχής, όπως η UNIVAC και η IBM . Η πρώτη εταιρεία που ιδρύθηκε με σκοπό την παροχή ειδικών προϊόντων και υπηρεσιών λογισμικού ήταν η Computer Usage Company, το 1955. Η βιομηχανία λογισμικού επεκτάθηκε στις αρχές της δεκαετίας του 1960, σχεδόν αμέσως μετά την πρώτη πώληση των υπολογιστών σε μαζικές παραγόμενες ποσότητες. Τα πανεπιστήμια, οι κυβερνήσεις και οι επιχειρήσεις δημιούργησαν ζήτηση για λογισμικό. Πολλά από αυτά τα προγράμματα γράφτηκαν από τους προγραμματιστές προσωπικού πλήρους απασχόλησης. ορισμένα διανεμήθηκαν ελεύθερα μεταξύ των χρηστών μιας συγκεκριμένης μηχανής χωρίς χρέωση. Και άλλα αναπτύχθηκαν σε εμπορική βάση. Άλλες επιχειρήσεις, όπως η Computer Sciences Corporation (που ιδρύθηκε το 1959), άρχισαν επίσης να αναπτύσσονται. Οι κατασκευαστές υπολογιστών / υλικού σύντομα άρχισαν να συνδυάζουν λειτουργικά συστήματα, λογισμικό συστήματος και περιβάλλοντα προγραμματισμού με τα μηχανήματά τους. Η βιομηχανία επεκτάθηκε σε μεγάλο βαθμό με την άνοδο του προσωπικού υπολογιστή (\"PC\") στα μέσα της δεκαετίας του 1970, η οποία έφερε υπολογιστές στον μέσο εργαζόμενο γραφείου. Στα επόμενα χρόνια, ο υπολογιστής βοήθησε επίσης στη δημιουργία μιας συνεχώς αναπτυσσόμενης αγοράς παιχνιδιών, εφαρμογών και λογισμικού κοινής ωφέλειας. CP / M, αντικαταστάθηκε αργότερα από το DOS, το δημοφιλές λειτουργικό σύστημα των Windows της Microsoft την εποχή εκείνη. Στα πρώτα χρόνια του 21ου αιώνα, δημιουργήθηκε ένα άλλο επιτυχημένο επιχειρηματικό μοντέλο για φιλοξενούμενο λογισμικό, το οποίο ονομάζεται λογισμικό-ως-υπηρεσία, ή SaaS. αυτό ήταν τουλάχιστον για τρίτη φορά το μοντέλο που είχε επιχειρηθεί. Από την άποψη των παραγωγών κάποιου ιδιόκτητου λογισμικού, το SaaS μειώνει τις ανησυχίες για μη εξουσιοδοτημένη αντιγραφή, δεδομένου ότι είναι προσβάσιμο μόνο μέσω του Διαδικτύου και εξ ορισμού δεν φορτώνεται λογισμικό πελάτη στον υπολογιστή του τελικού χρήστη. Μέχρι το 2014, ο ρόλος του προγραμματιστή σε σύννεφο είχε καθοριστεί σε αυτό το πλαίσιο, ένας ορισμός ενός «προγραμματιστή» γενικά δημοσιεύθηκε: Παραπομπές[Επεξεργασία | επεξεργασία κώδικα] ↑ «No Programmers». http://www.ericsink.com/No_Programmers.html. ↑ «Developer versus programmer». Αρχειοθετήθηκε από το πρωτότυπο στις 2010-11-25. https://web.archive.org/web/20101125071809/http://codebetter.com/blogs/raymond.lewallen/archive/2005/02/22/55812.aspx. Ανακτήθηκε στις 2020-02-11. ↑ «Developers AND Programmers». http://weblogs.asp.net/miked/archive/2006/10/13/_2200_Developers_2200_-and-_2200_Programmers_2200_.aspx. ↑ «Programmer vs. Developer vs. Software Engineer». Αρχειοθετήθηκε από το πρωτότυπο στις 10 July 2018. https://web.archive.org/web/20180710101939/http://discuss.joelonsoftware.com/default.asp?joel.3.112837.37#. Ανακτήθηκε στις 21 April 2008. ↑ «Programmer vs. Developer vs. Software Engineer». http://www.xtremevbtalk.com/archive/index.php/t-233780.html. ↑ Fuegi, J.; Francis, J. (2003). «Lovelace & Babbage and the creation of the 1843 'notes'». Annals of the History of Computing 25 (4): 18–26. doi:10.1109/MAHC.2003.1253887. ↑ Fuegi, J.; Francis, J. (October–December 2003). «Lovelace & babbage and the creation of the 1843 'notes'». IEEE Annals of the History of Computing 25 (4): 16–26. doi:10.1109/MAHC.2003.1253887. ↑ «Memorials». Eniacprogrammers.org. Ανακτήθηκε στις 11 Οκτωβρίου 2018. ↑ «ABC News: First Computer Programmers Inspire Documentary». Abcnews.go.com. 4 Δεκεμβρίου 2007. Ανακτήθηκε στις 3 Οκτωβρίου 2010. ↑ «International Programmers' Day». Αρχειοθετήθηκε από το πρωτότυπο στις 3 Ιανουαρίου 2018. Ανακτήθηκε στις 19 Σεπτεμβρίου 2018. ↑ Paul Niquette (1995). «Softword: Provenance for the Word 'Software'». adapted from Sophisticated: The Magazine (ISBN 1-58922-233-4) ↑ Elmer C. Kubie (Summer 1994). «Recollections of the first software company». Annals of the History of Computing 16 (2): 65–71. doi:10.1109/85.279238. ↑ Rebello, Kathy· Schwartz, Evan I.· Verity, John W.· Lewyn, Mark· Levine, Jonathan (28 Φεβρουαρίου 1993). «Is Microsoft Too Powerful?». Businessweek Archives. Bloomberg Businessweek. Ανακτήθηκε στις 26 Σεπτεμβρίου 2014. ↑ Hardiman, Nick (24 July 2014). «A portrait of the modern cloud developer». TechRepublic. http://www.techrepublic.com/article/a-portrait-of-the-modern-cloud-developer/."
    },
    {
        "id": 14,
        "url": "https://el.wikipedia.org/wiki/C%2B%2B",
        "title": "C++",
        "content": "Ο Μπιάρνε Στρούστρουπ, δημιουργός της γλώσσας C++. Η C++ (διαβάζεται: σι πλας πλας [siː plʌs plʌs]) είναι μία γενικού σκοπού γλώσσα προγραμματισμού Η/Υ. Θεωρείται μέσου επιπέδου γλώσσα, καθώς περιλαμβάνει έναν συνδυασμό χαρακτηριστικών από γλώσσες υψηλού και χαμηλού επιπέδου. Είναι μια μεταγλωττιζόμενη γλώσσα πολλαπλών παραδειγμάτων, με τύπους. Υποστηρίζει δομημένο, αντικειμενοστρεφή και γενικό προγραμματισμό. Η γλώσσα αναπτύχθηκε από τον Μπιάρνε Στρούστρουπ το 1979 στα εργαστήρια Bell της AT&T, ως βελτίωση της ήδη υπάρχουσας γλώσσας προγραμματισμού C. Ουσιαστικά ήταν η γλώσσα C εφοδιασμένη με κλάσεις όπως αυτές της Simula και γι' αυτό αρχικά ονομάστηκε \"C with Classes\". Ο Rick Mascitti πρότεινε το όνομα «C++» στα μέσα του 1983 και έκτοτε επικράτησε. Οι βελτιώσεις ξεκίνησαν με την προσθήκη κλάσεων, και ακολούθησαν, μεταξύ άλλων, εικονικές συναρτήσεις, υπερφόρτωση τελεστών, πολλαπλή κληρονομικότητα, πρότυπα κ.α. Η γλώσσα ορίστηκε παγκοσμίως, το 1998, με το πρότυπο ISO/IEC 14882:1998. Η τρέχουσα έκδοση αυτού του προτύπου είναι αυτή του 2020, η ISO/IEC 14882:2020. Μια καινούρια έκδοση είναι υπό ανάπτυξη, γνωστή ανεπίσημα με την ονομασία C++2b. Φιλοσοφία[Επεξεργασία | επεξεργασία κώδικα] Στο βιβλίο The Design and Evolution of C++ (1994), ο Μπιάρνε Στρούστρουπ περιγράφει τα κριτήρια που χρησιμοποιεί για το σχεδιασμό της C++, εξηγώντας πως η C++ είναι σχεδιασμένη: ως μία γενικής χρήσης γλώσσα με στατικούς τύπους, που είναι όσο αποτελεσματική και φορητή, όσο η C ώστε να υποστηρίζει άμεσα και σφαιρικά πολλά είδη προγραμματισμού (δομημένος προγραμματισμός, αντικειμενοστρεφής προγραμματισμός, γενικός προγραμματισμός) ώστε να δίνει επιλογές στον προγραμματιστή, ακόμα κι αν του επιτρέπει να επιλέξει λανθασμένα με σκοπό να είναι όσο το δυνατόν συμβατή με τη C, διευκολύνοντας έτσι τη μετάβαση από τη C στη C++ με σκοπό να αποφεύγει χαρακτηριστικά που αναφέρονται σε συγκεκριμένες πλατφόρμες ή δεν είναι γενικής χρήσης ώστε να μην δημιουργείται επιπλέον επεξεργαστικό κόστος για χαρακτηριστικά της γλώσσας που δεν χρησιμοποιούνται ώστε να λειτουργεί χωρίς κάποιο εξελιγμένο προγραμματιστικό περιβάλλον Το βιβλίο Inside the C++ Object Model (Lippman, 1996) περιγράφει πως οι μεταγλωττιστές μπορούν να μετατρέψουν εντολές ενός προγράμματος C++ σε μια διάταξη στη μνήμη. Παρόλα αυτά, οι συγγραφείς μεταγλωττιστών είναι γενικά ελεύθεροι να υλοποιήσουν το πρότυπο με δικό τους τρόπο. Χαρακτηριστικά[Επεξεργασία | επεξεργασία κώδικα] Η C++ κληρονόμησε το μεγαλύτερο μέρος της σύνταξης της C και τον προεπεξεργαστή της C. Το παρακάτω είναι ένα πρόγραμμα hello world που χρησιμοποιεί την λειτουργία stream της πρότυπης βιβλιοθήκης της C++ για να γράψει ένα μήνυμα στην κύρια έξοδο. Το παρακάτω πρόγραμμα χρησιμοποιεί την βιβλιοθήκη εισόδου/εξόδου iostream #include <iostream> // αρχείο επικεφαλίδας για την βιβλιοθήκη εισόδου/εξόδου iostream (για cout) // std: standard namespace // cout: \"see-output\" int main() { std::cout << \"Hello, world!\\n\"; } Τελεστές και υπερφόρτωση τελεστών[Επεξεργασία | επεξεργασία κώδικα] Η C++ παρέχει περισσότερους από 30 τελεστές, που καλύπτουν τη βασική αριθμητική, το χειρισμό bit, αναφορά δεικτών, συγκρίσεις, λογικές πράξεις κ.ά. Σχεδόν όλοι οι τελεστές μπορούν να υπερφορτωθούν για τύπους ορισμένους από το χρήστη, με λίγες εξαιρέσεις όπως πρόσβαση μέλους (. και .*). Το πλούσιο σύνολο από τελεστές που μπορούν να υπερφορτωθούν είναι βασικό για τη χρήση της C++ ως γλώσσα ειδικού πεδίου (domain specific language). Οι υπερφορτώσιμοι τελεστές είναι ακόμα βασικό μέρος πολλών προχωρημένων τεχνικών προγραμματισμού της C++, όπως οι έξυπνοι δείκτες. Η υπερφόρτωση ενός τελεστή δεν αλλάζει την προτεραιότητα των υπολογισμών όπου χρησιμοποιείται, ούτε τον αριθμό των τελεστέων που χρησιμοποιεί ο τελεστής (αν και οποιοσδήποτε τελεστέος μπορεί απλά να αγνοείται). Παραπομπές[Επεξεργασία | επεξεργασία κώδικα] ↑ 1,0 1,1 1,2 Bjarne Stroustrup, «Η γλώσσα προγραμματισμού C++», σελ. 39, Εκδότης: Κλειδάριθμος, 1999, (ISBN 9603321427 και 9789603321422). Αρχειοθετήθηκε 04/09/2019. Ανακτήθηκε 04/09/2019. Πηγές[Επεξεργασία | επεξεργασία κώδικα] «Η Προέλευση της C++» Αρχειοθετήθηκε 2007-01-08 στο Wayback Machine., Ζαφείρης Φιλίτσας. Ανακτήθηκε στις 2006-08-25. Εξωτερικοί σύνδεσμοι[Επεξεργασία | επεξεργασία κώδικα] Commons logo Τα Wikimedia Commons έχουν πολυμέσα σχετικά με το θέμα C++ The invention of C++ Αρχειοθετήθηκε 2006-08-24 στο Wayback Machine. — Συνέντευξη του Μπιάρνε Στρούστρουπ για τη δημιουργία της γλώσσας. (Αγγλικά) C++ στο Curlie Τα Βικιβιβλία έχουν ένα βιβλίο σχετικά, με τίτλο Εισαγωγή στην C και C++ σε Ολοκληρωμένο Περιβάλλον Δημιουργίας Λογισμικού Βιβλία:Η γλώσσα C++ σε βάθος (Ν. Χατζηγιαννάκης - Εκδόσεις ΚΛΕΙΔΑΡΙΘΜΟΣ) πσεΓλώσσες προγραμματισμού Ada ALGOL APL Applescript Assembly BASIC C C++ C# COBOL Erlang Forth Fortran Go Haskell Java JavaScript Kotlin Lisp Logo Lua ML Objective-C Pascal Perl PHP Prolog Python R Ruby Rust SQL Shell Simula Smalltalk Swift Visual Basic Καθιερωμένοι όροι LCCN: sh87007505 GND: 4193909-8 SUDOC: 029859778 BNF: cb12139768z (data) NKC: ph116956 BNE: XX540250 Πύλη:Προγραμματισμός ↑ [cpp.bytes.gr «Η γλώσσα C++ σε βάθος»] Check |url= value (βοήθεια)."
    },
    {
        "id": 15,
        "url": "https://el.wikipedia.org/wiki/Java",
        "title": "Java",
        "content": "Το λογότυπο της γλώσσας Java. Η Java είναι αντικειμενοστρεφής γλώσσα προγραμματισμού που σχεδιάστηκε από την εταιρεία πληροφορικής Sun Microsystems. Ιστορία[Επεξεργασία | επεξεργασία κώδικα] Στις αρχές του 1991, η Sun αναζητούσε το κατάλληλο εργαλείο για να αποτελέσει την πλατφόρμα ανάπτυξης λογισμικού σε μικρο-συσκευές (έξυπνες οικιακές συσκευές έως πολύπλοκα συστήματα παραγωγής γραφικών). Τα εργαλεία της εποχής ήταν γλώσσες όπως η C++ και η C. Μετά από διάφορους πειραματισμούς προέκυψε το συμπέρασμα ότι οι υπάρχουσες γλώσσες δεν μπορούσαν να καλύψουν τις ανάγκες τους. Ο \"πατέρας\" της Java, James Gosling, που εργαζόταν εκείνη την εποχή για την Sun, έκανε ήδη πειραματισμούς πάνω στη C++ και είχε παρουσιάσει κατά καιρούς κάποιες πειραματικές γλώσσες (C++ ++, που μετέπειτα ονομάστηκε C# ) ως πρότυπα για το νέο εργαλείο που αναζητούσαν στην Sun. Τελικά μετά από λίγο καιρό κατέληξαν με μια πρόταση για το επιτελείο της εταιρίας, η οποία ήταν η γλώσσα Oak. Το όνομά της το πήρε από το ομώνυμο δένδρο (βελανιδιά) το οποίο ο Gosling είχε έξω από το γραφείο του και έβλεπε κάθε μέρα. Από την Oak στη Java[Επεξεργασία | επεξεργασία κώδικα] Η Oak ήταν μία γλώσσα που διατηρούσε μεγάλη συγγένεια με την C++. Παρόλα αυτά είχε πολύ πιο έντονο αντικειμενοστρεφή (object oriented) χαρακτήρα σε σχέση με την C++ και χαρακτηριζόταν για την απλότητα της. Σύντομα η υπεύθυνοι ανάπτυξης της νέας γλώσσας ανακάλυψαν ότι το όνομα Oak ήταν ήδη κατοχυρωμένο οπότε κατά την διάρκεια μιας εκ των πολλών συναντήσεων σε κάποιο τοπικό καφέ αποφάσισαν να μετονομάσουν το νέο τους δημιούργημα σε Java που εκτός των άλλων ήταν το όνομα της αγαπημένης ποικιλίας καφέ για τους δημιουργούς της. Η επίσημη εμφάνιση της Java αλλά και του HotJava (πλοηγός με υποστήριξη Java) στη βιομηχανία της πληροφορικής έγινε το Μάρτιο του 1995 όταν η Sun την ανακοίνωσε στο συνέδριο Sun World 1995. Ο πρώτος μεταγλωττιστής (compiler) της ήταν γραμμένος στη γλώσσα C από τον James Gosling. Το 1994, ο A.Van Hoff ξαναγράφει τον μεταγλωττιστή της γλώσσας σε Java, ενώ το Δεκέμβριο του 1995 πρώτες οι IBM, Borland, Mitsubishi Electronics, Sybase και Symantec ανακοινώνουν σχέδια να χρησιμοοιήσουν τη Java για την δημιουργία λογισμικού. Από εκεί και πέρα η Java ακολουθεί μία ανοδική πορεία και είναι πλέον μία από τις πιο δημοφιλείς γλώσσες στον χώρο της πληροφορικής. Στις 13 Νοεμβρίου του 2006 η Java έγινε πλέον μια γλώσσα ανοιχτού κώδικα (GPL) όσον αφορά το μεταγλωττιστή (javac) και το πακέτο ανάπτυξης (JDK, Java Development Kit). Η εξαγορά από την Oracle και το μέλλον της Java[Επεξεργασία | επεξεργασία κώδικα] Στις 27 Απριλίου 2010 η εταιρία λογισμικού Oracle Corporation ανακοίνωσε ότι μετά από πολύμηνες συζητήσεις ήρθε σε συμφωνία για την εξαγορά της Sun Microsystems και των τεχνολογιών (πνευματικά δικαιώματα/ πατέντες) που η δεύτερη είχε στην κατοχή της ή δημιουργήσει. Η συγκεκριμένη συμφωνία θεωρείται σημαντική για το μέλλον της Java και του γενικότερου οικοσυστήματος τεχνολογιών γύρω από αυτή μιας και ο έμμεσος έλεγχος της τεχνολογίας και η εξέλιξη της περνάει σε άλλα χέρια. Εκδόσεις[Επεξεργασία | επεξεργασία κώδικα] Σήμερα οι υποστηριζόμενες εκδόσεις είναι οι Java 8 και 9. Οι σημαντικότερες που έχουν κυκλοφορήσει, με τις αντίστοιχες ημερομηνίες κυκλοφορίας, είναι οι εξής : JDK 1.0 (23 Ιανουαρίου 1996) JDK 1.1 (19 Φεβρουαρίου 1997) J2SE 1.2 (8 Δεκεμβρίου 1998) J2SE 1.3 (8 Μαΐου 2000) J2SE 1.4 (6 Φεβρουαρίου 2002) J2SE 5.0 (30 Σεπτεμβρίου 2004) Java SE 6 (11 Δεκεμβρίου 2006) Java SE 7 (28 Ιουλίου 2011) Java SE 8 (18 Μαρτίου 2014) Java SE 9 (21 Σεπτεμβρίου 2017) Java SE 10 (20 Μαρτίου 2018) Java SE 11 (LTS*) (25 Σεπτεμβρίου 2018) Java SE 12 (Μάρτιος 2019) Java SE 13 (Σεπτέμβριος 2019) Java SE 14 (Μάρτιος 2020) Java SE 15 (Σεπτέμβριος 2020) Java SE 16 (Μάρτιος 2021) Java SE 17 (LTS*) (Σεπτέμβριος 2021) LTS = Long-Term Support. Είναι η έκδοση η οποία προορίζεται να παραμείνει στάνταρντ για τα επόμενα χρόνια. Τα χαρακτηριστικά της Java[Επεξεργασία | επεξεργασία κώδικα] Ένα από τα βασικά πλεονεκτήματα της Java έναντι των περισσότερων άλλων γλωσσών είναι η ανεξαρτησία του λειτουργικού συστήματος και πλατφόρμας. Τα προγράμματα που είναι γραμμένα σε Java εκτελούνται ακριβώς το ίδιο σε Windows, Linux, Unix και Macintosh (σύντομα θα τρέχουν και σε Playstation καθώς και σε άλλες κονσόλες παιχνιδιών) χωρίς να χρειαστεί να ξαναγίνει μεταγλώττιση (compiling) ή να αλλάξει ο πηγαίος κώδικας για κάθε διαφορετικό λειτουργικό σύστημα. Για να επιτευχθεί όμως αυτό χρειαζόταν κάποιος τρόπος έτσι ώστε τα προγράμματα γραμμένα σε Java να μπορούν να είναι «κατανοητά» από κάθε υπολογιστή ανεξάρτητα του είδους επεξεργαστή (Intel x86, IBM, Sun SPARC, Motorola) αλλά και λειτουργικού συστήματος (Windows, Unix, Linux, BSD, Mac OS). Ο λόγος είναι ότι κάθε κεντρική μονάδα επεξεργασίας κατανοεί διαφορετικό κώδικα μηχανής. Ο συμβολικός κώδικας (assembly) που μεταφράζεται και εκτελείται σε Windows είναι διαφορετικός από αυτόν που μεταφράζεται και εκτελείται σε έναν υπολογιστή Macintosh. Η λύση δόθηκε με την ανάπτυξη της Εικονικής Μηχανής (Virtual Machine ή VM ή ΕΜ στα ελληνικά). Η εικονική μηχανή της Java[Επεξεργασία | επεξεργασία κώδικα] Αφού γραφεί κάποιο πρόγραμμα σε Java, στη συνέχεια μεταγλωττίζεται μέσω του μεταγλωττιστή javac, ο οποίος παράγει έναν αριθμό από αρχεία .class (κώδικας byte ή bytecode). Ο κώδικας byte είναι η μορφή που παίρνει ο πηγαίος κώδικας της Java όταν μεταγλωττιστεί. Όταν πρόκειται να εκτελεστεί η εφαρμογή σε ένα μηχάνημα, το Java Virtual Machine που πρέπει να είναι εγκατεστημένο σε αυτό θα αναλάβει να διαβάσει τα αρχεία .class. Στη συνέχεια τα μεταφράζει σε γλώσσα μηχανής που να υποστηρίζεται από το λειτουργικό σύστημα και τον επεξεργαστή, έτσι ώστε να εκτελεστεί. Αυτό συμβαίνει με την παραδοσιακή Εικονική Μηχανή (Virtual Machine). Πιο σύγχρονες εφαρμογές της εικονικής Μηχανής μπορούν και μεταγλωττίζουν εκ των προτέρων τμήματα bytecode απευθείας σε κώδικα μηχανής (εγγενή κώδικα ή native code) με αποτέλεσμα να βελτιώνεται η ταχύτητα. Χωρίς αυτό δε θα ήταν δυνατή η εκτέλεση λογισμικού γραμμένου σε Java. Η JVM είναι λογισμικό που εξαρτάται από την πλατφόρμα, δηλαδή για κάθε είδος λειτουργικού συστήματος και αρχιτεκτονικής επεξεργαστή υπάρχει διαφορετική έκδοση του. Έτσι υπάρχουν διαφορετικές JVM για Windows, Linux, Unix, Macintosh, κινητά τηλέφωνα, παιχνιδομηχανές κλπ. Οτιδήποτε θέλει να κάνει ο προγραμματιστής (ή ο χρήστης) γίνεται μέσω της εικονικής μηχανής. Αυτό βοηθάει στο να υπάρχει μεγαλύτερη ασφάλεια στο σύστημα γιατί η εικονική μηχανή είναι υπεύθυνη για την επικοινωνία χρήστη - υπολογιστή. Ο προγραμματιστής δεν μπορεί να γράψει κώδικα ο οποίος θα έχει καταστροφικά αποτελέσματα για τον υπολογιστή γιατί η εικονική μηχανή θα τον ανιχνεύσει και δε θα επιτρέψει να εκτελεστεί. Από την άλλη μεριά ούτε ο χρήστης μπορεί να κατεβάσει «κακό» κώδικα από το δίκτυο και να τον εκτελέσει. Αυτό είναι ιδιαίτερα χρήσιμο για μεγάλα κατανεμημένα συστήματα όπου πολλοί χρήστες χρησιμοποιούν το ίδιο πρόγραμμα συγχρόνως. Ο συλλέκτης απορριμμάτων (Garbage Collector)[Επεξεργασία | επεξεργασία κώδικα] Ακόμα μία ιδέα που βρίσκεται πίσω από τη Java είναι η ύπαρξη του συλλέκτη απορριμμάτων (Garbage Collector). Συλλογή απορριμμάτων είναι μία κοινή ονομασία που χρησιμοποιείται στον τομέα της πληροφορικής για να δηλώσει την ελευθέρωση τμημάτων μνήμης από δεδομένα που δε χρειάζονται και δε χρησιμοποιούνται άλλο. Αυτή η απελευθέρωση μνήμης στη Java είναι αυτόματη και γίνεται μέσω του συλλέκτη απορριμμάτων. Υπεύθυνη για αυτό είναι και πάλι η εικονική μηχανή η οποία μόλις «καταλάβει» ότι ο σωρός (heap) της μνήμης (στη Java η συντριπτική πλειοψηφία των αντικειμένων αποθηκεύονται στο σωρό σε αντίθεση με τη C++ όπου αποθηκεύονται κυρίως στη στοίβα) κοντεύει να γεμίσει ενεργοποιεί το συλλέκτη απορριμμάτων. Έτσι ο προγραμματιστής δε χρειάζεται να ανησυχεί για το πότε και αν θα ελευθερώσει ένα συγκεκριμένο τμήμα της μνήμης, ούτε και για σφάλματα δεικτών. Αυτό είναι ιδιαίτερα σημαντικό γιατί είναι κοινά τα σφάλματα προγραμμάτων που οφείλονται σε λανθασμένο χειρισμό της μνήμης. Η προεπιλεγμένη μέθοδος για συλλογή απορριμμάτων μοιράζει το σωρό σε δύο κομμάτια. Το πρώτο, χρησιμοποιείται για νέα αντικείμενα και λέγεται μαιευτήριο. Αφού επιβιώσουν ένα προεπιλεγμένο αριθμό εκκαθαρίσεων στο μαιευτήριο, ώριμα αντικείμενα μεταφέρονται στο δεύτερο κομμάτι του σωρού. Το μαιευτήριο είναι μοιρασμένο σε δύο κομμάτια, τον από-χωρο και τον προς-χωρο. Νέα αντικείμενα τοποθετούνται αρχικά στον από-χωρο. Όταν αυτός γεμίσει, ζωντανά αντικείμενα αντιγράφονται στον προς-χωρο και οι δύο χώροι ανταλλάσσουν ρόλο. Επιδόσεις[Επεξεργασία | επεξεργασία κώδικα] Παρόλο που η εικονική μηχανή προσφέρει όλα αυτά (και όχι μόνο) τα πλεονεκτήματα, η Java αρχικά ήταν πιο αργή σε σχέση με άλλες προγραμματιστικές γλώσσες υψηλού επιπέδου (high-level) όπως η C++. Εμπειρικές μετρήσεις στο παρελθόν είχαν δείξει ότι η C++ μπορούσε να είναι αρκετές φορές γρηγορότερη από την Java. Ωστόσο γίνονται προσπάθειες από τη Oracle για τη βελτιστοποίηση της εικονικής μηχανής, ενώ υπάρχουν και άλλες υλοποιήσεις της εικονικής μηχανής από διάφορες εταιρίες (όπως της IBM), οι οποίες μπορεί σε κάποια σημεία να προσφέρουν καλύτερα και σε κάποια άλλα χειρότερα αποτελέσματα. Επιπλέον με την καθιέρωση των μεταγλωττιστών JIT (Just In Time), οι οποίοι μετατρέπουν τον κώδικα byte απευθείας σε γλώσσα μηχανής, η διαφορά ταχύτητας από τη C++ έχει μικρύνει κατά πολύ. Οι τελευταίες εκδόσεις του javac με τη χρήση της τεχνολογίας Hot Spot έχουν καταφέρει αξιόλογες επιδόσεις που πλησιάζουν ή και ξεπερνούν σε μερικές περιπτώσεις τον εγγενή κώδικα. Κώδικας[Επεξεργασία | επεξεργασία κώδικα] Ως αντικειμενοστρεφής γλώσσα, η Java βασίζεται σε κλάσεις και αντικείμενα. Μια κλάση (class) είναι μια φόρμα για τη δημιουργία αντικειμένων (objects ή instances). Αφού πρώτα δημιουργηθεί μια κλάση, στη συνέχεια μπορεί να χρησιμοποιηθεί για την παραγωγή αντικειμένων. Παρομοιάζοντας, θα μπορούσαμε να πούμε ότι η κλάση αποτελεί μια \"συνταγή\" για τη δημιουργία αντικειμένων. Μια κλάση περιγράφει μια οντότητα, για παράδειγμα η κλάση Student μπορεί να περιγράψει ένα φοιτητή, η κλάση Employee έναν εργαζόμενο, η κλάση Car ένα αυτοκίνητο κ.λπ. Μια κλάση περιλαμβάνει α) πεδία (fields) και β) μεθόδους (methods). Τα πεδία αντιστοιχούν σε ιδιότητες των αντικειμένων της κλάσης ενώ οι μέθοδοι επιτελούν λειτουργίες στα αντικείμενα της κλάσης. Κάθε μέλος μίας κλάσης, είτε πεδίο είτε μέθοδος, πρoσδιορίζεται από έναν προσδιοριστή προσπέλασης (access modifier). Υπάρχουν τέσσερεις προσδιοριστές προσπέλασης: private, package-private (με κενό μετρατροπέα), protect και public. Τα private μέλη είναι ορατά μόνο από την ίδια κλάση, τα package-private είναι ορατά από κλάσεις του ίδιου πακέτου, τα protected από κλάσεις του ίδιου πακέτου και από κλάσεις εκτός πακέτου που επεκτείνουν (extends) αυτήν την κλάση, είναι δηλαδή υποκλάσεις της. Τα public μέλη είναι ορατά από όλες τις κλάσεις της εφαρμογής. Έστω, για παράδειγμα, ότι θέλουμε να δημιουργήσουμε μια κλάση η οποία να παριστά την οντότητα \"φοιτητής\" (Student) . Κάθε φοιτητής θα προσδιορίζεται από δύο πεδία, το πεδίο code (κωδικός) και το πεδίο name (όνομα). Επιπλέον, η κλάση θα περιέχει μεθόδους για ανάγνωση και τροποποίηση των πεδίων code και name καθώς και μεθόδους για κατασκευή νέου αντικειμένου Student (κατασκευαστές). Ο κώδικας που ακολουθεί δημιουργεί την κλάση Student και περιέχει: α) Δύο πεδία, το αριθμητικό (int) πεδίο code και το αλφαριθμητικό (String). name β) Δύο κατασκευαστές, έναν χωρίς παραμέτρους και έναν με παραμέτρους τις code και name. γ) Δύο μεθόδους λήψης της τιμής των πεδίων (getters), τις getCode() και getName. δ) Δύο μεθόδους εκχώρησης τιμής (setters) στα πεδία code και name, τις setCode() και setName(). public class Student{ private int code; private String name; //Kατασκευαστής της κλάσης χωρίς παραμέτρους public Student(){ code = 0; name = \"\"; } //Kατασκευαστής της κλάσης με παραμέτρους public Student(int code, String name){ this.code = code; this.name = name; } //Η μέθοδος επιστρέφει τον κωδικό public int getCode(){ return code; } //Η μέθοδος επιστρέφει το όνομα public String getName(){ return name; } //Η μέθοδος θέτει κωδικό σε ένα αντικείμενο public void setCode(int code){ this.code = code; } //Η μέθοδος θέτει όνομα σε ένα αντικείμενο public void setName(String name){ this.name = name; } } Εργαλεία ανάπτυξης[Επεξεργασία | επεξεργασία κώδικα] Όλα τα εργαλεία που χρειάζεται κάποιος για να γράψει Java προγράμματα έρχονται δωρεάν, από το περιβάλλον ανάπτυξης μέχρι εργαλεία build όπως το Apache Ant και βιβλιοθήκες, ενώ υπάρχουν πολλές διαφορετικές υλοποιήσεις της Εικονικής Μηχανής και του μεταγλωττιστή (π.χ. the GNU Compiler for Java) της Java. Πολλά εργαλεία και τεχνολογίες σε Java μπορούν να βρεθούν στο Apache Software Foundation αλλά και στο Jakarta Project. Ολοκληρωμένο περιβάλλον ανάπτυξης (IDE)[Επεξεργασία | επεξεργασία κώδικα] Για να να γράψει κάποιος κώδικα Java δε χρειάζεται τίποτα άλλο παρά έναν επεξεργαστή κειμένου, όπως το Σημειωματάριο (Notepad) των Windows ή ο vi (γνωστός στο χώρο του Unix). Παρόλ' αυτά, ένα ολοκληρωμένο περιβάλλον ανάπτυξης (IDE) βοηθάει πολύ, ιδιαίτερα στον εντοπισμό σφαλμάτων (debugging). Υπάρχουν αρκετά διαθέσιμα IDEs, ενώ πολλά από αυτά παρέχονται δωρεάν. Τα πιο γνωστά Ολοκληρωμένα Περιβάλλοντα Ανάπτυξης είναι το NetBeans της Apache, το Eclipse και το IntelliJ Idea της JetBrains. Δείτε επίσης[Επεξεργασία | επεξεργασία κώδικα] JAR Java Platform, Enterprise Edition Παραπομπές[Επεξεργασία | επεξεργασία κώδικα] ↑ (Αγγλικά) «JAVASOFT SHIPS JAVA 1.0». Ιστορική ανακοίνωση, που δημοσιεύθηκε στις 23/1/1996. ↑ Deitel, Paul· Deitel, Harvey (2015). Java Προγραμματισμός (Ελληνική Μετάφραση) (10η έκδοση). Αθήνα: Μ. Γκιούρδας. σελ. 19. ISBN 978-960-512-681-0. ↑ (Αγγλικά) «The Java® Virtual Machine Specification, SE 7 Edition» από docs.oracle.com. Ανακτήθηκε 27/1/2018. ↑ 4,0 4,1 Horstmann C. 2015, βλ. πηγές σελ. 5-6, 7 Πηγές[Επεξεργασία | επεξεργασία κώδικα] Cay S. Horstmann «Core Java, Volume I - Fundamentals» Tenth Edition, December 2015. Daniel Y. Liang \"Introduction to JAVA programming and data structures\" Twelfth Edition, 2020 Εξωτερικοί σύνδεσμοι[Επεξεργασία | επεξεργασία κώδικα] Wikibooks logo Τα αγγλικά Βικιβιβλία έχουν βιβλία που έχουν σχέση με τη: Java Commons logo Τα Wikimedia Commons έχουν πολυμέσα σχετικά με το θέμα Java Java Tutorial ((Linux)), ((Windows)) Community ((Linux)), ((Windows)) Java στο Curlie IDE[Επεξεργασία | επεξεργασία κώδικα] NetBeans ((Linux)), ((Windows)) Eclipse ((Linux)), ((Windows)) jΕdit ((Linux)), ((Windows)) JCreator Αρχειοθετήθηκε 2009-02-28 στο Wayback Machine. ((Windows)) JΒuilder IntelliJ IDEA Ομάδες χρηστών Java (User Groups)[Επεξεργασία | επεξεργασία κώδικα] jugs κοινότητα jhug (ελληνική ομάδα χρηστών Java) bejug (βελγική ομάδα χρηστών Java) jugmilano (μιλανέζικη ομάδα χρηστών Java) egjug (αιγυπτιακή ομάδα χρηστών Java) πσεΓλώσσες προγραμματισμού Ada ALGOL APL Applescript Assembly BASIC C C++ C# COBOL Erlang Forth Fortran Go Haskell Java JavaScript Kotlin Lisp Logo Lua ML Objective-C Pascal Perl PHP Prolog Python R Ruby Rust SQL Shell Simula Smalltalk Swift Visual Basic πσεΕλεύθερο λογισμικό και λογισμικό ανοικτού κώδικαΓενικάCopyleft · Γεγονότα και βραβεία · Ελεύθερο λογισμικό · Ορισμός του Ελεύθερου Λογισμικού · Δωρεάν και ελεύθερο · Κατάλογος ελεύθερου λογισμικού και λογισμικού ανοιχτού κώδικα · Λογισμικό ανοικτού κώδικαΛειτουργικά συστήματαAROS · BSD · Darwin · eCos · FreeDOS · GNU · Haiku · Inferno · Linux · Mach · MINIX · OpenSolaris · Plan 9 · ReactOS · SymbianΑνάπτυξη λογισμικούEclipse · Free Pascal · GCC · Gambas · Java · LLVM · Lua · NetBeans · Open64 · Perl · PHP · Python · ROSE · Ruby · TclΙστορίαGNU ·Haiku ·Linux · Mozilla (Application Suite · Firefox · Thunderbird)ΟργανισμοίApache Software Foundation · Ίδρυμα Blender · Eclipse Foundation · freedesktop.org · Ίδρυμα Ελεύθερου Λογισμικού (Ευρώπη · India ·Latin America) · FSMI ·GNOME Foundation · GNU Project · Google Code ·KDE e.V. · Linux Foundation · Mozilla Foundation · Open Source Geospatial Foundation · Open Source Initiative · Python Software Foundation - Software Freedom Conservancy · SourceForge · Symbian Foundation · The Document Foundation · Xiph.Org Foundation · XMPP Standards Foundation · X.Org FoundationΆδειες ελεύθερου λογισμικούApache · Artistic · BSD · GNU GPL · GNU LGPL · ISC · MIT · MPL · Ms-PL/RL · zlib · FSF approved licensesΠρότυπα αδειών λογισμικούΟρισμός του Λογισμικού Ανοιχτού Κώδικα · Ορισμός του Ελεύθερου Λογισμικού · Debian Free Software GuidelinesΣημαντικά θέματαBinary blob · Canonical's contributor agreement · Digital rights management · Συμβατότητα καρτών γραφικών · License proliferation · Mozilla software rebranding · Proprietary software · Διαμάχη SCO-Linux · Ασφάλεια · Πατέντες λογισμικού · Περιορισμοί υλικού · Trusted Computing · Viral licenseΆλλα θέματαΕναλλακτικοί όροι · Κοινότητα · Διανομή Linux · Forking · Κίνημα · Microsoft Open Specification Promise · Revolution OS · Σύγκριση με λογισμικό κλειστού κώδικα Καθιερωμένοι όροι LCCN: sh95008574 GND: 4401313-9 BNF: cb12533207m (data) NKC: ph117027 BNE: XX540033 Πύλη:Προγραμματισμός"
    },
    {
        "id": 16,
        "url": "https://el.wikipedia.org/wiki/C_(%CE%B3%CE%BB%CF%8E%CF%83%CF%83%CE%B1_%CF%80%CF%81%CE%BF%CE%B3%CF%81%CE%B1%CE%BC%CE%BC%CE%B1%CF%84%CE%B9%CF%83%CE%BC%CE%BF%CF%8D)",
        "title": "C (γλώσσα προγραμματισμού)",
        "content": "Η C είναι διαδικαστική γλώσσα προγραμματισμού γενικής χρήσης, η οποία αναπτύχθηκε αρχικά, μεταξύ του 1969 και του 1973, από τον Ντένις Ρίτσι στα εργαστήρια AT&T Bell Labs για να χρησιμοποιηθεί για την ανάπτυξη του λειτουργικού συστήματος UNIX. Όπως οι περισσότερες διαδικαστικές γλώσσες προγραμματισμού που ακολουθούν την παράδοση της ALGOL, η C έχει δυνατότητες δομημένου προγραμματισμού και επιτρέπει τη χρήση αναδρομής (αλλά όχι και εμφωλευμένων συναρτήσεων), ενώ, ο στατικός ορισμός του τύπου των μεταβλητών που επιβάλλει, προλαμβάνει πολλά σφάλματα κατά την χρήση τους. Ο σχεδιασμός της περιλαμβάνει δομές που μεταφράζονται αποδοτικά σε τυπικές εντολές μηχανής (machine instructions) και εξ αιτίας αυτού χρησιμοποιείται συχνά σε εφαρμογές που παλιότερα γράφονταν σε συμβολική γλώσσα (assembly language). Αυτό ακριβώς το χαρακτηριστικό της, που έχει σαν συνέπεια και την αυξημένη ταχύτητα εκτέλεσης των εφαρμογών που γράφονται σε αυτή, καθώς και το γεγονός ότι είναι διαθέσιμη στα περισσότερα σημερινά λειτουργικά συστήματα, συνέβαλε κατά πολύ στην καθιέρωση της και την χρήση της για ανάπτυξη λειτουργικών συστημάτων και λοιπών προγραμμάτων συστήματος (system software), αλλά και απλών εφαρμογών. Η C συγκαταλέγεται πλέον στις πιο ευρέως χρησιμοποιούμενες γλώσσες προγραμματισμού όλων των εποχών και πολλές νεώτερες γλώσσες έχουν επηρεαστεί άμεσα ή έμμεσα από αυτήν, συμπεριλαμβανομένων των C++, C#, D, Go, Java, JavaScript, Limbo, LPC, Perl, PHP, Python, καθώς και του κελύφους C (C shell) του Unix. Κάποιες από αυτές τις γλώσσες έχουν επηρεαστεί κυρίως στη σύνταξη τους, με το σύστημα τύπων, τα μοντέλα δεδομένων και το νόημα των εκφράσεων τους να διαφέρουν σημαντικά από την C. Η C++, ειδικά, ξεκίνησε σαν προεπεξεργαστής της C, αλλά έχει εξελιχθεί πλέον σε μια αντικειμενοστραφή γλώσσα, που αποτελεί υπερσύνολο της C. Φιλοσοφία[Επεξεργασία | επεξεργασία κώδικα] Η C είναι μια σχετικά μινιμαλιστική γλώσσα προγραμματισμού. Ανάμεσα στους σχεδιαστικούς στόχους που έπρεπε να καλύψει η γλώσσα περιλαμβανόταν το ότι θα μπορούσε να μεταγλωττιστεί άμεσα με τη χρήση μεταγλωττιστή ενός περάσματος (single-pass compiler) — με άλλα λόγια, ότι θα απαιτούνταν μόνο ένας μικρός αριθμός από εντολές σε γλώσσα μηχανής για κάθε βασικό στοιχείο της, χωρίς εκτεταμένη υποστήριξη στον χρόνο εκτέλεσης. Ως αποτέλεσμα, είναι δυνατό να γραφτεί κώδικας σε C σε χαμηλό επίπεδο προγραμματισμού με ακρίβεια ανάλογη της συμβολικής γλώσσας, στην πραγματικότητα η C ορισμένες φορές αποκαλείται (και χωρίς να υπάρχει πάντα αντιπαράθεση) «συμβολική γλώσσα υψηλού επιπέδου» («high-level assembly») ή «φορητή συμβολική γλώσσα» («portable assembly»). Επίσης, γίνονται αναφορές στη C ως γλώσσα προγραμματισμού μεσαίου επιπέδου. Χαρακτηριστικά[Επεξεργασία | επεξεργασία κώδικα] Στη C δεν επιβάλλεται κάποια συγκεκριμένη μορφή στον πηγαίο κώδικα (όπως, για παράδειγμα, συνέβαινε στις αρχικές εκδόσεις της Fortran). Ο προγραμματιστής, χωρίς να αγνοεί φυσικά το συντακτικό της γλώσσας, είναι ελεύθερος να δώσει όποια μορφή θέλει στον κώδικα που γράφει (free-format source). Το ελληνικό ερωτηματικό (;) (σύμβολο U+003B, όχι U+037E) χρησιμοποιείται ως τερματιστής εντολών (και όχι ως διαχωριστής, όπως στην Pascal, παραδείγματος χάριν) και τα άγκιστρα ({}) χρησιμοποιούνται για την ομαδοποίηση εντολών (όπως τα begin/end στην Pascal). Ακόμα, στη C όλος ο εκτελέσιμος κώδικας περιέχεται σε υπορουτίνες οι οποίες ονομάζονται «συναρτήσεις» (όχι με την αυστηρή έννοια του συναρτησιακού προγραμματισμού). Οι παράμετροι περνιούνται στις συναρτήσεις πάντα με τιμή (pass-by-value). Το πέρασμα με αναφορά (pass-by-reference) γίνεται έμμεσα στην ουσία, περνώντας, ως παραμέτρους των συναρτήσεων, δείκτες στις μεταβλητές των οποίων θέλουμε να αλλάζουμε τις τιμές μέσα από τις συναρτήσεις. Η C έχει ακόμα τα εξής χαρακτηριστικά: Έχει ένα πολύ μικρό σταθερό πλήθος λέξεων-κλειδιών (keywords), το οποίο περιλαμβάνει ένα πλήρες σύνολο δομών/εντολών ελέγχου ροής: for, if/else, while, switch, και do/while, goto. Υπάρχει μόνο ένας χώρος ονομάτων (namespace) και τα ονόματα (μεταβλητών, συναρτήσεων, κ.τ.λ.) που ορίζονται από το χρήστη δεν διακρίνονται με κάποιο τρόπο από τις λέξεις-κλειδιά της γλώσσας. Υπάρχει ένα μεγάλο πλήθος αριθμητικών, σχεσιακών και λογικών τελεστών, όπως οι: +, +=, ++, -, -=, --, *, *=, /, /=, ==, >,>=, <, <=, !=, &, &&, |, ||, ~, κ.ά. Σε μία εντολή μπορεί να γίνουν παραπάνω από μια εκχωρήσεις τιμών. Η τιμή που επιστρέφει μια συνάρτηση, μπορεί να αγνοηθεί εάν δεν χρειάζεται. Ο ορισμός των τύπων των μεταβλητών είναι στατικός και απαραίτητος, αλλά γίνονται έμμεσες μετατροπές από τη γλώσσα. Για παράδειγμα, παραστάσεις με τύπο χαρακτήρα μπορούν να χρησιμοποιηθούν σε σημεία που απαιτείται ακέραιος. Η σύνταξη των δηλώσεων ονομάτων προσομοιάζει την χρήση αυτών μέσα στον εκτελέσιμο κώδικα. Η C δεν έχει ειδική λέξη-κλειδί για τον ορισμό ονομάτων (όπως είναι η \"var\" στην Pascal, για παράδειγμα) ή συναρτήσεων (όπως η \"function\", πάλι στην Pascal). Μια γραμμή που ξεκινάει με το όνομα ενός τύπου, εκλαμβάνεται σαν ορισμός μεταβλητής ή συνάρτησης, ανάλογα με τον αν υπάρχουν, ή όχι, παρενθέσεις που περικλείουν (τυπικές) παραμέτρους συνάρτησης. Ο χρήστης μπορεί να ορίσει δικούς του τύπους (και σύνθετους), εάν το επιθυμεί. Μπορεί επίσης να ορίσει και τύπους εγγραφών (structs στη C, records σε άλλες γλώσσες). Μπορούν να οριστούν πίνακες, αν και δεν υπάρχει ειδική λέξη-κλειδί για τον ορισμό τους (όπως το \"array\" στην Pascal). Η δεικτοδότηση τους γίνεται με χρήση αγκυλών ([]), αν και πολύ συχνά γίνεται χρήση αριθμητικής δεικτών. Το πρώτο στοιχείο κάθε πίνακα δεικτοδοτείται πάντα από το μηδέν (0). Π.χ.: Το στοιχείο month είναι το πρώτο στοιχείο του πίνακα month. Τέλος, δεν υπάρχουν τελεστές για την σύγκριση ή εκχώρηση πινάκων. Είναι δυνατή η δημιουργία απαριθμήσιμων τύπων με τη χρήση της λέξης-κλειδί \"enum\", οι οποίοι μπορούν να χρησιμοποιηθούν όπου οι ακέραιοι και αντίστροφα. Δεν υπάρχει ιδιαίτερος τύπος για αλφαριθμητικά, τα οποία παραδοσιακά υλοποιούνται και αντιμετωπίζονται σαν πίνακες από χαρακτήρες, και έχουν έναν μηδενικό χαρακτήρα να σημαδεύει το τέλος τους (null-terminated arrays of characters). Είναι δυνατή η άμεση προσπέλαση χαμηλού επιπέδου στη μνήμη του υπολογιστή με τη χρήση δεικτών. Οι υπορουτίνες που δεν επιστρέφουν τιμή (\"procedures\" σε άλλες γλώσσες) είναι συναρτήσεις που ορίζονται να είναι τύπου \"void\" (ψευδοτύπος που δείχνει την απουσία επιστρεφόμενης τιμής, αλλά χρησιμοποιείται και για δείκτες που δεν δείχνουν σε αντικείμενο συγκεκριμένου τύπου). Δεν μπορούν να οριστούν συναρτήσεις μέσα σε άλλες συναρτήσεις (εμφωλιασμένες). Οι δείκτες σε συναρτήσεις και δεδομένα επιτρέπουν την υλοποίηση πολυμορφισμού στην πράξη. Ο προεπεξεργαστής της γλώσσας επιτρέπει τον ορισμό μακροεντολών, την συγχώνευση αρχείων πηγαίου κώδικα, καθώς και την μεταγλώττιση υπό συνθήκες. Αρχεία πηγαίου κώδικα μπορούν να μεταγλωττιστούν χωριστά και να συνδεθούν μαζί, ενώ υπάρχει η δυνατότητα ελέγχου της ορατότητας συναρτήσεων και μεταβλητών στα αλλα αρχεία (πέρα από αυτό στο οποίο ορίζονται) με το χαρακτηρισμό τους ως \"static\" ή \"extern\". Οι πολύπλοκες λειτουργίες, όπως οι λειτουργίες εισόδου/εξόδου, ο χειρισμός των αλφαριθμητικών, καθώς και οι μαθηματικές συναρτήσεις, έχουν ανατεθεί, με συνεπή τρόπο, στις αντίστοιχες βιβλιοθήκες. Η C δεν διαθέτει κάποιες από τις δυνατότητες νεώτερων γλωσσών, όπως τον προσανατολισμό στα αντικείμενα και την συλλογή απορριμάτων (garbage collection). Ιστορία[Επεξεργασία | επεξεργασία κώδικα] Πρώιμη ανάπτυξη[Επεξεργασία | επεξεργασία κώδικα] Σε πρώτη φάση,η C αναπτύχθηκε στα AT&T Bell Labs ανάμεσα στο 1969 και το 1973, σύμφωνα με τον D. Ritchie, η πιο δημιουργική περίοδος υπήρξε το 1972. Η νέα γλώσσα ονομάστηκε \"C\" λόγω του ότι πολλά από τα χαρακτηριστικά της προήλθαν από μια παλαιότερη γλώσσα, η οποία ονομαζόταν \"B\". Οι πηγές δεν επιτρέπουν την πλήρη εξακρίβωση για την προέλευση του ονόματος \"B\" : ο Ken Thompson το παρουσιάζει ως απλούστευση μιας έκδοσης της γλώσσας προγραμματισμού BCPL, αλλά είχε επίσης δημιουργήσει μία γλώσσα που ονομαζόταν Bon προς τιμήν της συζύγου του Bonnie. Μέχρι το 1973, η C είχε γίνει αρκετά ισχυρή και αποτελεσματική, ώστε το μεγαλύτερο μέρος του πυρήνα του UNIX (UNIX kernel), γραμμένο αρχικά σε PDP-11/20 assembly, επανεγγράφηκε σε C. Ήταν ένας από τους πρώτους πυρήνες που υλοποιήθηκε σε μια γλώσσα διαφορετική της assembly. (Προηγούμενα παραδείγματα περιλαμβάνουν το Multics system (γραμμένο σε PL/I), και το MCP (Master Control Program) για το Burroughs B5000 γραμμένο σε ALGOL το 1961.) K&R C[Επεξεργασία | επεξεργασία κώδικα] Το 1978, ο Dennis Ritchie και ο Brian Kernighan δημοσίευσαν την πρώτη έκδοση του βιβλίου \"The C Programming Language\". Το συγκεκριμένο βιβλίο, γνωστό στους προγραμματιστές της C ως \"K&R\", χρησίμευσε πολλά χρόνια σαν ανεπίσημος ορισμός της γλώσσας. Η έκδοση της C που περιγράφει αναφέρεται συνήθως ως \"K&R C.\" ή \"Common C\". (Η δεύτερη έκδοση του βιβλίου καλύπτει το μεταγενέστερο πρότυπο ANSI για τη C (ANSI C standard), βλ. συνέχεια.) Το K&R εισήγαγε τα παρακάτω χαρακτηριστικά στη γλώσσα: Τύποι δεδομένων: ενώσεις (union), τύποι ακεραίων (long int, unsigned int) Ο τελεστής (operator) =+ αλλάχθηκε σε += για να αποφευχθούν σημασιολογικά διφορούμενες εκφράσεις όπως η i=+10, που μπορούσε να ερμηνευθεί είτε σαν i =+ 10 είτε σαν i = +10. Η K&R C συχνά λογίζεται ως το βασικό μέρος της γλώσσας που πρέπει να υποστηρίζει ένας μεταγλωττιστής της C. Για αρκετά χρόνια, ακόμη και μετά την εισαγωγή της ANSI C, θεωρούνταν ο \"ελάχιστος συνήθης παρονομαστής\" στον οποίο έπρεπε να προσαρμοστούν οι προγραμματιστές της C σε περιπτώσεις κατά τις οποίες ήταν επιθυμητή η μέγιστη μεταφερσιμότητα (portability), καθώς δεν είχαν ενημερωθεί όλοι οι μεταγλωττιστές για πλήρη υποστήριξη της ANSI C. Επίσης, με προσοχή, ο κώδικας σε K&R C μπορούσε να γραφεί ώστε να είναι σύμφωνος και με το πρότυπο ANSI. ANSI C[Επεξεργασία | επεξεργασία κώδικα] Το 1983, το American National Standards Institute (ANSI) όρισε επιτροπή, τη X3J11, για να δώσει ένα σύγχρονο, πλήρη ορισμό της C. Μετά από μακρά και επίπονη επεξεργασία, το πρότυπο (standard) ολοκληρώθηκε το 1989 και επικυρώθηκε ως ANSI X3.159-1989 \"Programming Language C\". Η συγκεκριμένη έκδοση της γλώσσας ονομάζεται συχνά ANSI C ή, ορισμένες φορές, C89 (για να διαχωρίζεται από τη C99). Το 1990, το πρότυπο ANSI για τη C (με ορισμένες μικρές τροποποιήσεις) υιοθετήθηκε από τον Οργανισμό Διεθνών Προτύπων (International Organization for Standardization (ISO)) ως ISO/IEC 9899:1990. Αυτή η έκδοση καλείται C90. Επομένως, οι όροι \"C89\" και \"C90\" αναφέρονται ουσιαστικά στην ίδια γλώσσα. Ένας από τους στόχους της διαδικασίας δημιουργίας του προτύπου ANSI για τη C ήταν να δημιουργήσει ένα υπερσύνολο της K&R C, το οποίο θα απορροφούσε πολλά χαρακτηριστικά που είχαν εισαχθεί στην πορεία. Παρόλα αυτά, η επιτροπή συμπεριέλαβε και ορισμένα νέα χαρακτηριστικά, όπως function prototypes (δανεισμένα από τη C++), και ένα πιο ικανό προεπεξεργαστή (preprocessor). Η σύνταξη για τους ορισμούς παραμέτρων άλλαξε επίσης, ώστε να αντικατοπτρίζει το στυλ της C++. C99[Επεξεργασία | επεξεργασία κώδικα] Μετά τη διαδικασία καθορισμού του προτύπου ANSI, ο ορισμός της γλώσσας C παρέμενε σχετικά σταθερός για ορισμένο καιρό, ενώ η C++ συνέχιζε να αναπτύσσεται. (Normative Amendment 1 δημιούργησε μία νέα έκδοση της γλώσσας C το 1995, αλλά σπάνια είναι γνωστή.) Ωστόσο, το πρότυπο επανεξετάστηκε προς το τέλος της δεκαετίας του '90, γεγονός που οδήγησε στην έκδοση του ISO 9899:1999 το 1999. Το πρότυπο αυτό συχνά αναφέρεται ως \"C99\". Υιοθετήθηκε ως πρότυπο ANSI το Μάρτιο του 2000. Ο GCC και μερικοί άλλοι C compilers υποστηρίζουν πλέον τα περισσότερα χαρακτηριστικά του C99. Ωστόσο, υπάρχει μικρότερη υποστήριξη από εταιρίες όπως η Microsoft και η Borland που εστίασαν περισσότερο στη C++, καθώς η C++ παρέχει παρόμοια λειτουργικότητα και συχνά ασύμβατους τρόπους (π.χ., η complex template class). Ο Brandon Bray από τη Microsoft είπε \"Σε γενικές γραμμές, έχουμε δει μικρές απαιτήσεις για πολλά χαρακτηριστικά του C99. Μερικά χαρακτηριστικά έχουν μεγαλύτερη ζήτηση από άλλα, και θα τη λάβουμε υπόψιν μας σε μελλοντικές εκδόσεις εφόσον είναι συμβατά με τη C++.\" Ακόμη και ο GCC με την εκτεταμένη υποστήριξη του C99 ακόμη δεν προσεγγίζει μια πλήρως συμβατή υλοποίηση, ορισμένα χαρακτηριστικά-κλειδιά λείπουν ή δεν λειτουργούν σωστά. C11[Επεξεργασία | επεξεργασία κώδικα] Το 2007 άρχισαν οι εργασίες για μια ακόμα αναθεώρηση του προτύπου της C, ανεπίσημα αποκαλούμενο \"C1X\" ως και την επίσημη δημοσίευση του στις 8/12/2011. Η επιτροπή προτύπων της C έθεσε ως κατευθυντήριες γραμμές τον περιορισμό υιοθεσίας νέων χαρακτηριστικών τα οποία δεν έχουν δοκιμαστεί απο υπάρχουσες υλοποιήσεις. Το πρότυπο C11 προσθέτει πολυάριθμα χαρακτηριστικά στην C και στην βιβλιοθήκη συμπεριλαμβομένων type generic macros, anonymoys structures, βελτιωμένη υποστήριξη Unicode, atomic operations, multi-threading και συναρτήσεις bounds-checked. Επίσης κάνεις κάποιες προαιρετικές αναθεωρήσεις στην βιβλιοθήκη του C99 και βελτιώνει την συμβατότητα με την C++. Η πρότυπη μάκρο __STDC_VERSION__ προσδιορίζεται ως 201112L για να δηλώσει οτί η υποστήριξη για το C11 είναι διαθέσιμη. C18[Επεξεργασία | επεξεργασία κώδικα] Δημοσιευμένο το Ιούνιο του 2018, το C18 είναι το τρέχον πρότυπο για τη γλώσσα προγραμματισμού C. Δεν εισάγει νέα χαρακτηριστικά στη γλώσσα αλλά μόνο τεχνικές διορθώσεις και διευκρινίσεις σε ατέλειες του προτύπου C11. Η πρότυπη μάκρο __STDC_VERSION__ προσδιορίζεται ως 201710L. C23[Επεξεργασία | επεξεργασία κώδικα] C23 είναι το ανεπίσημο όνομα του επόμενου προτύπου που θα διαδεχθεί το C17. Αναμένεται να εκδοθεί μέσα στο 2024. Παράδειγμα \"Hello world\"[Επεξεργασία | επεξεργασία κώδικα] Πρόγραμμα σε C που εκτυπώνει στο τερματικό \"Hello world!\": #include <stdio.h> int main() { printf( \"Hello world!\" ); return 0; } Αναφορές[Επεξεργασία | επεξεργασία κώδικα] ↑ ↑ http://gcc.gnu.org/c99status.html ↑ https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3132.pdf Δείτε επίσης[Επεξεργασία | επεξεργασία κώδικα] C πρότυπη βιβλιοθήκη C++ C είσοδος/έξοδος αρχείων Βιβλία[Επεξεργασία | επεξεργασία κώδικα] Brian W. Kernighan, Dennis M. Ritchie. \"Η Γλώσσα Προγραμματισμού C\", Prentice-Hall (Ελληνική μετάφραση, εκδόσεις Κλειδάριθμος), 1988. Νίκος Μ. Χατζηγιαννάκης. \"Η γλώσσα C σε βάθος\", Εκδόσεις Κλειδάριθμος (Ελληνικά) http://c.bytes.gr Κωνσταντίνος Φ. Γραίκας. \"Γραμματική και Συντακτικό της ANSI C\". Εκδόσεις Κλειδάριθμος 2007, σελ. 296. Δημήτριος Καρολίδης. \"Μαθαίνετε εύκολα C\", Εκδόσεις Άβακας, 2013. Γεώργιος Σ. Τσελίκης, Νικόλαος Δ. Τσελίκας \"C: Από τη Θεωρία στην Εφαρμογή\"], Δ' Έκδοση, 2023, σελ. 888, ISBN 978-618-86762-0-6. www.c4all.gr/ Θεόδωρος Αλεβίζος. \"Προγραμματισμός με τη γλώσσα C++\", 2015 (Διαθέσιμο δωρεάν) Πάρις Μαστοροκώστας. \"Διαδικαστικός προγραμματισμός – Η γλώσσα C\", 2015. (Διαθέσιμο δωρεάν) Εξωτερικοί σύνδεσμοι[Επεξεργασία | επεξεργασία κώδικα] Commons logo Τα Wikimedia Commons έχουν πολυμέσα σχετικά με το θέμα C (γλώσσα προγραμματισμού) Wikiversity logo Στo Βικιεπιστήμιο υπάρχει ή αναπτύσσεται εκπαιδευτικό υλικό για αυτό το θέμα: C (γλώσσα προγραμματισμού) Τα Βικιβιβλία έχουν ένα βιβλίο σχετικά, με τίτλο Εισαγωγή στην C και C++ σε Ολοκληρωμένο Περιβάλλον Δημιουργίας Λογισμικού C programming — Εγχειρίδιο της C για αρχάριους (Αγγλικά) Programming in C : A tutorial — Εγχειρίδιο της C από τον Brian Kernighan (σε pdf) (Αγγλικά) Από τη B στη C (Αγγλικά) - Το άρθρο της αγγλικής Wikipedia για τη C. (Αγγλικά) C (γλώσσα προγραμματισμού) στο Curlie πσεΓλώσσες προγραμματισμού Ada ALGOL APL Applescript Assembly BASIC C C++ C# COBOL Erlang Forth Fortran Go Haskell Java JavaScript Kotlin Lisp Logo Lua ML Objective-C Pascal Perl PHP Prolog Python R Ruby Rust SQL Shell Simula Smalltalk Swift Visual Basic Καθιερωμένοι όροι LCCN: sh85018532 GND: 4113195-2 SUDOC: 027672441 BNF: cb119665180 (data) NKC: ph116955 Πύλη:Προγραμματισμός Αυτό το λήμμα σχετικά με την Πληροφορική χρειάζεται επέκταση. Μπορείτε να βοηθήσετε την Βικιπαίδεια επεκτείνοντάς το. ' '"
    },
    {
        "id": 17,
        "url": "https://el.wikipedia.org/wiki/%CE%9B%CE%B5%CE%B9%CF%84%CE%BF%CF%85%CF%81%CE%B3%CE%B9%CE%BA%CF%8C_%CF%83%CF%8D%CF%83%CF%84%CE%B7%CE%BC%CE%B1",
        "title": "Λειτουργικό σύστημα",
        "content": "Τυπική θέση του λειτουργικού συστήματος σε ένα υπολογιστικό σύστημα Λειτουργικό σύστημα (αγγλικά: Operating System ή OS) ονομάζεται στην επιστήμη της πληροφορικής το λογισμικό του υπολογιστή που είναι υπεύθυνο για τη διαχείριση και τον συντονισμό των εργασιών, καθώς και την κατανομή των διαθέσιμων πόρων . Το λειτουργικό σύστημα παρέχει ένα θεμέλιο, ένα μεσολαβητικό επίπεδο λογικής διασύνδεσης μεταξύ λογισμικού και υλικού, διαμέσου του οποίου οι εφαρμογές αντιλαμβάνονται εμμέσως τον υπολογιστή. Μια από τις κεντρικές αρμοδιότητες του λειτουργικού συστήματος είναι η διαχείριση του υλικού, απαλλάσσοντας έτσι το λογισμικό του χρήστη από τον άμεσο και επίπονο χειρισμό του υπολογιστή και καθιστώντας ευκολότερο τον προγραμματισμό τους. Σχεδόν όλοι οι υπολογιστές (παλάμης, επιτραπέζιοι, υπερυπολογιστές, ακόμη και παιχνιδομηχανές) χρησιμοποιούν έναν τύπο λειτουργικού συστήματος. Ορισμένα παλαιότερα μοντέλα ωστόσο βασίζονται σε ένα ενσωματωμένο λειτουργικό σύστημα, το οποίο περιέχεται σε έναν οπτικό δίσκο ή άλλες συσκευές αποθήκευσης δεδομένων. Ως λειτουργικό σύστημα (ΛΣ) χαρακτηρίζεται μία συλλογή βασικών προγραμμάτων , η οποία ελέγχει τη λειτουργία του υπολογιστή συνολικά και χρησιμοποιείται ως υπόβαθρο για την εκτέλεση όλων των υπόλοιπων προγραμμάτων, τη διαχείριση των περιφερειακών συσκευών και την εξασφάλιση της επικοινωνίας μεταξύ χρήστη και υπολογιστή. Στην πράξη πρόκειται για ένα επίπεδο λογισμικού που μεσολαβεί μεταξύ του υλικού και των εκτελούμενων προγραμμάτων σε έναν ηλεκτρονικό υπολογιστή. Αποτελείται από ένα σύνολο μηχανισμών μέσω των οποίων επιτυγχάνεται αυτόματη διαχείριση των πόρων ενός υπολογιστή και ελεγχόμενη κατανομή τους στις εκτελούμενες εφαρμογές, έτσι ώστε οι τελευταίες να είναι σε θέση να προσπελάσουν εύκολα τους πόρους και τις συσκευές του συστήματος χωρίς να χρειάζεται να γνωρίζουν με ακρίβεια τη δομή του υποκείμενου υλικού, αλλά και ώστε πολλαπλές εφαρμογές να μπορούν να εκτελούνται ταυτόχρονα χωρίς να έρχονται σε διένεξη μεταξύ τους ή με τον υπολογιστή. Οι πρώιμοι υπολογιστές στερούνταν λειτουργικού συστήματος. Ένας άνθρωπος 'χειριστής' (operator) φόρτωνε τα προγράμματα στη μνήμη του υπολογιστή και φρόντιζε για την εκτέλεσή τους, εξ ου και το όνομα του λογισμικού συστήματος το οποίο αντικατέστησε τις ανθρώπινες αυτές ενέργειες (Operating System). Με το μεσολαβητικό επίπεδο διασύνδεσης που προσφέρει το ΛΣ, οι εφαρμογές μπορούν να αξιοποιούν εύκολα τη μνήμη, τον επεξεργαστή, το σύστημα αρχείων και τις περιφερειακές συσκευές. Δηλαδή το ΛΣ δημιουργεί ένα απλουστευμένο εικονικό περιβάλλον μέσα στο οποίο εκτελούνται οι εφαρμογές. Οι τελευταίες, μέσα από κάποια συγκεκριμένη και τυποποιημένη προγραμματιστική διασύνδεση που τους προσφέρει το ΛΣ, τις κλήσεις συστήματος, διαμορφώνουν αυστηρά συμμορφούμενα με αυτήν τη διασύνδεση αιτήματα για να αποκτήσουν πόρους, προκειμένου να φέρουν εις πέρας τις εργασίες που ζητά ο χρήστης. Στα PC το ΛΣ είναι το πρώτο λογισμικό που «φορτώνεται» στη μνήμη του υπολογιστή μετά την εκτέλεση του BIOS. Οποιοδήποτε λογισμικό φορτωθεί στη συνέχεια βασίζεται στο ΛΣ για την παροχή όλων των υπηρεσιών οι οποίες απαιτούν πρόσβαση στο υλικό. Υπηρεσίες[Επεξεργασία | επεξεργασία κώδικα] Το λειτουργικό σύστημα περιέχει κώδικα χαμηλού επιπέδου, αποκλειστικά για την αρχιτεκτονική του επεξεργαστή στην οποία εκτελείται (γραμμένο είτε σε κάποια κατάλληλη γλώσσα προγραμματισμού υψηλού επιπέδου, όπως η C, είτε απευθείας σε συμβολική γλώσσα), ο οποίος αναλαμβάνει την υλοποίηση όλων αυτών των μηχανισμών. Ο εν λόγω κώδικας, ο οποίος κατά την κανονική λειτουργία του υπολογιστή είναι αποθηκευμένος στη μνήμη, ονομάζεται «πυρήνας» και ο κώδικας των εκτελούμενων εφαρμογών («κώδικας χρήστη») δεν έχει άμεση πρόσβαση σε αυτόν. Ο πυρήνας όμως παρέχει μία προγραμματιστική διασύνδεση, τις κλήσεις συστήματος που προαναφέρθηκαν, με την οποία τα προγράμματα χρήστη μπορούν να καλούν με ελεγχόμενο τρόπο διαδικασίες που εξάγει ο πυρήνας και παρέχουν υπηρεσίες στον καλούντα. Η σύνταξη, η σημασιολογία και η ονοματολογία των κλήσεων συστήματος διαφέρει από ΛΣ σε ΛΣ, με αποτέλεσμα ένα εκτελέσιμο πρόγραμμα συνήθως να μπορεί να τρέξει μόνο σε Ο κώδικας χρήστη δεν μπορεί να προσπελάσει μόνος του τους πόρους του υπολογιστή (π.χ. δίσκους, μνήμη συστήματος, περιφερειακά, δίκτυο κλπ) αλλά μπορεί να ζητήσει ό,τι χρειάζεται (π.χ. άνοιγμα ενός αρχείου στον δίσκο) από τον πυρήνα μέσω των κλήσεων συστήματος. Οι βασικοί μηχανισμοί ενός λειτουργικού συστήματος αφορούν τη διαχείριση της εκτέλεσης των προγραμμάτων χρήστη (μέσω του μηχανισμού των διεργασιών και - στα συστήματα τα οποία υποστηρίζουν ταυτοχρονισμό / πολυδιεργασία / πολυπρογραμματισμό - του κατάλληλου χρονοπρογραμματισμού τους), της επικοινωνίας μεταξύ τους (μέσω των μηχανισμών εικονικής μνήμης και διαδιεργασιακής επικοινωνίας) και των δεδομένων που αυτές χρησιμοποιούν (μέσω του συστήματος αρχείων). Με τον τρόπο που είναι υλοποιημένοι οι εν λόγω μηχανισμοί διασφαλίζουν συνήθως τόσο την ασφάλεια του πυρήνα απέναντι στον κώδικα χρήστη, όσο και την ασφάλεια μεταξύ των προγραμμάτων χρήστη, ώστε κανένα να μην παρεμποδίζει ή να επηρεάζει αρνητικά την πρόσβαση των άλλων στους πόρους του συστήματος. Διαχείριση διεργασιών[Επεξεργασία | επεξεργασία κώδικα] Ένα πρόγραμμα που εκτελείται στον υπολογιστή συνιστά μία ή περισσότερες διεργασίες. Πρόκειται για το βασικό μέσο εκτέλεσης προγραμμάτων σε ένα συνηθισμένο ΛΣ. Ο ίδιος κώδικας / πρόγραμμα μπορεί να εκτελείται ταυτόχρονα μέσα από πολλές διαφορετικές διεργασίες οι οποίες μπορεί να ανήκουν σε διαφορετικούς χρήστες. Στα πλαίσια της σειριακής αρχιτεκτονικής φον Νόιμαν και των υπολογιστών που έχουν οικοδομηθεί με βάση αυτήν, μόνο μια διεργασία μπορεί να εκτελείται στην ΚΜΕ (Κεντρική Μονάδα Επεξεργασίας) οποιαδήποτε χρονική στιγμή· επομένως οι ποικίλες διεργασίες οι οποίες είναι ταυτόχρονα ενεργές εκτελούνται ψευδοπαράλληλα, με διαδοχική εναλλαγή του επεξεργαστή μεταξύ τους κάθε λίγη ώρα. Σε ένα παράλληλο σύστημα, όπου υπάρχουν πολλαπλοί επεξεργαστές, ο ταυτοχρονισμός / πολυδιεργασία μπορούν να υλοποιηθούν πραγματικά παράλληλα. Σε κάθε περίπτωση, το τμήμα του πυρήνα το οποίο λαμβάνει διάφορες αποφάσεις σχετικά με την ανάθεση των ΚΜΕ στις διάφορες διεργασίες ονομάζεται χρονοπρογραμματιστής. Διαχείριση μνήμης[Επεξεργασία | επεξεργασία κώδικα] Στις σύγχρονες αρχιτεκτονικές υπολογιστών η μνήμη είναι οργανωμένη ιεραρχικά. Αρχίζοντας από την ταχύτερη: καταχωρητές, κρυφή μνήμη, κύρια μνήμη και δευτερεύουσα μνήμη (π. χ. σκληροί δίσκοι). Το τμήμα εκείνο του ΛΣ που καλείται διαχειριστής μνήμης συντονίζει τη χρήση των διαφόρων τύπων μνήμης, καταγράφοντας ποια τμήματά τους είναι διαθέσιμα, ποια είναι δεσμευμένα και, αναλόγως με τις απαιτήσεις των διεργασιών, εκχωρεί ή απελευθερώνει τμήματα για να τα χρησιμοποιήσουν οι τελευταίες. Αυτή η δραστηριότητα λέγεται διαχείριση εικονικής μνήμης, αφού η συνολική μνήμη που είναι σε θέση να αξιοποιήσουν οι διεργασίες κατά την εκτέλεσή τους μπορεί να υπερβαίνει το μέγεθος της κύριας μνήμης (της φυσικής μνήμης RAM), μέσω της δέσμευσης ενός τμήματος του σκληρού δίσκου από τον πυρήνα το οποίο χρησιμοποιείται από τον τελευταίο σαν επέκταση της κύριας μνήμης. Τα προηγμένα Λ.Σ. αποφεύγουν, όπου και όταν είναι δυνατό, τη χρήση αυτής της τεχνικής, επειδή η χρήση δευτερεύουσας μνήμης ως κύριας μειώνει την ταχύτητα του συστήματος. Συστήματα αρχείων[Επεξεργασία | επεξεργασία κώδικα] Το τμήμα του ΛΣ που ονομάζεται διαχειριστής συστήματος αρχείων δημιουργεί την αφαιρετική έννοια των αρχείων και των δένδρων καταλόγων. Έτσι ο χρήστης και οι εφαρμογές του έχουν τη δυνατότητα να βλέπουν τη δευτερεύουσα μνήμη σαν ένα σύνολο από αρχεία, τα οποία μπορούν να δημιουργούν, να τροποποιούν, να διαγράφουν, να μετακινούν και να αντιγράφουν. Δικτύωση[Επεξεργασία | επεξεργασία κώδικα] Τα περισσότερα σύγχρονα λειτουργικά συστήματα επιτρέπουν τη σύνδεση ενός υπολογιστή τόσο σε τοπικά δίκτυα όσο και στο Διαδίκτυο, ενσωματώνοντας στον κωδικά τους την υλοποίηση των απαιτούμενων αντίστοιχων πρωτοκόλλων. Εσωτερική ασφάλεια[Επεξεργασία | επεξεργασία κώδικα] Με τον όρο αυτό, γνωστό και ως προστασία μνήμης, εννοούνται οι ενέργειες στις οποίες προβαίνει το ΛΣ προκειμένου να προφυλάξει τους πόρους μιας διεργασίας από τις παρεμβάσεις άλλων διεργασιών που τυχαίνει να εκτελούνται (ψευδο)παράλληλα. Το σκεπτικό είναι πως, δεν πρέπει μια διεργασία ενός χρήστη (σε περίπτωση πολυχρηστικού διακομιστή που εξυπηρετεί πολλαπλούς πελάτες) ταυτόχρονα μέσω δικτύου, να έχει αποκλειστική πρόσβαση σε ολόκληρο το σύστημα αρχείων, ούτε μια διεργασία να εγγράφει δεδομένα στο τμήμα εκείνο της μνήμης που έχει εκχωρηθεί σε άλλη διεργασία. Εξωτερική ασφάλεια[Επεξεργασία | επεξεργασία κώδικα] Σαν κόμβος ενός δικτύου ένας υπολογιστής μπορεί να δεχτεί επιθέσεις από κακόβουλο λογισμικό. Τα σύγχρονα ΛΣ περιλαμβάνουν και τμήματα που είναι υπεύθυνα να αναγνωρίσουν τέτοιες απειλές. Το λειτουργικό σύστημα ενός υπολογιστικού συστήματος, το οποίο υποστηρίζει πολλούς διαφορετικούς χρήστες, εκτελεί ένα ευρύ φάσμα εφαρμογών και είναι συνδεδεμένο στο δίκτυο. Το γεγονός αυτό αυξάνει τις απαιτήσεις ασφάλειας των αντικειμένων του, επειδή συντρέχει κίνδυνος απώλειας, καταστροφής, διαγραφής, τροποποίησης ή διάδοσης τους, χωρίς την απαιτούμενη δικαιοδοσία. Ενδεικτικές ευπάθειες και απειλές αποτελούν η απώλεια συνθηματικών, η μη εξουσιοδοτημένη εκτέλεση λογισμικού με στόχο την σπατάλη των διαθέσιμων πόρων, καθώς και κακόβουλο λογισμικό ή ενέργειες. Οι συνηθέστεροι μηχανισμοί οι οποίοι εν μέρει προσφέρουν ασφάλεια σε ένα λειτουργικό σύστημα είναι, οι βιομετρικοί μέθοδοι, αγνωστικά πρωτόκολλα, μηχανισμοί δημοσίου κλειδιού και σύνθετα συνθηματικά. Ενώ, οι συνηθέστερες τεχνικές οι οποίες υιοθετούνται για την προστασία και την ακεραιότητα των λειτουργικών συστημάτων είναι, οι μέθοδοι φραγμών, μέθοδοι καταχωρητών, σύνολα ελέγχου και συνόψεις αρχείων, μηχανισμοί ανοχής σφαλμάτων, αναχώματα ασφαλείας (Firewalls) και σύστημα ανίχνευσης εισβολών(Intrusion Detection System). Από την άλλη πλευρά, το «content spoofing» ή διαφορετικά η αλλοίωση περιεχομένου, χαρακτηρίζει την τεχνική της επίθεσης η οποία επιτρέπει σε έναν εισβολέα να εισφέρει κακόβουλο ωφέλιμο φορτίο το οποίο παραποιείται αργότερα, ως νόμιμο περιεχόμενο ενός ιστού (Web). Το γεγονός αυτό ενδέχεται να εκδηλωθεί σε πολλές διαφορετικές μορφές και συμπεριλαμβάνεται στη λίστα των πιο συχνών επιθέσεων. Παράλληλα, σε πολλές περιπτώσεις ο εισβολέας αποκτά πρόσβαση σε μία υπάρχουσα ιστοσελίδα (website), παραποιώντας τον πηγαίο κώδικα των προγραμμάτων αλλοιώνοντας το περιεχόμενο του ιστού. Γραφική διασύνδεση χρήστη[Επεξεργασία | επεξεργασία κώδικα] Η εξωτερική απεικόνιση (συνήθως στην οθόνη) του λειτουργικού συστήματος, ώστε ο χρήστης να μπορεί να αλληλεπιδράσει με αυτό και να διαχειριστεί τα προγράμματα και τις εργασίες του, δεν ταυτίζεται με το ίδιο το ΛΣ. Στην πραγματικότητα το κέλυφος (αγγλ: shell, εναλλακτικά στα ελληνικά είναι γνωστό και ως φλοιός), όπως λέγεται το εν λόγω τμήμα του ΛΣ το οποίο παρέχει μία οπτική και αλληλεπιδραστική διασύνδεση προς τους χρήστες, είναι απολύτως δευτερεύον σε σχέση με τον πυρήνα και τους μηχανισμούς του, παρόλο που πρόκειται για το μόνο συστατικό ενός λειτουργικού συστήματος το οποίο είναι άμεσα ορατό από έναν απλό χρήστη. Υπάρχουν δύο βασικοί τύποι κελύφους: οι γραμμές εντολών, όπου οι χρήστες απλώς πληκτρολογούν εντολές για να διαχειριστούν τα αρχεία και τα προγράμματά τους, και οι γραφικές διασυνδέσεις χρήστη (GUI), όπου οι χρήστες χειρίζονται ένα γραφικό περιβάλλον στηριζόμενο στο ποντίκι και σε οπτικές μεταφορές (εικονίδια, παράθυρα κλπ). Τα σύγχρονα ΛΣ παρέχουν τη δυνατότητα στον χρήστη να επικοινωνεί γραφικά με τον Η/Υ μέσω ποντικιού, παραθύρων, εικονιδίων, δείκτη ποντικιού, γραμμές εργασιών κλπ. Οδηγοί συσκευών[Επεξεργασία | επεξεργασία κώδικα] Ένα λειτουργικό σύστημα περιλαμβάνει και πολλούς οδηγούς συσκευών (drivers). Συνοπτικά, ένας οδηγός συσκευής είναι το λογισμικό συστήματος που χρησιμοποιεί το ΛΣ και οι διεργασίες των χρηστών κάθε φορά που πρέπει να ανταλλάξουν δεδομένα με τη συγκεκριμένη συσκευή. Συνήθως οι οδηγοί συσκευών περιλαμβάνονται στο λογισμικό που συνοδεύει την περιφερειακή συσκευή κατά την αγορά της. Ωστόσο τα περισσότερα ΛΣ διατίθενται και με ορισμένους προκατασκευασμένους, γενικής χρήσης οδηγούς συσκευών, συνήθως όχι τόσο βελτιστοποιημένους από άποψη ταχύτητας. Πυρήνας[Επεξεργασία | επεξεργασία κώδικα] Όπως αναφέρθηκε, ο όρος πυρήνας αφορά τα πιο βασικά μέρη ενός ΛΣ τα οποία αλληλεπιδρούν στενά με το υλικό. Αντιθέτως, τμήματα του ΛΣ που δεν ανήκουν στον πυρήνα μπορούν να θεωρηθούν π.χ. η διασύνδεση με τον χρήστη, τα πρωτόκολλα επικοινωνίας ανάμεσα στις εφαρμογές, τα πρωτόκολλα διαχείρισης περιόδων εργασιών χρηστών, τα πρωτόκολλα δικτύου κτλ. Μια ενδιαφέρουσα ανάλυση σχετικά με την διαφορά ΛΣ και πυρήνα μπορεί να βρεθεί εδώ (Linux και GNU). Πάντως δεν επικρατεί κάποια γενική συναίνεση σχετικά με το θέμα αυτό στην κοινότητα της πληροφορικής. Σύγχρονα λειτουργικά συστήματα[Επεξεργασία | επεξεργασία κώδικα] Στις μέρες μας (2012), τα δημοφιλέστερα λειτουργικά συστήματα στους μικροϋπολογιστές, (συμπεριλαμβανομένων των προσωπικών υπολογιστών), έχουν διαμορφωθεί σε δύο μεγάλες οικογένειες: αυτή των Unix-συμβατών και την οικογένεια των Microsoft Windows. Οι κεντρικοί υπολογιστές και τα ενσωματωμένα συστήματα χρησιμοποιούν μια ποικιλία άλλων λειτουργικών συστημάτων, τα περισσότερα από τα οποία δεν έχουν άμεση συγγένεια με τα Windows ή με το Unix. Τα Unix-συμβατά Λειτουργικά Συστήματα αποτελούν μια πολυποίκιλη ομάδα, με πολλές κύριες υποκατηγορίες συμπεριλαμβανομένων των System V, BSD, και GNU/Linux. Το εμπορικό σήμα Unix χρησιμοποιείται από πολλά ΛΣ που έχουν πολλά κοινά με το αρχικό Unix. Τα Unix Λ.Σ. τρέχουν σε μια μεγάλη γκάμα από αρχιτεκτονικές υπολογιστών. Χρησιμοποιούνται πολύ σαν συστήματα εξυπηρετητές στις επιχειρήσεις και σε σταθμούς εργασίας σε ακαδημαϊκούς και μηχανολογικούς χώρους εργασίας. Παραλλαγές του Unix που διακινούνται ως Ελεύθερο λογισμικό, όπως το GNU/Linux και BSD αυξάνουν σε δημοτικότητα στο χώρο των σταθμών εργασίας και των προσωπικών υπολογιστών. Παραλλαγές που διακινούνται με κλειστές άδειες χρήσης όπως το HP-UX της Hewlett-Packard, το Irix της Silicon Graphics και το AIX της IBM έχουν σχεδιαστεί να τρέχουν μόνο στο υλικό των συγκεκριμένων εταιρειών ενώ άλλες παραλλαγές μπορούν να τρέξουν και σε προσωπικούς υπολογιστές. Το Solaris της Sun (που άλλαξε άδεια χρήσης σε λογισμικό ανοιχτού κώδικα υπό την CDDL άδεια) είναι ένα τέτοιο πολύμορφο αλλά αληθινό Unix και μπορεί να τρέχει στους σταθμούς εργασίας της Sun αλλά και στον μικρότερο υπολογιστή αρχιτεκτονικής x86. Το ΛΣ Mac OS X της Apple είναι μια παραλλαγή του BSD, και έχει αντικαταστήσει τα προηγούμενα (μη-unix) MacOS ΛΣ της Apple σε μια σχετικά μικρή αλλά αφοσιωμένη αγορά, έχοντας γίνει ένα πολύ δημοφιλές Unix. Η οικογένεια των Microsoft Windows ΛΣ ξεκίνησε σαν ένα επίπεδο γραφικής διασύνδεσης πάνω από το παλιότερο MS-DOS περιβάλλον για τους IBM PC. Οι σύγχρονες εκδόσεις των Windows βασίζονται στον καινούργιο πυρήνα των Windows NT που πρωτοδιαμορφώθηκε στο OS/2, με πιο πρόσφατη έκδοση εν έτει 2010 τα Windows 7. Τα Windows τρέχουν πάνω σε 32- και 64-bit Intel και AMD υπολογιστές, αν και προηγούμενες εκδόσεις έτρεχαν και σε DEC Alpha, MIPS και PowerPC αρχιτεκτονικές (και υπήρξε και προσπάθεια να μεταφερθεί και σε αρχιτεκτονική SPARC). Σήμερα, τα Windows είναι το δημοφιλέστερο ΛΣ προσωπικών υπολογιστών απολαμβάνοντας ένα σχεδόν μονοπώλιο του 90% του παγκόσμιου μεριδίου αγοράς των προσωπικών υπολογιστών. Επίσης χρησιμοποιείται ευρέως και στους εξυπηρετητές υποστηρίζοντας εφαρμογές όπως Web εξυπηρετητές (Web Servers) και εξυπηρετητές βάσεων δεδομένων (DBMS Servers). Τα ΛΣ μεγάλων υπολογιστών, όπως της IBM z/OS και ενσωματωμένων ΛΣ όπως QNX, eCos, Symbian και Palm OS, είναι συνήθως άσχετα με το Unix και τα Windows. Τα ΛΣ Windows CE, Windows NT Embedded 4.0 και Windows XP Embedded σχετίζονται με τα Windows. Παλιότερα ΛΣ που ακόμα χρησιμοποιούνται σε κλειστές αγορές περιλαμβάνουν το παρόμοιο με τα Windows OS/2 της IBM, το VMS της Hewlett-Packard (πρώην DEC), το Mac OS, το όχι-Unix προηγούμενο του Mac OS της Apple X και το AmigaOS, το πρώτο με γραφική διασύνδεση χρήστη ΛΣ με αναπτυγμένες δυνατότητες πολυμέσων που έγινε διαθέσιμο στο κοινό. Παλαιότερο, επίσης, ΛΣ που χρησιμοποιείται ακόμη σε πολύ περιορισμένες εφαρμογές, είναι ο πρόγονος των Windows στους Προσωπικούς υπολογιστές, το MS-DOS. Η έρευνα και η ανάπτυξη νέων τύπων ΛΣ συνεχίζεται και αποτελεί ένα ενεργό πεδίο της πληροφορικής. Παραδείγματα λειτουργικών συστημάτων[Επεξεργασία | επεξεργασία κώδικα] UNIX - που περιλαμβάνει όλα τα UNIX BSD (FreeBSD, OpenBSD, NetBSD), το Solaris (και το OpenSolaris), το GNU/Linux και το Mac OS X Mac OS (μέχρι την έκδοση 9) Microsoft Windows MS-DOS CP/M AmigaOS Ερευνητικά λειτουργικά συστήματα[Επεξεργασία | επεξεργασία κώδικα] Πολλά λειτουργικά συστήματα αναπτύσσονται από πανεπιστήμια, επιχειρήσεις, χομπίστες ή άλλους φορείς για καθαρά επιστημονικούς λόγους ώστε να διερευνηθούν νέες τεχνικές ή να χρησιμοποιηθούν ως βάση για μελλοντική εμπορική ή παραγωγική χρήση. Μερικά παραδείγματα ερευνητικών λειτουργικών συστημάτων είναι τα εξής: Multics Sprite (λειτουργικό σύστημα) MenuetOS Plan 9 Sortix ToaruOS EMPIX του ΕΜΠ Για μια πιο πλήρη λίστα δείτε εδώ: http://wiki.osdev.org/Projects Παραπομπές[Επεξεργασία | επεξεργασία κώδικα] ↑ 1,0 1,1 «Εισαγωγή στα λειτουργικά συστήματα» (PDF). Αρχειοθετήθηκε από το πρωτότυπο (PDF) στις 21 Ιουλίου 2011. Ανακτήθηκε στις 21 Ιουλίου 2011. ↑ Λειτουργικά Συστήματα - Διεργασίες ↑ 3,0 3,1 3,2 Daniel Pierre Bovet, Marco Cesati, Understanding the Linux Kernel: [from I/Ο Ports to Process Management]., O'Reilly 2005, σελ. 8, ISBN 978-0-596-00565-8 ↑ «Έρευνα της AT Internet». Αρχειοθετήθηκε από το πρωτότυπο στις 9 Μαρτίου 2011. Ανακτήθηκε στις 16 Μαρτίου 2011. ↑ «The Hitchhiker's Guide to EMPIX». Αρχειοθετήθηκε από το πρωτότυπο στις 21 Ιουλίου 2011. Ανακτήθηκε στις 16 Μαρτίου 2011. Πηγές[Επεξεργασία | επεξεργασία κώδικα] Αρχιτεκτονική Υπολογιστών: Μια Δομημένη Προσέγγιση, Tanenbaum Andrew S., Εκδ. Κλειδάριθμος Σύγχρονα Λειτουργικά Συστήματα, Tanenbaum Andrew S., Εκδ. Κλειδάριθμος Principles of Information Security,[Whitman M., Mattord Η (2011), 4th Edition] Βιβλιογραφία[Επεξεργασία | επεξεργασία κώδικα] \"ΛΕΙΤΟΥΡΓΙΚΑ ΣΥΣΤΗΜΑΤΑ\",Γ.Κ.ΠΑΠΑΚΩΝΣΤΑΝΤΙΝΟΥ, Ν.Α.ΜΠΙΛΑΛΗΣ, Π.Α.ΤΣΑΝΑΚΑΣ, Εκδ.Συμμετρία 1986. \"Fundamentals of Operating Systems\",A.M.Lister,5th ed. with R.D.Eager, Springer 1993. Εξωτερικοί σύνδεσμοι[Επεξεργασία | επεξεργασία κώδικα] Wikiversity logo Στo Βικιεπιστήμιο υπάρχει ή αναπτύσσεται εκπαιδευτικό υλικό για αυτό το θέμα: Λειτουργικό σύστημα Commons logo Τα Wikimedia Commons έχουν πολυμέσα σχετικά με το θέμα Λειτουργικό σύστημα Ιστορική αναδρομή λειτουργικών συστημάτων Αρχειοθετήθηκε 2011-05-19 στο Wayback Machine. Εισαγωγή στα λειτουργικά συστήματα Αρχειοθετήθηκε 2011-07-21 στο Wayback Machine. ΕΑΠ - Λειτουργικά Συστήματα Αρχειοθετήθηκε 2011-05-19 στο Wayback Machine. Καθιερωμένοι όροι LCCN: sh85094982 GND: 4006216-8 BNF: cb119333481 (data) NDL: 00865121 NKC: ph115593"
    },
    {
        "id": 18,
        "url": "https://el.wikipedia.org/wiki/%CE%91%CE%BD%CE%BF%CE%B9%CF%87%CF%84%CF%8C_%CE%BB%CE%BF%CE%B3%CE%B9%CF%83%CE%BC%CE%B9%CE%BA%CF%8C",
        "title": "Λογισμικό ανοικτού κώδικα",
        "content": "Το λήμμα παραθέτει τις πηγές του αόριστα, χωρίς παραπομπές. Βοηθήστε συνδέοντας το κείμενο με τις πηγές χρησιμοποιώντας παραπομπές, ώστε να είναι επαληθεύσιμο. Το πρότυπο τοποθετήθηκε χωρίς ημερομηνία. Για τη σημερινή ημερομηνία χρησιμοποιήστε: {{χωρίς παραπομπές|11|01|2025}} Το λογότυπο του ανοιχτού λογισμικού Στον χώρο της πληροφορικής και των ηλεκτρονικών υπολογιστών, με τον όρο λογισμικό ανοικτού κώδικα (αγγλ.: Open Source Software, OSS) εννοείται λογισμικό του οποίου ο πηγαίος κώδικας διατίθεται σε τρίτον για να τον εξετάσει. Κατά καιρούς έχουν εμφανιστεί αρκετές διαφορετικές άδειες χρήσης σχεδιασμένες να συνοδεύουν λογισμικό ανοικτού κώδικα. Μερικές από αυτές επιτρέπουν στους χρήστες και να τροποποιήσουν τον κώδικα ή και να τον αξιοποιήσουν σε άλλες εφαρμογές. Το λογισμικό ανοικτού κώδικα δεν σημαίνει απαραιτήτως δωρεάν λογισμικό, ούτε Ελεύθερο Λογισμικό σύμφωνα με τον ορισμό που δίνει στο Ελεύθερο Λογισμικό το Ίδρυμα Ελεύθερου Λογισμικού, αλλά αναφέρεται μόνο στο γεγονός πως επιτρέπεται σε κάθε χρήστη να εξετάσει και να χρησιμοποιήσει τη γνώση και τις δυνατότητες που προσφέρει ο παρεχόμενος πηγαίος κώδικας. Στην πράξη, τα περισσότερα προγράμματα ανοιχτού κώδικα παρέχονται δωρεάν και μπορούν να χαρακτηριστούν ελεύθερα. Δείτε επίσης[Επεξεργασία | επεξεργασία κώδικα] Ελεύθερο λογισμικό ΕΕΛ/ΛΑΚ Εξωτερικοί σύνδεσμοι[Επεξεργασία | επεξεργασία κώδικα] SourceForge.net - Αποθετήριο και σελίδες ανάπτυξης για λογισμικό ανοιχτού κώδικα Αυτό το λήμμα σχετικά με την Πληροφορική χρειάζεται επέκταση. Μπορείτε να βοηθήσετε την Βικιπαίδεια επεκτείνοντάς το. πσεΕλεύθερο λογισμικό και λογισμικό ανοικτού κώδικαΓενικάCopyleft · Γεγονότα και βραβεία · Ελεύθερο λογισμικό · Ορισμός του Ελεύθερου Λογισμικού · Δωρεάν και ελεύθερο · Κατάλογος ελεύθερου λογισμικού και λογισμικού ανοιχτού κώδικα · Λογισμικό ανοικτού κώδικαΛειτουργικά συστήματαAROS · BSD · Darwin · eCos · FreeDOS · GNU · Haiku · Inferno · Linux · Mach · MINIX · OpenSolaris · Plan 9 · ReactOS · SymbianΑνάπτυξη λογισμικούEclipse · Free Pascal · GCC · Gambas · Java · LLVM · Lua · NetBeans · Open64 · Perl · PHP · Python · ROSE · Ruby · TclΙστορίαGNU ·Haiku ·Linux · Mozilla (Application Suite · Firefox · Thunderbird)ΟργανισμοίApache Software Foundation · Ίδρυμα Blender · Eclipse Foundation · freedesktop.org · Ίδρυμα Ελεύθερου Λογισμικού (Ευρώπη · India ·Latin America) · FSMI ·GNOME Foundation · GNU Project · Google Code ·KDE e.V. · Linux Foundation · Mozilla Foundation · Open Source Geospatial Foundation · Open Source Initiative · Python Software Foundation - Software Freedom Conservancy · SourceForge · Symbian Foundation · The Document Foundation · Xiph.Org Foundation · XMPP Standards Foundation · X.Org FoundationΆδειες ελεύθερου λογισμικούApache · Artistic · BSD · GNU GPL · GNU LGPL · ISC · MIT · MPL · Ms-PL/RL · zlib · FSF approved licensesΠρότυπα αδειών λογισμικούΟρισμός του Λογισμικού Ανοιχτού Κώδικα · Ορισμός του Ελεύθερου Λογισμικού · Debian Free Software GuidelinesΣημαντικά θέματαBinary blob · Canonical's contributor agreement · Digital rights management · Συμβατότητα καρτών γραφικών · License proliferation · Mozilla software rebranding · Proprietary software · Διαμάχη SCO-Linux · Ασφάλεια · Πατέντες λογισμικού · Περιορισμοί υλικού · Trusted Computing · Viral licenseΆλλα θέματαΕναλλακτικοί όροι · Κοινότητα · Διανομή Linux · Forking · Κίνημα · Microsoft Open Specification Promise · Revolution OS · Σύγκριση με λογισμικό κλειστού κώδικα"
    },
    {
        "id": 19,
        "url": "https://el.wikipedia.org/wiki/Python_Software_Foundation",
        "title": "Python Software Foundation",
        "content": "Python Software FoundationΣυντομογραφίαPSFΊδρυση6 Μαρτίου 2001Τύποςμη κερδοσκοπικός οργανισμόςΣκοπόςΝα προωθήσει, προστατεύσει και εξελίξει τη γλώσσα προγραμματισμού Python, όπως και να υποστηρίξει και να βοηθήσει στην ανάπτυξη της διαφορετικότητας στη χρήση από την διεθνή κοινότητα προγραμματιστώνΈδραΝτέλαγουερ, Ηνωμένες Πολιτείες ΑμερικήςΥπηρεσίεςσε όλο τον κόσμοΠρόεδροςΓκίντο βαν Ρόσσουμ (Guido van Rossum)Ιστότοποςwww.python.org/psf-landing/δεδομένα (π • σ • ε ) Το Python Software Foundation (συντομογραφία: PSF) είναι ένας μη κερδοσκοπικός οργανισμός, ο οποίος ξεκίνησε να λειτουργεί στις 6 Μαρτίου του 2001, με σκοπό την υποστήριξη της γλώσσας προγραμματισμού Python. Aποστολή του είναι να προωθεί την ανάπτυξη της κοινότητας Python, να αναλαμβάνει την οργάνωση και την ευθύνη σε διάφορες διαδικασίες της κοινότητας, συμπεριλαμβανομένης της ανάπτυξης της βασικής διανομής της Python, τη διαχείριση πνευματικών δικαιωμάτων, τα συνέδρια των προγραμματιστών συμπεριλαμβανομένων των PyCons και τη συγκέντρωσης κεφαλαίων για την δική του συντήρησή. Το 2005, το Python Software Foundation έλαβε το βραβείο Computerworld Horizon στις τεχνολογίες αιχμής. Ιστορία[Επεξεργασία | επεξεργασία κώδικα] Το πρώτο συνέδριο της κοινότητας Python έγινε τον Νοέμβριο του 1994, πολύ πριν την ίδρυση του PSF. Python Software Activity[Επεξεργασία | επεξεργασία κώδικα] Πριν την ίδρυση της PSF (2001), λειτουργούσε ο επίσης μη κερδοσκοπικός οργανισμός Python Software Activity (συντομογραφία: PSA), που όμως είχε διαφορετικό, πιο περιορισμένο σκοπό και λιγότερα μέλη. Τα μέλη, τα οποία ήταν από σπουδαστές έως εταιρείες και οργανισμοί, ήταν συνδρομητικά (στο πλαίσιο των οικονομικών προσδοκιών τους) και είχαν πλεονεκτήματα (π.χ. νεότερες εκδόσεις, υποστήριξη, κλπ) έναντι των υπόλοιπον χρηστών. Παραπομπές[Επεξεργασία | επεξεργασία κώδικα] ↑ «Mission statement». Python Software Foundation (στα Αγγλικά). Αρχειοθετήθηκε από το πρωτότυπο στις 17 Ιουνίου 2019. Ανακτήθηκε στις 10 Σεπτεμβρίου 2019. ↑ «About the Python Software Foundation». Python.org (στα Αγγλικά). Αρχειοθετήθηκε από το πρωτότυπο στις 10 Σεπτεμβρίου 2019. Ανακτήθηκε στις 10 Σεπτεμβρίου 2019. ↑ «Python Software Foundation». Python.org (στα Αγγλικά). Αρχειοθετήθηκε από το πρωτότυπο στις 23 Αυγούστου 2019. Ανακτήθηκε στις 10 Σεπτεμβρίου 2019. ↑ «Python Software Foundation Wins Computerworld Horizon Award for Popular Python Programming Language». Elemental Security (στα Αγγλικά). 15 Σεπτεμβρίου 2005. Αρχειοθετήθηκε από το πρωτότυπο στις 1 Μαΐου 2015. Ανακτήθηκε στις 5 Οκτωβρίου 2016. ↑ «Computerworld Horizon Awards 2005 Honorees» (στα Αγγλικά). Computerworld. 12 Σεπτεμβρίου 2005. Αρχειοθετήθηκε από το πρωτότυπο στις 31 Ιουλίου 2019. Ανακτήθηκε στις 5 Οκτωβρίου 2016. ↑ «Python Conferences». ftp.ntua.gr (στα Αγγλικά). Αρχειοθετήθηκε από το πρωτότυπο στις 14 Φεβρουαρίου 2019. Ανακτήθηκε στις 10 Σεπτεμβρίου 2019. ↑ «Python Community Resources». ftp.ntua.gr (στα Αγγλικά). Αρχειοθετήθηκε από το πρωτότυπο στις 10 Σεπτεμβρίου 2019. Ανακτήθηκε στις 10 Σεπτεμβρίου 2019. ↑ Lutz, Mark (23 Αυγούστου 2006). Programming Python. \"O'Reilly Media, Inc.\". σελ. 8. ISBN 9780596554613. ↑ Hammond, Mark· Robinson, Andy (2000). Python Programming On Win32: Help for Windows Programmers (στα Αγγλικά). \"O'Reilly Media, Inc.\". σελ. 13. ISBN 9781565926219. Εξωτερικοί σύνδεσμοι[Επεξεργασία | επεξεργασία κώδικα] (Αγγλικά) Python Software Foundation, ο επίσημος ιστότοπος πσεΕλεύθερο λογισμικό και λογισμικό ανοικτού κώδικαΓενικάCopyleft · Γεγονότα και βραβεία · Ελεύθερο λογισμικό · Ορισμός του Ελεύθερου Λογισμικού · Δωρεάν και ελεύθερο · Κατάλογος ελεύθερου λογισμικού και λογισμικού ανοιχτού κώδικα · Λογισμικό ανοικτού κώδικαΛειτουργικά συστήματαAROS · BSD · Darwin · eCos · FreeDOS · GNU · Haiku · Inferno · Linux · Mach · MINIX · OpenSolaris · Plan 9 · ReactOS · SymbianΑνάπτυξη λογισμικούEclipse · Free Pascal · GCC · Gambas · Java · LLVM · Lua · NetBeans · Open64 · Perl · PHP · Python · ROSE · Ruby · TclΙστορίαGNU ·Haiku ·Linux · Mozilla (Application Suite · Firefox · Thunderbird)ΟργανισμοίApache Software Foundation · Ίδρυμα Blender · Eclipse Foundation · freedesktop.org · Ίδρυμα Ελεύθερου Λογισμικού (Ευρώπη · India ·Latin America) · FSMI ·GNOME Foundation · GNU Project · Google Code ·KDE e.V. · Linux Foundation · Mozilla Foundation · Open Source Geospatial Foundation · Open Source Initiative · Python Software Foundation - Software Freedom Conservancy · SourceForge · Symbian Foundation · The Document Foundation · Xiph.Org Foundation · XMPP Standards Foundation · X.Org FoundationΆδειες ελεύθερου λογισμικούApache · Artistic · BSD · GNU GPL · GNU LGPL · ISC · MIT · MPL · Ms-PL/RL · zlib · FSF approved licensesΠρότυπα αδειών λογισμικούΟρισμός του Λογισμικού Ανοιχτού Κώδικα · Ορισμός του Ελεύθερου Λογισμικού · Debian Free Software GuidelinesΣημαντικά θέματαBinary blob · Canonical's contributor agreement · Digital rights management · Συμβατότητα καρτών γραφικών · License proliferation · Mozilla software rebranding · Proprietary software · Διαμάχη SCO-Linux · Ασφάλεια · Πατέντες λογισμικού · Περιορισμοί υλικού · Trusted Computing · Viral licenseΆλλα θέματαΕναλλακτικοί όροι · Κοινότητα · Διανομή Linux · Forking · Κίνημα · Microsoft Open Specification Promise · Revolution OS · Σύγκριση με λογισμικό κλειστού κώδικα"
    },
    {
        "id": 20,
        "url": "https://el.wikipedia.org/wiki/GNU_General_Public_License",
        "title": "Γενική Άδεια Δημόσιας Χρήσης GNU",
        "content": "Λογότυπος του Επεξεργασία: Γενική Άδεια Δημόσιας Χρήσης GNU Λογότυπος του GNU Η Γενική Άδεια Δημόσιας Χρήσης GNU (GNU General Public License, ή GNU GPL ή απλά GPL) είναι πιθανόν η περισσότερο δημοφιλής άδεια χρήσης ελεύθερου λογισμικού, και είναι η άδεια που προστατεύει το μεγαλύτερο ποσοστό του ελεύθερου λογισμικού που υπάρχει μέχρι σήμερα. Παρουσίαση[Επεξεργασία | επεξεργασία κώδικα] Η άδεια γράφτηκε αρχικά από τον Ρίτσαρντ Στόλλμαν για το εγχείρημα GNU. Η πιο πρόσφατη έκδοση της άδειας, η έκδοση 3, κυκλοφόρησε στις 29 Ιουνίου 2007. Η GPLv3 έχει διχάσει την κοινότητα του ανοιχτού λογισμικού, καθώς μέρος των προγραμματιστών του Linux δηλώνουν πως δεν είναι ευχαριστημένοι με την καινούργια έκδοση. Η άδεια GPL, που δημιουργήθηκε για τα προγράμματα που έγραφε το Gnu Project, δίνει στους κατόχους ενός προγράμματος τα ακόλουθα τέσσερα δικαιώματα, που στην κοινότητα του ελεύθερου λογισμικού είναι γνωστά και ως Τέσσερις Ελευθερίες: να τρέξουν ένα πρόγραμμα για οποιοδήποτε λόγο. να μελετήσουν τη λειτουργία ενός προγράμματος και να το τροποποιήσουν να διανείμουν αντίγραφα του προγράμματος έτσι ώστε να βοηθήσουν τον πλησίον να βελτιώσουν το πρόγραμμα και να προσφέρουν τις βελτιώσεις στο κοινό, έτσι ώστε να ωφεληθεί ολόκληρη η κοινότητα Προϋποθέσεις για τα παραπάνω είναι ο ανοιχτός κώδικας, δηλαδή ο κώδικας του προγράμματος να είναι γνωστός και προσβάσιμος στον χρήστη. Η διαφορά της GPL από την BSD είναι ότι κάθε αντίγραφο, παράγωγο και προϊόν ενός GPL προγράμματος, υποχρεούται να κυκλοφορεί κι αυτό υπό την ίδια άδεια. Αντίθετα στην άλλη περίπτωση, τα παράγωγα προγράμματα μπορεί να είναι και ιδιόκτητα (κλειστού κώδικα). Η μεγαλύτερη απόσταση όμως είναι μεταξύ GNU και ιδιόκτητου λογισμικού. Το τελευταίο δεν δίνει κανένα δικαίωμα στο χρήστη, πέραν από το δικαίωμα χρήσης και αυτό κατόπιν συμφωνίας με τον ιδιοκτήτη του προγράμματος (με τη μορφή μιας End User License Agreement). Κριτικοί του ιδιόκτητου λογισμικού υποστηρίζουν ότι δεν πρέπει να χρειάζεται άδεια για χρήση και υποστηρίζουν ότι οι περιορισμοί αυτοί και η διάθεση από τους ιδιοκτήτες του λογισμικού μόνο των δυαδικών πακέτων και όχι του πηγαίου κώδικα του προγράμματος απαγορεύουν νόμιμες διαδικασίες όπως η ανάστροφη μηχανική. Δημοφιλία και στατιστικές[Επεξεργασία | επεξεργασία κώδικα] Σύμφωνα με κάποιες μελέτες και μετρήσεις, η GPL είναι η δημοφιλέστερη άδεια ελεύθερου και ανοιχτού λογισμικού. Σε μέτρηση που έγινε τον Απρίλιο του 2005, 75% από τα 23,479 ελεύθερα προγράμματα του Freshmeat, και 68% από τα προγράμματα στο SourceForge, ανήκουν στην GPL. Αξίζει να αναφερθεί ότι οι δύο αυτοί δικτυακοί τόποι, ανήκουν στην εταιρεία Geeknet, η οποία υποστηρίζει τόσο την άδεια όσο και κατ' επέκτασιν το Λίνουξ. Μια παλαιότερη έρευνα που έκανε το Red Hat Linux 7.1 το 2001, βρήκε πως το 50% του πηγαίου κώδικα ήταν άδειας GPL, και η έρευνα του 1997 που έκανε το Metalab, το μεγαλύτερο αρχείο ελεύθερου λογισμικού της εποχής, έδειξε το ίδιο. Τα πιο γνωστά/σημαντικά προγράμματα που ανήκουν στην άδεια αποτελούν τον πυρήνα Λίνουξ και τον μεταγγλωτιστή GNU Compiler Collection. Άλλα προγράμματα ελεύθερου λογισμικού κυκλοφορούν σε πολλαπλές άδειες, μεταξύ των οποίων και GPL, όπως είναι η Perl. Η GPL στην δοκιμασία[Επεξεργασία | επεξεργασία κώδικα] Το ανοιχτό λογισμικό εκ φύσεως είναι πιο ευάλωτο στην καταπάτηση των δικαιωμάτων των προγραμματιστών από χρήστες ή εταιρείες που χρησιμοποιούν κώδικα χωρίς να σέβονται τις άδειες υπό τις οποίες αυτός δημοσιεύεται. Η GPL αναγκάζει το οποιοδήποτε λογισμικό χρησιμοποιεί ή βασίζεται σε κώδικα που κυκλοφορεί υπό την GPL, να δώσει την δυνατότητα στους χρήστες που το επιθυμούν να δουν τον κώδικα. Παρόλα ταύτα, μερικές υποθέσεις έφτασαν ως τα δικαστήρια όπου και αποδείχτηκε η ασφάλεια και σιγουριά της άδειας αυτής και η πρόθεση του Free Software Foundation να προασπίσει τις τέσσερις ελευθερίες που εγγυάται η άδεια.. Κείμενα[Επεξεργασία | επεξεργασία κώδικα] Το κείμενο της GNU General Public License Ανεπίσημη μετάφραση της GPL στα ελληνικά Το προσχέδιο της έκδοσης 3. Παραπομπές[Επεξεργασία | επεξεργασία κώδικα] ↑ (Αγγλικά) Ψήφοι μέρος των προγραμματιστών του Linux, δίνοντας την γνώμη τους στην GPLv3 (2ο προσχέδιο) ↑ (Αγγλικά) Άποψη Αρχειοθετήθηκε 2006-10-01 στο Wayback Machine. του Λίνους Τόρβαλντς ↑ (Αγγλικά) Η εταιρεία Sitecom Germany χρησιμοποιεί κώδικα του προγράμματος netfilter/iptables και χάνει την υπόθεση στα γερμανικά δικαστήρια ↑ (Αγγλικά) Επίθεση Αρχειοθετήθηκε 2006-09-25 στο Wayback Machine. κατά της GPL στις ΗΠΑ ↑ (Αγγλικά) Η D-Link Germany GmbH χρησιμοποίησε μέρος του κώδικα του Linux και χάνει την υπόθεση Αρχειοθετήθηκε 2014-10-07 στο Wayback Machine. στα γερμανικά δικαστήρια Εξωτερικοί σύνδεσμοι[Επεξεργασία | επεξεργασία κώδικα] http://www.gnu.org/home.el.html Αρχειοθετήθηκε 2006-01-28 στο Wayback Machine. Κείμενο του Richard Stallman για την GPLv3 που παρουσιάστηκε στις Βρυξέλλες, 1 Απριλίου 2007 πσεΕλεύθερο λογισμικό και λογισμικό ανοικτού κώδικαΓενικάCopyleft · Γεγονότα και βραβεία · Ελεύθερο λογισμικό · Ορισμός του Ελεύθερου Λογισμικού · Δωρεάν και ελεύθερο · Κατάλογος ελεύθερου λογισμικού και λογισμικού ανοιχτού κώδικα · Λογισμικό ανοικτού κώδικαΛειτουργικά συστήματαAROS · BSD · Darwin · eCos · FreeDOS · GNU · Haiku · Inferno · Linux · Mach · MINIX · OpenSolaris · Plan 9 · ReactOS · SymbianΑνάπτυξη λογισμικούEclipse · Free Pascal · GCC · Gambas · Java · LLVM · Lua · NetBeans · Open64 · Perl · PHP · Python · ROSE · Ruby · TclΙστορίαGNU ·Haiku ·Linux · Mozilla (Application Suite · Firefox · Thunderbird)ΟργανισμοίApache Software Foundation · Ίδρυμα Blender · Eclipse Foundation · freedesktop.org · Ίδρυμα Ελεύθερου Λογισμικού (Ευρώπη · India ·Latin America) · FSMI ·GNOME Foundation · GNU Project · Google Code ·KDE e.V. · Linux Foundation · Mozilla Foundation · Open Source Geospatial Foundation · Open Source Initiative · Python Software Foundation - Software Freedom Conservancy · SourceForge · Symbian Foundation · The Document Foundation · Xiph.Org Foundation · XMPP Standards Foundation · X.Org FoundationΆδειες ελεύθερου λογισμικούApache · Artistic · BSD · GNU GPL · GNU LGPL · ISC · MIT · MPL · Ms-PL/RL · zlib · FSF approved licensesΠρότυπα αδειών λογισμικούΟρισμός του Λογισμικού Ανοιχτού Κώδικα · Ορισμός του Ελεύθερου Λογισμικού · Debian Free Software GuidelinesΣημαντικά θέματαBinary blob · Canonical's contributor agreement · Digital rights management · Συμβατότητα καρτών γραφικών · License proliferation · Mozilla software rebranding · Proprietary software · Διαμάχη SCO-Linux · Ασφάλεια · Πατέντες λογισμικού · Περιορισμοί υλικού · Trusted Computing · Viral licenseΆλλα θέματαΕναλλακτικοί όροι · Κοινότητα · Διανομή Linux · Forking · Κίνημα · Microsoft Open Specification Promise · Revolution OS · Σύγκριση με λογισμικό κλειστού κώδικα"
    },
    {
        "id": 21,
        "url": "https://el.wikipedia.org/wiki/%CE%9C%CF%8C%CE%BD%CF%84%CF%85_%CE%A0%CE%AC%CE%B9%CE%B8%CE%BF%CE%BD",
        "title": "Monty Python",
        "content": "Μόντυ ΠάιθονΧώρα πολιτογράφησηςΗνωμένο ΒασίλειοΚίνημαυπερρεαλισμόςΕίδος τέχνηςσάτιρα, σουρεαλιστικό χιούμορ, μαύρη κωμωδία και παρωδίαΚαλλιτεχνικά ρεύματαυπερρεαλισμόςΣημαντικά έργαThe Ministry of Silly Walks, Dead Parrot Sketch, The Funniest Joke in the World, The Lumberjack Song, Spam, The Fish-Slapping Dance, Four Yorkshiremen sketch, Ένας Προφήτης... Μα τι Προφήτης!, Johann Gambolputty, Monty Python's The Meaning of Life, Οι Ιππότες της Ελεεινής Τραπέζης, Monty Python's Flying Circus, And Now for Something Completely Different και Monty Python Live at the Hollywood BowlΒραβεύσειςβραβείο Ευρωπαϊκής Ακαδημίας Κινηματογράφου Συνολικής προσφοράς (2001)ΙστοσελίδαΕπίσημος ιστότοπος Σχετικά πολυμέσαδεδομένα (π • σ • ε ) Οι Monty Python (ή Μόντι Πάιθον, γνωστοί και ως The Pythons) είναι το όνομα της ομάδας παραγωγής της τηλεοπτικής σειράς Το ιπτάμενο τσίρκο των Μόντι Πάιθον (Monty Python's Flying Circus), μιας κωμωδίας που άρχισε να εκπέμπεται στη Μεγάλη Βρετανία το 1969, αλλά και μιας σειράς εκπομπών, κινηματογραφικών έργων, ηχογραφήσεων και θεατρικών παραγωγών από το 1969 μέχρι το 1989. Τα μέλη της ομάδας των Μόντι Πάιθον[Επεξεργασία | επεξεργασία κώδικα] Τα μέλη της ομάδας των Μόντι Πάιθον είναι οι Γκράχαμ Τσάπμαν (Graham Chapman), Έρικ Άιντλ (Eric Idle), Τέρι Γκίλιαμ (Terry Gilliam), Τέρι Τζόουνς (Terry Jones), Τζον Κλιζ (John Cleese) και Μάικλ Πέιλιν (Michael Palin). Έργα των Μόντι Πάιθον[Επεξεργασία | επεξεργασία κώδικα] Τα κωμικά και σατιρικά έργα τους είχαν μεγάλη επιρροή στη λαϊκή κουλτούρα στη Βρετανία, αλλά και σε παγκόσμιο επίπεδο, επηρεάζοντας μετέπειτα Βρετανούς δημιουργούς. Από τα πιο σημαντικά έργα τους είναι: Το ιπτάμενο τσίρκο των Μόντι Πάιθον κωμωδία σε τηλεοπτική σειρά η οποία παράχθηκε και παρουσιάστηκε στο BBC της Μεγάλης Βρετανίας από το 1969 με 45 επεισόδια μέχρι το 1974. And Now for Something Completely Different (1971), κινηματογραφική ταινία με σκετς από την τηλεοπτική σειρά. Οι ιππότες της Ελεεινής Τραπέζης (Monty Python and the Holy Grail) (1975) σατιρική κινηματογραφική ταινία για τον μύθο του Βασιλιά Αρθούρου. Ένας προφήτης... Μα τι προφήτης! (Monty Python's Life of Brian) (1979), μια κινηματογραφική σάτιρα με την ιστορία ενός νεαρού Εβραίου που θεωρήθηκε μεσσίας. Monty Python Live at the Hollywood Bowl (1982), η ταινία από μια ζωντανή παρουσίασή τους, στην οποία έπαιξαν μερικά από τα πιο ωραία κωμικά τους σκετς. Μόντι Πάιθον, το νόημα της ζωής (1983), μια κινηματογραφική συλλογή από σκετς για το νόημα της ζωής, με αρκετό μαύρο χιούμορ. Φωτογραφίες μελών της ομάδας των Μόντι Πάιθον[Επεξεργασία | επεξεργασία κώδικα] Michael Palin Eric Idle Terry Gilliam John Cleese Δείτε επίσης[Επεξεργασία | επεξεργασία κώδικα] Ιππότες που λένε Νι! Παραπομπές[Επεξεργασία | επεξεργασία κώδικα] ↑ 1,0 1,1 Ανακτήθηκε στις 12 Αυγούστου 2022. ↑ www.europeanfilmacademy.org/European-Film-Awards-Winners-2001.72.0.html. Ανακτήθηκε στις 15 Δεκεμβρίου 2019. ↑ «10 πράγματα που αξίζει να ξέρεις για τους Μόντι Πάιθον». Athens Voice. 2 Νοεμβρίου 2019. Ανακτήθηκε στις 27 Ιανουαρίου 2024. ↑ «Ο Κάρολος, οι Μόντι Πάιθον και ο Νικ Κέιβ - Τελικά ποιος νοιάζεται για τον νέο βασιλιά;». Η Ναυτεμπορική. 6 Μαΐου 2023. Ανακτήθηκε στις 27 Ιανουαρίου 2024. ↑ «Κακώς χειροκροτούσαν οι επίσημοι τα κορίτσια με το ανόητο βάδισμα των Μόντι Πάιθον». Έθνος. 1 Ιανουαρίου 1980. Ανακτήθηκε στις 27 Ιανουαρίου 2024. ↑ «Μόντι Πάιθον: Τα 50α γενέθλια, οι εκπλήξεις και το ρεκόρ Γκίνες». HuffPost Greece. 27 Ιουνίου 2019. Ανακτήθηκε στις 27 Ιανουαρίου 2024. ↑ Wilmut (1980), p. 250. ↑ Chapman, Graham· Gilliam, Terry· Cleese, John· Idle, Eric· Jones, Terry· Palin, Michael (2003). The Pythons. Orion. ISBN 9780752852935. Εξωτερικοί σύνδεσμοι[Επεξεργασία | επεξεργασία κώδικα] Commons logo Τα Wikimedia Commons έχουν πολυμέσα σχετικά με το θέμα Monty Python https://web.archive.org/web/20060314132918/http://www.pythonline.com/ Ιστότοπος του Έρικ Άιντλ για τους Μόντι Πάιθον (Αγγλικά) Καθιερωμένοι όροι VIAF: 154754514 Europeana: agent/base/146886 LCCN: n79022378 ISNI: 0000 0001 2298 4731 GND: 811153-4 SELIBR: 331784 SUDOC: 031805949 BNF: cb13773092f (data) MusicBrainz: 4a5c8526-f8ec-43f1-97af-49722ad88394 NLA: 36024358 NDL: 00954548 NKC: ko2002149886"
    },
    {
        "id": 22,
        "url": "https://el.wikipedia.org/wiki/%CE%A0%CF%8D%CE%B8%CF%89%CE%BD%CE%B1%CF%82",
        "title": "Πύθωνας",
        "content": "Πύθωνας Ινδικός πύθωνας (Πύθων ο μόλουρος - Python molurus) Συστηματική ταξινόμηση Βασίλειο: Ζώα (Animalia) Συνομοταξία: Χορδωτά (Chordata) Υποσυνομοταξία: Σπονδυλωτά (Vertebrata) Ομοταξία: Ερπετά (Reptilia) Τάξη: Φολιδωτά (Squamata) Υποτάξη: Φίδια (Serpentes) Οικογένεια: Πυθωνίδες (Pythonidae) Γένος: Πύθων (Python)Daudin, 1803 Συνώνυμα Python - Daudin, 1803 Συσφιγκτήρ - Wagler, 1830 Enygrus - Wagler, 1830 Engyrus - Gary, 1831 Enygris - Gray, 1842 Heleionomus - Gray, 1842 Hortulia - Gray, 1842 Αστερόφις - Fitzinger, 1843 Ασπιδοβόας - Sauvage, 1884 Πύθωνας είναι γένος ανιοβόλων φιδιών που ανήκουν στην οικογένεια των πυθωνιδών και στην τάξη των φολιδωτών ερπετών. Απαντώνται στην Αφρική και στην Ασία. Σήμερα αναγνωρίζονται επτά συνολικά είδη. Η κοινή του ονομασία είναι πύθωνας. Το μήκος του κυμαίνεται, ανάλογα με το είδος, από μερικά εκατοστά μέχρι 10 μ.. Το κύριο χαρακτηριστικό τους είναι ότι δεν έχουν αδένες με δηλητήριο και σκοτώνουν τη λεία τους σφίγγοντάς την με τις δυνατές σπείρες τους. Από τα επτά είδη επικίνδυνο για τον άνθρωπο είναι ο «πύθων ο δικτυωτός», ο οποίος ζει στις ζούγκλες της Μαλαισίας και της Μιανμάρ. Το βάρος αυτού του πύθωνα μπορεί να φθάσει τα 120 κιλά. Είδη[Επεξεργασία | επεξεργασία κώδικα] Είδος Αρχή Υποείδος Κοινή ονομασία Γεωγραφική κατανομή Python anchietae (Πύθων του Αντσιέτα) Bocage, 1887 0 Πύθωνας της Αγκόλας Αφρική στη νότια Αγκόλα και στη νότια Ναμίμπια Python curtus (Πύθων ο κοντός) Schlegel, 1872 2 Κοντός πύθωνας Νοτιοανατολική Ασία στη νότια Ταϊλάνδη, στη Μαλαισία και στο Σαράουακ κα σε Ινδονησία (Σουμάτρα, Καλιμαντάν και αλλού) Python molurus (Πύθων ο μόλουρος)T (Linnaeus, 1758) 1 Ινδικός πύθωνας Πακιστάν, Ινδία, Σρι Λάνκα, Νεπάλ, Μπανγκλαντές, Μιανμάρ, νότια Κίνα, Χονγκ Κονγκ, Λάος, Βιετνάμ, Καμπότζη, Μαλαισία, Ινδονησία Python regius (Πύθων ο βασιλικός) (Shaw, 1802) 0 Βασιλικός πύθωνας Κεντρική, Δυτική και Ανατολική Αφρική Python reticulatus (Πύθων ο δικτυωτός) (Schneider, 1801) 0 Πύθωνας δικτυωτός νοτιοανατολική Ασία, Ινδονησία, Φιλιππίνες Python sebae (Πύθων ο σέβειος) (Gmelin, 1788) 1 Αφρικανικός πύθωνας των βράχων Υποσαχάρια Αφρική Python timoriensis (Πύθων του Τιμόρ) (Peters, 1876) 0 Πύθωνας του Τιμόρ Ινδονησία, νησιά Τιμόρ *) Χωρίς το τυπικό υποείδος. Τροφή[Επεξεργασία | επεξεργασία κώδικα] Η κύρια τροφή στα μεγάλα φίδια του γένους είναι τα διάφορα θηλαστικά ζώα. Αυτά τα καταπίνουν ολόκληρα και για τον λόγο αυτό η στοματική και φαρυγγική τους κοιλότητα διαστέλλεται. Αναπαραγωγή[Επεξεργασία | επεξεργασία κώδικα] Ο πύθωνας γεννά αυγά και ο αριθμός τους σε μερικά είδη υπερβαίνει τα 100 ανά γέννα. Η διάρκεια της επώασης είναι 9-11 εβδομάδες. Κατά την περίοδο αυτή το θηλυκό δεν προσλαμβάνει τροφή. Παραπομπές[Επεξεργασία | επεξεργασία κώδικα] ↑ McDiarmid RW, Campbell JA, Touré T. 1999. Snake Species of the World: A Taxonomic and Geographic Reference, vol. 1. Herpetologists' League. 511 pp. ISBN 1-893777-00-6 (series). ISBN 1-893777-01-4 (volume). ↑ ITIS, ID =202186, taxon=Python, 11 Σεπτεμβρίου 2007 ↑ Named for José Alberto de Oliveira Anchieta (Portuguese explorer and naturalist) ↑ Ο βασιλικός πύθωνας έχει μικρές διαστάσεις και χρωματιστά σχέδια. ↑ Το είδος αυτό είναι αδηφάγο και πολύ επιθετικό. Κρύβεται σε πυκνές φυλλωσιές την ημέρα και βγαίνει προς αναζήτηση τροφής τη νύχτα. Το μήκος του μπορεί να φθάσει και τα 8 μέτρα. Βιβλιογραφία[Επεξεργασία | επεξεργασία κώδικα] wiktionary logo Το Βικιλεξικό έχει σχετικό λήμμα: πύθωνας Commons logo Τα Wikimedia Commons έχουν πολυμέσα σχετικά με το θέμα Πύθωνας Wikispecies logo Τα Βικιείδη έχουν πληροφορίες για το θέμα: Πύθωνας Εγκυκλοπαίδεια 2002, τόμ. 17, σελ. 105, εκδ. 1984 Καθιερωμένοι όροι NKC: ph317220"
    },
    {
        "id": 23,
        "url": "https://el.wikipedia.org/wiki/%CE%93%CE%BB%CF%8E%CF%83%CF%83%CE%B1_%CF%83%CE%B5%CE%BD%CE%B1%CF%81%CE%AF%CF%89%CE%BD",
        "title": "Γλώσσα προγραμματισμού σεναρίων",
        "content": "Μια γλώσσα σεναρίων (scripting language, script language) ή γλώσσα επέκτασης (extension language) είναι μια γλώσσα προγραμματισμού που επιτρέπει τον έλεγχο μιας ή περισσότερων εφαρμογών. Τα \"σενάρια\" (\"scripts\") είναι διακριτά από τον βασικό κώδικα της εφαρμογής, καθώς γράφονται συνήθως σε διαφορετική γλώσσα και συχνά δημιουργούνται ή τροποποιούνται από τον τελικό χρήστη. Τα σενάρια συνήθως διερμηνεύονται από τον πηγαίο κώδικα ή τον κώδικα byte (bytecode), ενώ η εφαρμογή συνήθως έχει ήδη πρώτα μεταγλωττιστεί σε κώδικα μηχανής. Οι πρώτες γλώσσες σεναρίων συχνά αποκαλούνταν γλώσσες δέσμης (batch languages) ή γλώσσες ελέγχου εργασιών (job control languages). Αυτές οι πρώτες γλώσσες σεναρίων δημιουργήθηκαν για να συντομεύσουν την παραδοσιακή διαδικασία διόρθωση-μεταγλώττιση-σύνδεση-εκτέλεση. Ιστορία[Επεξεργασία | επεξεργασία κώδικα] Οι πρώτοι κεντρικοί υπολογιστές (τη δεκαετία του 1950) δεν είχαν δυνατότητες αλληλεπίδρασης αλλά λειτουργούσαν με επεξεργασία δεσμών. Η Job Control Language (JCL) της IBM είναι κλασική γλώσσα που χρησιμοποιήθηκε για τον έλεγχο της επεξεργασίας δεσμών. Τα πρώτα αλληλεπιδραστικά κελύφη αναπτύχθηκαν κατά τη δεκαετία του 1960 για να γίνει δυνατός ο απομακρυσμένος χειρισμός των πρώτων συστημάτων χρονικού διαμερισμού (time-sharing), τα οποία χρησιμοποιούσαν σενάρια κελύφους για τον έλεγχο της εκτέλεσης των προγραμμάτων, σε ένα πρόγραμμα, το κέλυφος. Γλώσσες όπως η Tcl και η Lua σχεδιάστηκαν ειδικά σαν γλώσσες σεναρίων γενικού σκοπού, οι οποίες να μπορούν να ενσωματωθούν σε οποιαδήποτε εφαρμογή. Άλλες γλώσσες όπως η Visual Basic for Applications (VBA) παρείχαν σημαντική ολοκλήρωση με τις δυνατότητες αυτοματοποίησης του συστήματος στο οποίο εκτελούνταν. Η ενσωμάτωση αυτών των γλωσσών σεναρίων γενικού σκοπού αντί της ανάπτυξης μιας νέας γλώσσας ανά εφαρμογή είχε προφανή πλεονεκτήματα, γλιτώνοντας τον προγραμματιστή της εφαρμογής από την ανάγκη να δημιουργεί από το μηδέν έναν νέο μεταφραστή για τη γλώσσα, ενώ ο χρήστης μπορούσε να χρησιμοποιήσει γνώσεις που είχε αποκτήσει σε άλλα περιβάλλοντα. Υπάρχει λογισμικό που ενσωματώνει πολλές διαφορετικές γλώσσες προγραμματισμού. Οι σύγχρονοι περιηγητές Ιστού (web browsers) συνήθως περιλαμβάνουν μια γλώσσα για τη συγγραφή επεκτάσεων του ίδιου του περιηγητή και αρκετές πρότυπες γλώσσες για τον έλεγχό του, όπως η JavaScript (διάλεκτος της ECMAScript) ή η XUL. Τύποι γλωσσών σεναρίων[Επεξεργασία | επεξεργασία κώδικα] Γλώσσες ελέγχου εργασιών και κελύφη[Επεξεργασία | επεξεργασία κώδικα] Κύριο λήμμα: Σενάριο κελύφους Ο έλεγχος εργασιών (job control) δημιουργησε μια μεγάλη κλάση γλωσσών σεναρίων, για την εκκίνηση και τον έλεγχο της συμπεριφοράς προγραμμάτων του συστήματος. (Σύμφωνα με αυτήν την έννοια, τα κελύφη γραμμής εντολών μπορούν να θεωρηθούν απόγονοι της γλώσσας προγραμματισμού JCL, ή Job Control Language, της IBM, που χρησιμοποιήθηκε ακριβώς για αυτόν τον σκοπό.) Πολλοί από τους διερμηνείς αυτών των γλωσσών παίζουν δεύτερο ρόλο και σαν διερμηνείς γραμμής εντολών όπως το κέλυφος Unix ή το COMMAND.COM του MS-DOS. Άλλες, όπως η AppleScript, προσφέρουν σύνταξη και εντολές που να μοιάζουν με Αγγλικά, για την κατασκευή σεναρίων. Σε συνδυασμό με τα πλαίσια του Cocoa του Mac OS X, ο χρήστης μπορεί να φτιάξει ολόκληρες εφαρμογές χρησιμοποιώντας μονο αντικείμενα AppleScript και Cocoa. Σενάρια GUI[Επεξεργασία | επεξεργασία κώδικα] Με την εμφάνιση των γραφικών διασυνδέσεων χρήστη (graphical user interfaces) αναπτύχθηκε ένα εξειδικευμένο είδος γλώσσας σεναρίων για τον έλεγχο του υπολογιστή. Γλώσσες αυτού του είδους αλληλεπιδρούν με τα ίδια γραφικά παράθυρα, μενού, ποντίκια και άλλα γραφικά αντικείμενα και τεχνολογίες που ελέγχει το σύστημα. Αυτό το επιτυγχάνουν προσομοιώνοντας τις ενέργειες ενός ανθρώπου-χρήστη και συνήθως χρησιμοποιούνται για τον αυτοματισμό ενεργειών του χρήστη ή για να ρυθμίσουν μια γνωστή κατάσταση. Όταν ο έλεγχος γίνεται μέσα από προσομοιωμένα πατήματα πλήκτρων ή κλικ του ποντικιού αυτές οι γλώσσες ονομάζονται \"μακροεντολές\" (\"macros\"). Αυτές οι γλώσσες θα μπορούσαν θεωρητικά να χρησιμοποιηθούν για να ελέγξουν οποιαδήποτε εφαρμογή τρέχει σε έναν υπολογιστή που βασίζεται σε γραφική διασύνδεση χρήστη, στην πραγματικότητα όμως η υποστήριξη για τέτοιες γλώσσες συνήθως εξαρτάται από την εφαρμογή και το λειτουργικό σύστημα. Υπάρχουν κάποιες εξαιρέσεις σε αυτόν τον περιορισμό. Υπάρχουν γλώσσες αυτού του είδους που βασίζονται στην αναγνώριση γραφικών αντικειμένων από τα πίξελ που φαίνονται στην οθόνη και δεν εξαρτώνται από την υποστήριξη του λειτουργικού συστήματος ή της εφαρμογής. Εξειδικευμένες γλώσσες εφαρμογών[Επεξεργασία | επεξεργασία κώδικα] Πολλές μεγάλες εφαρμογές περιέχουν μια δική τους γλώσσα σεναρίων, προσαρμοσμένη στις ανάγκες του χρήστη. Επίσης, πολλά συστήματα βιντεοπαιχνιδιών χρησιμοποιούν μια ειδική γλώσσα σεναρίων για την περιγραφή των προγραμματισμένων ενεργειών των χαρακτήρων που ελέγχονται από τον υπολογιστή (non-player characters, NPCs) και του περιβάλλοντος του παιχνιδιού. Οι γλώσσες αυτού του τύπου σχεδιάζονται για μια μόνο εφαρμογή και, αν και μπορεί να μοιάζουν με κάποια γλώσσα γενικού σκοπού (όπως η QuakeC του Quake, που σχεδιάστηκε με βάση την C), έχουν ειδικά χαρακτηριστικά που τις ξεχωρίζουν. Η Emacs Lisp, αν και πλήρης διάλεκτος της Lisp, περιέχει κάποια ειδικά χαρακτηριστικά για την επέκταση των λειτουργιών του διορθωτή Emacs. Μια ειδική γλώσσα σεναρίων μιας εφαρμογής μπορεί να θεωρηθεί ότι είναι μια γλώσσα προγραμματισμού ειδικού πεδίου (domain-specific programming language), η οποία εξειδικεύεται σε μια εφαρμογή. Φυλλομετρητές Ιστού[Επεξεργασία | επεξεργασία κώδικα] Οι φυλλομετρητές Ιστού (Web browsers) είναι εφαρμογές που εμφανίζουν ιστοσελίδες και μπορούν να εκτελέσουν σενάρια για να αλλάξουν την εμφάνιση ή την συμπεριφορά των ιστοσελίδων αυτών (για παράδειγμα, να αλλάξουν το περιεχόμενο ανάλογα με τον χρήστη που το βλέπει). Έχουν αναπτυχθεί αρκετές ειδικές γλώσσες ελέγχου φυλλομετρητών, όπως η JavaScript, η VBScript της Microsoft (που λειτουργεί μόνο στον Internet Explorer), η XUL του εγχειρήματος Mozilla (που λειτουργεί μόνο στον Firefox) και η XSLT, μια γλώσσα παρουσίασης που μετατρέπει περιεχόμενο XML σε κάποια νέα μορφή. Όταν χρησιμοποιούνται τεχνικές που συνδυάζουν την XML και τα σενάρια JavaScript για να βελτιωθεί η εμπειρία του χρήστη και η απόκριση μιας ιστοσελίδας, η πρακτική ονομάζεται AJAX. Τα σενάρια στην πλευρά του πελάτη (client-side scripts) στέλνονται από τον διακομιστή στον υπολογιστή του πελάτη. Παράδειγμα σεναρίου στην πλευρά του πελάτη είναι μια ιστοσελίδα που περιέχει ένα κουμπί, το οποίο, όταν πατηθεί από τον χρήστη, εμφανίζει ένα παράθυρο με κάποιο μήνυμα μέσω JavaScript. Γλώσσες επεξεργασίας κειμένου[Επεξεργασία | επεξεργασία κώδικα] Η επεξεργασία εγγραφών κειμένου είναι από τις παλαιότερες χρήσεις των γλωσσών σεναρίων. Τα σενάρια που γράφονται για τα εργαλεία του Unix AWK, sed και grep αυτοματοποιούν εργασίες που έχουν να κάνουν με ρυθμίσεις με μορφή κειμένου και με αρχεία καταγραφών (log files). Σημαντικό ρόλο παίζουν οι κανονικές εκφράσεις, που είναι μια τυπική γλώσσα που περιγράφει τη λεξιλογική δομή του κειμένου, και η οποία χρησιμοποιείται από όλα αυτά τα εργαλεία. Η Perl σχεδιάστηκε αρχικά για να αντιμετωπιστούν περιορισμοί σε αυτά τα εργαλεία και έχει καταλήξει να είναι μια από τις πιο ευρέως χρησιμοποιούμενες γλώσσες κοινού σκοπού. Δυναμικές γλώσσες γενικού σκοπού[Επεξεργασία | επεξεργασία κώδικα] Δείτε επίσης: Δυναμική γλώσσα προγραμματισμού Κάποιες γλώσσες, όπως η Perl, άρχισαν σαν γλώσσες σεναρίων αλλά στη συνέχεια αναπτύχθηκαν σε γλώσσες προγραμματισμούς για ευρύτερους σκοπούς. Άλλες παρόμοιες γλώσσες – συχνά διερμηνευμένες, με αυτόματη διαχείριση μνήμης ή με δυναμικά χαρακτηριστικά – έχουν περιγραφεί σαν \"γλώσσες σεναρίων\", λόγω των ομοιοτήτων τους, ακόμα και αν χρησιμοποιούνται συχνότερα για την ανάπτυξη εφαρμογών. Συνήθως αυτές οι γλώσσες δεν αποκαλούνται \"γλώσσες σεναρίων\" από τους ίδιους τους χρήστες τους. Γλώσσες επέκτασης και ενσωματωμένες γλώσσες[Επεξεργασία | επεξεργασία κώδικα] Αρκετές γλώσσες έχουν σχεδιαστεί έτσι ώστε να μπορούν να αντικαταστήσουν τις γλώσσες σεναρίων που είναι εξειδικευμένες για κάποια εφαρμογή, προσφέροντας ενσωμάτωση στο πρόγραμμα της εφαρμογής. Ο προγραμματιστής της εφαρμογής (που χρησιμοποιεί C ή κάποια άλλη γλώσσα χαμηλού επιπέδου ή προγραμματισμού συστημάτων) προσθέτει \"σημεία αγκίστρωσης\" (\"hooks\"), όπου η γλώσσα σεναρίων μπορεί να ελέγξει την εφαρμογή. Οι γλώσσες αυτές έχουν τον ίδιο σκοπό με τις εξειδικευμένες γλώσσες επέκτασης εφαρμογών αλλά ο χρήστης έχει το πλεονέκτημα να μπορεί να μεταφέρει κάποιες από τις γνώσεις του ανάμεσα στις εφαρμογές. Η JavaScript ξεκίνησε, και σε μεγάλο βαθμό εξακολουθεί, να είναι γλώσσα συγγραφής σεναρίων μέσα σε φυλλομετρητές αλλά η δημιουργία προτύπου της γλώσσας (ECMAScript) την έκανε δημοφιλή σαν γλώσσα γενικού σκοπού που μπορεί να ενσωματωθεί. Ειδικότερα η υλοποίηση του εγχειρήματος Mozilla (SpiderMonkey) ενσωματώνεται σε πολλά περιβάλλοντα, όπως το Yahoo! Widget Engine. Άλλες εφαρμογές που ενσωματώνουν υλοποιήσεις της ECMAScript είναι τα προϊόντα της Adobe, Adobe Flash (ActionScript) και Adobe Acrobat (για σενάρια σε αρχεία PDF). Η Tcl δημιουργήθηκε σαν γλώσσα επέκτασης αλλά χρησιμοποιείται πια πιο συχνά όπως η Python, η Perl και η Ruby. Υπάρχουν πολύπλοκες εφαρμογές, που βασίζονται στις εργασίες (tasks), οι οποίες μπορεί να ενσωματώνουν και να δίνουν στον χρήστη μια γλώσσα προγραμματισμού για περισσότερες δυνατότητες ελέγχου και λειτουργίες μέσω μιας διεπαφής χρήστη (η οποία μπορεί να είναι και αυτή πολύπλοκη). Για παράδειγμα, τα εργαλεία δημιουργίας 3D του Autodesk Maya ενσωματώνουν τη γλώσσα σεναρίων MEL, ενώ το Blender χρησιμοποιεί για τον ίδιο σκοπό την Python. Άλλοι τύποι εφαρμογών που χρειάζονται έναν τρόπο να προστίθενται γρήγορα νέα χαρακτηριστικά ή να είναι γρηγορότερος ο κύκλος τροποποίηση-εκτέλεση του κώδικα (όπως οι μηχανές παιχνιδιών) χρησιμοποιούν επίσης κάποια ενσωματωμένη γλώσσα. Κατά τη διάρκεια της ανάπτυξης, αυτό διευκολύνει τη γρήγορη δημιουργία και τροποποίηση χαρακτηριστικών, χωρίς ο χρήστης να πρέπει να γνωρίζει τις εσωτερικές λειτουργίες της εφαρμογής ή να πρέπει να την μεταγλωττίζει πάλι μετά από κάθε αλλαγή (κάτι που μπορεί να είναι χρονοβόρο). Για αυτόν τον σκοπό, χρησιμοποιούνται πολλές γλώσσες σεναρίων, από τις πιο γνωστές Lua και Python, σε λιγότερο γνωστές όπως η AngelScript και η Squirrel. Ανάλυση αγοράς[Επεξεργασία | επεξεργασία κώδικα] Σύμφωνα με μια έρευνα σε παγκόσμιο επίπεδο της Evans Data το 2008 Αρχειοθετήθηκε 2011-11-23 στο Wayback Machine., η πιο διαδεδομένη γλώσσα σεναρίων είναι η JavaScript και ακολουθεί η PHP. Η Perl είναι η τρίτη πιο διαδεδομένη γλώσσα σεναρίων, αλλά είναι πολύ πιο διαδεδομένη στη Βόρεια Αμερική. Δείτε επίσης[Επεξεργασία | επεξεργασία κώδικα] Διερμηνευμένη γλώσσα Shebang (Unix) Κέλυφος (υπολογιστές) Προγραμματισμός συστημάτων Web template languages Παραπομπές[Επεξεργασία | επεξεργασία κώδικα] ↑ IEEE Computer, 2008, In praise of scripting, Ronald Loui ↑ Brown, Vicki. «\"Scripting Languages\"». Ανακτήθηκε στις 22 Ιουλίου 2009. ↑ «PHP, JavaScript, Ruby, Perl, Python, and Tcl Today: The State of the Scripting Universe - CIO.com». Αρχειοθετήθηκε από το πρωτότυπο στις 23 Νοεμβρίου 2011. Ανακτήθηκε στις 28 Σεπτεμβρίου 2011. Εξωτερικοί σύνδεσμοι[Επεξεργασία | επεξεργασία κώδικα] Patterns for Scripted Applications (Αγγλικά) Are Scripting Languages Any Good? A Validation of Perl, Python, Rexx, and Tcl against C, C++, and Java (PDF) — μελέτη του 2003 (Αγγλικά) Scripting on the Java platform — JavaWorld (Αγγλικά) \"Programming is Hard - Let's Go Scripting\" by Larry Wall - μεταγραφή του λόγου State of the Onion στην ιστοσελίδα Perl.com."
    },
    {
        "id": 24,
        "url": "https://el.wikipedia.org/wiki/%CE%9A%CE%BB%CE%AE%CF%83%CE%B5%CE%B9%CF%82_%CF%83%CF%85%CF%83%CF%84%CE%AE%CE%BC%CE%B1%CF%84%CE%BF%CF%82",
        "title": "Κλήση συστήματος",
        "content": "Το λήμμα παραθέτει τις πηγές του αόριστα, χωρίς παραπομπές. Βοηθήστε συνδέοντας το κείμενο με τις πηγές χρησιμοποιώντας παραπομπές, ώστε να είναι επαληθεύσιμο. Το πρότυπο τοποθετήθηκε χωρίς ημερομηνία. Για τη σημερινή ημερομηνία χρησιμοποιήστε: {{χωρίς παραπομπές|11|01|2025}} Στην πληροφορική κλήσεις συστήματος ονομάζεται ένα σύνολο υπηρεσιών που παρέχει ο πυρήνας του λειτουργικού συστήματος μέσω μίας προτυποποιημένης προγραμματιστικής διασύνδεσης. Κανονικά ο κώδικας των εκτελούμενων προγραμμάτων («κώδικας χρήστη») δεν έχει άμεση πρόσβαση στον πυρήνα, αλλά χάρη στις κλήσεις συστήματος που αυτός εξάγει, τα προγράμματα χρήστη μπορούν να καλούν με ελεγχόμενο τρόπο διαδικασίες που παρέχουν υπηρεσίες στον καλούντα. Η σύνταξη, η σημασιολογία και η ονοματολογία των κλήσεων συστήματος διαφέρει από ΛΣ σε ΛΣ, με αποτέλεσμα ένα εκτελέσιμο πρόγραμμα συνήθως να μπορεί να τρέξει μόνο σε ένα ΛΣ. Ο κώδικας χρήστη δεν μπορεί να προσπελάσει μόνος του τους πόρους του υπολογιστή (π.χ. δίσκους, μνήμη συστήματος, περιφερειακές συσκευές, δίκτυο κλπ), αλλά μπορεί να ζητήσει ό,τι χρειάζεται (π.χ. άνοιγμα ενός αρχείου στον δίσκο) από τον πυρήνα μέσω των κλήσεων συστήματος. Συνήθως οι γλώσσες προγραμματισμού παρέχουν προτυποποιημένες βιβλιοθήκες που αποκρύπτουν αυτήν τη διαδικασία από τον προγραμματιστή και παρέχουν φορητότητα πηγαίου κώδικα από ΛΣ σε ΛΣ. Π.χ. η απλή συνάρτηση fopen() της πρότυπης βιβλιοθήκης της γλώσσας C, με κοινή σύνταξη για όλες τις αρχιτεκτονικές και λειτουργικά συστήματα αλλά με διαφορετική υλοποίηση για το καθένα, όταν κληθεί καλεί με τη σειρά της την αντίστοιχη κλήση συστήματος - κατά κανόνα πιο πολύπλοκη - που παρέχει το υποκείμενο ΛΣ. Ο κώδικας που υλοποιεί τις κλήσεις συστήματος είναι ουσιαστικά τμήμα του πυρήνα, οπότε η fopen() του συγκεκριμένου παραδείγματος ζητά μετάβαση του επεξεργαστή σε «κατάσταση πυρήνα», κατά την οποία μπορούν να εκτελεστούν εντολές με άμεση επίδραση στο υλικό και στους πόρους του υπολογιστή, και μεταφέρει τον έλεγχο στον κώδικα της κλήσης συστήματος. Όταν ο τελευταίος τερματίσει ο επεξεργαστής μεταβαίνει πάλι σε «κατάσταση χρήστη» και η fopen() συνεχίζει την εκτέλεσή της από την εντολή που ακολουθεί την κλήση συστήματος. Φυσικά τα προγράμματα χρήστη μπορούν να παρακάμψουν την fopen() και να καλέσουν κατευθείαν τον πυρήνα, κάτι που γίνεται αναγκαστικά όταν η βιβλιοθήκη της γλώσσας προγραμματισμού δεν παρέχει υψηλού επιπέδου διασύνδεση (όπως την fopen()) για κάποια λειτουργία. Ακόμα και σε αυτή την περίπτωση όμως οι κλήσεις συστήματος είναι προσπελάσιμες από τα προγράμματα χρήστη μόνο μέσω της μεσολάβησης των βιβλιοθηκών συστήματος (π.χ. της glibc), αφού για παράδειγμα η κλήση συστήματος OPEN των ΛΣ τύπου Unix καθίσταται προσβάσιμη μέσω της συνάρτησης συστήματος open(), η οποία είναι αυτή που καλείται εσωτερικά από την υψηλότερου επιπέδου fopen() στις υλοποιήσεις της πρότυπης βιβλιοθήκης της C για Unix. Κάθε φορά που μία διεργασία καλεί μία κλήση συστήματος το ΛΣ εκτελεί έναν έλεγχο ώστε να επιβεβαιώσει ότι πράγματι η διεργασία αυτή έχει δικαίωμα να εκτελέσει τη συγκεκριμένη πράξη στον συγκεκριμένο πόρο (π.χ. ανάγνωση αρχείου). Τα δικαιώματα πρόσβασης των διαφορετικών χρηστών του συστήματος (άρα και των διεργασιών που αυτοί δημιουργούν μέσω των προγραμμάτων που εκτελούν), διατηρούνται από το ΛΣ σε κατάλληλες δομές δεδομένων. Οι κλήσεις συστήματος διαχειρίζονται τους ίδιους πόρους για λογαριασμό διαφορετικών διεργασιών, με αποτέλεσμα να προσπελαύνουν και να τροποποιούν κατά τη λειτουργία τους τις ίδιες εσωτερικές δομές δεδομένων του πυρήνα. Το λειτουργικό σύστημα αναλαμβάνει να συντονίσει τις κλήσεις συστήματος που εκτελούνται από κάθε διεργασία ώστε να μην προξενούνται προβλήματα. Ακόμη, ο χρονοπρογραμματιστής του πυρήνα επιβλέπει κάθε κλήση συστήματος, αφού πολλές από αυτές οδηγούν σε αναστολή της καλούσας διεργασίας μέχρι να απελευθερωθεί κάποιος πόρος ή να ικανοποιηθεί κάποια άλλη συνθήκη. Unix[Επεξεργασία | επεξεργασία κώδικα] Κύριο λήμμα: POSIX Στα συστήματα Unix οι κλήσεις συστήματος, οι οποίες χαρακτηρίζονται από ένα αναγνωριστικό όνομα και έναν αριθμό παραμέτρων, εκτελούνται μέσα από κατάλληλες συναρτήσεις της γλώσσας προγραμματισμού C, ομαδοποιημένες σε βιβλιοθήκες του συστήματος. Οι βιβλιοθήκες αυτές συνήθως διατηρούν εσωτερική «κατάσταση» (καθολικές μεταβλητές και δομές δεδομένων), οπότε συνδέονται στατικά κατά τη μεταγλώττιση ενός προγράμματος με αυτό· έτσι κάθε εφαρμογή έχει ενσωματωμένο το δικό της στιγμιότυπο των βιβλιοθηκών συστήματος που χρησιμοποιεί. Κάθε κλήση συστήματος επιστρέφει έναν ακέραιο αριθμό στη συνάρτηση που την κάλεσε· αρνητική τιμή επιστροφής σημαίνει αποτυχία ενώ θετική σημαίνει επιτυχία. Σε περίπτωση αποτυχίας ο κωδικός λάθους αποθηκεύεται στην errno, μία εσωτερική καθολική μεταβλητή που διατηρεί αυτομάτως το λειτουργικό σύστημα για κάθε διεργασία ξεχωριστά. Η τιμή της errno διατηρείται μέχρι την επόμενη κλήση συστήματος, ασχέτως αν αυτή θα είναι επιτυχής ή αποτυχημένη. Το μήνυμα που αντιστοιχεί στον τρέχοντα κωδικό λάθους της errno επιστρέφεται από τη συνάρτηση strerror() που παρέχει η γλώσσα C σε περιβάλλοντα Unix, ενώ εκτύπωση αυτού του μηνύματος γίνεται με την αντίστοιχη συνάρτηση perror(). Η προγραμματιστική διασύνδεση των κλήσεων συστήματος των διαφόρων εκδοχών του Unix οριστικοποιήθηκε με τη σειρά προτύπων POSIX (IEEE 1003), τα οποία επίσης καθόριζαν και άλλες λεπτομέρειες του ΛΣ όπως το κέλυφος γραμμής εντολών. Έτσι ο πηγαίος κώδικας ενός προγράμματος μπορεί να μεταγλωττιστεί επιτυχώς σε οποιοδήποτε λειτουργικό σύστημα ακολουθεί το πρότυπο POSIX χωρίς να χρειαστεί αλλαγές, ενώ η συμμόρφωση με το POSIX αποτελεί προϋπόθεση για να μπορεί ένα λειτουργικό σύστημα να αποκαλείται Unix. Windows[Επεξεργασία | επεξεργασία κώδικα] Κύριο λήμμα: Διασύνδεση Προγραμματισμού Εφαρμογών Windows Πηγές[Επεξεργασία | επεξεργασία κώδικα] Αρχιτεκτονική Υπολογιστών: Μια Δομημένη Προσέγγιση, Tanenbaum Andrew S., Εκδ. Κλειδάριθμος Σύγχρονα Λειτουργικά Συστήματα, Tanenbaum Andrew S., Εκδ. Κλειδάριθμος"
    },
    {
        "id": 25,
        "url": "https://el.wikipedia.org/wiki/Microsoft_Windows",
        "title": "Microsoft Windows",
        "content": "Το λήμμα δεν περιέχει πηγές ή αυτές που περιέχει δεν επαρκούν. Μπορείτε να βοηθήσετε προσθέτοντας την κατάλληλη τεκμηρίωση. Υλικό που είναι ατεκμηρίωτο μπορεί να αμφισβητηθεί και να αφαιρεθεί. Η σήμανση τοποθετήθηκε στις 13/10/2016. Microsoft WindowsΓενικά ΔημιουργοίMicrosoftΗμερ. Δημιουργίας20 Νοέμβριος 1985ΕίδοςMS-DOS/9x-based, Windows CE, Windows NT Διανομή Έκδοση10.0.22000.556 (8 Μάρτιος 2022)Δοκιμαστική έκδοση10.0.22567.200 (7 Μάρτιος 2022)ΛειτουργικάΑρχιτεκτονικήΑρχιτεκτονική ARM, x86Διαχείριση πακέτωνMicrosoft StoreΔιαθέσιμο σε137 γλώσσεςΠροκάτοχοςMS-DOS Ανάπτυξη ΤύποςΛειτουργικό ΣύστημαΓραφικό περιβάλλονΔιεπαφή Προγραμματισμού Εφαρμογών Windows, NET FrameworkΓραμμένο σεC,C++,AssemblyΚατάστασηΕνεργήΆδεια χρήσηςMS-EULA Σύνδεσμοι Επίσημος ιστότοποςMicrosoft Windows Τα Microsoft Windows (ή απλά Windows) είναι μια σειρά από λειτουργικά συστήματα για προσωπικούς υπολογιστές και διακομιστές. Η σειρά εμφανίστηκε πρώτα από τη Microsoft το 1985 για να ανταγωνιστεί το καινούριο σύστημα της Apple, τον Apple Macintosh, το οποίο χρησιμοποιούσε γραφικό περιβάλλον. Τα Microsoft Windows τελικά επικράτησαν στην παγκόσμια αγορά προσωπικών υπολογιστών με ένα μερίδιο αγοράς που υπολογίζεται περίπου στο 90%. Τα Microsoft Windows είναι λογισμικό κλειστού κώδικα. Tα Windows αναπτύχθηκαν για τους IBM συμβατούς μικροϋπολογιστές, οι οποίοι ήταν βασισμένοι στην αρχιτεκτονική x86 της Intel και σήμερα σχεδόν όλες οι εκδόσεις των Windows είναι κατασκευασμένες για αυτή την πλατφόρμα. Από τον Σεπτέμβριο του 2022, η πιο πρόσφατη έκδοση των Windows για υπολογιστές, tablet και ενσωματωμένες συσκευές είναι τα Windows 11. Οι πιο πρόσφατες εκδόσεις για υπολογιστές διακομιστή είναι ο Windows Server 2022. Μια εξειδικευμένη έκδοση των Windows εκτελείται στην κονσόλα παιχνιδιών Xbox One. Εκδόσεις των Windows[Επεξεργασία | επεξεργασία κώδικα] Εκδόσεις DOS[Επεξεργασία | επεξεργασία κώδικα] Windows 1.0 Κύριο λήμμα: Windows 1.0 Τα Windows 1.0 ήταν ένα γραφικό περιβάλλον λειτουργίας 16-bit, που κυκλοφόρησε στις 20 Νοεμβρίου 1985, από την αμερικανική εταιρεία Microsoft. Ήταν η πρώτη προσπάθεια της Microsoft να εφαρμόσει μία multitasking γραφική διεπαφή χρήστη-λειτουργικού περιβάλλοντος που βασίζονται στην πλατφόρμα του υπολογιστή. Windows 2.0 Κύριο λήμμα: Windows 2.0 Τα Windows 2.0 ήταν ένα 16-bit λειτουργικό περιβάλλον της σειράς προϊόντων Micrososft Windows . Χρησιμοποιούσε ως βάση το λειτουργικό σύστημα MS-DOS. Ήταν το επόμενο προϊόν μετά τα Windows 1.0 Τα Windows 2.0 συμπληρώθηκαν με τα Windows/286 και Windows/386 το 1988. Windows 2.1x Κύριο λήμμα Windows 2.1x Τα Windows 2.1x (με κωδικό όνομα Blaze) είναι μια σειρά λειτουργικών συστημάτων λειτουργικών περιβαλλόντων βασισμένα σε γραφικά περιβάλλοντα και δημιουργήθηκε από την Microsoft. Αποτελείται από τα Windows/286 και Windows/386, τα οποία κυκλοφόρησαν 27 Μαΐου του 1988, λιγότερο από έξι μήνες μετά τα Windows 2.0. Windows 3.0 Κύριο λήμμα: Windows 3.0 Τα Windows 3.0 είναι η τρίτη μεγάλη έκδοση των Microsoft Windows, και κυκλοφόρησαν στις 22 Μαΐου 1990. Έγινε η πρώτη πολύ επιτυχημένη έκδοση των Windows και έγινε ισχυρός αντίπαλος για τα υπόλοιπα λειτουργικά συστήματα. Τα Windows 3.1 ακολούθησαν την έκδοση των Windows 3.0. Windows 3.1x Κύριο λήμμα: Windows 3.1x Τα Windows 3.1x (με κωδικό όνομα Janus) είναι μια σειρά λειτουργικών συστημάτων 16-bit που δημιουργήθηκε από την Microsoft για χρήση σε προσωπικούς υπολογιστές. Η σειρά ξεκίνησε με τα Windows 3.1 τον Απρίλιο του 1992 ως ο διάδοχος των Windows 3.0. Windows 9x[Επεξεργασία | επεξεργασία κώδικα] Windows 95 Κύριο λήμμα: Windows 95 Τα Windows 95 (με κωδικό όνομα Chicago) είναι μια προσανατολισμένη προς τον καταναλωτή γραφική διεπαφή χρήστη με βάση το λειτουργικό σύστημα. Κυκλοφόρησαν στις 24 Αυγούστου 1995 από τη Microsoft, και ήταν μια σημαντική εξέλιξη από τις προηγούμενες εκδόσεις των Windows. Windows 98 Κύριο λήμμα: Windows 98 Τα Windows 98 (με κωδικό όνομα Memphis) είναι ένα γραφικό λειτουργικό σύστημα της Microsoft. Παρουσιάστηκε στους κατασκευαστές στις 15 Μαΐου 1998 και στα καταστήματα στις 25 Ιουνίου 1998. Τα Windows 98 αντικατέστησαν τα Windows 95 Windows Me Κύριο λήμμα: Windows Me Τα Windows Me (Millennium Edition) ήταν σχεδιασμένα για χρήση σε οικιακούς υπολογιστές και παρείχαν αρκετές βελτιώσεις στις λειτουργίες μουσικής, βίντεο και οικιακής δικτύωσης, καθώς επίσης και στην αξιοπιστία, σε σύγκριση με τις προηγούμενες εκδόσεις. Τα Windows Me κυκλοφόρησαν στις 14 Σεπτεμβρίου του 2000. Windows NT[Επεξεργασία | επεξεργασία κώδικα] Πρώτες εκδόσεις Windows NT 3.1 Κύριο λήμμα: Windows NT 3.1 Τα Windows NT 3.1 ήταν η πέμπτη έκδοση των Micrososft Windows και ανήκει στην οικογένεια της Microsoft. Κυκλοφόρησαν στις 27 Ιουλίου του 1993 και ήταν η πρώτη έκδοση των Windows NT (New Technology -ελλ. Νέα Τεχνολογία-). Τα Windows NT 3.1 τα διαδέχτηκαν τα Windows NT 3.5. Windows NT 3.5 Κύριο λήμμα: Windows NT 3.5 Τα Windows NT 3.5 (με κωδικό όνομα Daytona) είναι ένα λειτουργικό σύστημα που δημιουργήθηκε από τη Microsoft και κυκλοφόρησε στις 21 Σεπτεμβρίου 1994. Είναι η δεύτερη έκδοση των Windows NT και ο διάδοχος των Windows NT 3.1. Windows NT 3.51 Κύριο λήμμα: Windows NT 3.51 Τα Windows NT 3.51 είναι ένα λειτουργικό σύστημα που δημιουργήθηκε από τη Microsoft και κυκλοφόρησε στις 30 Μαΐου του 1995. Είναι η τρίτη έκδοση των Windows NT και ο διάδοχος των Windows NT 3.5. Τα Windows NT 3.51 διαδέχτηκαν τα Windows NT 4.0. Η υποστήριξη των Windows NT 3.51 έληξε στις 31 Δεκεμβρίου του 2001. Windows NT 4.0 Κύριο λήμμα: Windows NT 4.0 Τα Windows NT 4.0 είναι ένα προληπτικό πολλαπλών εργασιών γραφικό λειτουργικό σύστημα 32-bit που δημιουργήθηκε από τη Microsoft και κυκλοφόρησε στις 31 Ιουλίου 1996. Σχεδιάστηκε για υπολογιστές uniprocessor ή συμμετρικής πολυεπεξεργασίας και είναι μέρος της σειράς λειτουργικών συστημάτων με όνομα Windows NT. Windows 2000 Κύριο λήμμα: Windows 2000 Εκδόσεις πελατών Τα Windows 2000 είναι ένα λειτουργικό σύστημα που κυκλοφόρησαν για βιομηχανοποίηση στις 15 Δεκεμβρίου του 1999 και διαθέσιμα στις 17 Φεβρουαρίου του 2000 και είναι ο διάδοχος των Windows NT 4.0. Windows XP Κύριο λήμμα: Windows XP Τα Windows XP (κωδικός Whistler, επίσης γνωστά ως Windows NT 5.1) είναι ένα λειτουργικό σύστημα των Windows της Microsoft για προσωπικούς υπολογιστές. Κυκλοφόρησε στις 25 Οκτωβρίου 2001. Windows Vista Κύριο λήμμα: Windows Vista Τα Windows Vista (με κωδική ονομασία Longhorn) είναι μία έκδοση του λειτουργικού συστήματος Microsoft Windows της Microsoft. Κυκλοφόρησαν στις 30 Ιανουαρίου 2007. Windows 7 Κύριο λήμμα: Windows 7 Τα Windows 7 (προηγουμένως γνωστά με τις κωδικές ονομασίες Blackcomb και Vienna) είναι ο διάδοχος των Windows Vista και κυκλοφόρησαν στις 22 Οκτωβρίου 2009 σε 32-bit και σε 64-bit εκδόσεις. Windows 8 και 8.1 Κύριο λήμμα: Windows 8 και Windows 8.1 Τα Windows 8 είναι έκδοση του λειτουργικού συστήματος Windows της Microsoft. Κυκλοφορήσαν στην αγορά στις 26 Οκτωβρίου 2012, όπως ανακοίνωσε η Microsoft. Προορίζονται για χρήση σε επιτραπέζιους και φορητούς υπολογιστές, καθώς και σε tablet. Τα Windows 8.1 (κωδική ονομασία Blue) είναι μια αναβάθμιση για τα Windows 8, μια έκδοση των Windows NT, ένα λειτουργικό σύστημα υπολογιστή που κυκλοφόρησε από τη Microsoft. Κυκλοφόρησε επίσημα στις 17 Οκτωβρίου του 2013, σχεδόν ένα χρόνο μετά την επίσημη έκδοση του προκατόχου του. Windows 10 Κύριο λήμμα: Windows 10 Τα Windows 10 είναι ένα λειτουργικό σύστημα της Microsoft για υπολογιστές, τα οποία κυκλοφόρησαν επισήμως στις 29 Ιουλίου του 2015 και αποτέλεσαν το νεότερο λειτουργικό σύστημα της εταιρίας μέχρι τις 5 Οκτωβρίου 2021, όπου και κυκλοφόρησε η επόμενη έκδοση των Windows, τα Windows 11. Windows 11 Κύριο λήμμα: Windows 11 Τα Windows 11 είναι μια σημαντική έκδοση του λειτουργικού συστήματος Windows NT που αναπτύχθηκε από τη Microsoft και ανακοινώθηκε στις 24 Ιουνίου 2021 και είναι ο διάδοχος των Windows 10, που κυκλοφόρησαν το 2015. Τα Windows 11 κυκλοφόρησαν στις 5 Οκτωβρίου 2021, ως δωρεάν αναβάθμιση μέσω του Windows Update για κατάλληλες συσκευές με Windows 10. Windows Server Windows Server 2003 Κύριο λήμμα: Windows Server 2003 Τα Windows Server 2003 είναι λειτουργικό σύστημα της Microsoft και κυκλοφόρησε στις 24 Απριλίου του 2003. Βασίζονται στα Windows XP και είναι μια ενισχυμένη έκδοση. Δύο χρόνια αργότερα, το 2005, μια καινούρια έκδοση των Windows Server 2003 κυκλοφόρησε με όνομα Windows Server 2003 R2 Windows Server 2008 Windows Server 2012 Windows Server 2016 Windows Server 2019 Windows Server 2022 Εξειδικευμένες εκδόσεις Windows Preinstallation Environment Windows Embedded[Επεξεργασία | επεξεργασία κώδικα] Embedded Compact Κύριο λήμμα: Windows CE Τα Windows CE είναι λειτουργικό σύστημα της Microsoft για μικρούς υπολογιστές, προσωπικούς βοηθούς και ενσωματωμένα συστήματα. Η τελευταία έκδοσή του (6.0) αναφέρεται επίσημα ως Windows Embedded CE. Είναι λειτουργικό διαφορετικό από τα Windows για προσωπικούς υπολογιστές και βασίζεται σε πυρήνα που αναπτύχθηκε ανεξάρτητα. CE 5.0 Embedded CE 6.0 Embedded Compact 7 Embedded Automotive Embedded Industry Embedded 8 Windows Mobile[Επεξεργασία | επεξεργασία κώδικα] Pocket PC 2000 Κύριο λήμμα: Pocket PC 2000 Τα Pocket PC 2000 (με κωδικό όνομα Rapier) είναι η πρώτη έκδοση του Windows Mobile. Κυκλοφόρησαν στις 19 Απριλίου του 2000, ήταν βασισμένα στα Windows CE 3.0 και ήταν ο διάδοχος των Palm-size PCs, με συμβατότητα να ήταν διαθέσιμη για εφαρμογές των Palm-size PCs. Pocket PC 2002 Mobile 2003 Mobile 5.0 Mobile 6.0 Mobile 6.1 Mobile 6.5 Windows Phone[Επεξεργασία | επεξεργασία κώδικα] Phone 7 Κύριο λήμμα: Phone 7 Τα Windows Phone 7 ανακοινώθηκαν στις 15 Φεβρουαρίου του 2010 και κυκλοφόρησαν στις 8 Νοεμβρίου του 2010 στις ΗΠΑ. Το 2011, η Microsoft κυκλοφόρησε τα Windows Phone 7.5 “Mango”. Η αναβάθμιση περιλάμβανε τον φυλλομετρητή Internet Explorer 9. Μια μικρή αναβάθμιση κυκλοφόρησε το 2012 γνωστή ως “Tango”, περιλάμβανε επιδιορθώσεις σφαλμάτων και το λειτουργικό σύστημα χρειαζόταν λιγότερες απαιτήσεις υλισμικού, για να λειτουργήσει σε έξυπνα τηλέφωνα με επεξεργαστική ισχή 800 MHz και 256GB RAM. Phone 8 Phone 8.1 10 (mobile) Ακυρωθείσες εκδόσεις[Επεξεργασία | επεξεργασία κώδικα] Cairo Κύριο λήμμα: Cairo Τα Windows Cairo ήταν το κωδικό όνομα ενός έργου στη Microsoft από το 1991 έως το 1996.Τα Windows Cairo δεν κυκλοφόρησαν ποτέ, παρόλο που τμήματα των τεχνολογιών του έχουν έκτοτε εμφανιστεί σε άλλα προϊόντα Nashville Κύριο λήμμα: Nashville Τα Windows Nashville (πρώην Cleveland) ήταν μια ακυρωθείσα έκδοση των Windows. Κυκλοφόρησαν το 1996, ανάμεσα σε Chicago (Windows 95) και Memphis (Windows 98), και αναφερόταν δημόσια ως και Windows 96. Nepture Κύριο λήμμα Neptune Τα Windows Neptune ήταν μια ακυρωθείσα έκδοση των Windows. Κυκλοφόρησαν στις 27 Δεκεμβρίου του 1999 και βασιζόταν στα Windows 2000. Ήταν η πρώτη έκδοση των Windows που ήταν σχεδιασμένη στον κώδικα των Windows NT και αντικατέστησε τις εκδόσεις Windows 9x. Odyssey Κύριο λήμμα: Odyssey Το Windows Odyssey είναι η κωδική ονομασία μιας έκδοσης του λειτουργικού συστήματος Micrososft Windows, η οποία ακυρώθηκε και προοριζόταν να ακολουθήσει την έκδοση Windows 2000. Αργότερα συνδυάστηκε με τα Windows Neptune για τη δημιουργία των Windows XP. Λογότυπο[Επεξεργασία | επεξεργασία κώδικα] 1985-1992 1992-1995 1995-2001 2001-2007 2007-2009 2009-2012 2012-2021 2021-Σήμερα Δείτε επίσης[Επεξεργασία | επεξεργασία κώδικα] Windows CE Windows Mobile Windows Phone Παραπομπές[Επεξεργασία | επεξεργασία κώδικα] ↑ Error: Unable to display the reference properly. See the documentation for details. ↑ Error: Unable to display the reference properly. See the documentation for details. ↑ Error: Unable to display the reference properly. See the documentation for details. ↑ http://www.zdnet.com/windows-8s-delivery-date-october-26-7000001158/ Εξωτερικοί σύνδεσμοι[Επεξεργασία | επεξεργασία κώδικα] Commons logo Τα Wikimedia Commons έχουν πολυμέσα σχετικά με το θέμα Microsoft Windows Επίσημος ιστότοπος Blog Microsoft Developer Network InformIT- Ιστορία των Microsoft Windows πσεΕκδόσεις των Microsoft WindowsΕκδόσεις DOS Windows 1.0 Windows 2.0 Windows 2.1x Windows 3.0 Windows 3.1x Windows 9x Windows 95 (Ανάπτυξη) Windows 98 Windows Me Windows NTΠρώτες εκδόσεις Windows NT 3.1 Windows NT 3.5 Windows NT 3.51 Windows NT 4.0 Windows 2000 Εκδόσεις πελατών Windows XP εκδόσεις x64 Media Center Fundamentals Windows Vista εκδόσεις Windows 7 εκδόσεις Windows 8 εκδόσεις 8.1 RT Windows 10 εκδόσεις Windows 11 Windows Server Server 2003 Home Server Server 2008 EBS 2008 HPC Server 2008 Server 2008 R2 Home Server 2011 Server 2012 Server 2016 Server 2019 MultiPoint Server Server Essentials Εξειδικευμένες εκδόσεις Windows Preinstallation Environment Windows Embedded Embedded Compact CE 5.0 Embedded CE 6.0 Embedded Compact 7 Embedded Automotive Embedded Industry Embedded 8 Windows Mobile Pocket PC 2000 Pocket PC 2002 Mobile 2003 Mobile 5.0 Mobile 6.0 Mobile 6.1 Mobile 6.5 Windows Phone Phone 7 Phone 8 Phone 8.1 10 (mobile) Ακυρωθείσες εκδόσεις Cairo Nashville Neptune Odyssey πσεΣτοιχεία των WindowsΕργαλεία διαχείρισης Γραμμή εντολών Πίνακας Ελέγχου Εκκαθάριση Δίσκου Ανασυγκρότηση Δίσκου Ρυθμίσεις Επαναφορά Συστήματος Διαχείριση Εργασιών Windows Error Reporting Windows Ink Windows Installer PowerShell Windows Update Εφαρμογές 3D Builder Alarms & Clock Αριθμομηχανή Ημερολόγιο Κάμερα Πίνακας χαρακτήρων Cortana Edge Fax and Scan Feedback Hub Get Help Groove Μεγεθυντικός φακός Mail Maps Media Player Movies & TV Mobility Center Αφηγητής Σημειωματάριο OneDrive OneNote Ζωγραφική Paint 3D People Phone Companion Φωτογραφίες Quick Assist Εργαλείο αποκομμάτων Speech Recognition Skype Sticky Notes View 3D Store Tips Ηχογράφηση Wallet Windows To Go WordPad Xbox Ασφάλεια Windows Defender Windows Firewall Που έχουν αποσυρθείΠαιχνίδια Solitaire Hearts 3D Pinball FreeCell Chess Titans Purble Place Inkball Hold 'Em Spider Solitaire Tinker Εφαρμογές ActiveMovie Anytime Upgrade Address Book Backup and Restore Cardfile CardSpace Contacts Desktop Gadgets Diagnostics DriveSpace Δημιουργία DVD Easy Transfer Fax File Manager Help and Support Center HyperTerminal Internet Explorer Journal Media Center Meeting Space Messaging Messenger Mobile Device Center Movie Maker NetMeeting NTBackup Outlook Express Συλλογή φωτογραφιών Program Manager Steps Recorder WinHelp Write Λοιπά Scandisk Προστασία αρχείων Video for Windows Windows SideShow Windows Services for UNIX Windows System Assessment Tool Μετακινήθηκαν στο Windows Store DVD Player Hover! Mahjong Minesweeper Καθιερωμένοι όροι VIAF: 230666902 LCCN: n88027331 GND: 4192183-5 BNF: cb14400232k (data) BIBSYS: 7006728 NKC: ph117055"
    },
    {
        "id": 26,
        "url": "https://el.wikipedia.org/wiki/IDLE_(Python)",
        "title": "IDLE (Python)",
        "content": "IDLE (Python)IDLE σε περιβάλλον Ubuntu: Το παράθυρο ρύθμισης της επισήμανσης σύνταξης και πίσω το κέλυφος της Python Γενικά Ημερ. Δημιουργίας22 Δεκέμβριος 1998Είδοςολοκληρωμένο περιβάλλον ανάπτυξης, βιβλιοθήκη, ελεύθερο λογισμικό Διανομή Έκδοση3.11.0 (24 Οκτώβριος 2022)ΛειτουργικάΑνεξάρτητο πλατφόρμας Ανάπτυξη Υπευθ. ανάπτυξηςΓκίντο βαν ΡόσσουμΓραμμένο σεPython Σύνδεσμοι Επίσημος ιστότοποςhttps://python.org/idleΑποθετήριο κώδικαhttps://github.com/python/cpython/tree/master/Lib/idlelib Το IDLE (συντομογραφία του Integrated DeveLopment Environment ή Integrated Development and Learning Environment) είναι ένα ολοκληρωμένο περιβάλλον ανάπτυξης (IDE) για την γλώσσα προγραμματισμού Python και παρέχεται δωρεάν μαζί με την εγκατάσταση από την έκδοση 1.5.2 beta. Είναι εξολοκλήρου γραμμένο σε Python και επειδή ως γραφικό περιβάλλον χρήστη (GUI) χρησιμοποιεί το Tkinter toolkit, μπορεί να εκτελεσθεί σε περιβάλλον Linux, Microsoft Windows και Mac OS X. Πιθανολογείται ότι το όνομα προήλθε από ένα μέλος της κωμικής σειράς «Monty Python's Flying Circus», τον Eric Idle. Ιστορία[Επεξεργασία | επεξεργασία κώδικα] Ο Γκίντο βαν Ρόσσουμ (Guido van Rossum), όταν ξεκίνησε να δημιουργεί το IDLE δεν είχε πολύ χρόνο να το τελειοποιήσει, οπότε αποφάσισε κάθε βελτίωση να την κυκλοφορεί όσο πιο σύντομα μπορούσε και με συχνότερες εκδόσεις. IDLE 0.1, είναι πρώτη πρόχειρη έκδοση, η οποία κυκλοφόρησε στις 16 Οκτωβρίου του 1998 και απευθυνόταν στα συνδρομητικά μέλη της Python,[Σημ 1] που είχαν την έκδοση 1.5.2 alpha. IDLE 0.2, κυκλοφορεί στις 8 Ιανουαρίου του 1999, που λειτουργεί σε Unix ή Windows (NT ή 9x), Tcl/Tk 8.0 και Python έκδοση 1.5.2 beta. Χαρακτηριστικά[Επεξεργασία | επεξεργασία κώδικα] Το IDLE να είναι ένα απλό IDE, κατάλληλο για αρχάριους, ιδιαιτέρως σε εκπαιδευτικό περιβάλλον. Σύμφωνα με το IDLE Help της εφαρμογής τα κύρια χαρακτηριστικά είναι: Κειμενογράφος που υποστηρίζει πολλαπλά παράθυρα με χρωματική επισήμανση σύνταξης (syntax highlighting), αυτόματη συμπλήρωση εντολών (autocompletion), κατάλληλη στοίχιση των εντολών με την έξυπνη χρήση των εσοχών και άλλα. Το κέλυφος (shell) της διαδραστικής χρήσης της Python με χρωματική επισήμανση σύνταξης. Ενσωματωμένο εργαλείο αποσφαλμάτωσης (debugger) για την παρακολούθηση της εκτέλεσης του κώδικα με σκοπό την εύρεση σφαλμάτων. Σημειώσεις[Επεξεργασία | επεξεργασία κώδικα] ↑ Μέλη της τότε Python Software Activity (PSA), η οποία αργότερα αντικαταστάθηκε από την Python Software Foundation (PSF). Παραπομπές[Επεξεργασία | επεξεργασία κώδικα] ↑ «Python 3.11.0 is now available». 24 Οκτώβριος 2022. ↑ 2,0 2,1 2,2 Guido van Rossum (8 Ιανουαρίου 1999). «Subject: IDLE 0.2 -- Integrated DeveLopment Environment for Python». Ανακτήθηκε στις 10 Σεπτεμβρίου 2019. ↑ Από την επιλογή: Help > About, του ίδιου του λογισμικού (του IDLE) ↑ «24.6. IDLE». Python 2.7.16 documentation (στα Αγγλικά). Python Software Foundation. Αρχειοθετήθηκε από το πρωτότυπο στις 6 Μαΐου 2019. Ανακτήθηκε στις 10 Σεπτεμβρίου 2019. ↑ 5,0 5,1 5,2 5,3 5,4 Αγγελιδάκης, Ν., βλ. πηγές σελ. 13 (σελ. 22 του pdf) ↑ 6,0 6,1 Guido van Rossum (16 Οκτωβρίου 1998). «IDLE 0.1 -- a Python IDE». Linux Weekly News (στα Αγγλικά). Αρχειοθετήθηκε από το πρωτότυπο στις 25 Σεπτεμβρίου 2018. Ανακτήθηκε στις 10 Σεπτεμβρίου 2019. Πηγές[Επεξεργασία | επεξεργασία κώδικα] Αγγελιδάκης, Νικόλαος Α., Εκπαιδευτικός Πληροφορικής, Μ.Δ.Ε. (M.Sc.) στην Επιστήμη Υπολογιστών (Ηράκλειο, Αύγουστος 2015). \"Εισαγωγή στον προγραμματισμό με την Python\". Αρχειοθετήθηκε 12/06/2018 Ανακτήθηκε 07/04/2019. (ISBN 978-960-93-7364-7). Ηλεκτρονικό βιβλίο 150 σελίδων, για αρχάριους και με άδεια: CC BY-SA 4.0. Εξωτερικοί σύνδεσμοι[Επεξεργασία | επεξεργασία κώδικα] IDLE home page in the Python documentation IDLE page in the Python wiki A guide to using IDLE"
    },
    {
        "id": 27,
        "url": "https://el.wikipedia.org/wiki/%CE%9F%CE%BB%CE%BF%CE%BA%CE%BB%CE%B7%CF%81%CF%89%CE%BC%CE%AD%CE%BD%CE%BF_%CF%80%CE%B5%CF%81%CE%B9%CE%B2%CE%AC%CE%BB%CE%BB%CE%BF%CE%BD_%CE%B1%CE%BD%CE%AC%CF%80%CF%84%CF%85%CE%BE%CE%B7%CF%82",
        "title": "Ολοκληρωμένο περιβάλλον ανάπτυξης",
        "content": "Το λήμμα παραθέτει τις πηγές του αόριστα, χωρίς παραπομπές. Βοηθήστε συνδέοντας το κείμενο με τις πηγές χρησιμοποιώντας παραπομπές, ώστε να είναι επαληθεύσιμο. Το πρότυπο τοποθετήθηκε χωρίς ημερομηνία. Για τη σημερινή ημερομηνία χρησιμοποιήστε: {{χωρίς παραπομπές|11|01|2025}} Ένα ολοκληρωμένο περιβάλλον ανάπτυξης (integrated development environment, IDE) είναι μία σουίτα λογισμικού που βοηθάει στην ανάπτυξη προγραμμάτων υπολογιστή. Συνήθως ένα IDE περιλαμβάνει κάποιον επεξεργαστή πηγαίου κώδικα, έναν μεταγλωττιστή, εργαλεία αυτόματης παραγωγής κώδικα, αποσφαλματωτή, συνδέτη, σύστημα ελέγχου εκδόσεων και εργαλεία κατασκευής γραφικών διασυνδέσεων χρήστη για τις υπό ανάπτυξη εφαρμογές. Αυτό το λήμμα σχετικά με την Πληροφορική χρειάζεται επέκταση. Μπορείτε να βοηθήσετε την Βικιπαίδεια επεκτείνοντάς το."
    },
    {
        "id": 28,
        "url": "https://el.wikipedia.org/wiki/%CE%94%CE%B9%CE%B5%CF%81%CE%BC%CE%B7%CE%BD%CE%AD%CE%B1%CF%82_(%CF%85%CF%80%CE%BF%CE%BB%CE%BF%CE%B3%CE%B9%CF%83%CF%84%CE%AD%CF%82)",
        "title": "Διερμηνέας (υπολογιστές)",
        "content": "Το λήμμα παραθέτει τις πηγές του αόριστα, χωρίς παραπομπές. Βοηθήστε συνδέοντας το κείμενο με τις πηγές χρησιμοποιώντας παραπομπές, ώστε να είναι επαληθεύσιμο. Η σήμανση τοποθετήθηκε στις 06/02/2020. Στην πληροφορική διερμηνέας ή διερμηνευτής (interpreter) συνήθως σημαίνει ένα πρόγραμμα που εκτελεί ή ερμηνεύει εντολές σε κάποια γλώσσα προγραμματισμού. Η διερμήνευση και η μεταγλώττιση είναι τα δύο βασικά μέσα με τα οποία υλοποιούνται οι γλώσσες προγραμματισμού, αν και δεν αποτελούν εντελώς διακριτές κατηγορίες, καθώς οι λειτουργίες τους επικαλύπτονται σε κάποιον βαθμό. Διερμηνέας είναι ένα πρόγραμμα που είτε: εκτελεί τον πηγαίο κώδικα απευθείας μεταφράζει τον πηγαίο κώδικα σε μια περισσότερο αποδοτική μορφή (κώδικα) που αμέσως εκτελεί σαφώς εκτελεί προ-μεταγλωττισμένο κώδικα που έχει δημιουργήσει κάποιος μεταγλωττιστής που είναι μέρος του συστήματος διερμήνευσης. Με την τελευταία έννοια, ο επεξεργαστής είναι μιας μορφής διερμηνέας εντολών κώδικα μηχανής σε συνδυασμό με τον μεταγλωττιστή που τις παράγει. Η Perl, η Python, η MATLAB, και η Ruby είναι παραδείγματα γλωσσών που μεταφράζουν τον κώδικα σε αποδοτική μορφή, στο νούμερο 2 παραπάνω, ενώ η UCSD Pascal και η εικονική μηχανή της Java ανήκουν στο νούμερο 3 παραπάνω: τα προγράμματα Java μεταγλωττίζονται και αποθηκεύονται ως κώδικας bytecode, που στη συνέχεια συνδέεται κατά την ώρα της εκτέλεσης και εκτελείται από ένα διερμηνέα (εικονική μηχανή). Μερικά συστήματα όπως η Smalltalk συνδυάζουν τη δεύτερη και τρίτη κατηγορία. Ο όρος διερμηνευμένη γλώσσα σημαίνει ότι η κανονική υλοποίηση της γλώσσας είναι διερμηνέας ή μεταγλωττιστής. Μια γλώσσα υψηλού επιπέδου είναι βασικά μια αφαίρεση, που (ιδανικά) δεν εξαρτάται από κάποια συγκεκριμένη υλοποίηση. Θεωρητικά, οποιαδήποτε γλώσσα μπορεί να είναι είτε μεταγλωττισμένη είτε διερμηνευμένη, έτσι ο διαχωρισμός αυτός εφαρμόζεται μόνο με βάση την συνήθη πρακτική υλοποίησης, και όχι κάποια συγκεκριμένη ιδιότητα μιας γλώσσας. Πολλές γλώσσες έχουν υλοποιηθεί τόσο με χρήση μεταγλωττιστών όσο και με διερμηνείς, όπως η Lisp, η Pascal, η C, η BASIC και η Python. Η γλώσσα Java μεταφράζεται σε μια μορφή που προορίζεται συνήθως για διερμήνευση, αν και συχνά χρησιμοποιείται η μεταγλώττιση ακριβώς-στην-ώρα (just-in-time compilation) για να παράγει κώδικα μηχανής πριν την εκτέλεση. Οι γλώσσες .Net της Microsoft μεταγλωττίζονται στην CIL από την οποία συνήθως μεταγλωττίζονται στη συνέχεια σε κώδικα μηχανής, αν και υπάρχει εικονική μηχανή που μπορεί να διερμηνεύσει τη CIL. Αυτό το λήμμα σχετικά με την Πληροφορική χρειάζεται επέκταση. Μπορείτε να βοηθήσετε την Βικιπαίδεια επεκτείνοντάς το."
    },
    {
        "id": 29,
        "url": "https://el.wikipedia.org/wiki/%CE%94%CE%B5%CF%83%CE%BC%CE%B5%CF%85%CE%BC%CE%AD%CE%BD%CE%B7_%CE%BB%CE%AD%CE%BE%CE%B7_(%CF%85%CF%80%CE%BF%CE%BB%CE%BF%CE%B3%CE%B9%CF%83%CF%84%CE%AD%CF%82)",
        "title": "Δεσμευμένη λέξη (υπολογιστές)",
        "content": "Το λήμμα δεν περιέχει πηγές ή αυτές που περιέχει δεν επαρκούν. Μπορείτε να βοηθήσετε προσθέτοντας την κατάλληλη τεκμηρίωση. Υλικό που είναι ατεκμηρίωτο μπορεί να αμφισβητηθεί και να αφαιρεθεί. Η σήμανση τοποθετήθηκε στις 19/03/2015. Ο όρος δεσμευμένη λέξη ή λέξη-κλειδί (αγγλικά: reserved word ή reserved identifier ή keyword) στον προγραμματισμό, δηλώνει λέξη (ακολουθία χαρακτήρων) την οποία ο μεταγλωττιστής αντιλαμβάνεται σαν τελεστή κάποιας λειτουργίας. Για παράδειγμα η λέξη if συχνά θεωρείται δεσμευμένη και δηλώνει την έναρξη επιλογής. Οι δεσμευμένες λέξεις δεν μπορούν να χρησιμοποιηθούν σαν ονόματα μεταβλητών ή σταθερών. wiktionary logo Το Βικιλεξικό έχει σχετικό λήμμα: δεσμευμένη λέξη Αυτό το λήμμα σχετικά με την Πληροφορική χρειάζεται επέκταση. Μπορείτε να βοηθήσετε την Βικιπαίδεια επεκτείνοντάς το."
    },
    {
        "id": 30,
        "url": "https://el.wikipedia.org/wiki/%CE%A4%CF%8D%CF%80%CE%BF%CF%82_%CE%B4%CE%B5%CE%B4%CE%BF%CE%BC%CE%AD%CE%BD%CF%89%CE%BD",
        "title": "Τύπος δεδομένων",
        "content": "Στον προγραμματισμό υπολογιστών, ένας τύπος δεδομένων (data type) είναι μία κατηγοριοποίηση που προσδιορίζει διαφορετικούς τύπους από δεδομένα, όπως κινητής υποδιαστολής (floating-point), ακεραίους (integer), ή τύπους δεδομένων αλήθειας (Boolean), η οποία καθορίζει τις πιθανές τιμές για αυτόν τον τύπο, τις λειτουργίες που μπορούν να επιτελεστούν σε τιμές αυτού του τύπου, την σημασία των δεδομένων και τον τρόπο που οι τιμές αυτού του τύπου μπορούν να αποθηκευτούν. Οι τύποι δεδομένων χρησιμοποιούνται μέσα σε συστήματα τύπων (type systems), τα οποία προσφέρουν διάφορους τρόπους για τον ορισμό, την υλοποίηση και την χρήση τους. Διαφορετικά συστήματα τύπων εξασφαλίζουν διαφορετικούς βαθμούς ασφάλειας τύπων (type safety). Τυπικά, ένας τύπος μπορεί να οριστεί ως \"οποιαδήποτε ιδιότητα ενός προγράμματος την οποία μπορούμε να προσδιορίσουμε πριν την εκτέλεση του προγράμματος\". Επισκόπηση[Επεξεργασία | επεξεργασία κώδικα] Σχεδόν όλες οι γλώσσες προγραμματισμού περιλαμβάνουν ρητά την έννοια του τύπου δεδομένων, παρόλο που διαφορετικές γλώσσες μπορεί να χρησιμοποιούν διαφορετική ορολογία. Οι συνήθεις τύποι δεδομένων είναι: ακέραιοι (integers), τύποι δεδομένων αληθείας (booleans), χαρακτήρες (characters), κινητής υποδιαστολής (floating-point numbers), αλφαριθμητικές συμβολοσειρές (strings). Για παράδειγμα, στην γλώσσα προγραμματισμού Java, ο τύπος \"int\" αναπαριστά το σύνολο των 32-bit ακεραίων του οποίου οι τιμές ανήκουν στο διάστημα από -2,147,483,648 έως 2,147,483,647, όπως και τις λειτουργίες που μπορούν να εφαρμοστούν πάνω σε ακέραιους, όπως η πρόσθεση, η αφαίρεση και ο πολλαπλασιασμός. Τα χρώματα αφετέρου αναπαρίστανται από τρία bytes που υποδηλώνουν την ποσότητα από κόκκινο, πράσινο και μπλε, και μία συμβολοσειρά που αναπαριστά το όνομα του χρώματος. Οι επιτρεπτές λειτουργίες περιλαμβάνουν πρόσθεση και αφαίρεση, αλλά όχι πολλαπλασιασμό. Οι περισσότερες γλώσσες προγραμματισμού επιτρέπουν επίσης στον προγραμματιστή να ορίσει επιπλέον τύπους δεδομένων, συνήθως συνδυάζοντας πολλαπλά στοιχεία από άλλους τύπους και ορίζοντας τις έγκυρες λειτουργίες του νέου τύπου δεδομένων. Για παράδειγμα, ένας προγραμματιστής μπορεί να δημιουργήσει έναν καινούργιο τύπο δεδομένων που θα ονομάζεται \"μιγαδικός αριθμός\", ο οποίος θα περιλάμβανε πραγματικά και φανταστικά μέρη. Ένας τύπος δεδομένων αναπαριστά επίσης έναν περιορισμό στην ερμηνεία των δεδομένων σε ένα σύστημα τύπων, περιγράφοντας την αναπαράσταση, την ερμηνεία και την δομή των τιμών ή αντικειμένων που αποθηκεύονται στην μνήμη του υπολογιστή. Το σύστημα τύπων χρησιμοποιεί την πληροφορία του τύπου δεδομένων για να ελέγξει την ορθότητα των προγραμμάτων τα οποία έχουν πρόσβαση ή χειρίζονται τα δεδομένα. Κλάσεις τύπων δεδομένων[Επεξεργασία | επεξεργασία κώδικα] Τύποι δεδομένων μηχανής[Επεξεργασία | επεξεργασία κώδικα] Όλα τα δεδομένα στους υπολογιστές που βασίζονται σε ψηφιακά ηλεκτρονικά κυκλώματα αναπαρίστανται ως bit (εναλλακτικές 0 και 1) στο πιο χαμηλό επίπεδο. Η μικρότερη μονάδα δεδομένων που μπορεί να διευθυνσιοδοτηθεί είναι συνήθως μια ομάδα από bit που αποκαλούνται byte (συνήθως μία οκτάδα (octet), που είναι 8 bit). Η μονάδα που μπορεί να επεξεργαστεί από εντολές γλώσσας μηχανής ονομάζεται λέξη (word) (η οποία από το 2011 είναι τυπικά 32 ή 64 bit). Οι περισσότερες εντολές ερμηνεύουν την λέξη ως έναν δυαδικό αριθμό, έτσι ώστε ένας 32 bit αριθμός να μπορεί να αναπαραστήσει μη προσημασμένες ακέραιες τιμές από 0 έως 2 32 − 1 {\\displaystyle 2^{32}-1} ή προσημασμένες ακέραιες τιμές από − 2 31 {\\displaystyle -2^{31}} έως 2 31 − 1 {\\displaystyle 2^{31}-1} . Λόγω του συμπληρώματος ως προς 2, η μηχανή και η γλώσσα μηχανής ως επί το πλείστον δεν χρειάζεται να διακρίνουν τους μη προσημασμένους από τους προσημασμένους τύπους δεδομένων. Υπάρχει ένα συγκεκριμένο σύνολο εντολών αριθμητικών πράξεων, οι οποίες χρησιμοποιούν διαφορετική ερμηνεία των bit μίας λέξης σαν έναν αριθμό κινητής υποδιαστολής. Οι τύποι δεδομένων μηχανής είναι αναγκαίο να εκτίθενται ή είναι διαθέσιμοι σε συστήματα ή χαμηλού επιπέδου γλώσσες προγραμματισμού ώστε να επιτρέπουν τον ευέλικτο έλεγχο του υλικού (hardware). Η γλώσσα προγραμματισμού C για παράδειγμα είναι εφοδιασμένη με τύπους δεδομένων διαφόρων μεγεθών, όπως ο short και ο long. Αν ένας αντίστοιχος εγγενής (native) τύπος δεν υπάρχει στην πλατφόρμα στόχο, ο μεταγλωττιστής θα τον \"σπάσει\" σε κώδικα που χρησιμοποιεί τύπους που υπάρχουν. Για παράδειγμα, αν ζητείται ένας ακέραιος των 32 bit σε μία πλατφόρμα των 16 bit, ο μεταγλωττιστής θα τον αντιμετωπίσει σιωπηρά ως έναν πίνακα από δύο ακεραίους των 16 bit. Πολλές γλώσσες επιτρέπουν δυαδικά και δεκαεξαδικά λεκτικά (literals), για τον εύκολο χειρισμό δεδομένων μηχανής. Σε υψηλότερου επιπέδου προγραμματισμό, οι τύποι δεδομένων μηχανής είναι συνήθως κρυμμένοι ή αφηρημένοι (abstracted) ως μία λεπτομέρεια της υλοποίησης που θα καθιστούσε τον κώδικα λιγότερο μεταφέρσιμο αν ήταν φανερή στον χρήστη. Για παράδειγμα, μπορεί να παρέχεται ένας γενικευμένος αριθμητικός τύπος αντί ενός τύπου συγκεκριμένου μεγέθους. Ο τύπος δεδομένων αληθείας[Επεξεργασία | επεξεργασία κώδικα] Κύριο: Τύπος δεδομένων αλήθειας Ο τύπος δεδομένων αληθείας αναπαριστά τις τιμές: αληθές και ψευδές. Παρότι μόνο δύο τιμές είναι πιθανές, σπάνια αναπαρίστανται στους υπολογιστές με ένα μόνο δυαδικό ψηφίο για λόγους αποδοτικότητας. Πολλές γλώσσες προγραμματισμού δεν είναι εφοδιασμένες με ρητό τύπο αληθείας. Αντί αυτού ερμηνεύουν το 0 (για παράδειγμα) ως ψευδές και τις υπόλοιπες τιμές ως αληθείς. Αριθμητικοί τύποι δεδομένων[Επεξεργασία | επεξεργασία κώδικα] Κάποια παραδείγματα αριθμητικών τύπων δεδομένων είναι: Ο ακέραιος (integer) τύπος δεδομένων, ή ολόκληρος αριθμός. Μπορεί να έχει υποτύπους ανάλογα με την ικανότητά τους να συμπεριλαμβάνουν αρνητικές τιμές (για παράδειγμα unsigned στην γλώσσα C και C++). Μπορεί επίσης να έχει έναν μικρό αριθμό από προκαθορισμένους υποτύπους (όπως ο short και ο long στην C/C++) ή να επιτρέπουν στους χρήστες να ορίσουν ελεύθερα υποτμήματα όπως το 1..12 (για παράδειγμα οι Pascal/Ada). Ο τύπος δεδομένων κινητής υποδιαστολής (floating point), ο οποίος αποκαλείται κάποιες φορές παραπλανητικά πραγματικός, περιέχει κλασματικές τιμές. Συνήθως έχουν προκαθορισμένα όρια στην μέγιστη τιμή τους και την ακρίβειά τους. Ο τύπος δεδομένων σταθερής υποδιαστολής (fixed point), που προσφέρεται για την αναπαράσταση νομισματικών τιμών. Συνήθως αναπαρίσταται εσωτερικά ως ακέραιος, γεγονός που οδηγεί σε προκαθορισμένες τιμές. Ο αριθμητικός τύπος μεγάλων αριθμών (Bignum) ή αριθμών μεταβλητής ακρίβειας (arbitrary precision) που δεν έχουν προκαθορισμένη ακρίβεια. Δεν είναι πρωταρχικοί τύποι και χρησιμοποιούνται με φειδώ για λόγους αποδοτικότητας. Συμβολοσειρές και τύποι δεδομένων κειμένου[Επεξεργασία | επεξεργασία κώδικα] Όπως: Αλφαριθμητικός χαρακτήρας (alphanumeric character). Ένα γράμμα της αλφαβήτου, ένα ψηφίο, ένα κενό, ένα σημείο στίξης κτλ. Αλφαριθμητική συμβολοσειρά (string), δηλαδή μία ακολουθία χαρακτήρων. Χρησιμοποιούνται συνήθως για να αναπαραστήσουν λέξεις ή κείμενο. Οι χαρακτήρες και οι συμβολοσειρές αποθηκεύουν ακολουθίες από ένα σύνολο χαρακτήρων (character sets) όπως ο κώδικας ASCII. Επειδή τα περισσότερα σύνολα χαρακτήρων περιλαμβάνουν και τα ψηφία, είναι δυνατό να έχουμε μία αριθμητική συμβολοσειρά, όπως η \"1234\". Ωστόσο πολλές γλώσσες θεωρούν ότι ανήκει σε διαφορετικό τύπο από τον αυτόν της αριθμητικής τιμής 1234. Οι τύποι των χαρακτήρων και των συμβολοσειρών μπορεί να έχουν διαφορετικούς υποτύπους σύμφωνα με το απαιτούμενο \"μέγεθος\" του χαρακτήρα. Ο αρχικός κώδικας ASCII μεγέθους 7-bit αποδείχθηκε ανεπαρκής και αντικαταστάθηκε από 8 και 16-bit σύνολα χαρακτήρων, τα οποία μπορούν να κωδικοποιήσουν ένα ευρύ φάσμα από μη λατινικά αλφάβητα (Εβραϊκά, Κινέζικα) και άλλα σύμβολα. Οι συμβολοσειρές μπορεί να είναι σταθερού είτε επεκτατού μεγέθους, ακόμα και μέσα στην ίδια γλώσσα. Μπορεί να έχουν υποτύπους ανάλογα με το μέγιστο μέγεθός τους. Σημείωση: οι συμβολοσειρές δεν είναι πρωταρχικοί τύποι σε όλες τις γλώσσες. Για παράδειγμα στην C αποτελούνται από πίνακες (arrays) χαρακτήρων. Απαριθμήσεις[Επεξεργασία | επεξεργασία κώδικα] Οι απαριθμήσεις. Αυτές έχουν τιμές που διαφέρουν μεταξύ τους, οι οποίες μπορούν να συγκριθούν και να ανατεθούν, αλλά δεν έχουν απαραίτητα κάποια συγκεκριμένη αναπαράσταση στην μνήμη του υπολογιστή. Οι μεταγλωττιστές και οι διερμηνευτές τις αναπαριστούν αυθαίρετα. Για παράδειγμα, τα τέσσερα χαρτιά σε μία τράπουλα θα μπορούσαν να είναι τέσσερις απαριθμητές με ονόματα ΣΠΑΘΙ, ΚΑΡΩ, ΜΠΑΣΤΟΥΝΙ, ΚΟΥΠΑ, που θα ανήκουν σε μία απαρίθμηση με όνομα τράπουλα. Αν η μεταβλητή V δηλωθεί να έχει τράπουλα για τύπο, μπορούμε να αναθέσουμε οποιαδήποτε από αυτές τις τιμές σε αυτή την μεταβλητή. Κάποιες υλοποιήσεις επιτρέπουν στον προγραμματιστή να αναθέσει ακέραιες τιμές στις τιμές απαρίθμησης, ή ακόμα και να τις αντιμετωπίζει ως τυπικά ισοδύναμες (type-equivalent) με τους ακεραίους. Επαγόμενοι Τύποι[Επεξεργασία | επεξεργασία κώδικα] Οι επαγόμενοι τύποι μπορούν να βασίζονται, ή να προέρχονται από τους βασικούς τύπους που εξηγήθηκαν παραπάνω. Σε κάποια γλώσσα σαν την C, οι συναρτήσεις (functions) έχουν τύπο που προέρχεται από τον τύπο της τιμής επιστροφής (return value) τους. Δείκτες και Αναφορές[Επεξεργασία | επεξεργασία κώδικα] Δείτε επίσης: Δείκτης (πληροφορική), Αναφορά (επιστήμη υπολογιστών) Ο βασικότερος μη σύνθετος επαγόμενος τύπος είναι ο δείκτης, ένας τύπος δεδομένων του οποίου η τιμή αναφέρεται ευθέως σε (ή \"δείχνει σε\") μία άλλη τιμή η οποία είναι αποθηκευμένη κάπου αλλού στην μνήμη του υπολογιστή χρησιμοποιώντας την διεύθυνση μνήμης της. Είναι μία πρωταρχική μορφή αναφοράς. (Σε καθημερινή ορολογία, ένας αριθμός σελίδας σε ένα βιβλίο θα μπορούσε να θεωρηθεί ένα κομμάτι δεδομένων που αναφέρεται σε ένα άλλο). Οι δείκτες αποθηκεύονται συχνά σε μία μορφή παρόμοια με έναν ακέραιο. Ωστόσο, στην προσπάθειά μας να δούμε τα περιεχόμενα που δείχνει ένας δείκτης (dereference) του οποίου η τιμή δεν είναι κάποια έγκυρη διεύθυνση μνήμης το πρόγραμμα θα μπορούσε να τερματιστεί βίαια (crash). Για την βελτίωση αυτού του πιθανού προβλήματος, οι δείκτες θεωρούνται διαφορετικού τύπου από τον τύπο των δεδομένων που δείχνουν, ακόμα και αν η υποκείμενη αναπαράσταση είναι η ίδια. Σύνθετοι τύποι[Επεξεργασία | επεξεργασία κώδικα] Οι σύνθετοι τύποι παράγονται από περισσότερους από έναν πρωταρχικούς τύπους. Αυτό μπορεί να γίνει με πολλούς τρόπους. Οι διαφορετικοί τρόποι με τους οποίους μπορούμε να τους συνδυάσουμε ονομάζονται δομές δεδομένων. Η κατασκευή ενός σύνθετου τύπου από πρωταρχικούς τύπους οδηγεί στη δημιουργία ενός νέου τύπου, για παράδειγμα ο τύπος πίνακας-ακεραίων είναι διαφορετικός τύπος από τον τύπο ακέραιος. Ένας πίνακας (array) αποθηκεύει έναν αριθμό από στοιχεία ιδίου τύπου σε μία συγκεκριμένη σειρά. Προσπελαύνονται χρησιμοποιώντας έναν ακέραιο για να δείξουμε ποιο στοιχείο απαιτείται (παρόλο που τα στοιχεία μπορεί να είναι οποιουδήποτε σχεδόν τύπου). Οι πίνακες μπορεί να είναι σταθερού μεγέθους ή επεκτάσιμοι. Εγγραφή (επίσης γνωστή ως δυάδα (tuple) ή δομή (struct)). Οι εγγραφές είναι από τις απλούστερες δομές δεδομένων. Μία εγγραφή είναι μία τιμή που περιέχει άλλες τιμές, συνήθως με σταθερό πλήθος και σειρά και δεικτοδοτημένες με ονόματα. Τα στοιχεία μίας εγγραφής αποκαλούνται συνήθως πεδία ή μέλη. Ένωση. Μία δήλωση τύπου ένωσης καθορίζει ποιοι από ένα πλήθος πρωταρχικών τύπων θα αποθηκευτούν στα στιγμιότυπά του, για παράδειγμα \"float ή long integer\". Σε σύγκριση με μία εγγραφή, η οποία θα μπορούσε να περιέχει μία τιμή κινητής υποδιαστολής και έναν ακέραιο, η ένωση περιέχει μόνο μία από τις δύο τιμές κάθε φορά. Η ένωση με ετικέτα (γνωστή και ως παραλλαγή (variant), παραλλαγμένη εγγραφή (variant record), διακεκριμένη ένωση (discriminated union), ή διαχωρισμένη ένωση (disjoint union)) περιέχει ένα επιπλέον πεδίο το οποίο υποδεικνύει τον τρέχοντα τύπο, για περισσότερη ασφάλεια τύπων. Το σύνολο είναι ένας αφηρημένος τύπος δεδομένων που μπορεί να αποθηκεύει συγκεκριμένες τιμές, χωρίς κάποια συγκεκριμένη διάταξη και χωρίς επαναλαμβανόμενες τιμές. Οι τιμές δεν ανακτώνται από το σύνολο, αλλά ο προγραμματιστής μπορεί να ρωτήσει το κατά πόσο μία τιμή περιέχεται στο σύνολο, παίρνοντας ως απάντηση ένα λογικό \"ναι\" ή \"όχι\". Ένα αντικείμενο περιέχει έναν αριθμό από πεδία δεδομένων, όπως οι εγγραφές, και έναν αριθμό από κομμάτια κώδικα για να την προσπέλασή τους και την τροποποίησή τους. Οι δομές δεδομένων που δεν περιέχουν κώδικα, όπως οι παραπάνω, ονομάζονται απλές δομές δεδομένων (plain old data structures). Πολλοί άλλοι σύνθετοι τύποι είναι δυνατοί, αλλά τείνουν να είναι περαιτέρω παραλλαγές και συνθέσεις των παραπάνω. Αφηρημένοι τύποι[Επεξεργασία | επεξεργασία κώδικα] Κύριο: Αφηρημένος τύπος δεδομένων Κάθε τύπος που δεν περιλαμβάνει κάποια υλοποίηση είναι ένας αφηρημένος τύπος δεδομένων. Για παράδειγμα, μία στοίβα (η οποία είναι ένας αφηρημένος τύπος δεδομένων) μπορεί να υλοποιηθεί με έναν πίνακα (ένα συνεχές κομμάτι μνήμης που περιέχει πολλαπλές τιμές), ή με μία συνδεδεμένη λίστα (ένα σύνολο από μη συνεχόμενα κομμάτια μνήμης που συνδέονται με δείκτες). Οι αφηρημένοι τύποι δεδομένων μπορούν να χειριστούν από κώδικα που δεν γνωρίζει ή \"ενδιαφέρεται\" για τους τύπους που περιέχονται σε αυτούς. Ο προγραμματισμός που δεν γνωρίζει τους υποκείμενους συγκεκριμένους τύπους που θα χρησιμοποιηθούν ονομάζεται γενικευμένος προγραμματισμός. Οι πίνακες και οι εγγραφές μπορεί να περιέχουν επίσης υποκείμενους τύπους, αλλά θεωρούνται συγκεκριμένοι επειδή προσδιορίζουν το πως τα περιεχόμενα ή τα στοιχεία τους αποθηκεύονται στην μνήμη. Παραδείγματα: Ένας έξυπνος δείκτης (smart pointer) είναι το αφηρημένο αντίστοιχο του δείκτη. Και οι δύο είναι ήδη αναφορών. Ένας πίνακας κατακερματισμού (hash table) ή λεξικό (dictionary) ή χάρτης/συσχετιστικός πίνακας (map/associative array) είναι μία πιο ευέλικτη παραλλαγή της εγγραφής, στην οποία ζευγάρια κλειδιού-τιμής μπορούν να εισαχθούν και να διαγραφούν ελεύθερα. Σε μία ουρά (queue) όποιος εισέλθει πρώτος εξέρχεται πρώτος. Παραλλαγές είναι η δύο-άκρων ουρά (deque) και η ουρά προτεραιότητας (priority queue). Ένα σύνολο (set) μπορεί να αποθηκεύει συγκεκριμένες τιμές, χωρίς κάποια συγκεκριμένη διάταξη και χωρίς επαναλαμβανόμενες τιμές. Σε μία στοίβα (stack) όποιος εισέλθει τελευταίος εξέρχεται πρώτος. Ένα δέντρο (tree) είναι μία ιεραρχική δενδρική δομή. Γράφος (graph). Βοηθητικοί τύποι[Επεξεργασία | επεξεργασία κώδικα] Για ευκολία, πολλές γλώσσες προγραμματισμού υψηλού επιπέδου είναι εφοδιασμένες με χρήσιμους στην πράξη τύπους, όπως για παράδειγμα χρονικές, ημερολογιακές και νομισματικές τιμές, ακόμα και στις περιπτώσεις που η γλώσσα επιτρέπει την κατασκευή τους από πρωταρχικούς τύπους. Συστήματα τύπων[Επεξεργασία | επεξεργασία κώδικα] Κύριο λήμμα: Σύστημα τύπων Ένα σύστημα τύπων συσχετίζει τύπους με κάθε υπολογισμένη τιμή. Εξετάζοντας την ροή αυτών των τιμών, ένα σύστημα τύπων προσπαθεί να αποδείξει ότι δεν μπορούν να συμβούν σφάλματα τύπων. Το εν λόγω σύστημα τύπων καθορίζει τι αποτελεί ένα σφάλμα τύπου, αλλά τα συστήματα τύπων προσπαθούν γενικά να εγγυηθούν ότι λειτουργίες που αναμένουν ένα συγκεκριμένο είδος τιμών δεν χρησιμοποιούνται σε τιμές για τις οποίες αυτές δεν έχουν νόημα. Ένας μεταγλωττιστής ενδέχεται να χρησιμοποιήσει τον στατικό τύπο μιας τιμής για να βελτιστοποιήσει την αποθήκευση που χρειάζεται και την επιλογή των αλγορίθμων για λειτουργίες πάνω στην τιμή. Σε πολλούς μεταγλωττιστές της γλώσσας προγραμματισμού C ο τύπος δεδομένων float, για παράδειγμα, αναπαρίσταται με 32 bit, σύμφωνα με το πρότυπο της IEEE για αριθμούς κινητής υποδιαστολής απλής ακρίβειας. Έτσι θα χρησιμοποιήσουν εντολές του μικροεπεξεργαστή ειδικές για αριθμούς κινητής υποδιαστολής πάνω σε αυτές τις τιμές (πρόσθεση κινητής υποδιαστολής, πολλαπλασιασμό, κτλ). Το βάθος των περιορισμών των τύπων και ο τρόπος αποτίμησής τους επηρεάζουν την τυποποίηση (typing) της γλώσσας. Μία γλώσσα προγραμματισμού μπορεί να συσχετίσει περαιτέρω μία λειτουργία με διαφορετικούς συγκεκριμένους αλγορίθμους για κάθε τύπο στην περίπτωση του πολυμορφισμού υποτύπων. Θεωρία τύπων είναι η μελέτη των συστημάτων τύπων, μολονότι τα συγκεκριμένα (concrete) συστήματα τύπων γλωσσών προγραμματισμού προέρχονται από πρακτικά θέματα αρχιτεκτονικής υπολογιστών, υλοποίησης μεταγλωττιστών και σχεδιασμού γλωσσών. Τα συστήματα τύπων μπορεί να είναι στατικά ή δυναμικά, αυστηρά ή ασθενή κτλ. Δείτε επίσης[Επεξεργασία | επεξεργασία κώδικα] Λεξικό δεδομένων Συναρτησιακός προγραμματισμός Είδος Θεωρία τύπων για μαθηματικά μοντέλα τύπων Σύστημα τύπων για διαφορετικές επιλογές στο σύστημα τύπων γλωσσών προγραμματισμού Αναφορές[Επεξεργασία | επεξεργασία κώδικα] ↑ http://multimedia.dictionary.reference.com/browse/data+type[νεκρός σύνδεσμος] ↑ Shaffer, C.A. Data Structures and Algorthms, 1.2 ↑ Programming Languages: Application and Interpretation, Shriram Krishnamurthi, Brown University Περαιτέρω διάβασμα[Επεξεργασία | επεξεργασία κώδικα] Luca Cardelli, Peter Wegner. On Understanding Types, Data Abstraction, and Polymorphism, Αρχειοθετήθηκε 2006-06-19 στο Wayback Machine. from Computing Surveys, (December, 1985) Various Data Types in C πσεΤύποι δεδομένωνΧωρίς ερμηνείαBit · Byte · Trit · Tryte · ΛέξηΑριθμητικοίΑκέραιος · Σταθερής υποδιαστολής · Κινητής υποδιαστολής · Πραγματικός · Μιγαδικός · Bignum · ΔιάστημαΚείμενοΧαρακτήρας · ΣυμβολοσειράΔείκτεςΔιεύθυνση · Αναφορά · Δείκτης συνάρτησηςΣύνθετοιΑλγεβρικός τύπος δεδομένων (γενικευμένος) · Πίνακας · Πίνακας αντιστοίχισης · Κλάση · Λίστα · Αντικείμενο · Τύπος επιλογής · Γινόμενο · Εγγραφή · Σύνολο · Ένωση (με ετικέτες)ΆλλοιΑλήθειας · Bottom type · Συλλογή · Τύπος απαρίθμησης · Εξαίρεση · Τύπος συνάρτησης · Αδιαφανής τύπος δεδομένων · Αναδρομικός τύπος δεδομένων · Σημαφόρος · Stream · Top type · Κλάση τύπου · Unit type · VoidΣχετικά θέματαΑφηρημένος τύπος δεδομένων · Δομή δεδομένων · Interface · Kind · Πρωτογενής τύπος δεδομένων · Υποτύποι · Template · Κατασκευαστής τύπων · Παραμετρικός πολυμορφισμός · Πολυμορφισμός υποτύπων"
    }
]