[
    {
        "url": "https://el.wikipedia.org/wiki/Python",
        "title": "Python",
        "content": "Το λογότυπο της PythonΗPythonείναιδιερμηνευόμενη(interpreted), γενικού σκοπού (general-purpose) καιυψηλού επιπέδου,γλώσσα προγραμματισμού.[1][2][3]Ανήκει στις γλώσσεςπροστακτικού προγραμματισμού(Imperative programming) και υποστηρίζει τόσο τοδιαδικαστικό(procedural programming) όσο και τοαντικειμενοστρεφές(object-oriented programming)προγραμματιστικό υπόδειγμα(programming paradigm).Είναιδυναμική γλώσσα προγραμματισμού(dynamically typed) και υποστηρίζεισυλλογή απορριμμάτων(garbage collection ή GC).Δημιουργήθηκε από τονΟλλανδόΓκίντο βαν Ρόσσουμ(Guido van Rossum) στο ερευνητικό κέντρο Centrum Wiskunde & Informatica (CWI) το 1989[4]και κυκλοφόρησε για πρώτη φορά το 1991.[4][5]Ο κύριος στόχος της είναι η αναγνωσιμότητα του κώδικά της και η ευκολία χρήσης της. Το συντακτικό της επιτρέπει στουςπρογραμματιστέςνα εκφράσουν έννοιες σε λιγότερες γραμμές κώδικα από ό,τι θα ήταν δυνατόν σε γλώσσες όπως ηC++ή ηJava.[3][6][7]Διακρίνεται λόγω του ότι έχει πολλές βιβλιοθήκες που διευκολύνουν ιδιαίτερα αρκετές συνηθισμένες εργασίες και για την ταχύτητα εκμάθησης της. Μειονεκτεί στο ότι επειδή είναι διερμηνευόμενη είναι πιο αργή από τις μεταγλωττιζόμενες (compiled) γλώσσες όπως ηCκαι η C++. Για αυτόν τον λόγο δεν είναι κατάλληλη για γραφή λειτουργικών συστημάτων.[8]Οι διερμηνευτές της Python είναι διαθέσιμοι για εγκατάσταση σε πολλάλειτουργικά συστήματα, επιτρέποντας στην Python την εκτέλεση κώδικα σε ευρεία γκάμα συστημάτων. Χρησιμοποιώντας εργαλεία τρίτων, όπως τοPy2exeή το Pyinstaller,[9]ο κώδικας της Python μπορεί να πακεταριστεί σε αυτόνομα εκτελέσιμα προγράμματα για μερικά από τα πιο δημοφιλή λειτουργικά συστήματα, επιτρέποντας τη διανομή του βασισμένου σε Python λογισμικού για χρήση σε αυτά τα περιβάλλοντα χωρίς να απαιτείται εγκατάσταση του διερμηνευτή της Python.Η Python αναπτύσσεται ωςανοιχτό λογισμικό(open source) και η διαχείρισή της γίνεται από τον μη κερδοσκοπικό οργανισμόPython Software Foundation.[8]Ο κώδικας διανέμεται με την άδεια Python Software Foundation License η οποία είναι συμβατή με τηνGPL. Το όνομα της γλώσσας προέρχεται από την ομάδα των Άγγλων κωμικώνΜόντυ Πάιθονκαι δεν έχει καμιά σχέση με το φίδιπύθωνα, παρότι το λογότυπό της παραπέμπει σε κάτι τέτοιο.[4][4][10]Ιστορικό[Επεξεργασία|επεξεργασία κώδικα]Η Python δημιουργήθηκε από τον Γκίντο βαν Ρόσσουμ στο ερευνητικό κέντρο Centrum Wiskunde & Informatica (CWI) το 1989.[4]Αρχικά, η Python ήτανγλώσσα σεναρίωνπου χρησιμοποιήθηκε στο κατανεμημένολειτουργικό σύστημαAmoeba,[4]ικανή και γιακλήσεις συστήματος. Θεωρείται διάδοχος της γλώσσας προγραμματισμού ABC, μια και αυτή υπήρξε η βασική πηγή έμπνευσης για τον Γκίντο βαν Ρόσσουμ.[4]Η Python 2.0 κυκλοφόρησε στις 16 Οκτωβρίου του 2000. Στις 3 Δεκεμβρίου 2008 κυκλοφόρησε η έκδοση 3.0 (γνωστή και ως py3k ή python 3000). Πολλά από τα καινούργια χαρακτηριστικά αυτής της έκδοσης έχουν μεταφερθεί στις εκδόσεις 2.6 και 2.7 που είναι προς τα πίσω συμβατές.Η Python 3.0 είναι ιστορικά η πρώτη γλώσσα προγραμματισμού που σπάει την προς τα πίσω συμβατότητα με προηγούμενες εκδόσεις ώστε να διορθωθούν κάποια λάθη που υπήρχαν σε προγενέστερες εκδόσεις και να καταστεί ακόμα πιο σαφής ο απλός τρόπος με τον οποίο μπορούν να γίνουν κάποια πράγματα.Η Python 3.0 συνοδεύεται με το πρόγραμμα 2to3.py, που επιτρέπει την μετατροπή κώδικα της έκδοσης 2.0 σε 3.0.[11][12]ΟΓκίντο βαν Ρόσσουμ, πρωτοστατούσε στην κοινότητα της Python μέχρι τον Ιούλιο του 2018, οπότε και παραιτήθηκε,[13][14]για να συνεχίσει μόνο ως μέλος του Διοικητικού Συμβουλίου.Η πιο πρόσφατη έκδοση είναι η 3.13 και δημοσιεύτηκε στις 8 Μαΐου 2024Διερμηνευτής[Επεξεργασία|επεξεργασία κώδικα]Για να εκτελεστούν διαδραστικά (interactively) μεμονωμένες εντολές ή προγράμματα είναι απαραίτητη η εγκατάσταση του διερμηνευτή της Python, ο οποίος είναι ελεύθερα διαθέσιμος για «κατέβασμα» (download) από τον επίσημο ιστότοπό της (www.python.org). ΓιαMicrosoft Windowsυπάρχουν εκδόσεις των 32 ή 64 bits. Στα λειτουργικά συστήματα Linux και Mac OS X συνηθίζεται να είναι προεγκατεστημένη, πιθανότατα όμως να είναι μια παλαιότερη έκδοσή της.[15]IDLE[Επεξεργασία|επεξεργασία κώδικα]Κύριο λήμμα:IDLE (Python)Για τη συγγραφή προγραμμάτων είναι απαραίτητος ένας κειμενογράφος ή ακόμα καλύτερα έναολοκληρωμένο περιβάλλον ανάπτυξης(Integrated Development Environment - IDE), το οποίο είναι ένα ειδικό λογισμικό για την ανάπτυξη εφαρμογών. Η Python έρχεται μαζί με ένα εύχρηστο και απλό περιβάλλον ανάπτυξης με την ονομασία ΙDLE. Τα αρχικά του προέρχονται από τις λέξεις Interactive DeveLopment Environment και είναι γραμμένο σε Python από τονΓκίντο βαν Ρόσσουμ. Χρησιμοποιεί τη βιβλιοθήκη γραφικών Tkinter, οπότε μπορεί να εκτελεσθεί σε περιβάλλον Linux, Windows και Mac OS X. Το IDLE μας δίνει τη δυνατότητα να χρησιμοποιήσουμε διαδραστικά τον διερμηνευτή της γλώσσας, να γράψουμε και να επεξεργαστούμε προγράμματα, να τα αποθηκεύσουμε σε αρχεία, να τα εκτελέσουμε, να κάνουμε αποσφαλμάτωση (debugging).[16]Δομή και σύνταξη[Επεξεργασία|επεξεργασία κώδικα]Η γλώσσα χρησιμοποιείδιερμηνέα(interpreter) για την δημιουργία του εκτελέσιμου κώδικα.Ονοματοδοσία μεταβλητών[Επεξεργασία|επεξεργασία κώδικα]Τα ονόματα που λαμβάνουν οι μεταβλητές υπόκεινται στους εξής κανόνες:[17][18][19]Είναι λέξεις που αποτελούνται από αλφαριθμητικούς χαρακτήρες (γράμματα και αριθμούς) και την κάτω παύλα (underscore, \"_\"). Μπορεί να αρχίζει με αλφαβητικό χαρακτήρα ή κάτω παύλα (_).Δεν επιτρέπεται να αρχίζει με αριθμό (π.χ.var4_1είναι σωστό, αλλά το4var_1είναι λάθος).Υπάρχει διάκριση πεζών και κεφαλαίων γραμμάτων (case sensitivity), οπότε και οι μεταβλητές διαφοροποιούνται λόγω πεζών ή κεφαλαίων (π.χ. άλλη η μεταβλητήVarκαι άλλη ηvar).Δεν επιτρέπονταιδεσμευμένες λέξεις(λέξεις-κλειδιά,keywords), δηλαδή λέξεις με ιδιαίτερη σημασία (idetifiers), όπωςprint, type, False, float, None,κλπ.[18]Η Python έχει 33 λέξεις-κλειδιά.[20]Μπορούν να χρησιμοποιηθούν και ελληνικά ή άλλης γλώσσας γράμματα, αλλά δεν συνίσταται γιατί δημιουργείται δυσανάγνωστος κώδικας.[21]Τύποι δεδομένων[Επεξεργασία|επεξεργασία κώδικα]Οιτύποι δεδομένωντης Python διακρίνονται στους αρχέγονους (primitive data type), στις πιο σύνθετεςδομές δεδομένων(λίστες, πλειάδες, σύνολα, λεξικά) και, λόγω των αντικειμενοστρεφών δυνατοτήτων της, στις κλάσεις (classes). Λόγω του ότι η Python είναιδυναμική γλώσσαδεν δηλώνονται οι τύποι των μεταβλητών πριν χρησιμοποιηθούν. Ο τύπος που τους αποδίδεται εξαρτάται από την τιμή που θα πάρουν κατά την διάρκεια της εκτέλεσης του προγράμματος. Όταν χρησιμοποιηθεί (π.χ. σε έκφραση ή συνάρτηση) πρέπει να έχει πάρει τιμή γιατί ο διερμηνευτής (interpreter) δίνει λάθος που το ονομάζειNameError. Για αυτόν τον λόγο η Python υποστηρίζει τον ιδιαίτερο τύποNoneType(βλ. παρακάτω).[18]Αρχέγονοι (primitive) τύποι δεδομένων[Επεξεργασία|επεξεργασία κώδικα]Οιαρχέγονοι τύποιείναι:[18][19]int(ακέραιος). Στην Python οι ακέραιοι μπορούν να είναι οσοδήποτε μεγάλοι.[22]float(κινητής υποδιαστολής)str(συμβολοσειράή string). Είναι ακολουθία χαρακτήρων που περικλείονται από μονά ή διπλά εισαγωγικά.[17]Σε ειδικές περιπτώσεις μπορεί να γίνει χρήση τριπλών εισαγωγικών (μονών :''' ή διπλών: \"\"\").[19]bool. Ολογικός τύπος(Boolean) μεταβλητής με τιμέςTrueήFalse.[23][24]NoneType. Αυτός ο τύπος μεταβλητής παίρνει την τιμήNoneμε ανάθεση (assignment,= None) και αντιμετωπίζεται, στον σχεδιασμό του προγράμματος, σαν μεταβλητή που δεν έχει τιμή.[18]Noneεπιστρέφουν και οι συναρτήσεις που δεν επιστρέφουν τιμή (δεν έχουνreturn <έκφραση>), όπως για παράδειγμα ηprint().[25]Δεν έχει μεταβλητή τύπου Character (όπως για παράδειγμα η C/C++). Σε αυτή την περίπτωση χρησιμοποιείται η μεταβλητή String με ένα χαρακτήρα.Η συνάρτησηtype()μας επιστρέφει τον τύπο της μεταβλητής.[26]Αν η μεταβλητή δεν έχει πάρει τιμή μας επιστρέφειNoneType.Ενσωματωμένες δομές δεδομένων[Επεξεργασία|επεξεργασία κώδικα]Οι ενσωματωμένεςδομές δεδομένωνστην Python είναι η Λίστα (List), η Πλειάδα (Tuple), τo Σύνολo (Set) και το Λεξικό (Dictionary).Λίστα (list)[Επεξεργασία|επεξεργασία κώδικα]Ηλίσταυλοποιεί τον γνωστόαφηρημένο τύπο δεδομένων. Μοιάζει με την δομή τουπίνακα(array), αλλά σε αντίθεση με αυτόν μπορεί να περιέχει ανομοιογενή αντικείμενα (items) ή αλλιώς στοιχεία (elements), τα οποία μπορεί να είναι οποιαδήποτε δομή δεδομένων (ακόμα και λίστα). Όπως στους πίνακες τα στοιχεία είναι διατεταγμένα σε συγκεκριμένη σειρά, προσπελάσιμα με δείκτες και επιτρέπεται η επανάληψη τους. Ορίζεται με ένα ζευγάριτετραγωνισμένων αγκύλων[]και με τα στοιχεία να χωρίζονται μεταξύ τους με κόμμα, π.χ. η ακολουθία[ <στοιχείο1>, ..., <στοιχείοΝ> ]ορίζει μια λίστα Ν στοιχείων. Μπορεί να οριστεί μια κενή λίστα μόνο με τις αγκύλες και χωρίς περιεχόμενο.[27]Επειδή η συμβολοσειρά (string) αποτελεί μια διατεταγμένη ακολουθία χαρακτήρων μοιάζει με λίστα και χρησιμοποιεί παρόμοιους τελεστές (operators) και συναρτήσεις (methods). Η μεγάλη διαφορά τους είναι ότι η λίστα είναι δυναμικός ή αλλιώς μεταβλητός (mutable) τύπος δεδομένων, ενώ η συμβολοσειρά στατικός ή αλλιώς αμετάβλητος (immutable) τύπος δεδομένων. Στη λίστα μπορούμε να αλλάξουμε τα στοιχεία που περιέχει. Στη συμβολοσειρά η αλλαγή των χαρακτήρων που περιέχει γίνεται μόνο με αντικατάσταση (overwriting) μέσω ανάθεσης (assignment) από νέα συμβολοσειρά.[28][29]Πλειάδα (tuple)[Επεξεργασία|επεξεργασία κώδικα]Ηπλειάδαυλοποιεί την αντίστοιχη μαθηματική έννοια τηςπλειάδας. Είναι μια πεπερασμένη ακολουθία στοιχείων διατεταγμένων σε συγκεκριμένη σειρά και μοιάζει πολύ με τηνλίστα(list). Ορίζεται με ένα ζευγάριπαρενθέσεων()και με τα στοιχεία να χωρίζονται μεταξύ τους με κόμμα, π.χ. η ακολουθία( <στοιχείο1>, ..., <στοιχείοΝ> )ορίζει μια πλειάδα Ν στοιχείων. Αν το επιτρέπουν τα συμφραζόμενα μπορούν να παραληφθούν οι παρενθέσεις. Διαφέρει από την δομή της λίστας στο ότι η πλειάδα είναι στατική ή αλλιώς αμετάβλητη (immutable) δομή δεδομένων. Αφού δημιουργηθεί δεν μπορεί να μεταβληθεί. Η χρήση της πλειάδας είναι προτιμότερη από της λίστας όταν δεν χρειάζεται να αλλάξουμε τα στοιχεία της γιατί θεωρητικά είναι αποτελεσματικότερη σε ταχύτητα στις διάφορες λειτουργίες της. Η πλειάδα που περιέχει ένα στοιχείο ορίζεται πάντα με ένα κόμμα μετά το στοιχείο, π.χ.( <στοιχείο>,), διότι οι παρενθέσεις χρησιμοποιούνται και στην ομαδοποίηση των εκφράσεων (expressions) και η γραφή χωρίς κόμμα, π.χ.= ( <στοιχείο> )λαμβάνεται από τον διερμηνευτής (interpreter) ως ανάθεση (assignment), δηλαδή= <στοιχείο>.[28]Λεξικό (dictionary)[Επεξεργασία|επεξεργασία κώδικα]Toλεξικό(dictionary) είναι μια δομή δεδομένων για την αποθήκευση ζευγαριών τιμών της μορφήςκλειδί:τιμή(key : value). Ορίζεται με ένα ζευγάρι αγκύλων{}και με τα ζευγάρια να χωρίζονται μεταξύ τους με κόμμα, π.χ. η ακολουθία{ κλειδί1 : τιμή1, ..., κλειδίΝ : τιμήΝ }ορίζει ένα λεξικό Ν ζευγαριών. Ανάμεσα στοκλειδίκαι τηντιμήυπάρχει η άνω-κάτω τελεία (:). Τακλειδιάπρέπει να είναι μοναδικά γιατί χρησιμεύουν στην προσπέλαση της αντίστοιχηςτιμής. Τα κλειδιά πρέπει να είναι στατικοί ή αλλιώς αμετάβλητοι (immutable) τύποι δεδομένων, όπως ακέραιοι αριθμοί, συμβολοσειρές, αμετάβλητες πλειάδες (όταν όλα τα στοιχεία της πλειάδας είναι αμετάβλητα).[30]Ανάθεση τιμών (assignment)[Επεξεργασία|επεξεργασία κώδικα]Επειδή η Python είναιδυναμική γλώσσα προγραμματισμού(dynamically typed) διαφέρει από τις άλλες παραδοσιακές γλώσσεςπροστακτικού προγραμματισμού(Imperative programming) στον τρόπο που γίνεται η ανάθεση τιμών στις μεταβλητές της. Συνήθως οι μεταβλητές δηλώνονται πριν τους ανατεθούν τιμές και μαζί δηλώνεται και ο τύπος τους (interer, floating point, character, κλπ.). Στην Python οι μεταβλητές δηλώνονται μαζί με την ανάθεση των τιμών σε αυτές (ακόμα και όταν τους δοθεί η τιμήNone) και δεν είναι δεσμευμένες σε κάποιο συγκεκριμένο τύπο δεδομένων. Μία μεταβλητή μπορεί να είναι ακεραία (integer) και η ίδια στη συνέχεια να γίνει συμβολοσειρά (string) αν της ανατεθεί τιμή συμβολοσειράς.Στην Python, όταν κατά την εκτέλεση ενός προγράμματος, αναθέτουμε τιμή σε μια μεταβλητήx, π.χ.x = 2, η τιμή 2 αντιγράφεται σε χώρο μνήμης πού δεσμεύεται (memory allocation), μαζί με άλλες ιδιότητες, όπως π.χ. ότι ο τύπος της είναι ακέραιος (integer).[31]Στην μεταβλητή x αποδίδεται η διεύθυνση (memory address) αυτής της θέσης στην μνήμη. Η μεταβλητή λειτουργεί σανδείκτης(pointer). Η ίδια η μεταβλητή δεν έχει κάποια τιμή ή τύπο δεδομένων, αλλά έχει τη θέση της μνήμης που «αντιπροσωπεύει». Σε ένα πρόγραμμα μετά την ανάθεσηx = 2(η μεταβλητή είναι τύπου integer), στην συνέχεια της εκτέλεσης μπορεί να εκτελεστεί η ανάθεσηx = \"hellow world\", οπότε η μεταβλητή «αντιπροσωπεύει» την συμβολοσειρά \"hellow world\" (είναι τύπου string). Στην δεύτερη ανάθεση η τιμή 2 δεν «αντιπροσωπεύεται» από κάποια μεταβλητή (δεν χρειάζεται πλέον στο πρόγραμμα) και οσυλλέκτης απορριμμάτων(garbage collector), της Python, αναλαμβάνει «αυτόματα» να αποδεσμεύσει (memory de-allocation) τον χώρο της μνήμης που αυτή κατέχει.[31][32]Εσοχές (indentation)[Επεξεργασία|επεξεργασία κώδικα]Η στοίχιση στα αριστερά ή αλλιώς οι αριστερές εσοχές (indentation) έχουν μεγάλη σημασία γιατί ορίζουν τα block (ομαδοποίηση) του κώδικα.[33]Αυτό σε άλλες γλώσσες, όπως C και Java επιτυγχάνεται με την χρήση των αγκύλων{ }.[34]Στην Python το block κώδικα αρχίζει εκεί που η αριστερή εσοχή αυξάνεται προς τα δεξιά και τελειώνει εκεί που καταργείται η εσοχή. Εσοχή μέσα σε εσοχή σημαίνει block μέσα σε block (nested blocks).[23]Η εσοχή μπορεί να είναι οσοδήποτε μεγάλη ή μικρή - του ίδιου πάντα μεγέθους - αλλά συνίσταται η χρήση 4 κενών χαρακτήρων (spacebars) για ευκολότερη αναγνωσιμότητα του κώδικα.[35]Για παράδειγμα μια εμφωλιασμένη εντολήifορίζεται ως εξής:[34]if<λογικήέκφραση1>:εντολή1εντολή2if<λογικήέκφραση2>:εντολή3εντολή4ενολή5εντολή6Το block της πρώτηςifπεριέχει τις εντολή1, εντολή2, την δεύτερηifκαι τελειώνει με την εντολή5. Η εντολή6 είναι εκτός block (δεν ανήκει στην εξωτερικήif). Η εσωτερικήif(εμφωλιασμένη) με την δική της εσοχή ορίζει ένα block (που περιέχει την εντολή3 και εντολή4) μέσα στο block της εξωτερικήςif.Τελεστές[Επεξεργασία|επεξεργασία κώδικα]Τελεστές πράξεων[Επεξεργασία|επεξεργασία κώδικα]Υποστηρίζει τους γνωστούς, με τις άλλες γλώσσες προγραμματισμού, τελεστές (operators), όπως τους+,-,*,/,**,%, που όμως έχουν κάποιες διαφοροποιήσεις ανάλογα με τους τελεστέους (operands), δηλαδή τον τύπο των μεταβλητών, όπου εφαρμόζονται (πολυμορφισμός).[36]Ο τελεστής της πρόσθεσης+όταν οι τελεστέοι είναι Strings εκτελεί την πράξη της συνένωσης (concatenation) και ο πολλαπλασιασμός*την πράξη της αναπαραγωγής (replication) του String όταν αυτό πολλαπλασιάζεται με ακέραιο (integer). Δηλαδή η έκφραση (expression):\"abc\" + \"def\"έχει ως αποτέλεσμα\"abcdef\"και η\"abc\" * 3ή3 * \"abc\"έχει ως αποτέλεσμα\"abcabcabc\"αντίστοιχα.[17]Τελεστές λογικής[Επεξεργασία|επεξεργασία κώδικα]Υποστηρίζει τους λογικούς τελεστέςand,orκαιnotγιαμεταβλητές τύπου Boolean. Τα εμφωλιασμένα (nested)notαποδίδονται ως διπλή άρνηση (άρνηση στην άρνηση). Η σειρά (προτεραιότητα) εκτέλεσης είναιnot, and, or.[23]Εμβέλεια ονομάτων οντοτήτων (scope)[Επεξεργασία|επεξεργασία κώδικα]Στις οντότητες ή αντικείμενα (μεταβλητές, συναρτήσεις, κλάσεις, κλπ.), που δημιουργούνται σε ένα πρόγραμμα, για να μπορούν να χρησιμοποιηθούν (προσπελαστούν), αποδίδονται ονόματα (name binding). Για παράδειγμα στην Python μια οντότητα, όπως είναι μια μεταβλητή, δεν δηλώνεται, αλλάδημιουργείταικαιονοματίζεταιόταν της γίνει ανάθεση (assignment) κάποιας τιμής. Οντότητες πουδημιουργούνταιμέσα σε ένα block κώδικα, όπως το σώμα μιας συνάρτησης, μιας εντολήςifήfor, κλπ., έχουν περιορισμένη εμβέλεια και μπορούν να χρησιμοποιηθούν μόνο μέσα στο block που έχουν ονομαστεί. Ένα τέτοιο όνομα δεν είναι προσπελάσιμο εκτός του block ακόμα και αν έχει την ίδια ονομασία και λέγεται ότι είναιτοπικής εμβέλειας(local scope). Ένα όνομα που δηλώνεται στο κύριο σώμα (block) του προγράμματος μπορεί να προσπελαστεί σε ολόκληρο το πρόγραμμα, ακόμα και στα block που έχουν οριστεί μέσα στο πρόγραμμα και λέγεται ότι είναικαθολικής εμβέλειας(global scope).[37]Μέσα σε ένα block ο διερμηνευτής (interpreter) χρησιμοποιεί την τοπική ονομασία μιας οντότητας ακόμα και αν υπάρχει άλλη με την ίδια ονομασία και καθολική εμβέλεια. Συγκεκριμένα ο διερμηνευτής όταν συναντήσει ένα όνομα (π.χ. μεταβλητής) μέσα σε ένα block ελέγχει πρώτα αν έχει δημιουργηθεί αυτό το όνομα μέσα στο block (οπότε είναι τοπικής εμβέλειας) και το χρησιμοποιεί, έστω και αν υπάρχει ίδια ονομασία εκτός του block (καθολικής εμβέλειας). Αν δεν το βρει μέσα στο block τότε και μόνο τότε ελέγχει αν υπάρχει τέτοια ονομασία που να έχει δημιουργηθεί στο κύριο μέρος του προγράμματος (είναι καθολικής εμβέλειας) και χρησιμοποιεί αυτήν. Δηλαδή μια καθολικής εμβέλειας μεταβλητή χρησιμοποιείται μέσα σε ένα block, μόνο αν δεν υπάρχει τοπικής εμβέλειας μεταβλητή με το ίδιο όνομα, μέσα στο block.[37][38]Δήλωση global[Επεξεργασία|επεξεργασία κώδικα]Όταν μέσα σε ένα block γίνει η ανάθεσηnum = 123, τότε δημιουργείται (αναγκαστικά) η τοπικής εμβέλειας μεταβλητήnumακόμα και αν υπάρχει καθολικής εμβέλειαςnum. Στην περίπτωση που δεν είναι επιθυμητό να δημιουργηθεί η τοπικήnum, αλλά η τιμή123να ανατεθεί στην καθολικήnumγίνεται χρήση της δήλωσηςglobal. Δηλώνονταςglobal num, πριν από τηνnum = 123, ο διερμηνευτής δεν δημιουργεί τοπικήnum, αλλά δίνει την τιμή123, στην καθολική που ήδη υπάρχει.[37][38]Παράδειγμα προγράμματος[Επεξεργασία|επεξεργασία κώδικα]Ένα από τα πιο απλά προγράμματα στην γλώσσα Python είναι η εμφάνιση ενός γραπτού αποτελέσματος (π.χ. Hello, world!):>>> print(\"Hello, world!\")\nHello, world!Ένα ιδιαίτερο χαρακτηριστικό της γλώσσας είναι η χρήση κενών διαστημάτων σαν εσοχές (whitespace) για τον διαχωρισμό των συντακτικών δομών (block of code) του προγράμματος, σε αντίθεση με την πρακτική σε άλλες γλώσσες όπου για τον ίδιο σκοπό χρησιμοποιούνται ειδικά σύμβολα (π.χ. αγκύλες). Αυτό, σε συνδυασμό με το ότι χρησιμοποιεί πλήρεις αγγλικές λέξεις στη θέση συμβόλων, καθιστούν τον κώδικα της Python ευανάγνωστο από όσους έχουν βασική γνώση τωναγγλικών.age=21ifage>=18:print(\"You vote\")else:print(\"You don't vote\")Διαδικαστικός προγραμματισμός[Επεξεργασία|επεξεργασία κώδικα]Για παράδειγμα, ο παρακάτω γεννήτορας (generator)generate_primesπαράγειπρώτους αριθμούς:fromitertoolsimportcountdefgenerate_primes(stop_at=None):primes=[]fornincount(2):ifstop_atisnotNoneandn>stop_at:returncomposite=Falseforpinprimes:ifnotn%p:composite=Truebreakelifp**2>n:breakifnotcomposite:primes.append(n)yieldnΚαι για να καλέσουμε τη συνάρτηση, υπολογίζοντας τους πρώτους αριθμούς από το 1 στο 100:foriingenerate_primes():ifi>100:breakprint(i)Αντικειμενοστρεφής προγραμματισμός[Επεξεργασία|επεξεργασία κώδικα]Παράδειγμα αντικειμενοστρεφούς προγράμματος γραμμένο σε Python, το οποίο παρουσιάζει μια κλάση Υπάλληλος:classEmployee:def__init__(self,id,name,position):self.id=id;self.name=name;self.position=position;defprintEmployee(self):print(self.id,\"|\",self.name,\"|\",self.position);e1=Employee(1230,\"Νικόλαος Παπαγεωργού\",\"Βοηθός Προγραμματιστή\");e1.printEmployee();Εκπαίδευση[Επεξεργασία|επεξεργασία κώδικα]Η Python ενδείκνυται ως γλώσσα εισαγωγική στον προγραμματισμό και στην επιστήμη των υπολογιστών γενικότερα, με δεδομένη την απλότητα στη σύνταξή της. Διεθνώς πολλά πανεπιστήμια αλλά και η δευτεροβάθμια εκπαίδευση σε πολλές χώρες, υιοθετούν μια python first προσέγγιση εισαγωγής στον προγραμματισμό. Στη δευτεροβάθμια εκπαίδευση της χώρας μας το πρώτο βήμα έγινε με τα Επαγγελματικά Λύκεια στα οποία έχει εισαχθεί στο σχετικό μάθημα (πηγή: Αράπογλου, κ.α.2017).[39]Επίσης, η Python χρησιμοποιείται ως εργαλείο για εισαγωγή σε βασικές έννοιες των υπολογιστών, (βλέπε για παράδειγμα: Avouris et al. 2017[40]), ενώ η Python έχει υποστηρίξει με επιτυχία  οικοδομιστικές προσεγγίσεις στη μάθηση, σε επί μέρους αντικείμενα, όπως σε media studies (βλέπε Guzdial, 2004). Άλλες προτεινόμενες προσεγγίσεις είναι η χρήση της Python για διαχείριση δεδομένων, για μελέτες σε ανθρωπιστικές σπουδές, για γεωγραφικά συστήματα πληροφοριών, κλπ.Υπάρχει διαθέσιμο πλούσιο υλικό και στην Ελληνική γλώσσα, πέραν της διεθνούς βιβλιογραφίας και πηγών. Για παράδειγμα στις ιστοσελίδες διαδικτυακών μαθημάτωνmathesis.cup.grκαιcoursity.grυπάρχουν διαδικτυακά μαθήματα εισαγωγής στον προγραμματισμό με Python, το περιεχόμενο των οποίων διατίθεται ελεύθερα. Στο mathesis.cup.gr υπάρχει μάθημα προχωρημένου προγραμματισμού με Python.Επίσης οργανώνονται από σύμπραξη Ελληνικών Πανεπιστημίων και την υποστήριξη της ΕΛΛΑΚθερινά σχολεία στην Python.Παραπομπές[Επεξεργασία|επεξεργασία κώδικα]↑«Programming Language Trends - O'Reilly Radar». Radar.oreilly.com. 2 Αυγούστου 2006. Ανακτήθηκε στις 17 Ιουλίου 2013.↑«The RedMonk Programming Language Rankings: January 2013 – tecosystems». Redmonk.com. 28 Φεβρουαρίου 2013. Ανακτήθηκε στις 17 Ιουλίου 2013.↑3,03,1Αγγελιδάκης, Ν., βλ. πηγές σελ. 5 (σελ. 14 του pdf)↑4,04,14,24,34,44,54,6Αγγελιδάκης, Ν., βλ. πηγές σελ. 7 (σελ. 16 του pdf)↑(Αγγλικά) «The Making of Python: A Conversation with Guido van Rossum, Part I by Bill Venners» στο artima.com. Δημοσιεύθηκε 13/01/2003.Αρχειοθετήθηκε19/02/2019. Ανακτήθηκε 27/04/2019.↑Summerfield, Mark.Rapid GUI Programming with Python and Qt.Python is a very expressive language, which means that we can usually write far fewer lines of Python code than would be required for an equivalent application written in, say, C++ or Java↑McConnell, Steve (30 Νοεμβρίου 2009).Code Complete, p. 100.ISBN9780735636972.↑8,08,1Αγγελιδάκης, Ν., βλ. πηγές, σελ. 6 (σελ. 15 του pdf)↑«PyInstaller Home Page». Αρχειοθετήθηκεαπό το πρωτότυποστις 8 Ιουλίου 2014. Ανακτήθηκε στις 27 Ιανουαρίου 2014.↑(Αγγλικά) «History of Python» από python-course.eu.Αρχειοθετήθηκε29/08/2017. Ανακτήθηκε 27/04/2019.↑«2to3 - Automated Python 2 to 3 code translation — Python 3.7.4 documentation».docs.python.org(στα Αγγλικά). Ανακτήθηκε στις 14 Σεπτεμβρίου 2019.↑(Αγγλικά) «Python 2to3 windows CMD» στο stackoverflow.com. Ανακτήθηκε 2019-09-14.↑(Αγγλικά) Carlie Fairchild. «Guido van Rossum Stepping Down from Role as Python's Benevolent Dictator For Life» στο www.linuxjournal.com. Δημοσιεύθηκε 12/07/2018.Αρχειοθετήθηκε27/03/2019. Ανακτήθηκε 15/04/2019.↑(Αγγλικά) «Python boss Guido van Rossum steps down after 30 years» στο www.theinquirer.net.Αρχειοθετήθηκε19/02//2019. Ανακτήθηκε 15/04/2019.↑Αγγελιδάκης, Ν., βλ. πηγές σελ. 11 (σελ. 20 του pdf)↑Αγγελιδάκης, Ν., βλ. πηγές σελ. 13 (σελ. 22 του pdf)↑17,017,117,2«Μαθήματα Προγραμματισμού Python. Μάθημα 2ο» του Γιάννη Φυτίλη στο pcsteps.gr. Δημοσιεύθηκε 27/09/2017.Αρχειοθετήθηκε23/04/2019. Ανακτήθηκε 23/04/2019.↑18,018,118,218,318,4Μιχάλης Πλεξουσάκης, 2016. «Γλώσσα προγραμματισμού python3 - Μεταβλητές - Ονόματα μεταβλητών - Λέξεις κλειδιά» από users.tem.uoc.gr.Αρχειοθετήθηκε20/04/2019. Ανακτήθηκε 23/04/2019.↑19,019,119,2Αγγελιδάκης, Ν., βλ. πηγές, Κεφάλαιο 3, σελ. 17-23 (σελ. 26-32 του pdf)↑Αγγελιδάκης, Ν., βλ. πηγές σελ. 22 (σελ. 31 του pdf)↑Αγγελιδάκης, Ν., βλ. πηγές σελ. 21 (σελ. 30 του pdf)↑Αγγελιδάκης, Ν., βλ. πηγές, σελ. 27 (σελ. 36 του pdf)↑23,023,123,2«Μαθήματα Προγραμματισμού Python. Μάθημα 3ο» του Γιάννη Φυτίλη στο pcsteps.gr. Δημοσιεύθηκε 04/10/2017.Αρχειοθετήθηκε23/04/2019. Ανακτήθηκε 23/04/2019.↑Αγγελιδάκης, Ν., βλ. πηγές, σελ. 34-37 (σελ. 43-46 του pdf)↑«Μαθήματα Προγραμματισμού Python. Μάθημα 4ο» του Γιάννη Φυτίλη στο pcsteps.gr. Δημοσιεύθηκε 11/10/2017.Αρχειοθετήθηκε24/04/2019. Ανακτήθηκε 23/04/2019.↑Αράπογλου, Βραχνός, κλπ, βλ. πηγές, σελ. 32 (σελ. 33 του pdf)↑«Μαθήματα Προγραμματισμού Python. Μάθημα 6ο» του Γιάννη Φυτίλη στο pcsteps.gr. Δημοσιεύθηκε 25/10/2017.Αρχειοθετήθηκε25/04/2019. Ανακτήθηκε 23/04/2019.↑28,028,1«Μαθήματα Προγραμματισμού Python. Μάθημα 7ο» του Γιάννη Φυτίλη στο pcsteps.gr. Δημοσιεύθηκε 01/11/2017.Αρχειοθετήθηκε25/04/2019. Ανακτήθηκε 23/04/2019.↑Αγγελιδάκης, Ν., βλ. πηγές, σελ. 86-98 (σελ. 95-107 του pdf)↑Αγγελιδάκης, Ν., βλ. πηγές, σελ. 103-106 (σελ. 112-115 του pdf)↑31,031,1Αράπογλου, Βραχνός, κλπ, βλ. πηγές, σελ. 36-38 (σελ. 37-39 του pdf)↑Αγγελιδάκης, Ν., βλ. πηγές, σελ. 22 (σελ. 31 του pdf)↑Μιχάλης Πλεξουσάκης, 2016. «Γλώσσα προγραμματισμού python3 - Λογικές εκφράσεις και μεταβλητές» από users.tem.uoc.gr.Αρχειοθετήθηκε30/03/2018. Ανακτήθηκε 23/04/2019.↑34,034,1Αγγελιδάκης, Ν., βλ. πηγές, σελ. 38 (σελ. 47 του pdf)↑(Αγγλικά) Συνίσταται η χρήση 4 κενών στις εσοχές. «PEP 8 -- Style Guide for Python Code -> Indentation» από python.org. Δημοσιεύθηκε 05/07/2001.Αρχειοθετήθηκε17/04/2019. Ανακτήθηκε 22/04/2019.↑Αράπογλου, Βραχνός, κλπ., βλ. πηγές, σελ. 33 (σελ. 34 του pdf)↑37,037,137,2«Μαθήματα Προγραμματισμού Python. Μάθημα 5ο», του Γιάννη Φυτίλη στο pcsteps.gr. Δημοσιεύθηκε 18/10/2017.Αρχειοθετήθηκε25/04/2019. Ανακτήθηκε 23/04/2019.↑38,038,1Αγγελιδάκης, Ν., βλ. πηγές, σελ. 58-60 (σελ. 67-69 του pdf)↑Αναστάσιος Χατζηπαπαδόπουλος, Δρ. Βασίλης Σ. Μπελεσιώτης, 2018. «Πέτρα-Ψαλίδι-Χαρτί. Από το Δομημένο στον Αντικειμενοστρεφή προγραμματισμόΑρχειοθετήθηκε2019-04-12 στοWayback Machine.»,Τμήμα Πληροφορικής, Ιόνιο ΠανεπιστήμιοΑρχειοθετήθηκε2019-01-29 στοWayback Machine., σελ. 14 (σελ. 2 του pdf).Αρχειοθετήθηκε12/04/2019. Ανακτήθηκε 12/04/2019.↑Avouris, Nikolaos; Sgarbas, Kyriakos; Paliouras, Vassilis; Koukias, Michalis (2017-04).«Work in progress: An introduction to computing course using a Python-based experiential approach».2017 IEEE Global Engineering Education Conference (EDUCON)(IEEE).doi:10.1109/educon.2017.7943071.ISBN9781509054671.http://dx.doi.org/10.1109/educon.2017.7943071.Πηγές[Επεξεργασία|επεξεργασία κώδικα]Αγγελιδάκης, Νικόλαος Α., Εκπαιδευτικός Πληροφορικής, Μ.Δ.Ε. (M.Sc.) στην Επιστήμη Υπολογιστών (Ηράκλειο, Αύγουστος 2015). \"Εισαγωγή στον προγραμματισμό με την Python\".Αρχειοθετήθηκε12/06/2018 Ανακτήθηκε 07/04/2019.(ISBN978-960-93-7364-7). Ηλεκτρονικό βιβλίο 150 σελίδων, για αρχάριους και με άδεια: CC BY-SA 4.0.Αράπογλου Α.,Βραχνός Ε.,Λέκκα Δ.,Κανίδης Ε.,Μακρυγιάννης Π., Μπελεσιώτης Β., Τζήμας Δ., Παπαδάκης Σπ., «Προγραμματισμός Υπολογιστών Γ΄ Τάξη ΕΠΑ.Λ.» με χρήσηPython 2, Διδακτικό Υλικό, Εκδόσεις Διόφαντος.(ISBN978-960-06-5309-0).Αρχειοθετήθηκε14/09/2019.(Αγγλικά) Dave Kuhlman, (December 15, 2013). «A Python Book: Beginning Python, AdvancedPython, and Python Exercises».Αρχειοθετήθηκε19/06/2018. Ανακτήθηκε 15/04/2019. Abstract:This document is a self-learning document for a course in Python programming. This course contains (1) a part for beginners, (2) a discussion of several advanced topics that are of interest to Python programmers, and (3) a Python workbook with lots of exercises.Βιβλία[Επεξεργασία|επεξεργασία κώδικα]Ελληνικά[Επεξεργασία|επεξεργασία κώδικα]Αβούρης Ν., Μ. Κουκιάς, Β. Παλιουράς, Κ. Σγάρμπας, \"PYTHON Εισαγωγή στους υπολογιστέςΑρχειοθετήθηκε2017-05-09 στοWayback Machine.\"[1]. 3η αναθεωρημένη έκδοση, Πανεπιστημιακές Εκδόσεις Κρήτης, 2016.Καρολίδης Δ., \"Μαθαίνετε εύκολα Python\", 2η έκδοση,Εκδόσεις Άβακας, 2018.J. Guttag, \"Υπολογισμοί και προγραμματισμός με την Python\",Εκδόσεις Κλειδάριθμος, 2015.T. Gaddis, \"Ξεκινώντας με την Python\",Εκδόσεις DaVinciΑρχειοθετήθηκε2019-10-15 στοWayback Machine., 2015.Αναστάσιος Χατζηπαπαδόπουλος, Εκπαιδευτικός Πληροφορικής, (2018). «Ανάπτυξη Εφαρμογών σε Προγραμματιστικό Περιβάλλον με Python» απόusers.sch.gr/chatzipap/.Αρχειοθετήθηκε17/04/2018. Ανακτήθηκε 16/04/2019. Από τον πρόλογο: «Στο βιβλίο αυτό περιέχονται προτεινόμενες/ενδεικτικές λύσεις στα πανελλαδικά θέματα Γ & Δ(έτη 2000 –2017) του μαθήματος της Ανάπτυξης Εφαρμογών σε Προγραμματιστικό Περιβάλλον με τη χρήση όμως όχιψευδο-γλώσσαςαλλά της Python(έκδοση 2.7.10) με τον τρόπο που αυτή παρουσιάζεται στα διδακτικά εγχειρίδια της Β’ και Γ’ Τάξης του Τομέα Πληροφορικής των ΕΠΑΛ.».(ISBN978-960-93-9926-5)Χατζηγιαννάκης Νίκος,«Η γλώσσα Python σε βάθος»,Εκδόσεις Κλειδάριθμος, 2023, ISBN 978-960-645-471, Κωδικός Ευδόξου: 122075004Αγγλικά[Επεξεργασία|επεξεργασία κώδικα](Αγγλικά) Guzdial, M. (2004). Introduction to media computation: A multimedia cookbook in Python. Pearson/Custom Pub.Δείτε επίσης[Επεξεργασία|επεξεργασία κώδικα]RubyΕξωτερικοί σύνδεσμοι[Επεξεργασία|επεξεργασία κώδικα]Η επίσημη ιστοσελίδα για τη γλώσσα(Αγγλικά)Ελληνική Κοινότητα Προγραμματιστών PythonΕισαγωγή στην PythonΑρχειοθετήθηκε2010-09-15 στοWayback Machine.Άμεση PythonΤεκμηρίωση και περισσότερες πληροφορίες(Αγγλικά)Βιβλίο για την Python μεταφρασμένο από την ελληνική κοινότητα Ubuntu.Αρχειοθέτηση2013-06-05.Python for Informaticsστο P2PUGoogle's Python ClassPython Programming στο en.wikibooks.orgPythonστοCurlieΔιαδικτυακό μάθημα \"Εισαγωγή στην Python\" στην πλατφόρμα mathesis.cup.grΑρχειοθετήθηκε2019-04-16 στοWayback Machine.Διαδικτυακό μάθημα \"Προχωρημένος Προγραμματισμός με την Python\" στην πλατφόρμα mathesis.cup.grΑρχειοθετήθηκε2019-04-16 στοWayback Machine.Θερινό σχολείο Power Python (εισαγωγικό και προχωρημένο επίπεδο)Ελεύθερο Διαδικτυακό μάθημα για το πανελλαδικά εξεταζόμενο μάθημα του τομέα Πληροφορικής των ΕΠΑΛ \"Προγραμματισμός Υπολογιστών\" με Python στην πλατφόρμα moodle.sepchiou.grWikibooks logoΤα αγγλικά Βικιβιβλίαέχουν βιβλία που έχουν σχέση με την:PythonCommons logoΤαWikimedia Commonsέχουν πολυμέσα σχετικά με το θέμαPythonπσεΓλώσσες προγραμματισμούAdaALGOLAPLApplescriptAssemblyBASICCC++C#COBOLErlangForthFortranGoHaskellJavaJavaScriptKotlinLispLogoLuaMLObjective-CPascalPerlPHPPrologPythonRRubyRustSQLShellSimulaSmalltalkSwiftVisual BasicπσεΕλεύθερο λογισμικόκαιλογισμικό ανοικτού κώδικαΓενικάCopyleft·Γεγονότα και βραβεία·Ελεύθερο λογισμικό·Ορισμός του Ελεύθερου Λογισμικού·Δωρεάν και ελεύθερο·Κατάλογος ελεύθερου λογισμικού και λογισμικού ανοιχτού κώδικα·Λογισμικό ανοικτού κώδικαΛειτουργικά συστήματαAROS·BSD·Darwin·eCos·FreeDOS·GNU·Haiku·Inferno·Linux·Mach·MINIX·OpenSolaris·Plan 9·ReactOS·SymbianΑνάπτυξη λογισμικούEclipse·Free Pascal·GCC·Gambas·Java·LLVM·Lua·NetBeans·Open64·Perl·PHP·Python·ROSE·Ruby·TclΙστορίαGNU·Haiku·Linux·Mozilla(Application Suite·Firefox·Thunderbird)ΟργανισμοίApache Software Foundation·Ίδρυμα Blender·Eclipse Foundation·freedesktop.org·Ίδρυμα Ελεύθερου Λογισμικού(Ευρώπη·India·Latin America) ·FSMI·GNOME Foundation·GNU Project·Google Code·KDE e.V.·Linux Foundation·Mozilla Foundation·Open Source Geospatial Foundation·Open Source Initiative·Python Software Foundation-Software Freedom Conservancy·SourceForge·Symbian Foundation·The Document Foundation·Xiph.Org Foundation·XMPP Standards Foundation·X.Org FoundationΆδειες ελεύθερου λογισμικούApache·Artistic·BSD·GNU GPL·GNU LGPL·ISC·MIT·MPL·Ms-PL/RL·zlib·FSF approved licensesΠρότυπα αδειών λογισμικούΟρισμός του Λογισμικού Ανοιχτού Κώδικα·Ορισμός του Ελεύθερου Λογισμικού·Debian Free Software GuidelinesΣημαντικά θέματαBinary blob·Canonical's contributor agreement·Digital rights management·Συμβατότητα καρτών γραφικών·License proliferation·Mozilla software rebranding·Proprietary software·Διαμάχη SCO-Linux·Ασφάλεια·Πατέντες λογισμικού·Περιορισμοί υλικού·Trusted Computing·Viral licenseΆλλα θέματαΕναλλακτικοί όροι·Κοινότητα·Διανομή Linux·Forking·Κίνημα·Microsoft Open Specification Promise·Revolution OS·Σύγκριση με λογισμικό κλειστού κώδικαΚαθιερωμένοι όροιLCCN:sh96008834GND:4434275-5SUDOC:051626225BNF:cb13560465c(data)NKC:ph170668Πύλη:Προγραμματισμός↑«PYTHON».Πανεπιστημιακές Εκδόσεις Κρήτης. 2016-10-01. Αρχειοθετήθηκε απότο πρωτότυποστις 2017-05-09.https://web.archive.org/web/20170509131811/http://www.cup.gr/book/python. Ανακτήθηκε στις 2018-07-06."
    },
    {
        "url": "https://el.wikipedia.org/wiki/%CE%94%CE%B9%CE%B5%CF%81%CE%BC%CE%B7%CE%BD%CE%B5%CF%85%CE%BC%CE%AD%CE%BD%CE%B7_%CE%B3%CE%BB%CF%8E%CF%83%CF%83%CE%B1",
        "title": "Διερμηνέας (υπολογιστές)",
        "content": "Το λήμμα παραθέτει τις πηγές του αόριστα, χωρίςπαραπομπές.Βοηθήστε συνδέοντας το κείμενο με τις πηγέςχρησιμοποιώντας παραπομπές, ώστε να είναιεπαληθεύσιμο.Η σήμανση τοποθετήθηκε στις 06/02/2020.Στηνπληροφορικήδιερμηνέαςήδιερμηνευτής(interpreter) συνήθως σημαίνει έναπρόγραμμαπουεκτελείήερμηνεύειεντολές σε κάποιαγλώσσα προγραμματισμού. Η διερμήνευση και ημεταγλώττισηείναι τα δύο βασικά μέσα με τα οποία υλοποιούνται οι γλώσσες προγραμματισμού, αν και δεν αποτελούν εντελώς διακριτές κατηγορίες, καθώς οι λειτουργίες τους επικαλύπτονται σε κάποιον βαθμό.Διερμηνέαςείναι ένα πρόγραμμα που είτε:εκτελεί τονπηγαίο κώδικααπευθείαςμεταφράζει τον πηγαίο κώδικα σε μια περισσότερο αποδοτική μορφή (κώδικα) που αμέσως εκτελείσαφώς εκτελεί προ-μεταγλωττισμένο κώδικα που έχει δημιουργήσει κάποιος μεταγλωττιστής που είναι μέρος του συστήματος διερμήνευσης.Με την τελευταία έννοια, οεπεξεργαστήςείναι μιας μορφής διερμηνέας εντολών κώδικα μηχανής σε συνδυασμό με τον μεταγλωττιστή που τις παράγει.ΗPerl, ηPython, ηMATLAB, και ηRubyείναι παραδείγματα γλωσσών που μεταφράζουν τον κώδικα σε αποδοτική μορφή, στο νούμερο 2 παραπάνω, ενώ ηUCSD Pascalκαι η εικονική μηχανή τηςJavaανήκουν στο νούμερο 3 παραπάνω: τα προγράμματα Java μεταγλωττίζονται και αποθηκεύονται ως κώδικας bytecode, που στη συνέχειασυνδέεταικατά την ώρα της εκτέλεσης και εκτελείται από ένα διερμηνέα (εικονική μηχανή). Μερικά συστήματα όπως ηSmalltalkσυνδυάζουν τη δεύτερη και τρίτη κατηγορία.Ο όροςδιερμηνευμένη γλώσσασημαίνει  ότι η κανονική υλοποίηση της γλώσσας είναι διερμηνέας ή μεταγλωττιστής. Μια γλώσσα υψηλού επιπέδου είναι βασικά μια αφαίρεση, που (ιδανικά) δεν εξαρτάται από κάποια συγκεκριμένη υλοποίηση.Θεωρητικά, οποιαδήποτε γλώσσα μπορεί να είναι είτεμεταγλωττισμένηείτε διερμηνευμένη, έτσι ο διαχωρισμός αυτός εφαρμόζεται μόνο με βάση την συνήθη πρακτική υλοποίησης, και όχι κάποια συγκεκριμένη ιδιότητα μιας γλώσσας.Πολλές γλώσσες έχουν υλοποιηθεί τόσο με χρήση μεταγλωττιστών όσο και με διερμηνείς, όπως ηLisp, ηPascal, ηC, ηBASICκαι ηPython.  Η γλώσσαJavaμεταφράζεται σε μια μορφή που προορίζεται συνήθως για διερμήνευση, αν και συχνά χρησιμοποιείται ημεταγλώττιση ακριβώς-στην-ώρα(just-in-time compilation) για να παράγει κώδικα μηχανής πριν την εκτέλεση.  Οι γλώσσες .Net τηςMicrosoftμεταγλωττίζονται στηνCILαπό την οποία συνήθως μεταγλωττίζονται στη συνέχεια σε κώδικα μηχανής, αν και υπάρχειεικονική μηχανήπου μπορεί να διερμηνεύσει τη CIL.Αυτό το  λήμμα σχετικά με τηνΠληροφορικήχρειάζεταιεπέκταση. Μπορείτε να βοηθήσετε την Βικιπαίδειαεπεκτείνοντάς το."
    },
    {
        "url": "https://el.wikipedia.org/wiki/%CE%93%CE%BB%CF%8E%CF%83%CF%83%CE%B1_%CF%85%CF%88%CE%B7%CE%BB%CE%BF%CF%8D_%CE%B5%CF%80%CE%B9%CF%80%CE%AD%CE%B4%CE%BF%CF%85",
        "title": "Γλώσσα προγραμματισμού υψηλού επιπέδου",
        "content": "Το λήμμα δεν περιέχειπηγέςή αυτές που περιέχει δεν επαρκούν.Μπορείτε να βοηθήσετεπροσθέτοντας την κατάλληλη τεκμηρίωση. Υλικό που είναι ατεκμηρίωτο μπορεί να αμφισβητηθεί και να αφαιρεθεί.Η σήμανση τοποθετήθηκε στις 24/10/2016.Ωςυψηλού επιπέδουγλώσσα προγραμματισμού(high-level programming language) ορίζεται αυτή  που επιτρέπει τημεταφερσιμότηταενόςπρογράμματοςαπό έναν υπολογιστή σε έναν άλλο. Αποτελείται από εντολές εύκολα κατανοητές στον προγραμματιστή, καθώς μοιάζουν με -περιορισμένη-φυσική γλώσσα. Για την εκτέλεση του προγράμματος από τον υπολογιστή, απαιτείται η χρήσημεταγλωττιστήγια την παραγωγή του προγράμματος σεγλώσσα μηχανής.Ανάλογα με το σκοπό τους, οι γλώσσες προγραμματισμού υψηλού επιπέδου διακρίνονται σε γλώσσες ειδικού σκοπού -όπως ηFORTRAN, ηCOBOL, ηLISPκαι σε γλώσσες γενικής χρήσης -όπως ηPython, ηCη Visual Basic και ηJava.Αυτό το  λήμμα σχετικά με τηνΠληροφορικήχρειάζεταιεπέκταση. Μπορείτε να βοηθήσετε την Βικιπαίδειαεπεκτείνοντάς το."
    },
    {
        "url": "https://el.wikipedia.org/wiki/%CE%93%CE%BB%CF%8E%CF%83%CF%83%CE%B1_%CF%80%CF%81%CE%BF%CE%B3%CF%81%CE%B1%CE%BC%CE%BC%CE%B1%CF%84%CE%B9%CF%83%CE%BC%CE%BF%CF%8D",
        "title": "Γλώσσα προγραμματισμού",
        "content": "Το λήμμα παραθέτει τις πηγές του αόριστα, χωρίςπαραπομπές.Βοηθήστε συνδέοντας το κείμενο με τις πηγέςχρησιμοποιώντας παραπομπές, ώστε να είναιεπαληθεύσιμο.Το πρότυπο τοποθετήθηκε χωρίς ημερομηνία. Για τη σημερινή ημερομηνία χρησιμοποιήστε:{{χωρίς παραπομπές|9|01|2025}}Γλώσσα προγραμματισμούλέγεται μια τεχνητή γλώσσα που μπορεί να χρησιμοποιηθεί για τον έλεγχο μιας μηχανής, συνήθως ενόςυπολογιστή. Οι γλώσσες προγραμματισμού (όπως άλλωστε και οι ανθρώπινες γλώσσες) ορίζονται από ένα σύνολο συντακτικών και εννοιολογικών κανόνων, που ορίζουν τη δομή και το νόημα, αντίστοιχα, των προτάσεων της γλώσσας.Οι γλώσσες προγραμματισμού χρησιμοποιούνται για να διευκολύνουν την οργάνωση και διαχείριση πληροφοριών, αλλά και για την ακριβή διατύπωσηαλγορίθμων. Ορισμένοι ειδικοί χρησιμοποιούν τον όρογλώσσα προγραμματισμούμόνο γιατυπικές γλώσσεςπου μπορούν να εκφράσουν όλους τους πιθανούς αλγορίθμους. Μη-υπολογιστικές γλώσσες όπως ηHTMLή τυπικές γραμματικές όπως ηBNFδεν λέγονται συνήθως γλώσσες προγραμματισμού.Υπάρχουν περίπου 9000 διαφορετικές γλώσσες προγραμματισμού[1]και κάθε χρόνο δημιουργούνται περισσότερες.Χαρακτηριστικά των γλωσσών προγραμματισμού[Επεξεργασία|επεξεργασία κώδικα]Κάθε γλώσσα προγραμματισμού έχει το δικό της σύνολο τυπικών προδιαγραφών (ή κανόνων) που αφορούν τοσυντακτικό, το λεξιλόγιο και τονόηματης. Για πολλές γλώσσες που χρησιμοποιούνται ευρέως και έχουν χρησιμοποιηθεί για αρκετό χρονικό διάστημα (π.χ.C,C++,Java,Scheme), υπάρχουν ειδικοί φορείς τυποποίησης, οι οποίοι μέσα από τακτές συναντήσεις δημιουργούν, τροποποιούν ή επεκτείνουν τις τυπικές προδιαγραφές που διέπουν τη χρήση μιας γλώσσας προγραμματισμού. Άλλες γλώσσες δεν περιγράφονται σε κάποιο επίσημο πρότυπο αλλά ορίζονται μόνο με βάση κάποια υλοποίησή τους (που αποτελεί τοντε φάκτο πρότυπο), όπως ηPythonπου περιγράφεται από την υλοποίηση CPython.Ιστορία γλωσσών προγραμματισμού[Επεξεργασία|επεξεργασία κώδικα]ΒλέπεΙστορία γλωσσών προγραμματισμού.Κατηγοριοποίηση γλωσσών προγραμματισμού[Επεξεργασία|επεξεργασία κώδικα]Δεν υπάρχει απλός τρόπος να κατηγοριοποιηθούν οι γλώσσες προγραμματισμού. Αυτό συμβαίνει γιατί συνήθως κάθε γλώσσα προγραμματισμού περιέχει επιρροές από πολλές προηγούμενες γλώσσες, συνδυάζοντας θετικά στοιχεία και προσθέτοντας νέα. Χαρακτηριστικά που εμφανίζονται σε μια γλώσσα και έχουν θετική αποδοχή, συνήθως υιοθετούνται από μεταγενέστερες γλώσσες ακόμα και αν πρόκειται για γλώσσες που ανήκουν σε διαφορετική κατηγορία.Η κατηγοριοποίηση είναι ακόμα πιο περίπλοκη για το λόγο ότι πολλές γλώσσες συνήθως ανήκουν σε παραπάνω από μία κατηγορίες. Για παράδειγμα, ηJavaείναι τόσοαντικειμενοστρεφήςόσο και παράλληλη γλώσσα, δεδομένου ότι υποστηρίζει την οργάνωση των δεδομένων και υπολογισμών σε αντικείμενα, αλλά επιτρέπει επίσης και την δημιουργία προγραμμάτων με ταυτόχρονανήματα (threads)που εκτελούνται παράλληλα.Δεδομένης της δυσκολίας στην κατηγοριοποίηση, μπορούμε να κατηγοριοποιήσουμε τις γλώσσες προγραμματισμού με διάφορους τρόπους. Οι συνηθέστεροι τρόποι είναι:με βάση τον τρόπο οργάνωσης του προγράμματοςμε βάση τον στόχο που έχει η γλώσσαμε βάση τον τρόπο που περιγράφουν το ζητούμενο αποτέλεσμαΣτην πρώτη περίπτωση προκύπτουν κατηγορίες όπως:Διαδικαστικές γλώσσες(procedural) όπου το πρόγραμμα είναι οργανωμένο σε διαδικασίες, που αποτελούνται από σειρές εντολών που περιγράφουν αλγορίθμους. Παραδείγματα γλωσσών που ανήκουν σε αυτή την κατηγορία είναι ηPascalή ηC.Αντικειμενοστρεφείς γλώσσες(object-oriented) όπου το πρόγραμμα είναι οργανωμένο σε αντικείμενα. Ένα αντικείμενο είναι μια μονάδα που αποτελείται από την περιγραφή κάποιων δεδομένων και την περιγραφή των αλγορίθμων που τα επεξεργάζονται. Ένα αντικειμενοστρεφές πρόγραμμα αποτελείται από διάφορα αντικείμενα που αλληλεπιδρούν μεταξύ τους. Παραδείγματα αντικειμενοστρεφών γλωσσών είναι ηJavaή ηC++.Συναρτησιακές γλώσσες(functional) όπου οι υπολογισμοί εκφράζονται ως εφαρμογές μαθηματικών συναρτήσεων, σε αντίθεση με τα άλλα είδη προγραμματισμού όπου οι υπολογισμοί εκφράζονται ως σειρές εντολών, όπου η κάθε μία αλλάζει με κάποιο τρόπο την κατάσταση του συστήματος. Θεωρητικό τους υπόβαθρο είναι ολ-λογισμός. Χαρακτηριστικές συναρτησιακές γλώσσες είναι ηLisp, ηHaskellκαι ηOCaml.Στην περίπτωση που η κατηγοριοποίηση των γλωσσών προγραμματισμού γίνει με βάση το στόχο που έχει η γλώσσα, υπάρχουν οι παρακάτω κατηγορίες:Γλώσσες γενικής χρήσης. Σε αυτήν την κατηγορία ταξινομούνται γλώσσες που δημιουργήθηκαν για τον προγραμματισμό γενικών εφαρμογών, καθώς και πολλές εκπαιδευτικές γλώσσες που αποδείχτηκαν χρήσιμες για την ανάπτυξη γενικών εφαρμογών, όπως ηPascal.Γλώσσες προγραμματισμού συστημάτων, που χρησιμοποιούνται συνήθως για τον προγραμματισμό λειτουργικών συστημάτων ή οδηγών (drivers) υλικού, όπου χρειάζεται πολλές φορές ο προγραμματιστής να έχει έλεγχο και γνώση του πως λειτουργεί το υλικό. Η πιο συχνά χρησιμοποιούμενη γλώσσα προγραμματισμού συστημάτων είναι ηC.Γλώσσες σεναρίων(scripting). Αυτές οι γλώσσες χρησιμοποιούνται συνήθως για τη γρήγορη ανάπτυξη μικρών προγραμμάτων, σε περιπτώσεις που ο χρόνος του προγραμματιστή είναι πιο πολύτιμος από την ταχύτητα εκτέλεσης του προγράμματος, όπως για παράδειγμα συμβαίνει όταν το πρόγραμμα απλά αυτοματοποιεί απλές λειτουργίες. Παραδείγματα γλωσσών σεναρίων (scripting) είναι ηPerl, ηPython, ηRubyή τακελύφητου λειτουργικού συστήματος Unix (shells).Γλώσσες ειδικών εφαρμογών. Σε αυτή την κατηγορία ανήκουν γλώσσες που αναπτύχθηκαν ειδικά για μια συγκεκριμένη εφαρμογή. Για παράδειγμα, η γλώσσαPostScriptείναι σχεδιασμένη ειδικά για να περιγράφονται με λεπτομέρεια κείμενα προς εκτύπωση, ενώ η γλώσσαMatlabείναι σχεδιασμένη για την επεξεργασία πινάκων από αριθμητικά δεδομένα.Παράλληλεςήκατανεμημένεςγλώσσες. Στη συγκεκριμένη κατηγορία ταξινομούνται γλώσσες που επιτρέπουν τη ανάπτυξη παράλληλων προγραμμάτων, όπου πολλές εντολές εκτελούνται ταυτόχρονα σε πολλούς υπολογιστές, έτσι ώστε το τελικό αποτέλεσμα να προκύψει γρηγορότερα. Οι παράλληλες γλώσσες προσφέρουν συνήθως εύκολους τρόπους επικοινωνίας μεταξύ των νημάτων που εκτελούνται παράλληλα, καθώς και τρόπους ώστε να δημιουργούνται καινούριες παράλληλες εκτελέσεις. Παραδείγματα γλωσσών που ανήκουν (και) σε αυτή την κατηγορία είναι ηGo, ηJava, ηErlang, ηMultiLispή ηCilk.Εκπαιδευτικά προγραμματιστικά περιβάλλοντα. Σε αυτή την κατηγορία ανήκουν εκπαιδευτικές; γλώσσες  προγραμματισμού οι οποίες απευθύνονται σε αρχάριους προγραμματιστές για την κατασκευή μικροεφαρμογών. Είναι κατάλληλες για την εκμάθηση προγραμματισμού σε μικρές ηλικίες. Παραδείγματα τέτοιων γλωσσών είναι η LOGO, το Game Maker και το App Inventor.Τέλος, στην περίπτωση που η κατηγοριοποίηση γίνεται με βάση τον τρόπο που περιγράφεται το ζητούμενο, υπάρχουν οι παρακάτω κατηγορίες:Προστακτικές γλώσσες προγραμματισμού(imperative) είναι οι γλώσσες που περιγράφουν το ζητούμενο αποτέλεσμα κατασκευαστικά, δίνοντας μια σειράεντολώνπου όταν εκτελεστούν παράγουν το ζητούμενο αποτέλεσμα. Τέτοιες γλώσσες είναι ηC, ηJavaαλλά και ηOCaml.Δηλωτικές γλώσσες προγραμματισμού(declarative) είναι οι γλώσσες που περιγράφουν το ζητούμενο αποτέλεσμα χρησιμοποιώντας τις ιδιότητες που έχει, και όχι τον τρόπο με τον οποίο υπολογίζεται. Παραδείγματα δηλωτικών γλωσσών είναι ηHaskell, ηSQLκαι ηProlog.Γλώσσες προγραμματισμού[Επεξεργασία|επεξεργασία κώδικα]κατ' αλφαβητική σειρά:AdaAlgolApplescriptAWKBASICCC++C#CilkClojureCOBOLDatalogDelphiErlangForthFORTRANGoHaskellJavaJavaScriptKotlinLispLogoLuaLucidMathematicaMatlabMirandaMLOBJ/Σύστημα MaudeObjective-COCamlPascalPerlPHPPrologPythonRRubyScalaSchemeSimulaSmalltalkSQLTclTypeScriptVisual BasicΓΛΩΣΣΑΗ παραπάνω λίστα είναι ενδεικτική και σε καμία περίπτωση δεν εξαντλεί το εύρος και την ποικιλία των χιλιάδων γλωσσών που χρησιμοποιούνται στην πράξη.Πηγές[Επεξεργασία|επεξεργασία κώδικα]\"Εφαρμογές Πληροφορικής\",ΙΤΥΕ ΔΙΟΦΑΝΤΟΣ, σελ 52-53,ISBN 978-960-06-4894-2Δείτε επίσης[Επεξεργασία|επεξεργασία κώδικα]Γλώσσες χαμηλού επιπέδου[Επεξεργασία|επεξεργασία κώδικα]Γλώσσα μηχανήςΣυμβολική γλώσσαΘεωρητικές γλώσσες[Επεξεργασία|επεξεργασία κώδικα]λ-λογισμόςΨευδοκώδικαςΓλώσσες με εξαρτώμενους τύπους[Επεξεργασία|επεξεργασία κώδικα]AgdaCoqΆλλα θέματα[Επεξεργασία|επεξεργασία κώδικα]Οπτική γλώσσα προγραμματισμούΣύστημα τύπωνPlankalkülΠαραπομπές[Επεξεργασία|επεξεργασία κώδικα]↑«How Many Coding Languages Are There?».Περαιτέρω διάβασμα[Επεξεργασία|επεξεργασία κώδικα]Fundamental Concepts in Programming Languages(βασικές έννοιες των γλωσσών προγραμματισμού)(Αγγλικά)Εφαρμογές Πληροφορικής (Διαδραστικά σχολικά βιβλία)Καθιερωμένοι όροιLCCN:sh85107313GND:4047409-4BNF:cb13318353n(data)NDL:00569224NKC:ph115890Πύλη:Προγραμματισμός"
    },
    {
        "url": "https://el.wikipedia.org/wiki/%CE%A0%CF%81%CE%BF%CF%83%CF%84%CE%B1%CE%BA%CF%84%CE%B9%CE%BA%CF%8C%CF%82_%CF%80%CF%81%CE%BF%CE%B3%CF%81%CE%B1%CE%BC%CE%BC%CE%B1%CF%84%CE%B9%CF%83%CE%BC%CF%8C%CF%82",
        "title": "Προστακτικός προγραμματισμός",
        "content": "Στηνπληροφορικήκαλούμεπροστακτικό προγραμματισμό(Αγγλικά:Imperative programming), σε αντίθεση με τοδηλωτικό προγραμματισμό, έναπρογραμματιστικό υπόδειγμαόπου το ζητούμενο κατασκευάζεται / υπολογίζεται αλλάζοντας την κατάσταση του υπολογιστή μέσω εντολών. Η ιδέα είναι ότι έχουμε εντολές/statementsπου συνήθως μοιράζονται κοινές μεταβλητές.[1]Το υπόδειγμα αυτό ακολουθούν οιδιαδικαστικές γλώσσες προγραμματισμού, όπως ηPascal, ηC, ηFortran, κ.α., αλλά και πολλέςαντικειμενοστρεφείς γλώσσεςόπως ηJava, ηC++, ηC#, κ.α. Η ιδέα του προστακτικού προγραμματισμού απορρέει από τηναρχιτεκτονική φον Νόιμανη οποία σχεδιάστηκε την δεκαετία 1940. Κατά την αρχιτεκτονική αυτή η κάθε εντολή (γλώσσας μηχανής) εκτελείται διαδοχικά (σε κάθε κύκλο λειτουργίας του επεξεργαστή). Η μετέπειτα ανάπτυξη των γλωσσών προγραμματισμού υψηλού επιπέδου (όπως για παράδειγμα η Pascal ή η C) βασίστηκαν στην αρχιτεκτονική φον Νόιμαν και υλοποίησαν το υπόδειγμα του προστατικού προγραμματισμό όπου ο προγραμματισμός γίνεται σε γλώσσα υψηλού επιπέδου.[2]Σε μια γλώσσα προστακτινού προγραμματισμού (σε σύγκριση με μια γλώσσα συναρτησιακού προγραμματισμού) έχουμε πολύπλοκη σημασιολογία, πολύπλοκο συντακτικό και η αποδοτική εκτέλεση του προγράμματος είναι ευθύνη του προγραμματιστή. Στην περίπτωση που θέλουμε το πρόγραμμα να εκτελεστεί ταυτόχρονα σε περισσότερους πυρήνες ο προγραμματιστής πρέπει να το σχεδιάσει το πρόγραμμα και την ταυτόχρονη εκτέλεση, σε αντίθεση σε ένα πρόγραμμα συναρτησιακού προγραμματισμού το οποίο μπορεί να εκτελεστεί ταυτόχρονα χωρίς παραπάνω σχεδίαση από τον προγραμματιστή (λόγω των αναδρομικών κλήσεων συναρτήσεων κλπ).[3]Παράδειγμα[Επεξεργασία|επεξεργασία κώδικα]Αν θέλουμε να υπολογίσουμε το άθροισμα ακέραιων αριθμών από το 1 μέχρι ένα αριθμόnσε κάποια προστακτική γλώσσα προγραμματισμού θα χρησιμοποιούσαμε 2 μεταβλητές οι οποίες θα αλλάζανε τιμές κατά την εκτέλεση του προγράμματος[4]όπως φαίνεται στο παρακάτωψευδοκώδικα:count := 0\ntotal := 0 \nrepeat\n   count := count + 1\n   total := total + count\nuntil\n   count = nή υλοποιημένο στην γλώσσα C++:intcount=0;inttotal=0;do{count++;total+=count;}while(count!=n);Στο παράδειγμα αυτό οι τιμές των μεταβλητώνcountκαιtotalκατά την διάρκεια εκτέλεσης του κώδικα αλλάζουν τιμές μέχρι να υπολογιστεί το άθροισμα και αυτό ο τύπος προγραμματισμού λέγεται προστακτικός. Το πρόβλημα αυτό θα μπορούσε να λυθεί με μια αναδρομική συνάρτηση πάνω σε μια λίστα με τιμές 1..n μεθοδολογία η οποία δεν συνηθίζεται στον προστακτικό προγραμματισμό αλλά στονδηλωτικό προγραμματισμόόπως φαίνεται στην αναδρομική κλίση λίστας με 3 αριθμούς:sum [1,2,3]\n= 1 + sum[2,3]\n= 1 + (2 + sum[3])\n= 1 + (2 + (3 + sum[]))\n= 1 + (2 + (3 + 0))\n= 6Δείτε επίσης[Επεξεργασία|επεξεργασία κώδικα]Δηλωτικός προγραμματισμόςΠαραπομπές[Επεξεργασία|επεξεργασία κώδικα]↑Haridi, Peter Van Roy; Seif (2004).Concepts, techniques, and models of computer programming. Cambridge, Mass. [u.a.]: MIT Press. σελ. 406.ISBN0-262-22069-5.↑Tucker, Allen B., επιμ. (2004).Computer science handbook(2η έκδοση). Boca Raton, Flor.: Chapman & Hall/CRC. σελίδες 90–1, 90–2.ISBN158488360X.↑Σαγώνας, Κωστής.«Γλώσσες Συναρτησιακού Προγραμματισμού»(PDF). Σημειώσεις από μάθημα πληροφορικής στο Εθνικό Μετσόβιο Πολυτεχνείο. Ανακτήθηκε στις 1 Δεκεμβρίου 2014.[νεκρός σύνδεσμος]↑Hutton, Graham (2007).Programming in Haskell(5. print. έκδοση). Cambridge [u.a.]: Cambridge Univ. Press. σελ. 3.ISBN978-0-521-69269-4."
    },
    {
        "url": "https://el.wikipedia.org/wiki/%CE%94%CE%B9%CE%B1%CE%B4%CE%B9%CE%BA%CE%B1%CF%83%CF%84%CE%B9%CE%BA%CF%8C%CF%82_%CF%80%CF%81%CE%BF%CE%B3%CF%81%CE%B1%CE%BC%CE%BC%CE%B1%CF%84%CE%B9%CF%83%CE%BC%CF%8C%CF%82",
        "title": "Δομημένος προγραμματισμός",
        "content": "Στηνπληροφορικήδομημένος προγραμματισμός(structured programming) ήδιαδικαστικός προγραμματισμός(procedural programming) είναι μίαπροσέγγιση στον προγραμματισμό[1], η οποία βασίζεται στην έννοια τηςκλήσης διαδικασίας. Ηδιαδικασία, γνωστή επίσης και ως ρουτίνα, υπορουτίνα, μέθοδος ή συνάρτηση (δεν σχετίζεται άμεσα με τημαθηματικήέννοια τηςσυνάρτησης), είναι απλά ένα αυτοτελές σύνολο εντολών προς εκτέλεση.[2]Ο δομημένος προγραμματισμός βασίζεται στην αρχή τουδιαίρει και βασίλευε, καθώς διασπά το βασικό πρόβλημα σε μικρότερα υποπροβλήματα (γνωστά επίσης και ως εργασίες). Κάθε εργασία με πολύπλοκη περιγραφή διαιρείται σε μικρότερες, έως ότου οι εργασίες να είναι αρκετά μικρές, περιεκτικές και εύκολες προς κατανόηση[1].Ιστορική διαδρομή[Επεξεργασία|επεξεργασία κώδικα]Ιστορικά ο δομημένος προγραμματισμός αναπτύχθηκε ύστερα από έρευνα κατά τηδεκαετία του 1960, ως βελτίωση του ήδη υπάρχοντος διαδικαστικού προγραμματισμού. Ένα από τα πιο σημαντικά αποτελέσματα αυτής της έρευνας ήταν η ανάπτυξη της γλώσσαςPascal (γλώσσα προγραμματισμού), από τονΝίκλαους Βιρτ(Niklaus Wirth) το1971, η οποία σύντομα έγινε η προτιμώμενη γλώσσα διδασκαλίας σε πολλά πανεπιστήμια[3]. Η έννοια της διαδικασίας επομένως ήταν προϋπάρχουσα αλλά δεν έπαιζε τόσο σημαντικό ρόλο στη δομή των υπό συγγραφή εφαρμογών, καθώς τα δεδομένα ήταν αρκετά διαχωρισμένα από τις διαδικασίες και έπρεπε ο προγραμματιστής να θυμάται για κάθε διαδικασία ποια άλλη καλούσε, αλλά και ποια δεδομένα διαφοροποιούνταν[1]. Καθώς όμως οι περισσότερες διαδικαστικές γλώσσες γρήγορα υιοθέτησαν στοιχεία ώστε να υποστηρίζουν δομημένο προγραμματισμό, οι δύο όροι σήμερα έχουν πρακτικώς ταυτιστεί. Με τον καιρό οι δομημένες γλώσσες έφτασαν να μην επαρκούν για τη συγγραφή προγραμμάτων, επεκτάθηκαν και ως λύση υιοθετήθηκε οαντικειμενοστρεφής προγραμματισμός.Πλεονεκτήματα[Επεξεργασία|επεξεργασία κώδικα]Ο δομημένος προγραμματισμός βοηθάει την ευκολότερη συγγραφή πολύπλοκων προγραμμάτων. Με τον δομημένο προγραμματισμό γίνεται πιο εύκολη και ταχύτερη η διαχείριση, η συντήρηση και ηαποσφαλμάτωση, καθώς βασίζεται σε μεγαλύτερες, πολυπλοκότερες και περιεκτικότερες μονάδες, όπως οι διαδικασίες, αντί για μεμονωμένες εντολές.Παράδειγμα[Επεξεργασία|επεξεργασία κώδικα]Παράδειγμα δομημένου προγραμματισμού σε γλώσσα C:#include <stdio.h>\n  int sum(int,int);\n   \n  int main() {\n      int x,y;\n\n      puts(\"Δύο ακέραιοι με κενό ενδιάμεσα:\");\n      scanf(\"%d %d\",&x,&y);\n      printf(\"Sum is %d\\n\", sum(x,y));\n\n      return 0;\n  }\n\n  int sum(int k, int l) {\n      return k+l;\n  }Παραπομπές[Επεξεργασία|επεξεργασία κώδικα]↑1,01,11,2Jesse Liberty, Bradley Jones,Sams Teach Yourself C++ in 21 Days, Sams Publishing, 2004, σελ. 8,ISBN 978-0-672-32711-7↑Σταματόπουλος, Παναγιώτης, 2015. «Κεφάλαιο 1. Διαδικαστικός και δηλωτικός προγραμματισμόςΑρχειοθετήθηκε2019-04-13 στοWayback Machine.» σελ.8 (σελ. 1 του pdf) απόΛογικός και συναρτησιακός προγραμματισμός(ISBN978-960-603-335-3). Δημοσιεύθηκε 19/10/2015.Αρχειοθετήθηκε13/04/2019. Ανακτήθηκε 14/04/2019.↑Harvey M. Deitel,C++ How to Program: how to program, Pearson Prentice Hall 2005, σελ 10,ISBN 978-0-13-185757-5Πύλη:Προγραμματισμός"
    },
    {
        "url": "https://el.wikipedia.org/wiki/%CE%91%CE%BD%CF%84%CE%B9%CE%BA%CE%B5%CE%B9%CE%BC%CE%B5%CE%BD%CE%BF%CF%83%CF%84%CF%81%CE%B5%CF%86%CE%AE%CF%82_%CF%80%CF%81%CE%BF%CE%B3%CF%81%CE%B1%CE%BC%CE%BC%CE%B1%CF%84%CE%B9%CF%83%CE%BC%CF%8C%CF%82",
        "title": "Αντικειμενοστρεφής προγραμματισμός",
        "content": "Στηνπληροφορικήαντικειμενοστρεφή προγραμματισμό(object-oriented programming)[1][2]ήΑΠ, ονομάζουμε έναπρογραμματιστικό υπόδειγματο οποίο εμφανίστηκε στα τέλη της δεκαετίας του 1970 και καθιερώθηκε κατά τη δεκαετία του 1990, αντικαθιστώντας σε μεγάλο βαθμό το παραδοσιακό υπόδειγμα τουδομημένου προγραμματισμού. Πρόκειται για μία μεθοδολογία ανάπτυξηςπρογραμμάτων, υποστηριζόμενη από κατάλληλεςγλώσσες προγραμματισμού, όπου ο χειρισμός σχετιζόμενωνδεδομένωνκαι τωνδιαδικασιώνπου επενεργούν σε αυτά γίνεται από κοινού, μέσω μίαςδομής δεδομένωνπου τα περιβάλλει ως αυτόνομη οντότητα με ταυτότητα και δικά της χαρακτηριστικά. Αυτή η δομή δεδομένων καλείταιαντικείμενοκαι αποτελεί πραγματικό στιγμιότυπο στημνήμηενός σύνθετου, και πιθανώς οριζόμενου από τον χρήστη,τύπου δεδομένωνπου ονομάζεταικλάση(class). Η κλάση προδιαγράφει τόσο δεδομένα όσο και τις διαδικασίες οι οποίες επιδρουζν επάνω τους· αυτή υπήρξε η πρωταρχική καινοτομία του ΑΠ.Έτσι μπορεί να οριστεί μία προδιαγραφή δομής αποθήκευσης (π.χ. μία κλάση «τηλεόραση») η οποία να περιέχει τόσο ιδιότητες (π.χ. μίαμεταβλητή(variable) «τρέχον κανάλι») όσο και πράξεις ή χειρισμούς επί αυτών των ιδιοτήτων (π.χ. μία διαδικασία (method/function) «άνοιγμα της τηλεόρασης»). Στο εν λόγω παράδειγμα κάθε υλική τηλεόραση (κάθε αντικείμενο αποθηκευμένο πραγματικά στη μνήμη) αναπαρίσταται ως ξεχωριστό, «φυσικό» στιγμιότυπο αυτής της πρότυπης, ιδεατής κλάσης. Επομένως μόνο τα αντικείμενα καταλαμβάνουν χώρο στη μνήμη του υπολογιστή ενώ οι κλάσεις αποτελούν απλώς «καλούπια». Οι αιτίες που ώθησαν στην ανάπτυξη του ΑΠ ήταν οι ίδιες με αυτές που οδήγησαν στην ανάπτυξη του δομημένου προγραμματισμού (ευκολία συντήρησης, οργάνωσης, χειρισμού καιεπαναχρησιμοποίησης κώδικαμεγάλων και πολύπλοκων εφαρμογών), όμως τελικώς η αντικειμενοστρέφεια επικράτησε καθώς μπορούσε να ανταπεξέλθει σε προγράμματα πολύ μεγαλύτερου όγκου και πολυπλοκότητας.Ιστορικό[Επεξεργασία|επεξεργασία κώδικα]Οι περισσότερες αντικειμενοστρεφείς έννοιες εμφανίστηκαν αρχικά στηγλώσσα προγραμματισμούSimula 67, η οποία ήταν προσανατολισμένη στην εκτέλεσηπροσομοιώσεωντου πραγματικού κόσμου. Οι ιδέες της Simula 67 επηρέασαν κατά τη δεκαετία του '70 την ανάπτυξη τηςSmalltalk, της γλώσσας που εισήγαγε τον όρο αντικειμενοστρεφής προγραμματισμός. Η Smalltalk αναπτύχθηκε από τονΆλαν Κέι(Alan Key) της εταιρείαςXeroxστο πλαίσιο μίας εργασίας με στόχο τη δημιουργία ενός χρήσιμου, αλλά και εύχρηστου,προσωπικού υπολογιστή. Όταν η τελική έκδοση της Smalltalk έγινε διαθέσιμη το1980η έρευνα για την αντικατάσταση του δομημένου προγραμματισμού με ένα πιο σύγχρονο υπόδειγμα ήταν ήδη εν εξελίξει. Στη γλώσσα αυτή όλοι οι τύποι δεδομένων ήταν κλάσεις (δεν υπήρχαν δηλαδή πια παραδοσιακές δομές δεδομένων παρά μόνο αντικείμενα).Την ίδια περίπου εποχή, και επίσης με επιρροές από τη Simula, ολοκληρωνόταν η ανάπτυξη τηςC++ως μίας ισχυρής επέκτασης της δημοφιλούς γλώσσας προγραμματισμούCστην οποία είχαν \"μεταμοσχευθεί\" αντικειμενοστρεφή χαρακτηριστικά. Η επιρροή της C++ καθ' όλη της δεκαετία του '80 ήταν καταλυτική με αποτέλεσμα τη σταδιακή κυκλοφορία αντικειμενοστρεφών εκδόσεων πολλών γνωστών διαδικαστικών γλωσσών προγραμματισμού. Κατά το πρώτο ήμισυ της δεκαετίας του '90 η βαθμιαία καθιέρωση στους μικροϋπολογιστές των γραφικών διασυνδέσεων χρήστη (GUI), για την ανάπτυξη των οποίων ο ΑΠ φαινόταν ιδιαιτέρως κατάλληλος, και η επίδραση της C++ οδήγησαν στην επικράτηση της αντικειμενοστρέφειας ως βασικού προγραμματιστικού υποδείγματος.Το 1995 η εμφάνιση τηςJava, μίας ιδιαίτερα επιτυχημένης, πλήρως αντικειμενοστρεφούς γλώσσας που έμοιαζε συντακτικώς με τη C/C++ και προσέφερε πρωτοποριακές για την εποχή δυνατότητες, έδωσε νέα ώθηση στον ΑΠ. Παράλληλα εμφανίστηκαν ποικίλες άτυπες βελτιώσεις στο βασικό προγραμματιστικό υπόδειγμα, όπως οι αντικειμενοστρεφείςγλώσσες μοντελοποίησης λογισμικού, τασχεδιαστικά πρότυπακ.λπ. Το 2001 ηMicrosoftεστίασε την προσοχή της στην πλατφόρμα.NET, μία ανταγωνιστική τηςJavaπλατφόρμα ανάπτυξης και εκτέλεσης λογισμικού, η οποία ήταν εξ ολοκλήρου προσανατολισμένη στην αντικειμενοστρέφεια.Έννοιες[Επεξεργασία|επεξεργασία κώδικα]Κεντρική ιδέα στον αντικειμενοστρεφή προγραμματισμό είναι ηκλάση(class), μία αυτοτελής καιαφαιρετικήαναπαράσταση κάποιας κατηγορίας αντικειμένων, είτε φυσικών αντικειμένων του πραγματικού κόσμου είτε νοητών, εννοιολογικών αντικειμένων, σε ένα περιβάλλον προγραμματισμού. Πρακτικώς είναι έναςτύπος δεδομένων, ή αλλιώς το προσχέδιο μιας δομής δεδομένων με δικά της περιεχόμενα, τόσομεταβλητέςόσο και διαδικασίες. Τα περιεχόμενα αυτά δηλώνονται είτε ωςδημόσια(public) είτε ωςιδιωτικά(private), με τα ιδιωτικά να μην είναι προσπελάσιμα από κώδικα εκτός της κλάσης. Οι διαδικασίες των κλάσεων συνήθως καλούνταιμέθοδοι(methods) και οι μεταβλητές τουςγνωρίσματα(attributes) ήπεδία(fields). Μία κλάση πρέπει ιδανικά να είναι εννοιολογικά αυτοτελής, να περιέχει δηλαδή μόνο πεδία τα οποία περιγράφουν μία κατηγορία αντικειμένων και δημόσιες μεθόδους οι οποίες επενεργούν σε αυτά όταν καλούνται από το εξωτερικό πρόγραμμα, χωρίς να εξαρτώνται από άλλα δεδομένα ή κώδικα εκτός της κλάσης, και επαναχρησιμοποιήσιμη, να αποτελεί δηλαδήμαύρο κουτίδυνάμενο να λειτουργήσει χωρίς τροποποιήσεις ως τμήμα διαφορετικών προγραμμάτων.Αντικείμενο(object) είναι το στιγμιότυπο μίας κλάσης, δηλαδή αυτή καθαυτή η δομή δεδομένων (με αποκλειστικά δεσμευμένο χώρο στημνήμη) βασισμένη στο «καλούπι» που προσφέρει η κλάση. Παραδείγματος χάριν, σε μία αντικειμενοστρεφή γλώσσα προγραμματισμού θα μπορούσαμε να ορίσουμε κάποια κλάση ονόματι BankAccount, η οποία αναπαριστά έναν τραπεζικό λογαριασμό, και να δηλώσουμε ένα αντικείμενο της με όνομα MyAccount. Το αντικείμενο αυτό θα έχει δεσμεύσει χώρο στη μνήμη με βάση τις μεταβλητές και τις μεθόδους που περιγράψαμε όταν δηλώσαμε την κλάση. Έτσι, στο αντικείμενο θα μπορούσε να περιέχεται ένα γνώρισμα Balance (=υπόλοιπο) και μία μέθοδος GetBalance (=επίστρεψε το υπόλοιπο). Ακολούθως, θα μπορούσαμε να δημιουργήσουμε ακόμα ένα ή περισσότερα αντικείμενα της ίδιας κλάσης, τα οποία θα είναι διαφορετικές δομές δεδομένων (διαφορετικοί τραπεζικοί λογαριασμοί στο παράδειγμα). Τα αντικείμενα μιας κλάσης μπορούν να προσπελάσουν τα ιδιωτικά περιεχόμενα άλλων αντικειμένων της ίδιας κλάσης.Ενθυλάκωση δεδομένων(data encapsulation) καλείται η ιδιότητα που προσφέρουν οι κλάσεις να «κρύβουν» τα ιδιωτικά δεδομένα τους από το υπόλοιπο πρόγραμμα και να εξασφαλίζουν πως μόνο μέσω των δημόσιων μεθόδων τους θα μπορούν αυτά να προσπελαστούν. Αυτή η τακτική παρουσιάζει μόνο οφέλη καθώς εξαναγκάζει κάθε εξωτερικό πρόγραμμα να φιλτράρει το χειρισμό που επιθυμεί να κάνει στα πεδία μίας κλάσης μέσω των ελέγχων που μπορούν να περιέχονται στις δημόσιες μεθόδους της κλάσης.Αφαίρεση δεδομένωνκαλείται η ιδιότητα των κλάσεων να αναπαριστούν αφαιρετικά πολύπλοκες οντότητες στο προγραμματιστικό περιβάλλον. Μία κλάση αποτελεί ένα αφαιρετικόμοντέλοκάποιας κατηγορίας αντικειμένων. Επίσης, οι κλάσεις προσφέρουν και αφαίρεση ως προς τον υπολογιστή, εφόσον η καθεμία μπορεί να θεωρηθεί ένας μικρός και αυτάρκης υπολογιστής (με δική του κατάσταση, μεθόδους και μεταβλητές).Κληρονομικότηταονομάζεται η ιδιότητα των κλάσεων να επεκτείνονται σε νέες κλάσεις, ρητά δηλωμένες ως κληρονόμους (υποκλάσειςή 'θυγατρικές κλάσεις'), οι οποίες μπορούν να επαναχρησιμοποιήσουν τις μεταβιβάσιμες μεθόδους και ιδιότητες της γονικής τους κλάσης αλλά και να προσθέσουν δικές τους. Στιγμιότυπα των θυγατρικών κλάσεων μπορούν να χρησιμοποιηθούν όπου απαιτούνται στιγμιότυπα των γονικών (εφόσον η θυγατρική είναι κατά κάποιον τρόπο μία πιο εξειδικευμένη εκδοχή της γονικής), αλλά το αντίστροφο δεν ισχύει. Παράδειγμα κληρονομικότητας είναι μία γονική κλάση Vehicle (=Όχημα) και οι δύο πιο εξειδικευμένες υποκλάσεις της Car (=Αυτοκίνητο) και Bicycle (=Ποδήλατο), οι οποίες λέμε ότι \"κληρονομούν\" από αυτήν. Πολλαπλή κληρονομικότητα είναι η δυνατότητα που προσφέρουν ορισμένες γλώσσες προγραμματισμού μία κλάση να κληρονομεί ταυτόχρονα από περισσότερες από μία γονικές. Από μία υποκλάση μπορούν να προκύψουν νέες υποκλάσεις που κληρονομούν από αυτήν, με αποτέλεσμα μία ιεραρχία κλάσεων που συνδέονται μεταξύ τους \"ανά γενιά\" με σχέσεις κληρονομικότητας.Υπερφόρτωση μεθόδου(method overloading) είναι η κατάσταση κατά την οποία υπάρχουν, στην ίδια ή σε διαφορετικές κλάσεις, μέθοδοι με το ίδιο όνομα και πιθανώς διαφορετικά ορίσματα. Αν πρόκειται για μεθόδους της ίδιας κλάσης διαφοροποιούνται μόνο από τις διαφορές τους στα ορίσματα και στον τύπο επιστροφής.Υποσκέλιση μεθόδου(method overriding) είναι η κατάσταση κατά την οποία μία θυγατρική κλάση και η γονική της έχουν μία μέθοδο ομώνυμη και με τα ίδια ορίσματα. Χάρη στη δυνατότητα τουπολυμορφισμούομεταγλωττιστής«ξέρει» πότε να καλέσει ποια μέθοδο, βασισμένος στον τύπο του τρέχοντος αντικειμένου. Δηλαδή πολυμορφισμός είναι η δυνατότητα των αντικειμενοστρεφών μεταγλωττιστών να αποφασίζουν δυναμικά ποια είναι η κατάλληλη να κληθεί μέθοδος σε συνθήκες υποσκέλισης.Αφηρημένη κλάση(abstract class) είναι μία κλάση που ορίζεται μόνο για να κληρονομηθεί σε θυγατρικέςυποκλάσειςκαι δεν υπάρχουν δικά της στιγμιότυπα (αντικείμενα). Η αφηρημένη κλάση ορίζει απλώς ένα \"συμβόλαιο\" το οποίο θα πρέπει να ακολουθούν οι υποκλάσεις της όσον αφορά τις υπογραφές των μεθόδων τους (όπου ως υπογραφή ορίζεται το όνομα, τα ορίσματα και η τιμή επιστροφής μίας διαδικασίας). Μία αφηρημένη κλάση μπορεί να έχει και μη αφηρημένες μεθόδους οι οποίες υλοποιούνται στην ίδια την κλάση (αν και φυσικά μπορούν να υποσκελίζονται σε υποκλάσεις). Αντιθέτως, οι αφηρημένες μέθοδοί της είναι απλώς ένας ορισμός της υπογραφής τους και εναπόκειται στις υποκλάσεις να τις υλοποιήσουν. Μία αφηρημένη κλάση που δεν έχει γνωρίσματα και όλες οι μέθοδοί της είναι αφηρημένες και δημόσιες καλείταιδιασύνδεση(interface). Οι κλάσεις που κληρονομούν από μία διασύνδεση λέγεται ότι την \"υλοποιούν\".Ακολουθεί ένα απλό παράδειγμα σε γλώσσα προγραμματισμούJava:interfaceLogger{publicvoidlog(Stringmsg);}classConsoleLoggerimplementsLogger{publicvoidlog(Stringmsg){System.err.println(\"\\nConsole logging...\"+msg+\"\\n\");}}classFileLoggerimplementsLogger{publicvoidlog(Stringmsg){System.out.println(\"\\nFile logging...\"+msg+\"\\n\");}}publicclassLogTest{publicstaticvoidmain(String[]args){if(args.length!=1){System.out.println(\"\\nError. Exiting...\");return;}Loggerlogg;Stringchoice=args[0];if(choice.equals(\"FileLogger\")){logg=newFileLogger();}elseif(choice.equals(\"ConsoleLogger\")){logg=newConsoleLogger();}else{System.err.println(\"\\nError. Exiting...\");return;}logg.log(\"Log This!\");}}Στο παραπάνω παράδειγμα ορίζουμε μία διασύνδεση Logger η οποία παρέχει την υπογραφή μίας μεθόδου log, που υποθέτουμε πως πρέπει να καταγράφει κάπου πληροφορίες για τα σφάλματα που συναντά η εφαρμογή όταν εκτελείται (οι πληροφορίες αυτές τής μεταβιβάζονται με το αλφαριθμητικό όρισμα msg). Η κλάση ConsoleLogger και η κλάση FileLogger είναι δύο διαφορετικές κλάσεις που υλοποιούν τη διασύνδεση Logger και υποσκελίζουν, η καθεμία με διαφορετικό τρόπο, τη μέθοδο log ώστε η μία να καταγράφει πληροφορίες στηνοθόνηκαι η άλλη σε κάποιοαρχείο.Το πρόγραμμα LogTest είναι ένα μικρό δοκιμαστικό πρόγραμμα το οποίο δέχεται ως όρισμαγραμμής εντολώντο πού επιθυμεί ο χρήστης να γίνεται η καταγραφή και δημιουργεί ένα στιγμιότυπο της αντίστοιχης κλάσης: της ConsoleLogger ή της FileLogger. Το στιγμιότυπο αυτό δηλώνεται με τον γενικότερο τύπο Logger, τον τύπο δηλαδή της διασύνδεσης που υλοποιούν και οι δύο κλάσεις, αλλά χάρη στον πολυμορφισμό καλείται αυτομάτως η κατάλληλη εκδοχή της μεθόδου log.Αρχές αντικειμενοστρεφούς σχεδίασης[Επεξεργασία|επεξεργασία κώδικα]Με το πέρασμα του χρόνου κωδικοποιήθηκαν κάποιες ανεπίσημες αρχές για την ορθή σχεδίαση αντικειμενοστρεφών συστημάτων λογισμικού. Οι αρχές αυτές παρουσιάστηκαν κατά καιρούς σε βιβλία και άρθρα ακαδημαϊκών και αναγνωρισμένωνμηχανικών λογισμικού. Οι σπουδαιότερες αρχές είναι οι παρακάτω:Αρχή ανοιχτότητας-κλειστότητας (open-closed principle), του δημιουργού της γλώσσας προγραμματισμούEiffelΜπέρτραντ Μέιερ. Η αρχή αυτή δηλώνει πως τα συστατικά ενός προγράμματος πρέπει να είναι \"ανοιχτά\" ως προς την επέκταση των δυνατοτήτων του συστήματος αλλά \"κλειστά\" ως προς αλλαγές στην υλοποίηση του. Πρακτικώς αυτό σημαίνει οι διάφορες κλάσεις και τα υπόλοιπα τμήματα λογισμικού να μη χρειάζεται να τροποποιηθούν σε περίπτωση που προστεθεί νέα λειτουργικότητα στο σύστημα (π.χ. μία νέα κλάση) προκειμένου να την αξιοποιήσουν. Βεβαίως είναι αδύνατο να μη χρειάζεται να τροποποιηθεί τίποτα, οπότε αυτό που επιτάσσει στην πραγματικότητα η εν λόγω αρχή είναι η ελαχιστοποίηση και η συγκέντρωση, κατά προτίμηση σε ένα μικρό τμήμα του κώδικα, των γραμμών που θα πρέπει να αλλάξουν. Αυτό συνήθως επιτυγχάνεται μέσω αφαίρεσης (με αφηρημένες κλάσεις ή διασυνδέσεις και πραγματικές κλάσεις που κληρονομούν από αυτές) και με χρήση του πολυμορφισμού. Έτσι, στο παράδειγμα της προηγούμενης ενότητας αν προσθέσουμε και μία τρίτη υλοποίηση της διασύνδεσης Logger, την PrinterLogger η οποία \"καταγράφει\" σφάλματα αποστέλλοντας τα προς εκτύπωση, ο κώδικας του προγράμματος γίνεται:publicclassLogTest{publicstaticvoidmain(String[]args){if(args.length!=1){System.out.println(\"\\nError. Exiting...\");return;}Loggerlogg;Stringchoice=args[0];if(choice.equals(\"FileLogger\")){logg=newFileLogger();}elseif(choice.equals(\"ConsoleLogger\")){logg=newConsoleLogger();}elseif(choice.equals(\"PrinterLogger\")){logg=newPrinterLogger();}else{System.err.println(\"\\nError. Exiting...\");return;}logg.log(\"Log This!\");}}Όπως φαίνεται μόνη αλλαγή είναι η προσθήκη μίας ακόμα δήλωσης else if. Η εντολήlogg.log(\"Log This!\");μπορεί να λειτουργήσει και με αντικείμενα του νέου τύπου χωρίς καμία τροποποίηση. Μία συνηθισμένη τακτική για διασφάλιση της κλειστότητας του ολικού προγράμματος ως προς την υλοποίηση μίας κλάσης, είναι η συνειδητή προσπάθεια για δήλωση όλων των γνωρισμάτων της ως ιδιωτικών. Έτσι η προσπέλαση των πεδίων της κλάσης μπορεί να ελεγχθεί εξ ολοκλήρου μέσω ειδικών δημόσιων μεθόδων της, γεγονός που διευκολύνει κατά πολύ την αποσφαλμάτωση: στις μεθόδους αυτές συγκεντρώνονται οι έλεγχοι επιτρεπτών τιμών για τα πεδία, έλεγχοι κατάλληλων συνθηκών κλπ.Αρχή υποκατάστασης Λίσκοφ (Liskov substitution principle), της επιστήμονα υπολογιστών Μπάρμπαρα Λίσκοφ. Η αρχή αυτή συμπυκνώνεται στον παρακάτω κανόνα για σχηματισμό μίας ορθής ιεραρχίας κλάσεων: μία κλάση Κ1 μπορεί να υλοποιηθεί ως υποκλάση μίας κλάσης Κ2 αν κάθε πρόγραμμα Π το οποίο λειτουργεί με αντικείμενα Κ2 συμπεριφέρεται με τον ίδιο τρόπο και με αντίστοιχα αντικείμενα Κ1. Έτσι με την αρχή υποκατάστασης Λίσκοφ φαίνεται πως για να οριστεί μία κλάση ως θυγατρική μίας άλλης δεν αρκεί να έχουν διαισθητικά μία ανάλογη εννοιολογική σχέση (π.χ. μία κλάση που αναπαριστά όχημα και μία που αναπαριστά αυτοκίνητο) αλλά, στο πλαίσιο του υπό εξέταση προγράμματος, τα αντικείμενα της υποκλάσης να έχουν πάντα την ίδια προγραμματιστική συμπεριφορά με τα αντικείμενα της υπερκλάσης υπό τις ίδιες συνθήκες.Αρχή αντιστροφής εξαρτήσεων (dependency inversion principle), του γνωστού μηχανικού λογισμικού Ρόμπερτ Σέσιλ Μάρτιν. Η αρχή αυτή πρακτικά αποτελεί εκλέπτυνση της αρχής ανοιχτότητας-κλειστότητας, προϋποθέτοντας όμως χρήση και της αρχής υποκατάστασης Λίσκοφ. Αφορά ιεραρχίες κληρονομικότητας κλάσεων και τη χρήση αντικειμένων αυτών των ιεραρχιών από εξωτερικά προγράμματα. Στα πλαίσια της αρχής αντιστροφής εξαρτήσεων ένα τμήμα λογισμικού Α (π.χ. μία κλάση) το οποίο χρησιμοποιεί τις υπηρεσίες που παρέχει ένα άλλο τμήμα λογισμικού Β, καλώντας για παράδειγμα μία μέθοδό του, θεωρείται στοιχείο \"υψηλότερου επιπέδου\" σε σχέση με το Β. Η αρχή λέει πως τα υψηλού επιπέδου στοιχεία δεν πρέπει να εξαρτώνται από την υλοποίηση χαμηλότερου επιπέδου στοιχείων, αλλά πως και τα δύο πρέπει να βασίζονται σε ενδιάμεσα επίπεδα αφαίρεσης. Στην πράξη αυτή η αφαίρεση είναι μία διασύνδεση (ή αφηρημένη κλάση) την οποία γνωρίζει το υψηλού επιπέδου στοιχείο Α και υλοποιεί το χαμηλού επιπέδου στοιχείο Β. Ακόμα και αν το Β αλλαχθεί με μία κλάση Γ η οποία επίσης υλοποιεί την ίδια διασύνδεση, το Α θα πρέπει να συνεχίσει να λειτουργεί χωρίς καμία τροποποίηση. Η αρχή αντιστροφής εξαρτήσεων δεν είναι παρά ένα απτό παράδειγμα χρήσης ιεραρχικών επιπέδων με τη βοήθεια ενδιάμεσων αφαιρέσεων, μίας πρακτικής που εφαρμόζεται κατά κόρον στην επιστήμη υπολογιστών (για ένα άλλο παράδειγμα βλέπεδίκτυα υπολογιστών).Αρχή διαχωρισμού διασυνδέσεων (interface segregation principle), του μηχανικού λογισμικού Ρόμπερτ Σέσιλ Μάρτιν. Η εν λόγω αρχή σημαίνει ότι σε περιπτώσεις όπου διαφορετικά υποσύνολα μεθόδων μίας κλάσης αφορούν διαφορετικές περιπτώσεις χρήσης της κλάσης, σκόπιμο είναι να ορίζουμε επιμέρους διασυνδέσεις τις οποίες η κλάση θα υλοποιεί. Κάθε τέτοια διασύνδεση θα ορίζει μόνο το αντίστοιχο υποσύνολο των μεθόδων.Αρχή μοναδικής αρμοδιότητας (single responsibility principle), τωνΤομ Ντε ΜάρκοκαιΜέιρ Πέιτζ Τζόουνς. Σύμφωνα με την αρχή αυτή κάθε κλάση θα πρέπει να έχει μόνο μία, καλά ορισμένη και διαχωρισμένη από το υπόλοιπο πρόγραμμα αρμοδιότητα, η ύπαρξη της οποίας να εξυπηρετεί έναν συγκεκριμένο σκοπό. Αν μπορούμε να εντοπίσουμε σε μία κλάση Α δύο διαφορετικές αρμοδιότητες, τότε η καλύτερη λύση είναι η διάσπαση της σε δύο κλάσεις Β' και Γ', καθεμία από τις οποίες θα λάβει έναυποσύνολοτων πεδίων και των μεθόδων της Α. Τα υποσύνολα αυτά θα είναι ξένα μεταξύ τους, οπότε με το ανάποδο σκεπτικό αν μπορούμε να διασπάσουμε μία κλάση Α σε δύο άλλες κλάσεις (π.χ. σε περίπτωση που κάποιες μέθοδοι δε χρησιμοποιούν κάποια γνωρίσματα, οπότε οι μεν μπορούν να καταλήξουν στη μία κλάση Β' και τα πεδία στην άλλη κλάση Γ') τότε πιθανώς η κλάση να παραβιάζει την αρχή μοναδικής αρμοδιότητας. Έτσι έχουν προταθεί κάποιες μετρικές οι οποίες επιχειρούν να προσδιορίσουν την έλλειψησυνοχής(cohesion) σε μία κλάση, δηλαδή το κατά πόσον οι μέθοδοι της δε σχετίζονται με τα γνωρίσματα της. Συνήθως η συνοχή αντιπαραβάλλεται με τησύζευξη(coupling), δηλαδή το βαθμό στον οποίον μία κλάση εξαρτάται από κάποια/ες άλλη/ες, και τα δύο αυτά μεγέθη είναι αντιστρόφως ανάλογα.Μετρικές ποιότητας[Επεξεργασία|επεξεργασία κώδικα]Κατά καιρούς έχουν οριστεί κάποιες μετρικές για την εκτίμηση της περιπλοκότητας και της ποιότητας μίας αντικειμενοστρεφούς σχεδίασης λογισμικού. Σε αυτές συμπεριλαμβάνονται και οι μετρικές έλλειψης συνοχής (LCOM). Ακολουθεί μία σύνοψη των σπουδαιότερων:Weighted Methods per Class (WMC)[Επεξεργασία|επεξεργασία κώδικα]Το ακέραιο πλήθος των μεθόδων που ορίζονται σε μία κλάση. Δεν υπάρχει ένα καθιερωμένο εύρος βέλτιστου WMC αλλά είναι γενικώς αποδεκτό ότι υπερβολικά μεγάλο WMC οδηγεί σε μεγαλύτερη πιθανότητα σφαλμάτων και προβλημάτων συντήρησης.Depth of Inheritance Tree (DIT)[Επεξεργασία|επεξεργασία κώδικα]Το μήκος του μέγιστου μονοπατιού κληρονομικότητας από την τρέχουσα κλάση έως τη ρίζα μιας ιεραρχίας κλάσεων. Μεγάλες τιμές DIT αυξάνουν την πολυπλοκότητα της σχεδίασης, την πιθανότητα σφαλμάτων αλλά και την επαναχρησιμοποίηση κώδικα λόγω της κληροδότησης μεθόδων. Μία βέλτιστη τιμή DIT θεωρείται το 5.Number of Children (NOC)[Επεξεργασία|επεξεργασία κώδικα]Το πλήθος των κλάσεων που κληρονομούν άμεσα από την τρέχουσα. Υψηλό NOC σημαίνει υψηλή επαναχρησιμοποίηση κώδικα αλλά πιθανόν να υποδεικνύει εννοιολογικά εσφαλμένη χρήση της κληρονομικότητας. Δεν υπάρχει κάποιο γενικώς αποδεκτό βέλτιστο NOC, αφού αυτό εξαρτάται από την εκάστοτε κλάση, αλλά εν γένει οι κλάσεις οι ευρισκόμενες υψηλότερα στην ιεραρχία κληρονομικότητας είναι θεμιτό να έχουν υψηλότερο NOC από όσες τοποθετούνται χαμηλότερα αφού είναι λιγότερο εξειδικευμένες.Coupling Between Object Classes (CBO)[Επεξεργασία|επεξεργασία κώδικα]Το πλήθος των κλάσεων από τις οποίες εξαρτάται η τρέχουσα κλάση. Κάθε τέτοια εξάρτηση μπορεί να είναι αμφίδρομη ή μονόδρομη οποιασδήποτε κατεύθυνσης. Επομένως υψηλό CBO σημαίνει υψηλή σύζευξη (coupling) και δεν είναι επιθυμητό, καθώς αποτρέπει την επαναχρησιμοποίηση κώδικα και ζημιώνει τον αρθρωτό σχεδιασμό του προγράμματος. Όσο χαμηλότερο είναι το CBO μίας κλάσης τόσο πιθανότερο είναι να μπορεί η τελευταία να επαναχρησιμοποιηθεί ως μαύρο κουτί. Υπερβολικά υψηλές θεωρούνται οι τιμές CBO > 14.Response for a Class (RFC και RFC’)[Επεξεργασία|επεξεργασία κώδικα]Η μετρική αυτή ισούται με το πλήθος των μεθόδων που μπορεί να εκτελεστούν ως απάντηση στη λήψη ενός μηνύματος / συμβάντος από την τρέχουσα κλάση (έστω Α), τόσο τοπικών της μεθόδων όσο και «απομακρυσμένων» μεθόδων άλλων κλάσεων οι οποίες καλούνται άμεσα από την Α. Η μετρική RFC’ συμπεριλαμβάνει επιπλέον και τις απομακρυσμένες μεθόδους που καλούνται εμμέσως (π. χ. από άμεσα καλούμενες απομακρυσμένες μεθόδους ή, αναδρομικά, από άλλες έμμεσα καλούμενες απομακρυσμένες μεθόδους). Κάθε μέθοδος μετράται μόνο μία φορά στον υπολογισμό του RFC, ανεξαρτήτως του πόσες φορές καλείται. Υψηλή τιμή RFC υποδεικνύει υψηλές πιθανότητες σφάλματος και δυσκολία συντήρησης.LCOM1[Επεξεργασία|επεξεργασία κώδικα]Μετρική έλλειψης συνοχής. Ισχύει LCOM1 = P - Q αν P > Q, διαφορετικά LCOM1 = 0. Τα P, Q υπολογίζονται με τον ακόλουθο αλγόριθμο (σε ψευδοκώδικα):P = 0; Q = 0;\nΓια κάθε ζεύγος μεθόδων της κλάσης\ndo\n{\n   Αν τα σύνολα των πεδίων που χρησιμοποιούν οι δύο τρέχουσες μέθοδοι είναι ξένα μεταξύ τους\n      P = P + 1;\n   Διαφορετικά\n      Q = Q + 1;\n}Μία τιμή LCOM1 = 0 υποδεικνύει συνεκτική κλάση, ενώ αν LCOM1 > 0 η κλάση καλό είναι να διασπαστεί. Η μετρική LCOM1 παρουσιάζει κάποια προβλήματα, όπως π.χ. ότι δίνει τιμή 0 για κλάσεις πολύ διαφορετικές μεταξύ τους.LCOM2[Επεξεργασία|επεξεργασία κώδικα]Βελτιωμένη μετρική έλλειψης συνοχής. Ισχύει LCOM2 = 1 - sum(mA)/(m*a), όπου m το πλήθος των μεθόδων της κλάσης, a το πλήθος των πεδίων της, mA το πλήθος των μεθόδων που προσπελαύνουν ένα γνώρισμα και sum(mA) το άθροισμα των mA για όλα τα πεδία μίας κλάσης. Η μετρική LCOM2 αποτελεί τον μέσο όρο των ποσοστών των μεθόδων που δε χρησιμοποιούν κάθε γνώρισμα. LCOM2 = 0 (υψηλή συνοχή) σημαίνει πως όλες οι μέθοδοι της κλάσης χρησιμοποιούν όλα τα πεδία της, ενώ LCOM2 = 1 (καμία συνοχή) σημαίνει πως καμία μέθοδος δεν προσπελαύνει κανένα πεδίο.LCOM3[Επεξεργασία|επεξεργασία κώδικα]Εναλλακτική μετρική έλλειψης συνοχής. Ισχύει LCOM3 = (m - sum(mA)/a) / (m-1). Η μετρική LCOM3 λαμβάνει τιμές από 0 (υψηλή συνοχή) έως 2 (καμία συνοχή). Τιμές μεγαλύτερες του 1 σημαίνουν πως με βεβαιότητα υπάρχει τουλάχιστον ένα \"νεκρό γνώρισμα\", δηλαδή γνώρισμα το οποίο δεν προσπελαύνεται από καμία μέθοδο της κλάσης.UML[Επεξεργασία|επεξεργασία κώδικα]Κύριο λήμμα:Γλώσσες μοντελοποίησης λογισμικούΜετά την ευρεία διάδοση του ΑΠ κατά τη δεκαετία του '90, το αντικειμενοστρεφές μοντέλο σχεδίασης (με κλάσεις, κληρονομικότητα, αντικείμενα και τυποποιημένες αλληλεπιδράσεις μεταξύ τους) επικράτησε ακόμη και για μοντελοποίηση που δεν περιελάμβανε καν προγραμματισμό (π. χ. σχήματαβάσεων δεδομένων). Έτσι αναπτύχθηκαν διάφορες πρότυπεςγλώσσες μοντελοποίησης λογισμικούοι οποίες τυποποιούσαν οπτικά σύμβολα και συμπεριφορές με στόχο την αφαιρετική περιγραφή της λειτουργίας και της δομής ενός υπολογιστικού συστήματος. Οι γλώσσες αυτές είχαν εξαρχής έναν εμφανή αντικειμενοστρεφή προσανατολισμό. Τελικά οι πιο δημοφιλείς από αυτές ενοποιήθηκαν στο κοινό πρότυπο UML που η πρώτη του έκδοση οριστικοποιήθηκε το1997.Η UML πλέον είναι η πρότυπη γλώσσα μοντελοποίησης στη μηχανική λογισμικού. Χρησιμοποιείται για τη γραφική απεικόνιση, προσδιορισμό, κατασκευή και τεκμηρίωση των στοιχείων ενός συστήματος λογισμικού. Μπορεί να χρησιμοποιηθεί σε διάφορες φάσεις ανάπτυξης, από την ανάλυση απαιτήσεων ως τον έλεγχο ενός ολοκληρωμένου συστήματος, και αποτελείται από ένα σύνολο προσυμφωνημένων όρων, συμβόλων και διαγραμμάτων.Σχεδιαστικά πρότυπα[Επεξεργασία|επεξεργασία κώδικα]Κύριο λήμμα:Σχεδιαστικά πρότυπαΚατά τα τέλη της δεκαετίας του '70 έναςαρχιτέκτοναςονόματιΚρίστοφερ Αλεξάντερεπιχείρησε να βρει και να καταγράψει αποδεδειγμένα ποιοτικούς σχεδιασμούς στον τομέα των κατασκευών. Έτσι μελέτησε πολλές διαφορετικές κατασκευές που εξυπηρετούσαν τον ίδιο σκοπό και προσπάθησε να ανακαλύψει κοινά στοιχεία, τα οποία κατηγοριοποίησε σεσχεδιαστικά πρότυπα(design patterns). Το 1987 η ιδέα της εύρεσης σχεδιαστικών προτύπων εφαρμόστηκε για πρώτη φορά στη μηχανική λογισμικού και μέχρι τα μέσα της δεκαετίας του '90 η εν λόγω έννοια είχε καθιερωθεί και εξαπλωθεί, στραμμένη πλέον στον κόσμο της αντικειμενοστρέφειας.Ένα πρότυπο σχεδίασης ορίζεται ως μία αποδεδειγμένα καλή λύση που έχει εφαρμοστεί με επιτυχία στην επίλυση ενός επαναλαμβανόμενου προβλήματος σχεδίασης συστημάτων λογισμικού. Τα πρότυπα σχεδίασης ορίζονται τόσο σε επίπεδο μακροσκοπικής σχεδίασης όσο και σε επίπεδο υλοποίησης, ενώ με τη χρήση τους ένας προγραμματιστής αντικαθιστά πρακτικώς μεγάλα τμήματα του κώδικα του με μαύρα κουτιά. Πρόκειται για αφαιρέσεις υψηλού επιπέδου που αποτελούν πλήρη υποσυστήματα, κατάλληλα ρυθμισμένα για την επίλυση συγκεκριμένων προβλημάτων και έτοιμα για χρήση. Έχουν οριστεί διάφορες κατηγορίες προτύπων, για διαφορετικά προβλήματα, και κάθε κατηγορία περιλαμβάνει πολλαπλά στοιχεία. Έτσι υπάρχουν κατασκευαστικά πρότυπα, δομικά πρότυπα, συμπεριφορικά πρότυπα κλπ.Δείτε επίσης[Επεξεργασία|επεξεργασία κώδικα]Αντικειμενοστρεφείς βάσεις δεδομένωνΑντικειμενοστρεφής προγραμματισμός στη CΠαραπομπές[Επεξεργασία|επεξεργασία κώδικα]↑Ο όρος object-oriented αποδόθηκε από τις ορολογικές ομάδες ΜΟΤΟ και ΕΛΟΤ/ΤΕ48/ΟΕ1 στα ελληνικά ως αντικειμενοστρεφής, αλλά η λέξη απαντάται στα ελληνικά και σαν «αντικειμενοστραφής».↑«Γιατί χρησιμοποιείτε τον όρο αντικειμενοστρεφής και όχι αντικειμενοστραφής;» από ιστοσελίδα τουΔιομήδη Σπινέλλη.Αρχειοθετήθηκε13/01/2019. Ανακτήθηκε 13/01/2019.Βιβλιογραφία και Πηγές[Επεξεργασία|επεξεργασία κώδικα]Βασικές Αρχές Γλωσσών Προγραμματισμού, Ellis Horowitz, Εκδόσεις ΚλειδάριθμοςΣχεδιαστικά Πρότυπα, Απόστολος Ζάρρας, Λέκτορας Πανεπιστημίου Ιωαννίνων,http://www.cs.uoi.gr/~zarras/dpatts.htmCore Techniques and Algorithms in Game Programming, Daniel Sanchez-Crespo Dalmeau, Εκδόσεις New RidersChidamber & Kemerer Object-Oriented Metrics Suite,http://www.aivosto.com/project/help/pm-oo-ck.htmlΑντικειμενοστραφής Προγραμματισμός στη Μ2000.https://www.ebooks4greeks.gr/antikeimenostrafhs-programmatismos-sth-m2000Καθιερωμένοι όροιLCCN:sh87007503GND:4233947-9BNF:cb12115131k(data)NDL:00937980NKC:ph115529BNE:XX537453wiktionary logoΤοΒικιλεξικόέχει σχετικό λήμμα:αντικειμενοστρεφής προγραμματισμόςΠύλη:Προγραμματισμός"
    },
    {
        "url": "https://el.wikipedia.org/wiki/%CE%A0%CF%81%CE%BF%CE%B3%CF%81%CE%B1%CE%BC%CE%BC%CE%B1%CF%84%CE%B9%CF%83%CF%84%CE%B9%CE%BA%CF%8C_%CF%85%CF%80%CF%8C%CE%B4%CE%B5%CE%B9%CE%B3%CE%BC%CE%B1",
        "title": "Προγραμματιστικό παράδειγμα",
        "content": "Προγραμματιστικό παράδειγμα(ήπρ. υπόδειγμα[1]ήπρ. μεθοδολογίαήπρ. προσέγγιση[2]) (αγγλικα:programming paradigm) καλείται η ιδιαίτερη τεχνική και οι μέθοδοι με τις οποίες ένα υπολογιστικό πρόβλημα και ηαλγοριθμικήλύση του προσεγγίζονται στονπρογραμματισμό των υπολογιστών. Είναι δηλαδή ένα σύνολο εννοιών οι οποίες εκφράζουν έναν συγκεκριμένο τρόπο σκέψης, και κατά συνέπεια έκφρασης της υλοποίησης, διαμορφώνοντας τον τρόπο σχεδιασμού ενός προγράμματος.[3]Μια γλώσσα προγραμματισμού μπορεί να υποστηρίξει πολλαπλά παραδείγματα. Έτσι, προγράμματα που γράφτηκαν στη γλώσσαC++ή στηνObject Pascalμπορεί να είναι αμιγώςδιαδικαστικά, ή αμιγώςαντικειμενοστρεφή, ή να περιέχουν στοιχεία και από τα δύο παραδείγματα. Οι δημιουργοί λογισμικού αποφασίζουν πώς να χρησιμοποιήσουν αυτά τα στοιχεία του υποδείγματος.Τα σημαντικότεραπρογραμματιστικά παραδείγματαείναι:Προστακτικός προγραμματισμός(Imperative programming)[1]Διαδικαστικός προγραμματισμός(procedural programming)[4], που είναι υποκατηγορία τουΔομημένου προγραμματισμού(Structured programming)[1]Αντικειμενοστρεφής προγραμματισμός(object-oriented programming)Δηλωτικός προγραμματισμός(declarative programming)[4]Συναρτησιακός προγραμματισμός(functional programming)Λογικός προγραμματισμός(Logic programming)Παραπομπές[Επεξεργασία|επεξεργασία κώδικα]↑1,01,11,2Αναστάσιος Χατζηπαπαδόπουλος, Δρ. Βασίλης Σ. Μπελεσιώτης, 2018. «Πέτρα-Ψαλίδι-Χαρτί. Από το Δομημένο στον Αντικειμενοστρεφή προγραμματισμόΑρχειοθετήθηκε2019-04-12 στοWayback Machine.»,Τμήμα Πληροφορικής, Ιόνιο ΠανεπιστήμιοΑρχειοθετήθηκε2019-01-29 στοWayback Machine., σελ. 14 (σελ. 2 του pdf).Αρχειοθετήθηκε12/04/2019. Ανακτήθηκε 12/04/2019.↑Αγγελιδάκης, Ν. (Ηράκλειο 2015). \"Εισαγωγή στον προγραμματισμό με την Python\", σελ. 5 (σελ. 14 του pdf).Αρχειοθετήθηκε12/06/2018 Ανακτήθηκε 07/04/2019.(ISBN978-960-93-7364-7).↑April J. Wells,Grid Application Systems Design, CRC Press 2007,σελ. 5,ISBN 978-0-8493-2997-5↑4,04,1Σταματόπουλος, Παναγιώτης, 2015. «Κεφάλαιο 1. Διαδικαστικός και δηλωτικός προγραμματισμόςΑρχειοθετήθηκε2019-04-13 στοWayback Machine.» σελ.8 (σελ. 1 του pdf) απόΛογικός και συναρτησιακός προγραμματισμός(ISBN978-960-603-335-3). Δημοσιεύθηκε 19/10/2015.Αρχειοθετήθηκε13/04/2019. Ανακτήθηκε 14/04/2019."
    },
    {
        "url": "https://el.wikipedia.org/wiki/%CE%94%CF%85%CE%BD%CE%B1%CE%BC%CE%B9%CE%BA%CE%AE_%CE%B3%CE%BB%CF%8E%CF%83%CF%83%CE%B1_%CF%80%CF%81%CE%BF%CE%B3%CF%81%CE%B1%CE%BC%CE%BC%CE%B1%CF%84%CE%B9%CF%83%CE%BC%CE%BF%CF%8D",
        "title": "Δυναμική γλώσσα προγραμματισμού",
        "content": "Ο όροςδυναμική γλώσσα προγραμματισμούχρησιμοποιείται ευρύτατα στην επιστήμη των υπολογιστών για να περιγράψειγλώσσες προγραμματισμούυψηλού επιπέδου που παρουσιάζουν κατά το χρόνο εκτέλεσης συμπεριφορά που άλλες γλώσσες ίσως παρουσιάζουν κατά τη μετάφραση. Αυτές οι συμπεριφορές μπορεί να αποτελούν επέκταση του προγράμματος, είτε προσθέτοντας νέο κώδικα, είτε επεκτείνοντας αντικείμενα και ορισμούς, είτε τροποποιώντας τοσύστημα τύπων, όλα κατά τη διάρκεια της εκτέλεσης του προγράμματος. Αυτές οι συμπεριφορές μπορούν να εφαρμοστούν σχεδόν σε οποιαδήποτε γλώσσα επαρκούς πολυπλοκότητας, αλλά οι δυναμικές γλώσσες παρέχουν εργαλεία για να διευκολύνουν τη χρήση τους.Οι περισσότερες δυναμικές γλώσσες έχουν δυναμικούς τύπους.Περιορισμοί και ασάφειες στον ορισμό[Επεξεργασία|επεξεργασία κώδικα]Ο ορισμός της δυναμικής γλώσσας προγραμματισμού είναι ασαφής γιατί προσπαθεί να κάνει διάκριση μεταξύ κώδικα και δεδομένων καθώς και μεταξύ χρόνου μετάφρασης και χρόνου εκτέλεσης, που δεν είναι όμως καθολικά. Οι εικονικές μηχανές, η μεταγλώττιση just-in-time και η δυνατότητα πολλών γλωσσών προγραμματισμού να μεταβάλλουν άμεσα τον κώδικα μηχανής σε κάποια συστήματα καθιστούν μια τέτοια διάκριση αφηρημένη. Σε γενικές γραμμές, ο ισχυρισμός ότι μια γλώσσα προγραμματισμού είναι δυναμική αναφέρεται περισσότερο την ευκολία χρήσης ορισμένων δυναμικών χαρακτηριστικών της γλώσσας παρά στις δυνατότητες της ίδιας της γλώσσας.Παραδείγματα[Επεξεργασία|επεξεργασία κώδικα]Ορισμένα παραδείγματα γλωσσών προγραμματισμού που θεωρούνται δυναμικές:[1][2]BeanShell[3]Common Lispκαι μερικές άλλες διάλεκτοι τηςLispGroovy[4]JavaScriptActionScriptPerlPHPPythonRubySmalltalkTclObjective-CΚάποιες από αυτές τις γλώσσες υποστηρίζονται και στο.NET Frameworkαπό το MicrosoftDynamic Language Runtime.Παραπομπές[Επεξεργασία|επεξεργασία κώδικα]↑http://www.eclipse.org/dltk/↑«Αρχειοθετημένο αντίγραφο». Αρχειοθετήθηκεαπό το πρωτότυποστις 12 Ιουνίου 2010. Ανακτήθηκε στις 15 Ιανουαρίου 2011.↑http://static.springsource.org/spring/docs/2.0.x/reference/dynamic-language.html↑<http://groovy.codehaus.org/Αρχειοθετήθηκε2012-02-11 στοWayback Machine.Δείτε επίσης[Επεξεργασία|επεξεργασία κώδικα]Γλώσσα προγραμματισμού σεναρίων"
    },
    {
        "url": "https://el.wikipedia.org/wiki/%CE%A3%CF%85%CE%BB%CE%BB%CE%BF%CE%B3%CE%AE_%CE%B1%CF%80%CE%BF%CF%81%CF%81%CE%B9%CE%BC%CE%BC%CE%AC%CF%84%CF%89%CE%BD_(%CF%85%CF%80%CE%BF%CE%BB%CE%BF%CE%B3%CE%B9%CF%83%CF%84%CE%AD%CF%82)",
        "title": "Συλλογή απορριμμάτων (υπολογιστές)",
        "content": "Στηνπληροφορική, ησυλλογή απορριμμάτων(αγγλ.garbage collectionήGC) είναι μια μορφή αυτόματηςδιαχείρισης μνήμηςη οποία λειτουργεί στο υπόβαθρο, κατά την εκτέλεση ενόςπρογράμματος. Οσυλλέκτης απορριμμάτων(garbage collector), η απλώςσυλλέκτης, είναι συνήθως ένανήματου συστήματος (π.χ. τουλειτουργικού συστήματοςή μιαςεικονικής μηχανήςεπί της οποίας εκτελείται το βασικό πρόγραμμα) σχεδιασμένο κάθε φορά που ενεργοποιείται να απελευθερώνει τα τρέχοντααπορρίμματα: τημνήμητην οποία καταναλώνουν τα αντικείμενα που το πρόγραμμα δεν χρησιμοποιεί πια. Η συλλογή απορριμμάτων εφευρέθηκε από τονΤζον Μακάρθιτο 1959 για να λύσει προβλήματα τηςγλώσσας προγραμματισμούLisp.[1][2]Η συλλογή απορριμμάτων συχνά εμφανίζεται σαν το αντίθετο της χειροκίνητης διαχείρισης μνήμης, η οποία απαιτεί από τον προγραμματιστή να ορίζει ποια αντικείμενα μπορούν να απομακρυνθούν από τη μνήμη. Πολλά συστήματα όμως συνδυάζουν τις δύο προσεγγίσεις, μαζί με άλλες τεχνικές όπως η δέσμευση μνήμης στη στοίβα και η εξαγωγή περιοχών (region inference).Περιορισμένοι πόροι εκτός της μνήμης, όπως π.χ. οιδικτυακές υποδοχές, τα χειριστήριαβάσεων δεδομένων(database handles), τα παράθυρα για αλληλεπίδραση με τον χρήστη και οι περιγραφείς αρχείων και συσκευών, δεν επηρεάζονται από τη συλλογή απορριμμάτων. Υπάρχουν άλλες μέθοδοι για τη διαχείριση αυτών των πόρων, όπως οικαταστροφείς, που μπορούν να διαχειριστούν ακόμα και τη μνήμη, με αποτέλεσμα να μην χρειάζεται συλλογή απορριμμάτων. Κάποια συστήματα συλλογής απορριμμάτων επιτρέπουν σε αυτούς τους άλλους πόρους να σχετίζονται με μια περιοχή στη μνήμη, η οποία, όταν συλλεχθεί, να προκαλέσει την αποδέσμευση των πόρων, κάτι που ονομάζεται οριστικοποίηση (finalization). Αυτό όμως μπορεί να προκαλέσει περιπλοκές, όπως οι σημαντικές καθυστερήσεις μεταξύ της παύσης της χρήσης και της αποδέσμευσης σημαντικά περιορισμένων πόρων, ή η έλλειψη ελέγχου σχετικά με το ποιο νήμα θα κάνει την αποδέσμευση.Αρχές[Επεξεργασία|επεξεργασία κώδικα]Οι βασικές αρχές της συλλογής απορριμμάτων είναι:Βρες τα δεδομένα του προγράμματος που δεν πρόκειται να προσπελαστούν στο μέλλονΑποδέσμευσε τους πόρους που χρειάζονταν από τα αντικείμεναΠολλές γλώσσες προγραμματισμού χρειάζονται συλλογή απορριμμάτων, είτε σαν μέρος του ορισμού της γλώσσας (για παράδειγμα ηJava, ηC#και οι περισσότερεςγλώσσες σεναρίων) είτε στην πράξη σαν μέρος μιας ρεαλιστικής υλοποίησης (για παράδειγμα σε τυπικές γλώσσες όπως ολ-λογισμός) – αυτές ονομάζονταιγλώσσες με συλλογή απορριμμάτων(garbage collected languages). Άλλες γλώσσες έχουν σχεδιαστεί για χρήση με χειροκίνητη διαχείριση μνήμης αλλά υπάρχουν και υλοποιήσεις με συλλογή απορριμμάτων για αυτές (όπως για τηCή τηC++). Κάποιες γλώσσες, όπως ηAda, ηModula-3και ηC++/CLIεπιτρέπουν και συλλογή απορριμμάτων και χειροκίνητη διαχείριση μνήμης στην ίδια εφαρμογή, χρησιμοποιώντας διαφορετικούςσωρούς(heaps) για αντικείμενα που είτε αποδεσμεύονται αυτόματα, είτε η διαχείρισή τους γίνεται χειροκίνητα - άλλες, όπως ηD, έχουν συλλογή απορριμμάτων αλλά επιτρέπουν στον χρήστη να διαγράψει χειροκίνητα ένα αντικείμενο και να απενεργοποιήσει εντελώς τη συλλογή απορριμμάτων, όταν χρειάζεται περισσότερη ταχύτητα. Αν και η ενσωμάτωση της συλλογής απορριμμάτων στονμεταγλωττιστήκαι στο σύστημα χρόνου εκτέλεσης (run time system ή runtime) δίνει περισσότερες επιλογές, υπάρχουν συστήματα συλλογής απορριμμάτων τύπουpost hoc, με κάποια από αυτά να μην χρειάζονται επανάληψη της μεταγλώττισης. (ΗPost-hocσυλλογή απορριμμάτων συνήθως ονομάζεταιlitter collection.) Ο συλλέκτης απορριμμάτων σχεδόν είναι στενά συνδεδεμένος με τοσύστημα δέσμευσης μνήμης.Πλεονεκτήματα[Επεξεργασία|επεξεργασία κώδικα]Η συλλογή απορριμμάτων απαλλάσσει τον προγραμματιστή από το να πρέπει να αποδεσμεύει ο ίδιος τη μνήμη. Αυτό έχει σαν αποτέλεσμα κάποιες κατηγορίεςσφαλμάτωννα αποκλείονται ή να είναι πιο δύσκολο να εμφανιστούν:Τασφάλματα αιωρούμενου δείκτη(dangling pointer), που συμβαίνουν όταν μια θέση μνήμης αποδεσμεύεται αλλά εξακολουθούν να υπάρχουν δείκτες που δείχνουν σε αυτήν και ένας από αυτούς τους δείκτες χρησιμοποιείται στη συνέχεια από τον κώδικα. Τότε όμως η μνήμη μπορεί να έχει δεσμευτεί ξανά για άλλη χρήση και να περιέχει άλλα δεδομένα, με απροσδόκητα αποτελέσματα.Τασφάλματα διπλής αποδέσμευσης(double free bugs), που συμβαίνουν όταν ένα πρόγραμμα προσπαθεί να αποδεσμεύσει μια περιοχή μνήμης που έχει ήδη αποδεσμευτεί (και πιθανόν να έχει δεσμευτεί πάλι για άλλο σκοπό).Κάποιες μορφέςδιαρροών μνήμης(memory leaks), στις οποίες ένα πρόγραμμα δε μπορεί να απελευθερώσει τη μνήμη που καταλαμβάνουν αντικείμενα που δεν είναι πια ορατά από τον κώδικα, με αποτέλεσμα, αν αυτό συνεχιστεί, η μνήμη να εξαντληθεί. (Η συλλογή απορριμμάτων συνήθως δεν ασχολείται με δεδομένα που είναι πολύ μεγάλα σε όγκο και το πρόγραμμα δεν τα χρησιμοποιεί αλλά μπορεί να τα δει.)Κάποια από τα σφάλματα που αντιμετωπίζει η συλλογή απορριμμάτων μπορούν επίσης να οδηγούν και σε προβλήματαασφάλειας.Μειονεκτήματα[Επεξεργασία|επεξεργασία κώδικα]Συνήθως η συλλογή απορριμμάτων έχει κάποια μειονεκτήματα:Η συλλογή απορριμμάτων καταναλώνει υπολογιστικούς χώρους για να αποφασίσει ποια μνήμη θα αποδεσμεύσει, ανακαλύπτοντας πάλι πληροφορίες που μπορεί να είναι γνωστές στον προγραμματιστή. Αν δεν δοθεί ο χρόνος ζωής των αντικειμένων από τον προγραμματιστή, τότε το κόστος είναι μια υπολογιστική επιβάρυνση (overhead), που μπορεί να οδηγήσει σε αργή ταχύτητα εκτέλεσης. Η αλληλεπίδραση αυτής της επιβάρυνσης με τη μνήμη και την ιεραρχική δομή αυτής, μπορεί να οδηγήσει σε απαγορευτικές επιβαρύνσεις σε καταστάσεις που δεν αναμένονται ή δεν έχουν εντοπιστεί κατά τη δοκιμή του λογισμικού.Η στιγμή που γίνεται η συλλογή απορριμμάτων μπορεί να μην αναμένεται, με αποτέλεσμα να υπάρχουν καθυστερήσεις σε διάφορα χρονικά σημεία κατά την εκτέλεση του προγράμματος. Οι απρόβλεπτες καθυστερήσεις μπορεί να είναι απαράδεκτες σε περιβάλλοντα εφαρμογών πραγματικού χρόνου (real-time), στηνεπεξεργασία συναλλαγώνή σε προγράμματα που αλληλεπιδρούν με τον χρήστη.Ο προγραμματιστής δε μπορεί να χειρίζεταιδείκτες(pointers), μόνοαναφορές(references).Η μη ντετερμινιστική συλλογή απορριμμάτων δεν είναι συμβατή με τη διαχείριση των πόρων που χρησιμοποιούνται κατά το προγραμματιστικό ιδίωμαRAIIκαι δεν συλλέγονται αυτόματα. Αυτό έχει ως αποτέλεσμα τα αντικείμενα που δεν συλλέγονται αυτόματα να επηρεάζουν την αποδέσμευση των αντικειμένων που διαχειρίζεται η συλλογή απορριμμάτων, όταν αντικείμενα των δύο κατηγοριών συνδέονται μεταξύ τους.Ανιχνευτική συλλογή απορριμμάτων[Επεξεργασία|επεξεργασία κώδικα]Οι ανιχνευτικοί συλλέκτες απορριμμάτων (tracing garbage collectors) είναι ο συνηθέστερος τύπος συλλεκτών απορριμμάτων. Αρχικά εντοπίζουν τα αντικείμενα που είναι προσιτά (reachable) ή αυτά που θα μπορούσαν να είναι προσιτά, και στη συνέχεια αποδεσμεύουν όλα τα υπόλοιπα αντικείμενα.Προσιτότητα ενός αντικειμένου[Επεξεργασία|επεξεργασία κώδικα]Πρακτικά, ένα αντικείμενο είναι προσιτό αν αναφέρεται σε αυτό τουλάχιστον μια μεταβλητή του προγράμματος, είτε άμεσα, είτε μέσω αναφορών από άλλα προσιτά αντικείμενα. Ακριβέστερα, τα αντικείμενα μπορεί να είναι προσιτά με δύο μόνο τρόπους:Τα αντικείμενα ενός συγκεκριμένου συνόλου θεωρούνται προσιτά και ονομάζονταιρίζες(roots). Συνήθως είναι τα αντικείμενα στα οποία υπάρχουν αναφορές οπουδήποτε στηστοίβα κλήσεων(δηλαδή όλες οι τυπικές μεταβλητές και οι παράμετροι των συναρτήσεων που καλούνται), καθώς και όλες οι καθολικές (global) μεταβλητές.Κάθε αναφορά από ένα προσιτό αντικείμενο δείχνει και αυτή σε προσιτό αντικείμενο. Τυπικά, η προσιτότητα είναιμεταβατικό κλείσιμο(transitive closure).Ο ορισμός της προσιτότητας των απορριμμάτων δεν είναι ο καλύτερος, γιατί ένα πρόγραμμα μπορεί να χρησιμοποιήσει ένα αντικείμενο για τελευταία φορά και μετά να μεσολαβήσει μεγάλο χρονικό διάστημα μέχρι την αποδέσμευσή του, επειδή δεν είναι πια ορατό στο τρέχον περιβάλλον του προγράμματος. Κάποιες φορές γίνεται διάκριση μεταξύ τωνσυντακτικών απορριμμάτων(syntactic garbage), που είναι τα αντικείμενα που το πρόγραμμα δε μπορεί να δει, και τωνσημασιολογικών απορριμμάτων(semantic garbage), που είναι τα αντικείμενα που το πρόγραμμα δεν πρόκειται να χρησιμοποιήσει πάλι. Για παράδειγμα:Objectx=newFoo();Objecty=newBar();x=newQuux();/* σε αυτό το σημείο γνωρίζουμε ότι το αντικείμενο Foo* που αρχικά δόθηκε σαν τιμή στη x δεν μπορεί πια* να χρησιμοποιηθεί: είναι συντακτικά απορρίμματα*/if(x.check_something()){x.do_something(y);}System.exit(0);/* στην παραπάνω ενότητα, η y *θα μπορούσε* να είναι σημασιολογικά* απορρίμματα, αλλά δεν το γνωρίζουμε, μέχρι η x.check_something()* να επιστρέψει κάποια τιμή (αν τελικά επιστρέψει)*/Το πρόβλημα του ακριβούς χαρακτηρισμού των σημασιολογικών απορριμμάτων μπορεί να αποδειχτεί ότι είναιμερικώς υπολογίσιμο: ένα πρόγραμμα που δεσμεύει μνήμη για ένα αντικείμενοX, εκτελεί ένα τυχαίο πρόγραμμα εισόδουP, και χρησιμοποιεί τοXαν και μόνο αντοPτερματίζει θα απαιτούσε έναν συλλέκτη απορριμμάτων που θα έλυνε τοπρόβλημα τερματισμού(halting problem). Αν και οι συντηρητικές ευριστικές μέθοδοι για τον εντοπισμό σημασιολογικών απορριμμάτων εξακολουθούν να αποτελούν ενεργό ερευνητικό πεδίο, οι περισσότεροι συλλέκτες απορριμμάτων στην πράξη στοχεύουν στη συλλογή συντακτικών απορριμμάτων.Ένα άλλο θέμα είναι ότι σε γλώσσες προγραμματισμού που υπάρχουν και τύποι αναφοράς (reference types) και βασικοί τύποι τιμής (unboxed value types), ο συλλέκτης απορριμμάτων πρέπει με κάποιο τρόπο να μπορεί να ξεχωρίσει ποιες μεταβλητές της στοίβας ή ποια πεδία ενός αντικειμένου είναι τιμές και ποια είναι αναφορές: στη μνήμη μπορεί να μην υπάρχει διαφορά μεταξύ ενός ακεραίου και μιας αναφοράς. Ο συλλέκτης απορριμμάτων τότε πρέπει να γνωρίζει αν ένα στοιχείο είναι αναφοράς, ώστε να το ακολουθήσει, ή αν είναι βασική τιμή (primitive value). Μια συνηθισμένη λύση είναι η χρήση δεικτών με επιπλέον πληροφορία (tagged pointers).Ισχυρές και ασθενείς αναφορές[Επεξεργασία|επεξεργασία κώδικα]Ο συλλέκτης απορριμμάτων μπορεί να αποδεσμεύει μόνο αντικείμενα προς τα οποία δεν υπάρχουν αναφορές. Μπορούν όμως να υπάρχουν κάποιες αναφορές, οι οποίες δεν εμποδίζουν την αποδέσμευση, οι οποίες ονομάζονταιασθενείς αναφορές(weak references). Όταν οι ασθενείς αναφορές συγκρίνονται με τις συνηθισμένες αναφορές, οι τελευταίες τότε μπορεί να ονομάζονται καιισχυρές αναφορές(strong references). Ένα αντικείμενο τότε συλλέγεται όταν δεν υπάρχουν ισχυρές (δηλαδή κανονικές) αναφορές, ακόμα και αν υπάρχουν ασθενείς αναφορές σε αυτό.Μια ασθενής αναφορά δεν είναι απλά ένας οποιοσδήποτε δείκτης σε ένα αντικείμενο για το οποίο δεν ενδιαφέρεται ο συλλέκτης απορριμμάτων. Ο όρος συνήθως χρησιμοποιείται για μια ειδικά διαχειριζόμενη κατηγορία ειδικών αναφορών, που είναι ασφαλείς στη χρήση, ακόμα και όταν το αντικείμενό τους εξαφανιστεί, γιατί τότε αποκτούν κάποια ειδική και ασφαλή τιμή. Μια αναφορά που δεν είναι ασφαλής και ο συλλέτης απορριμμάτων δεν γνωρίζει για αυτήν, θα μείνει «αιωρούμενη» (dangling) γιατί θα συνεχίσει να αναφέρεται σε μια διεύθυνση μνήμης, όπου το αντικείμενο ήταν στο παρελθόν. Αυτό δεν είναι ασθενής αναφορά.Ασθενείς συλλογές[Επεξεργασία|επεξεργασία κώδικα]Υπάρχουν αντικείμενα που διατηρούν δείκτες προς συλλογές από άλλα αντικείμενα και τα παρακολουθούν με ασθενή τρόπο. Για παράδειγμα, υπάρχουν ασθενείς πίνακες κατακερματισμού (weak hash tables). Όπως και σε έναν κανονικό πίνακα κατακερματισμού, σε έναν ασθενή πίνακα κατακερματισμού διατηρείται μια σχέση μεταξύ αντικειμένων σε ζεύγη, με κάθε ζεύγος να είναι ένα κλειδί και μια τιμή. Ο πίνακας κατακερματισμού όμως δε διατηρεί κάποια ισχυρή αναφορά προς αυτά τα αντικείμενα. Όταν ένα κλειδί ή μια τιμή γίνει απόρριμμα η εγγραφή στον πίνακα διαγράφεται στιγμιαία. Υπάρχουν επίσης περιπτώσεις τέτοιων πινάκων που έχουν μόνο ασθενή κλειδιά και οι αναφορές κλειδιών είναι ισχυρές ή το αντίθετο (ισχυρά κλειδιά και ασθενείς τιμές).Οι ασθενείς πίνακες κατακερματισμού είναι σημαντικοί γιατί δίνουν τη δυνατότητα αποθήκευσης σχέσεων μεταξύ αντικειμένων, αλλά με τρόπο που τα αντικείμενα της σχέσης να μπορούν να γίνουν απορρίμματα αν τίποτα στο πρόγραμμα δεν έχει αναφορές προς αυτά (εκτός από τον ίδιο τον πίνακα). Αντίθετα, η χρήση ενός απλού πίνακα κατακερματισμού για αυτόν τον σκοπό θα οδηγούσε σε διαρροή μνήμης.Βασικός αλγόριθμος[Επεξεργασία|επεξεργασία κώδικα]Η ανιχνευτική συλλογή απορριμμάτων ονομάζεται έτσι γιατί ανιχνεύει όλον τον χώρο εργασίας στη μνήμη. Η συλλογή γίνεται σε κύκλους. Ένας κύκλος αρχίζει όταν ο συλλέκτης αποφασίζει (ή λάβει ειδοποίηση) ότι χρειάζεται να αποδεσμεύσει μνήμη, κάτι που συνήθως συμβαίνει όταν το σύστημα δεν έχει μνήμη ελεύθερη. Η αρχική μέθοδος περιλάμβανε ένα απλό «μαρκάρισμα-και-σκούπισμα» (mark-and-sweep), στο οποίο όλος ο χώρος εργασίας εξετάζεται μία ή περισσότερες φορές.Απλό μαρκάρισμα-και-σκούπισμα[Επεξεργασία|επεξεργασία κώδικα]Στο απλό μαρκάρισμα-και-σκούπισμα, κάθε αντικείμενο στη μνήμη έχει ένα πεδίο (συνήθως ένα bit) που προορίζεται για χρήση αποκλειστικά από τη συλλογή απορριμμάτων. Το πεδίο αυτό συνήθως είναι κενό, εκτός από τη διάρκεια του κύκλου συλλογής απορριμμάτων. Το πρώτο στάδιο της συλλογής διατρέχει ελεύθερα όλο το σύνολο των ριζών ('root set'), μαρκάροντας κάθε αντικείμενο προς το οποίο υπάρχει δείκτης, σανσε χρήση('in-use'). Επίσης μαρκάρονται και όλα τα αντικείμενα στα οποία δείχνουν τα αντικείμενα που ήδη μαρκαρίστηκαν, και ούτω καθεξής, μέχρι να μαρκαριστεί κάθε αντικείμενο στο οποίο μπορεί να φτάσει κανείς μέσω δεικτών από τις ρίζες. Στο τέλος, σκανάρεται όλη η μνήμη από την αρχή μέχρι το τέλος και εξετάζονται όλα τα ελεύθερα ή χρησιμοποιούμενα μέρη: όσα αντικείμενα εξακολουθούν να έχουν κενό το πεδίο 'σε χρήση', δεν είναι προσιτά από το πρόγραμμα ή τα δεδομένα του και η μνήμη που καταναλώνουν αποδεσμεύεται. (Στα αντικείμενα που έχουν μαρκαριστεί σαν 'σε χρήση', το πεδίο αυτό καθαρίζεται για τον επόμενο κύκλο συλλογής απορριμμάτων.)Η μέθοδος αυτή έχει διάφορα μειονεκτήματα, με το κυριότερο να είναι ότι όλο το υπόλοιπο σύστημα πρέπει να σταματήσει κατά τη διάρκεια της συλλογής επειδή απαγορεύεται κάθε αλλαγή του χώρου της μνήμης. Αυτό έχει σαν αποτέλεσμα τα προγράμματα να 'παγώνουν' περιστασιακά (και απροειδοποίητα), αποκλείοντας έτσι τις εφαρμογές πραγματικού χρόνου. Επιπλέον, πρέπει να εξεταστεί όλη η μνήμη που χρησιμοποιείται, συχνά δύο φορές, κάτι που μπορεί να προκαλέσει προβλήματα σε συστήματα με μνήμη σε σελίδες (paged memory).Μαρκάρισμα τριών χρωμάτων[Επεξεργασία|επεξεργασία κώδικα]Λόγω των προβλημάτων της προηγούμενης μεθόδου, οι περισσότεροι σύγχρονοι αλγόριθμοι ανιχνευτικής συλλογής απορριμμάτων υλοποιούν κάποια παραλλαγή του μαρκαρίσματος τριών χρωμάτων (tri-colour marking). Το μαρκάρισμα τριών χρωμάτων δουλεύει ως εξής:Αρχικά δημιουργεί άσπρα, γκρίζα και μαύρα σύνολα, τα οποία θα χρησιμοποιηθούν για να κρατείται πληροφορία για την πρόοδο ενός κύκλου.Το άσπρο σύνολο αρχικά είναι το σύνολο των αντικειμένων που είναι υποψήφια για να αποδεσμευτεί η μνήμη τους.Το μαύρο σύνολο είναι το σύνολο των αντικειμένων που μπορεί εύκολα να δειχτεί ότι δεν δείχνουν σε αντικείμενα στο άσπρο σύνολο (σε πολλές υλοποιήσεις αρχικά είναι το κενό σύνολο).Το γκρίζο σύνολο είναι όλα τα αντικείμενα που είναι προσιτά από αναφορές στις ρίζες αλλά τα αντικείμενα στα οποία δείχνουν τα γκρίζα αντικείμενα δεν έχουν ανιχνευτεί ακόμα. Τα γκρίζα αντικείμενα είναι γνωστό ότι είναι προσιτά από τις ρίζες, άρα δε μπορούν να θεωρηθούν απορρίμματα: τελικά τα γκρίζα αντικείμενα θα καταλήξουν στο μαύρο σύνολο. Το γκρίζο χρώμα σημαίνει ότι δεν έχουν ελεγχθεί ακόμα όλα τα αντικείμενα στα οποία δείχνει ένα αντικείμενο.Το γκρίζο σύνολο αρχικά περιέχει τα αντικείμενα προς τα οποία υπάρχουν αναφορές από το επίπεδο των ριζών ενώ συνήθως όλα τα υπόλοιπα αντικείμενα τοποθετούνται αρχικά στο άσπρο σύνολο.Τα αντικείμενα μπορούν να αλλάζουν χρώμα από άσπρο σε γκρίζο ή από γκρίζο σε άσπρο, ποτέ προς την άλλη κατεύθυνση.Επιλέγεται ένα αντικείμενο από το γκρίζο σύνολο. Το αντικείμενο μετακινείται στο μαύρο σύνολο και τα άσπρα αντικείμενα στα οποία αναφέρεται άμεσα γίνονται γκρίζα. Αυτό σημαίνει ότι το αντικείμενο δε μπορεί θεωρηθεί απόρριμμα και το ίδιο ισχύει και για τα αντικείμενα στα οποία δείχνει.Το προηγούμενο βήμα επαναλαμβάνεται μέχρι να αδειάσει το γκρίζο σύνολο.Όταν δεν υπάρχουν άλλα αντικείμενα στο γκρίζο σύνολο, όλα τα αντικείμενα που μένουν στο άσπρο σύνολο είναι προφανώς μη προσιτά και ο χώρος που καταλαμβάνουν αποδεσμεύεται.Τα 3 σύνολα χωρίζουν τη μνήμη, με κάθε αντικείμενο του συστήματος, συμπεριλαμβανομένων των ριζών, να ανήκει ακριβώς σε ένα από αυτά τα σύνολα.Ο αλγόριθμος του μαρκαρίσματος τριών χρωμάτων διατηρεί την εξής σημαντική αναλλοίωτη (invariant):Κανένα μαύρο αντικείμενο δεν δείχνει απευθείας σε άσπρο αντικείμενο.Αυτό εγγυάται την ασφαλή καταστροφή των άσπρων αντικειμένων όταν αδειάσει το γκρίζο σύνολο. (Υπάρχουν εκδοχές του αλγορίθμου που δεν διατηρούν την παραπάνω αναλλοίωτη αλλά εξακολουθούν να ισχύουν οι βασικές ιδιότητες.)Η μέθοδος των τριών χρωμάτων έχει ένα σημαντικό πλεονέκτημα: μπορεί να χρησιμοποιηθεί χωρίς το σύστημα να σταματά για μεγάλα χρονικά διαστήματα. Αυτό επιτυγχάνεται με το μαρκάρισμα αντικειμένων όταν αυτά δημιουργούνται και δεσμεύεται ο χώρος τους στη μνήμη, και κατά τη διάρκεια της τροποποίησής τους από το πρόγραμμα, διατηρώντας τα σύνολο. Το σύστημα μπορεί να παρακολουθεί το μέγεθος των συνόλων και να κάνει συλλογή απορριμμάτων περιοδικά, και όχι μόνο όταν χρειάζεται. Επίσης με αυτόν τον τρόπο αποτρέπεται η ανίχνευση όλου του χώρου εργασίας στη μνήμη σε κάθε κύκλο.Στρατηγικές υλοποίησης[Επεξεργασία|επεξεργασία κώδικα]Για την υλοποίηση του βασικού αλγορίθμου τριών χρωμάτων πρέπει να ληφθούν κάποιες σημαντικές σχεδιαστικές αποφάσεις, οι οποίες επηρεάζουν σημαντικά την ταχύτητα της συλλογής απορριμμάτων.Μετακίνηση[Επεξεργασία|επεξεργασία κώδικα]Όταν προσδιοριστεί το σύνολο των προσιτών αντικειμένων, η συλλογή απορριμμάτων μπορεί απλά να αποδεσμεύσει τη μνήμη που καταλαμβάνουν τα απρόσιτα αντικείμενα, και να αφήσουν όλη την υπόλοιπη μνήμη ως έχει, ή να αντιγράψει μερικά (ή όλα) τα προσιτά αντικείμενα σε έναν νέο χώρο στη μνήμη, ενημερώνοντας όλες τις αναφορές προς αυτά τα αντικείμενα. Αυτοί οι τρόποι συλλογής απορριμμάτων ονομάζονται «μη μετακινούντες» και «μετακινούντες» αντίστοιχα (\"non-moving\" και \"moving\", ή εναλλακτικά, \"non-compacting\" και \"compacting\").Εκ πρώτης όψεως, μια στρατηγική συλλογής απορριμμάτων με μετακίνηση μπορεί να μοιάζει μη αποδοτική και αργή σε σχέση με τη στρατηγική που δεν μετακινεί, γιατί σε κάθε κύκλο κάνει παραπάνω δουλειά. Στην πράξη όμως η στρατηγική συλλογής απορριμμάτων με μετακίνηση οδηγεί σε πολλά πλεονεκτήματα όσον αφορά την ταχύτητα, τόσο κατά την ίδια τη συλλογή απορριμμάτων, όσο και κατά τη διάρκεια της εκτέλεσης του προγράμματος:Δεν χρειάζεται επιπλέον προσπάθεια για την αποδέσμευση του χώρου που καταλαμβάνουν τα νεκρά αντικείμενα: όλος ο χώρος της μνήμης, από τον οποίο μετακινήθηκαν αντικείμενα, θεωρείται ελεύθερος χώρος. Αντίθετα, η συλλογή απορριμμάτων χωρίς μετακίνηση πρέπει να επισκεφτεί κάθε απρόσιτο αντικείμενο και με κάποιον τρόπο να αποδεσμεύσει τη μνήμη του.Για τον ίδιο λόγο με παραπάνω, χώρος για νέα αντικείμενα μπορεί να δεσμευτεί πολύ γρήγορα. Επειδή η συλλογή απορριμμάτων με μετακίνηση δημιουργεί μεγάλους συνεχείς χώρους μνήμης, τα νέα αντικείμενα μπορούν να δεσμευτούν, αυξάνοντας απλά κατά ένα κάποιον δείκτη που δείχνει σε 'ελεύθερη μνήμη'. Αντίθετα, η συλλογή απορριμμάτων χωρίς μετακίνηση μπορεί μετά από κάποιο χρονικό διάστημα να οδηγήσει σε κατακερματισμό (fragmentation) του σωρού, με αποτέλεσμα να πρέπει να χρησιμοποιηθούν δαπανηρές «ελεύθερες λίστες» (\"free lists\"), που δείχνουν ποια μπλοκ μνήμης είναι διαθέσιμα για δέσμευση νέων αντικειμένων.Αν χρησιμοποιηθεί η κατάλληλη σειρά επίσκεψης των περιεχομένων της μνήμης (για παράδειγμα, στην περίπτωση των λιστών, η επίσκεψη σε κάθε κόμβο πριν τον προηγούμενο), τα αντικείμενα που αναφέρονται σε άλλα αντικείμενα συχνά μπορούν να μετακινηθούν πολύ κοντά το ένα στο άλλο στη μνήμη, αυξάνοντας την πιθανότητα να ανήκουν στην ίδια γραμμήκρυφής μνήμης(cache line), ή στην ίδια σελίδαεικονικής μνήμης(virtual memory). Αυτό μπορεί να κάνει την πρόσβαση σε αυτά τα αντικείμενα πολύ γρήγορη, μέσω αυτών των αναφορών.Ένα μειονέκτημα της συλλογής απορριμμάτων με μετακίνηση είναι ότι επιτρέπει πρόσβαση μόνο μέσω αναφορών που διαχειρίζεται το περιβάλλον της συλλογής απορριμμάτων, και δεν επιτρέπει αριθμητική δεικτών. Αυτό συμβαίνει γιατί κάθε δείκτης προς ένα αντικείμενο δεν θα είναι έγκυρος όταν πια η συλλογή απορριμμάτων έχει μετακινήσει το αντικείμενο, και γίνεται αιωρούμενος δείκτης (dangling pointer). Για την επικοινωνία με τον κώδικα μηχανής, η συλλογή απορριμμάτων πρέπει να αντιγράψει τα περιεχόμενα του αντικειμένου σε μια θέση εκτός της μνήμης που συλλέγεται. Μια άλλη προσέγγιση είναι το αντικείμενο να είναι αμετακίνητο (pin), απαγορεύοντας στη συλλογή απορριμμάτων να το μετακινήσει και επιτρέποντας στη μνήμη να μοιράζεται μέσω απλών δεικτών (πιθανόν επιτρέποντας και την αριθμητική δεικτών).[3]Συλλογή με αντιγραφή, μαρκάρισμα-και-σκούπισμα και μαρκάρισμα-χωρίς-σκούπισμα[Επεξεργασία|επεξεργασία κώδικα]Οι συλλέκτες απορριμμάτων μπορούν να κατηγοριοποιηθούν ανάλογα με τον τρόπο που κρατούν τα τρία σύνολα αντικειμένων (άσπρα, γκρίζα και μαύρα) κατά τη διάρκεια ενός κύκλου συλλογής.Η πιο ευθεία προσέγγιση είναι αυτή του συλλέκτη αντιγραφής (semi-space collector), η οποία ανάγεται στο 1969. Σε αυτόν τον τρόπο συλλογής απορριμμάτων με μετακίνηση, η μνήμη χωρίζεται σε δύο χώρους, στον χώρο-από (\"from space\") και στον χώρο-προς (\"to space\"). Αρχικά τα αντικείμενα βρίσκονται στον χώρο \"to space\" μέχρι να χρειαστεί συλλογή απορριμμάτων λόγω έλλειψης χώρου. Στην αρχή της συλλογής, ο \"to space\" γίνεται \"from space\" και αντίστροφα (εναλλάσσονται οι ρόλοι τους). Τα αντικείμενα που είναι προσιτά από το σύνολο των ριζών αντιγράφονται από τον \"from space\" στον \"to space\". Τα αντικείμενα αυτά σαρώνονται στη συνέχεια και όλα τα αντικείμενα στα οποία δείχνουν αντιγράφονται στον \"to space\", μέχρι όλα τα προσιτά αντικείμενα να αντιγραφούν εκεί. Όταν το πρόγραμμα συνεχίσει την εκτέλεσή του, τα νέα αντικείμενα δεσμεύονται πάλι στον \"to space\", μέχρι να γεμίσει και η διαδικασία να επαναληφθεί. Το πλεονέκτημα αυτής της προσέγγισης είναι η απλότητα (τα σύνολα των τριών χρωμάτων κατασκευάζονται έμμεσα κατά τη διαδικασία της αντιγραφής), αλλά έχει το μειονέκτημα ότι απαιτείται μια σχετικά μεγάλη και συνεχής περιοχή ελεύθερης μνήμης σε κάθε κύκλο συλλογής. Η τεχνική αυτή ονομάζεται καιstop-and-copy. Οαλγόριθμος του Cheneyείναι βελτίωση του συλλέκτη αντιγραφής.Ένας συλλέκτης απορριμμάτων με μαρκάρισμα και σκούπισμα (mark and sweep) κρατά ένα ή δύο bit σε κάθε αντικείμενο, τα οποία δείχνουν αν είναι μαύρο ή άσπρο. Το γκρίζο σύνολο διατηρείται είτε σαν ξεχωριστή λίστα (όπως η στοίβα της διεργασίας), είτε χρησιμοποιώντας κάποιο άλλο bit. Καθώς διατρέχεται το δέντρο των αναφορών κατά τη διάρκεια της συλλογής (η φάση του «μαρκαρίσματος»), αυτά τα bit ενημερώνονται από τον συλλέκτη για να αντικατοπτρίζουν την τρέχουσα κατάσταση. Στη συνέχεια ένα τελικό «σκούπισμα» της μνήμης αποδεσμεύει τα άσπρα αντικείμενα. Η στρατηγική μαρκαρίσματος και σκουπίσματος έχει το πλεονέκτημα ότι, όταν καθοριστεί το σύνολο των αντικειμένων που δεν είναι προσιτά, μπορεί να ακολουθηθεί μια στρατηγική μετακίνησης ή μη μετακίνησης -- η επιλογή αυτή μάλιστα μπορεί να γίνει ακόμα και κατά τον χρόνο εκτέλεσης, ανάλογα με τη διαθέσιμη μνήμη. Από την άλλη πλευρά, έχει το μειονέκτημα ότι αυξάνεται λίγο το μέγεθος των αντικειμένων.Ένας συλλέκτης απορριμμάτων που μαρκάρει αλλά δεν σκουπίζει (mark and don't sweep) κρατά, όπως και στην προηγούμενη περίπτωση, ένα bit σε κάθε αντικείμενο για να θυμάται αν είναι άσπρο ή μαύρο -- το γκρίζο σύνολο διατηρείται είτε σαν ξεχωριστή λίστα ή με τη χρήση κάποιου άλλου bit. Υπάρχουν όμως δύο βασικές διαφορές.Τα χρώματα «μαύρο» και «άσπρο» σημαίνουν διαφορετικά πράγματα σε σχέση με τον συλλέκτη απορριμμάτων με μαρκάρισμα και σκούπισμα. Σε ένα σύστημα μαρκαρίσματος χωρίς σκούπισμα, όλα τα προσιτά αντικείμενα είναι πάντα μαύρα. Ένα αντικείμενο μαρκάρεται μαύρο όταν δεσμεύεται και μένει μαύρο, ακόμα και όταν δεν είναι πια προσιτό. Ένα άσπρο αντικείμενο είναι μνήμη που δε χρησιμοποιείται και μπορεί να δεσμευτεί.Η ερμηνεία του άσπρου/μαύρου bit μπορεί να αλλάξει. Αρχικά το άσπρο/μαύρο bit μπορεί να έχει τη σημασία (0=άσπρο, 1=μαύρο). Αν μια δέσμευση μνήμης δεν μπορέσει να βρει αρκετή (άσπρη) μνήμη, τότε αυτό σημαίνει ότι όλα τα αντικείμενα είναι μαρκαρισμένα σαν σε χρήση (μαύρα). Η σημασία του άσπρου/μαύρου bit τότε εναλλάσσεται (για παράδειγμα, 0=μαύρο, 1=άσπρο) και όλα τα αντικείμενα γίνονται άσπρα. Αυτό έχει σαν αποτέλεσμα να μην ισχύει εκείνη τη στιγμή η αναλλοίωτη ότι όλα τα προσιτά αντικείμενα είναι μαύρα, αλλά η πλήρης φάση μαρκαρίσματος που ακολουθεί τα ξανακάνει μαύρα. Όταν αυτό γίνει, όλη η μνήμη που δεν είναι προσιτή έχει γίνει άσπρη. Δεν χρειάζεται φάση «σκουπίσματος».Συλλογή απορριμμάτων σε γενεές[Επεξεργασία|επεξεργασία κώδικα]Έχει παρατηρηθεί ότι σε πολλά προγράμματα, τα πρόσφατα δημιουργημένα αντικείμενα είναι και αυτά που είναι και πιο πιθανό να μην είναι προσιτά σύντομα, κάτι που είναι γνωστό και ως βρεφική θνησιμότητα (infant mortality) ή γενεαλογική υπόθεση (generational hypothesis). Η συλλογή απορριμμάτων σε γενεές (generational garbage collection ή ephemeral garbage collection) χωρίζει τα αντικείμενα σε γενεές και, στους περισσότερους κύκλους, θα τοποθετήσει μόνο τα αντικείμενα ενός υποσυνόλου των γενεών αυτών στο αρχικό άσπρο σύνολο. Επιπλέον, το σύστημα χρόνου εκτέλεσης διατηρεί πληροφορίες για τις αναφορές μεταξύ των γενεών, παρακολουθώντας τη δημιουργία και την ενημέρωση των αναφορών. Όταν εκτελείται ο συλλέκτης απορριμμάτων, μπορεί να χρησιμοποιήσει αυτήν την πληροφορία για να αποδείξει ότι κάποια αντικείμενα στο αρχικό άσπρο σύνολο δεν είναι προσιτά χωρίς να πρέπει να διατρέξει ολόκληρο το δέντρο των αναφορών. Αν η γενεαολογική υπόθεση ισχύει, αυτό έχει σαν αποτέλεσμα πιο γρήγορους κύκλους συλλογής, ενώ συλλέγονται τα πιο πολλά προσιτά αντικείμενα.Για να υλοποιηθεί αυτή η ιδέα, πολλοί συλλέκτες απορριμμάτων αυτού του είδους χρησιμοποιούν διαφορετικές περιοχές μνήμης για αντικείμενα διαφορετικών ηλικιών. Όταν μια περιοχή γεμίσει, τα αντικείμενα στα οποία αναφέρονται περιοχές με μεγαλύτερη ηλικία αντιγράφονται στην επόμενη περιοχή, και ολόκληρη η περιοχή μπορεί τότε να χρησιμοποιηθεί για νέα αντικείμενα. Αυτή η τεχνική επιτρέπει πολύ γρήγορη σταδιακή (incremental) συλλογή απορριμμάτων, γιατί χρειάζεται μόνο συλλογή απορριμμάτων για μια περιοχή κάθε φορά.Η συλλογή απορριμμάτων σε γενεές είναι μια ευριστική προσέγγιση και κάποια μη προσιτά αντικείμενα δε μπορούν να αποδεσμευτούν κατά τη διάρκεια κάθε κύκλου. Μπορεί επομένως σποραδικά να χρειάζεται να διενεργείται ένα πλήρες μαρκάρισμα και σκούπισμα ή μια συλλογή απορριμμάτων με αντιγραφή, για την αποδέσμευση όλου του διαθέσιμου χώρου. Τα συστήματα χρόνου εκτέλεσης των σύγχρονων γλωσσών προγραμματισμού (όπως ηJavaκαι το.NET Framework) συνήθως χρησιμοποιούν κάποια υβριδική στρατηγική που συνδυάζει τις στρατηγικές που ήδη αναφέρθηκαν. Για παράδειγμα, οι περισσότεροι κύκλοι συλλογής μπορεί να εξετάζουν μόνο κάποιες γενεές, ενώ κάποιες φορές συμβαίνει μαρκάρισμα και σκούπισμα, και ακόμα πιο σπάνια μια πλήρης αντιγραφή, ώστε να ελέγχεται ο κατακερματισμός (fragmentation). Οι όροι \"minor cycle\" και \"major cycle\" χρησιμοποιούνται κάποιες φορές για να περιγράψουν αυτά τα διαφορετικά επίπεδα συλλογής.Stop-the-world, προσθετική και σύγχρονη συλλογή απορριμμάτων[Επεξεργασία|επεξεργασία κώδικα]Οι απλοί συλλέκτες απορριμμάτων σταματούν εντελώς την εκτέλεση του προγράμματος (stop-the-world) για να εκτελέσουν έναν κύκλο συλλογής, εξασφαλίζοντας ότι δεν θα δεσμευτούν νέα αντικείμενα, ούτε κάποια αντικείμενα πρόκειται να γίνουν απρόσιτα κατά τη συλλογή απορριμμάτων.Το φανερό μειονέκτημα αυτής της τεχνικής είναι ότι το πρόγραμμα δεν μπορεί να συνεχίσει τις εργασίες του όταν γίνεται η συλλογή απορριμμάτων και προκύπτει μια παύση (\"embarrassing pause\"). Αυτό έχει σαν αποτέλεσμα η συλλογή απορριμμάτων τύπου stop-the-world να είναι κατάλληλη κυρίως για προγράμματα χωρίς αλληλεπίδραση με τον χρήστη. Το πλεονέκτημά της είναι ότι είναι πιο εύκολο να υλοποιηθεί και εκτελείται πιο γρήγορα σε σχέση με την προσθετική συλλογή απορριμμάτων.Οι προσθετικοί (incremental) και οι σύγχρονοι (concurrent) συλλέκτες απορριμμάτων έχουν σχεδιαστεί έτσι ώστε να μειώνουν αυτήν την «αναστάτωση» κατά την εκτέλεση, παρεμβάλλοντας τις εργασίες τους στις δραστηριότητες του κύριου προγράμματος. Οι προσθετικοί συλλέκτες απορριμμάτων κάνουν συλλογή απορριμμάτων σε διακριτές φάσεις, επιτρέποντας την εκτέλεση του προγράμματος ανάμεσα στις φάσεις αυτές (και κάποιες φορές και κατά τη διάρκεια κάποιων από αυτές). Οι σύγχρονοι συλλέκτες απορριμμάτων δεν σταματούν καθόλου την εκτέλεση του προγράμματος, εκτός ίσως για το μικρό χρονικό διάστημα που σαρώνεται ηστοίβατου προγράμματος. Όλες μαζί οι προσθετικές φάσεις όμως παίρνουν περισσότερο χρόνο για να εκτελεστούν, σε σύγκριση με ένα πέρασμα συνολικής συλλογής απορριμμάτων, επομένως οι συλλέκτες απορριμμάτων αυτού του είδους μπορεί να κάνουν λιγότερο έργο ανά μονάδα χρόνου.Οι τεχνικές αυτές απαιτούν προσεκτική σχεδίαση ώστε να μην υπάρχουν ανεπιθύμητες αλληλεπιδράσεις μεταξύ του προγράμματος και του συλλέκτη απορριμμάτων. Για παράδειγμα, όταν το πρόγραμμα θελήσει να δεσμεύσει χώρο για κάποιο νέο αντικείμενο, το σύστημα χρόνου εκτέλεσης μπορεί να το σταματήσει μέχρι να ολοκληρωθεί η εκτέλεση, ή να ειδοποιήσει με κάποιον τρόπο τον συλλέκτη απορριμμάτων ότι υπάρχει ένα νέο, προσιτό αντικείμενο.Ακριβής/συντηρητική συλλογή απορριμμάτων και εσωτερικοί δείκτες[Επεξεργασία|επεξεργασία κώδικα]Οι συλλέκτες που μπορούν να αναγνωρίσουν σωστά όλους τους δείκτες (αναφορές) σε ένα αντικείμενο ονομάζονται ακριβείς (precise,exactήaccurate), ενώ το αντίθετο είναι οι συντηρητικοί (conservative) ή μερικώς συντηρητικοί (partly conservative) συλλέκτες. Οι συντηρητικοί συλλέκτες υποθέτουν ότι κάθε αλληλουχία bit στη μνήμη μπορεί να είναι δείκτης αν, ερμηνευόμενη σαν δείκτης, θα έδειχνε σε κάποιο αντικείμενο που έχει δεσμευτεί στη μνήμη. Οι συντηρητικοί συλλέκτες μπορεί να αναγνωρίσουν σαν δείκτες λάθος δεδομένα (false positives), με αποτέλεσμα να μην αποδεσμεύεται μνήμη λόγω λάθους αναγνώρισης. Αυτό στην πράξη δεν είναι πάντα πρόβλημα, εκτός και αν το πρόγραμμα χειρίζεται πολλά δεδομένα που μπορούν να αναγνωριστούν λανθασμένα σαν δείκτες. Οι περιπτώσεις λανθασμένης αναγνώρισης προκαλούν γενικά λιγότερα προβλήματα σε συστήματα 64-bit σε σχέση με τα συστήματα 32-bit επειδή το εύρος των έγκυρων διευθύνσεων μνήμης τείνει να είναι ένα πολύ μικρό υποσύνολο του εύρους των τιμών 64-bit. Για αυτόν τον λόγο, είναι σπάνιο κάποια αλληλουχία των 64 bit να μοιάζει με κάποιον έγκυρο δείκτη. Το αν ένας ακριβής συλλέκτης απορριμμάτων εξυπηρετεί στην πράξη εξαρτάται από τις ιδιότητες ασφάλειας τύπων (type safety) της εκάστοτε γλώσσας προγραμματισμού. Ένα παράδειγμα που χρειάζεται συντηρητικός συλλέκτης απορριμμάτων είναι ηγλώσσα C, η οποία επιτρέπει την μετατροπή μεταξύ δεικτών με τύπο (όχι void) και δεικτών χωρίς τύπο (void).Ένα σχετικό θέμα είναι αυτό των εσωτερικών δεικτών (internal pointers), που είναι οι δείκτες στα πεδία ενός αντικειμένου. Αν η σημασιολογία της γλώσσας επιτρέπει εσωτερικούς δείκτες, τότε μπορούν να υπάρχουν πολλές διαφορετικές διευθύνσεις που να αναφέρονται σε μέρη του ίδιου αντικειμένου, κάτι που περιπλέκει την απόφαση αν ένα αντικείμενο είναι απόρριμμα ή όχι. Ένα παράδειγμα είναι η γλώσσαC++, στην οποία η πολλαπλή κληρονομικότητα μπορεί να δημιουργήσει δείκτες προς αντικείμενα βάσης, οι οποίοι να έχουν διαφορετικές διευθύνσεις. Ακόμα και σε γλώσσες όπως ηJava, μπορούν να εμφανίζονται εσωτερικοί δείκτες κατά τον υπολογισμό, για παράδειγμα, της διεύθυνσης ενός στοιχείου ενός πίνακα. Σε ένα πρόγραμμα που έχει υποστεί βελτιστοποίηση, ο αντίστοιχος δείκτης στο ίδιο το αντικείμενο μπορεί να έχει ενημερωθεί στον καταχωρητή στον οποίο βρίσκεται – αυτό σημαίνει ότι πρέπει να γίνεται σάρωση που να βρίσκει αυτούς τους δείκτες.Ταχύτητα εκτέλεσης[Επεξεργασία|επεξεργασία κώδικα]Οι ανιχνευτικοί συλλέκτες απορριμμάτων έχουν κάποια κρυμμένη επιβάρυνση κατά τον χρόνο εκτέλεσης, που δεν ελέγχεται από τον προγραμματιστή και μπορεί να οδηγήσει σε προβλήματα ταχύτητας εκτέλεσης. Για παράδειγμα, οι συλλέκτες stop-the-world που χρησιμοποιούνται συχνά, σταματούν αυθαίρετα την εκτέλεση του προγράμματος σε διάφορες χρονικές στιγμές, κάτι που μπορεί να κάνει τη συλλογή απορριμμάτων αυτού του είδους ακατάλληλη για κάποιαενσωματωμένα συστήματα, λογισμικώνεξυπηρετητώνυψηλής απόδοσης και εφαρμογές με απαιτήσεις πραγματικού χρόνου.Ρητή δέσμευση μνήμης στον σωρόαναζήτηση καλύτερου/πρώτου-κατάλληλου μπλοκ με επαρκές μέγεθοςδιατήρηση λίστας ελεύθερου χώρου (free list)Συλλογή απορριμμάτωνεντοπισμός προσιτών αντικειμένωναντιγραφή προσιτών αντικειμένων στην περίπτωση των συλλεκτών αντιγραφήςσύνορα ανάγνωσης/εγγραφής (read/write barriers) στην περίπτωση των προσθετικών συλλεκτώναναζήτηση καλύτερου/πρώτου-κατάλληλου μπλοκ και διατήρηση της λίστας ελεύθερου χρόνου στην περίπτωση των συλλεκτών χωρίς αντιγραφήΕίναι δύσκολο να συγκριθούν οι δύο παραπάνω προσεγγίσεις απευθείας, γιατί η συμπεριφορά τους εξαρτάται από το εκάστοτε περιβάλλον εκτέλεσης. Για παράδειγμα, στην καλύτερη περίπτωση συλλογής απορριμμάτων, η δέσμευση μνήμης απλά αυξάνει έναν δείκτη, ενώ στην καλύτερη περίπτωση ρητής δέσμευσης χώρου στον σωρό, ο μηχανισμός δέσμευσης μνήμης διατηρεί λίστες ελεύθερης μνήμης διαφόρων μεγεθών, με αποτέλεσμα η δέσμευση μνήμης απλά να ακολουθεί έναν δείκτη. Η κατηγοριοποίηση όμως αυτή της μνήμης σε χώρους διαφορετικών μεγεθών συχνά προκαλεί εξωτερικό κατακερματισμό σε σημαντικό βαθμό, κάτι που μπορεί να επηρεάσει αρνητικά την συμπεριφορά τηςκρυφής μνήμης. Η δέσμευση μνήμης σε μια γλώσσα με συλλογή απορριμμάτων μπορεί να υλοποιηθεί με δέσμευση στον σωρό στο παρασκήνιο (και όχι με την αύξηση ενός δείκτη), επομένως τα παραπάνω πλεονεκτήματα όσον αφορά την ταχύτητα μπορεί να μην ισχύουν πια. Σε κάποιες περιπτώσεις, όπως ταενσωματωμένα συστήματα, η επιβάρυνση της συλλογής απορριμμάτων και της διαχείρισης του σωρού μπορεί να αποφευχθεί με δέσμευση μνήμης από πριν και χρήση ενός πιο ελαφρού συστήματος για δέσμευση/αποδέσμευση.[4]Η επιβάρυνση των συνόρων εγγραφής (write barriers) είναι πιο πιθανό να είναι εμφανής σε προγράμματα σεπροστακτικό στυλ, τα οποία συχνά γράφουν δείκτες σε υπάρχουσεςδομές δεδομένων, σε αντίθεση με τα προγράμματα σεσυναρτησιακό στυλ, που κατασκευάζουν κάθε δεδομένο μια φορά και ποτέ δεν το αλλάζουν.Οι εξελίξεις στη συλλογή απορριμμάτων συχνά σχετίζονται με ζητήματα ταχύτητας. Οι πρώτοι συλλέκτες απορριμμάτων ήταν τύπου stop-the-world, αλλά η ταχύτητα αυτής της προσέγγισης δεν ήταν κατάλληλη για εφαρμογές που αλληλεπιδρούσαν με τον χρήστη ή το περιβάλλον. Η προσθετική συλλογή απορριμμάτων απέφυγε αυτό το πρόβλημα, με το μειονέκτημα ότι είχε μικρότερη αποδοτικότητα λόγω της χρήσης συνόρων. Οι τεχνικές γενεαλογικής συλλογής απορριμμάτων χρησιμοποιούνται στους συλλέκτες stop-the-world και στους προσθετικούς για να αυξηθεί η ταχύτητά τους, με την παραδοχή ότι κάποια απορρίμματα θα αργήσουν να εντοπιστούν.Ντετερμινισμός[Επεξεργασία|επεξεργασία κώδικα]Η ανιχνευτική συλλογή απορριμμάτων δεν είναιντετερμινιστικήόσον αφορά τον χρόνο της λήξης ζωής των αντικειμένων (finalization). Ένα αντικείμενο που θεωρείται απόρριμμα, τελικά θα εκκαθαριστεί, αλλά δεν παρέχεται καμία εγγύηση για το πότε (ή ακόμα και το αν) αυτό θα γίνει. Αυτό έχει επιπτώσεις στηνορθότητα προγράμματος, όταν τα αντικείμενα συνδέονται με πόρους που δεν ανήκουν στη μνήμη, και η αποδέσμευση των οποίων αποτελεί εξωτερική συμπεριφορά του προγράμματος, όπως η διακοπή μιας σύνδεση δικτύου, η απελευθέρωση μιας συσκευής ή το κλείσιμο ενός αρχείου. Μια τεχνική συλλογής απορριμμάτων που παρέχει ντετερμινισμό σε αυτές τις περιπτώσεις είναι το καταμέτρηση αναφορών (reference counting).Η συλλογή απορριμμάτων μπορεί να έχει μη ντετερμινιστική επίδραση στον χρόνο εκτέλεσης, εισάγοντας κάποιες φορές παύσεις στην εκτέλεση του προγράμματος, οι οποίες δεν σχετίζονται με τον αλγόριθμο που εκτελείται. Στην ανιχνευτική συλλογή απορριμμάτων, μια αίτηση για δέσμευση χώρου στη μνήμη μπορεί να επιστρέψει κάποιο αποτέλεσμα αμέσως ή να οδηγήσει σε μια χρονοβόρα συλλογή απορριμμάτων. Στην καταμέτρηση αναφορών, αν και η δέσμευση μνήμης για αντικείμενα είναι συνήθως γρήγορη, η μείωση ενός μετρητή μιας αναφοράς είναι μη ντετερμινιστική, γιατί μπορεί να γίνει μηδέν και να οδηγήσει σε αναδρομική διάσχιση της μνήμης ώστε να μειωθούν και οι μετρητές των αναφορών των άλλων αντικειμένων στα οποία δείχνει το αντικείμενο.Συλλογή απορριμμάτων σε πραγματικό χρόνο[Επεξεργασία|επεξεργασία κώδικα]Αν και η συλλογή απορριμμάτων είναι γενικά μη ντετερμινιστική, μπορεί να χρησιμοποιηθεί σε συστήματα αυστηρά πραγματικού χρόνου (hard real-time). Ένας συλλέκτης πραγματικού χρόνου μπορεί να εγγυηθεί ότι, στη χειρότερη περίπτωση, θα παραχωρήσει έναν συγκεκριμένο αριθμό υπολογιστικών πόρων στο τμήμα του προγράμματος που χρειάζεται τη μνήμη. Οι περιορισμοί που ακολουθεί ένας συλλέκτης πραγματικού χρόνου βασίζονται συνήθως είτε στον φόρτο εργασίας (work based), είτε στον χρόνο (time based). Ένας περιορισμός στον χρόνο θα μπορούσε να είναι ο εξής: σε κάθε χρονικό παράθυρο διάρκειαςT, το πρόγραμμα θα πρέπει να εκτελείται τουλάχιστον για χρόνοTm. Στην περίπτωση της ανάλυσης του φόρτου εργασίας, χρησιμοποιείται συνήθως το μέγεθος MMU (minimal mutator utilization).[5]Μια από τις πρώτες υλοποιήσεις συλλογής απορριμμάτων πραγματικού χρόνου για τηνJVMαφορούσε τον αλγόριθμο Metronome.[6]Υπάρχουν επίσης άλλες εμπορικές υλοποιήσεις.[7]Καταμέτρηση αναφορών[Επεξεργασία|επεξεργασία κώδικα]Η καταμέτρηση αναφορών είναι μια μορφή συλλογής απορριμμάτων όπου κάθε αντικείμενο διατηρεί τον αριθμό των αντικειμένων που έχουν αναφορές προς αυτό. Τα απορρίμματα είναι όσα αντικείμενα έχουν μηδέν αναφορές. Ο μετρητής ενός αντικειμένου αυξάνεται όταν δημιουργείται μια αναφορά προς αυτό και μειώνεται όταν μια τέτοια αναφορά καταστρέφεται. Η μνήμη που καταλαμβάνει το αντικείμενο απελευθερώνεται όταν ο μετρητής φτάσει το μηδέν.Η καταμέτρηση αναφορών έχει δύο σημαντικά μειονεκτήματα:Αν δύο ή περισσότερα αντικείμενα δείχνουν το ένα στο άλλο, μπορεί να δημιουργείται κύκλος, στον οποίο κανένας μετρητής δεν πρόκειται να φτάσει το μηδέν και η μνήμη κανενός αντικειμένου δεν πρόκειται να απελευθερωθεί. Κάποια συστήματα συλλογής απορριμμάτων με καταμέτρηση αναφορών (όπως αυτό τηςCPython) χρησιμοποιούν ειδικούς αλγόριθμους εντοπισμού κύκλων για να αντιμετωπίσουν αυτό το πρόβλημα.[8]Μια άλλη στρατηγική είναι η χρήση ασθενών αναφορών (weak references) για τους δείκτες προς τα πίσω, οι οποίοι δημιουργούν τους κύκλους. Στην καταμέτρηση αναφορών, μια ασθενής αναφορά λειτουργεί όπως μια ασθενής αναφορά σε έναν ανιχνευτικό συλλέκτη απορριμμάτων. Είναι ένα ιδιαίτερο αντικείμενο-αναφορά, η ύπαρξη του οποίου δεν αυξάνει τον μετρητή αναφορών ενός αντικειμένου που δείχνει σε αυτό. Επιπλέον μια ασθενής αναφορά είναι ασθενής με την έννοια ότι όταν το αντικείμενο που αναφέρεται σε αυτήν γίνεται απόρριμμα, κάθε ασθενής αναφορά σε αυτό λήγει (lapses) αντί να μείνει αιωρούμενη, παίρνει δηλαδή κάποια προβλεπόμενη τιμή, όπως η κενή αναφορά (null).Στις απλές υλοποιήσεις, κάθε ανάθεση σε αναφορά και κάθε αναφορά που βγαίνει εκτός εμβέλειας, έχουν ως αποτέλεσμα την αλλαγή ενός ή περισσότερων μετρητών αναφορών. Στην πιο συνηθισμένη περίπτωση όμως, όταν μια αναφορά αντιγράφεται από μια μεταβλητή της εξωτερικής εμβέλειας σε μια μεταβλητή εσωτερικής εμβέλειας, τέτοια ώστε ο χρόνος ζωής της εσωτερικής μεταβλητής να περιλαμβάνεται στον χρόνο ζωής της εξωτερικής, δεν χρειάζεται η αλλαγή στους μετρητές. Η εξωτερική μεταβλητή «έχει» την αναφορά. Στην γλώσσα προγραμματισμού C++, η τεχνική αυτή υλοποιείται με τις αναφορέςconst. Η καταμέτρηση αναφορών στη C++ συνήθως υλοποιείται με τη χρήση «έξυπνων δεικτών» (\"smart pointers\"), που έχουν συναρτήσεις κατασκευής (constructors), καταστροφής (destructors) και ανάθεσης που χειρίζονται τις αναφορές. Ένας έξυπνος δείκτης μπορεί να περαστεί με αναφορά σε μια συνάρτηση, έτσι ώστε να μην χρειαστεί να κατασκευαστεί μια νέα αναφορά με αντιγραφή (που θα αύξανε τον μετρητή αναφορών κατά την είσοδο στη συνάρτηση και θα τον μείωνε κατά την έξοδο). Αντίθετα, η συνάρτηση δέχεται μια αναφορά στον έξυπνο δείκτη, την οποία τη δημιουργεί με μικρό κόστος.Οι αλλαγές αυτές (αύξηση και μείωση κατά ένα), όταν χρησιμοποιούνται σεπολυνηματικόπεριβάλλον, πρέπει να είναι ατομικές λειτουργίες, όπως ηcompare-and-swap, όταν εμπλέκουν αντικείμενα που μπορεί να μοιράζονται ανάμεσα σε διαφορετικά νήματα. Οι ατομικές λειτουργίες έχουν κόστος στους πολυεπεξεργαστές και είναι ακόμα πιο δαπανηρές, όταν πρέπει να προσομοιωθούν από αλγόριθμους σε λογισμικό. Υπάρχουν τρόποι να βελτιωθεί αυτή η κατάσταση, όπως η χρήση αναφορών σε δύο επίπεδα, με πολλαπλούς μετρητές.Θεωρείται συχνά λανθασμένα ότι η καταμέτρηση αναφορών έχει ντετερμινιστική συμπεριφορά όσον αφορά το χρόνο εκτέλεσής του, σε σχέση με την ανιχνευτική συλλογή απορριμμάτων. Η καταμέτρηση αναφορών παρέχει ημι-ντετερμινιστική αποδοτικότητα όσον αφορά την αποδέσμευση σε περιπτώσεις που τα αντικείμενα προφανώς ζουν λίγο (στις ίδιες συνθήκες που και οι τεχνικές γενεαλογικής συλλογής απορριμμάτων έχουν ημι-ντετερμινιστική συμπεριφορά). Στην γενική περίπτωση, όταν μειώνεται ο μετρητής της αναφοράς ενός αντικειμένου, δεν μπορεί να μετρηθεί πόσος χρόνος θα χρειαστεί για αυτό από τον επεξεργαστή. Κάθε φορά που ένας μετρητής γίνεται μηδέν, και άρα το αντίστοιχο αντικείμενο γίνεται απόρριμμα, πρέπει να μειωθούν και όλοι οι μετρητές των αντικειμένων που ανήκουν στο αντικείμενο. Κάποιοι από αυτούς τους μετρητές μπορούν επίσης να γίνουν μηδέν, επαναλαμβάνοντας αυτήν τη διαδικασία, με αποτέλεσμα η καταμέτρηση αναφορών στην γενική περίπτωση να έχει μη ντετερμινιστικές παύσεις.Escape analysis[Επεξεργασία|επεξεργασία κώδικα]Η ανάλυση διαφυγής (escape analysis) μπορεί να χρησιμοποιηθεί για να μετατρέψει τη δέσμευση χώρου στον σωρό σε δέσμευση στη στοίβα, μειώνοντας το έργο του συλλέκτη απορριμμάτων.Συλλογή απορριμμάτων κατά τη μεταγλώττιση[Επεξεργασία|επεξεργασία κώδικα]Η συλλογή απορριμμάτων κατά τη μεταγλώττιση (compile-time garbage collection) είναι μια μορφήστατικής ανάλυσηςπου επιτρέπει στη μνήμη να επαναχρησιμοποιείται και να απελευθερώνεται με βάση αναλλοίωτες συνθήκες που είναι γνωστές από τη φάση της μεταγλώττισης. Αυτή η μορφή συλλογής απορριμμάτων μελετήθηκε στηγλώσσα προγραμματισμού Mercury.[9]Διαθεσιμότητα[Επεξεργασία|επεξεργασία κώδικα]Οιγλώσσες προγραμματισμού υψηλού επιπέδουείναι πιο πιθανό να έχουν σαν βασικό χαρακτηριστικό τη συλλογή απορριμμάτων. Οι γλώσσες που δεν περιλαμβάνουν συλλογή απορριμμάτων, μπορούν να την αποκτήσουν με τη βοήθεια εξωτερικών βιβλιοθηκών (όπως ο συλλέκτης απορριμμάτων του Boehm για τη C και τη C++). Αυτό δεν είναι πάντα χωρίς προβλήματα, αφού αλλάζουν οι μηχανισμοί δημιουργίας και καταστροφής των αντικειμένων.Οι περισσότερεςσυναρτησιακές γλώσσες προγραμματισμού, όπως ηML, ηHaskellκαι ηAPL, περιλαμβάνουν συλλογή απορριμμάτων. Ο ίδιος ο μηχανισμός εμφανίστηκε για πρώτη φορά στηLisp, η οποία και εισήγαγε τονσυναρτησιακό προγραμματισμό.Άλλες δυναμικές γλώσσες, όπως ηRuby(αλλά όχι ηPerl5, ή ηPHP, που χρησιμοποιούν καταμέτρηση αναφορών), τείνουν επίσης να χρησιμοποιούν συλλογή απορριμμάτων. Οιαντικειμενοστρεφείς γλώσσεςόπως ηSmalltalk, ηJavaκαι ηECMAScriptσυχνά ενσωματώνουν συλλογή απορριμμάτων. Εξαιρέσεις αποτελούν ηC++και ηDelphi, οι οποίες έχουν συναρτήσεις καταστροφής (destructors). ΗObjective-Cστο παρελθόν δεν είχε συλλογή απορριμμάτων, αλλά η ObjC 2.0 που υλοποιήθηκε από την Apple για τοMac OS Xχρησιμοποιεί έναν δικό της συλλέκτη στο χρόνο εκτέλεσης, ενώ το εγχείρημαGNUstepχρησιμοποιεί έναν συλλέκτη Boehm.Ιστορικά, οι γλώσσες που απευθύνονταν σε αρχάριους, όπως ηBASICκαι ηLogo, συχνά χρησιμοποιούσαν συλλογή απορριμμάτων για τύπους δεδομένων μεταβλητού μήκους που αποθηκεύονταν στον σωρό, όπως οι συμβολοσειρές και οι λίστες, ώστε να μην δυσκολεύουν τον προγραμματιστή με λεπτομέρειες διαχείρισης μνήμης. Στους πρώτους μικροϋπολογιστές, που είχαν μικρές μνήμες και αργούς επεξεργαστές, η συλλογή απορριμμάτων της BASIC συχνά προκαλούσε τυχαίες και (για τον χρήστη) ανεξήγητες παύσεις κατά την εκτέλεση του προγράμματος. Κάποιοιδιερμηνείςτης BASIC όπως ο Applesoft BASIC της οικογένειας τωνApple II, είχαν πολύ αργούς συλλέκτες απορριμμάτων για τις συμβολοσειρές, που σάρωναν συνέχεια τις συμβολοσειρές για να τοποθετήσουν αυτές με την υψηλότερη διεύθυνση, στις υψηλότερες θέσεις μνήμης (high memory). Αυτή η επανάληψη για μια συμβολοσειρά κάθε φορά είχα σαν αποτέλεσμαπολυπλοκότητα χρόνουO(N*N) όσον αφορά τον αριθμό των συμβολοσειρών, που μπορούσε να διακόψει προσωρινά την εκτέλεση προγραμμάτων που έκαναν συχνή χρήση συμβολοσειρών, ακόμα και για ένα λεπτό. Ένας άλλος συλλέκτης απορριμμάτων για την Applesoft BASIC που δημοσιεύτηκε στο Call-A.P.P.L.E. (Ιανουάριος 1981, σελ. 40–45, Randy Wiggington) έβρισκε μια ομάδα συμβολοσειρών σε κάθε πέρασμα στον σωρό, με αποτέλεσμα μια παύση των δύο λεπτών να γίνεται ενός δευτερολέπτου, ανάλογα και με το μέγεθος της ομάδας. Δημοσιεύτηκαν και άλλες προσεγγίσεις, αλλά καμία δεν έφτασε να μπει σε κάποια νεότερη έκδοση του διερμηνέα της BASIC.Περιορισμένα περιβάλλοντα[Επεξεργασία|επεξεργασία κώδικα]Η συλλογή απορριμμάτων σπάνια χρησιμοποιείται σεενσωματωμένα συστήματαή σε συστήματα πραγματικού χρόνου, όπου απαιτείται πολύ αυστηρός έλεγχος της χρήσης των περιορισμένων διαθέσιμων πόρων. Παρόλα αυτά, έχουν αναπτυχθεί συλλέκτες για τέτοια περιορισμένα περιβάλλοντα.[10]Το.NET Micro FrameworkτηςMicrosoftκαι ηJava Platform, Micro Editionείναι ενσωματωμένες πλατφόρμες λογισμικού, οι οποίες, όπως και οι μεγαλύτερες εκδόσεις τους, περιλαμβάνουν συλλογή απορριμμάτων.Παραπομπές[Επεξεργασία|επεξεργασία κώδικα]↑«Recursive functions of symbolic expressions and their computation by machine». Portal.acm.org. Ανακτήθηκε στις 29 Μαρτίου 2009.↑«Recursive functions of symbolic expressions and their computation by machine, Part I». Αρχειοθετήθηκεαπό το πρωτότυποστις 4 Οκτωβρίου 2013. Ανακτήθηκε στις 29 Μαΐου 2009.↑«Copying and Pinning». Msdn2.microsoft.com. Ανακτήθηκε στις 9 Ιουλίου 2010.↑«Memory allocation in embedded systems». Eros-os.org. Αρχειοθετήθηκεαπό το πρωτότυποστις 6 Μαρτίου 2012. Ανακτήθηκε στις 29 Μαρτίου 2009.↑«A parallel, real-time garbage collector».ACM SIGPLAN Notices36.5:  125–136. 22.doi:378795.378823.http://dl.acm.org/citation.cfm?doid=378795.378823.↑«The Metronome: A Simpler Approach to Garbage Collection in Real-Time Systems»(PDF).↑«Real-time Java, Part 4: Real-time garbage collection».↑«Reference Counts».Extending and Embedding the Python Interpreter. 21 Φεβρουαρίου 2008. Αρχειοθετήθηκεαπό το πρωτότυποστις 23 Οκτωβρίου 2008. Ανακτήθηκε στις 13 Νοεμβρίου 2008.While Python uses the traditional reference counting implementation, it also offers a cycle detector that works to detect reference cycles.↑«Compile-time garbage collection for the declarative language Mercury». Αρχειοθετήθηκεαπό το πρωτότυποστις 18 Ιουλίου 2008. Ανακτήθηκε στις 14 Μαρτίου 2012.↑«Wei Fu and Carl Hauser, \"A Real-Time Garbage Collection Framework for Embedded Systems\". ACM SCOPES '05, 2005». Portal.acm.org. Ανακτήθηκε στις 9 Ιουλίου 2010.Βιβλιογραφία[Επεξεργασία|επεξεργασία κώδικα]Jones, Richard· Hosking, Antony· Moss, Eliot (19 Αυγούστου 2011).The Garbage Collection Handbook: The Art of Automatic Memory Management. CRC Applied Algorithms and Data Structures Series. Chapman and Hall/CRC.ISBN1420082795.Jones, Richard· Lins, Rafael D. (1996).Garbage Collection: Algorithms for Automatic Dynamic Memory Management. Wiley.ISBN0471941484.Wilson, Paul R. (1992).«Uniprocessor Garbage Collection Techniques».IWMM '92 Proceedings of the International Workshop on Memory Management(Springer-Verlag).http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.2438.Εξωτερικοί σύνδεσμοι[Επεξεργασία|επεξεργασία κώδικα]Τεχνικές Συλλογής απορριμμάτων στη Διαχείριση ΜνήμηςThe Garbage Collection Handbook: The Art of Automatic Memory Management(Αγγλικά)Richard Jones' Garbage Collection Page,University of Kent(Αγγλικά)The Memory Management Reference(Αγγλικά)The Very Basics of Garbage Collection, by Thomas Padron-McCarthy(Αγγλικά)Publications by the OOPS group,University of Texas at Austin(Αγγλικά)A garbage collector for C and C++byHans Boehm(Αγγλικά)Expensive Explicit Deallocation: An Exampleby Hans Boehm(Αγγλικά)On-the-fly garbage collection: an exercise in cooperationbyEdsger W. DijkstraandLeslie Lamportand A.J.Martin and C.S.Scholten and E.F.M.Steffens(Αγγλικά)A Garbage Collection Course Curriculum at MSDN Academic Alliance(Αγγλικά)A Glance at Garbage Collection in Object-Oriented Languages(Αγγλικά)Notes on the CLR Garbage Collector[νεκρός σύνδεσμος](Αγγλικά)Understanding GC pauses in HotSpot JVM(Αγγλικά)ΥλοποιήσειςA Real-Time Garbage Collector Based on the Lifetimes of Objectsby H. Lieberman and C. Hewitt, MIT Artificial Intelligence Laboratory(Αγγλικά)TinyGC - an independent implementation of the BoehmGC API(Αγγλικά)Conservative Garbage Collection Implementation for C Languageby Yasin Hınıslıoğlu(Αγγλικά)MeixnerGC - an incremental mark and sweep garbage collector for C++ using smart pointers(Αγγλικά)"
    },
    {
        "url": "https://el.wikipedia.org/wiki/%CE%9F%CE%BB%CE%BB%CE%B1%CE%BD%CE%B4%CE%AF%CE%B1",
        "title": "Ολλανδία",
        "content": "Συντεταγμένες:52°19′N5°33′E﻿ / ﻿52.317°N 5.550°E﻿ /52.317; 5.550Κάτω ΧώρεςNederlandΣημαίαΕθνόσημοΕθνικό σύνθημα:\"Je maintiendrai\" (Γαλλικά)\"Ik zal handhaven\" (Ολλανδικά)(Θα μείνω ανυποχώρητος)Εθνικός ύμνος:Het Wilhelmus(Γουλιέλμος του Νασσάου)Τοποθεσία της χώρας στον κόσμοΗ θέση της Ολλανδίας (σκούρο πράσινο)-στηνΕυρωπαϊκή ήπειρο(πράσινο και σκούρο γκρι)-στηνΕυρωπαϊκή Ένωση(πράσινο)Πρωτεύουσακαι μεγαλύτερη πόληΆμστερνταμ152°21′N04°52′E﻿ / ﻿52.350°N 4.867°E﻿ /52.350; 4.867﻿ (Άμστερνταμ)Επίσημες γλώσσεςΟλλανδικάΚυρίαρχο κράτοςΒασίλειο των Κάτω ΧωρώνΠολίτευμαΒασιλευόμενη Κοινοβουλευτική ΔημοκρατίαΒασιλιάςΠρωθυπουργόςΓουλιέλμος-ΑλέξανδροςΝτικ ΣχόοφΑνεξαρτησία• Κηρύχθηκε• ΑναγνωρίστηκεΙσχύονΣύνταγμαΟγδοηκονταετής Πόλεμος(από τηνΙσπανία)26 Ιουλίου 158130 Ιανουαρίου 16481815 (αναθεωρήθηκε πολλές φορές, με τελευταία το 2002)Έκταση• Σύνολο• %Νερό•ΣύνοραΑκτογραμμή41.543km2(133η)18,411.027 km451 kmΠληθυσμός• Εκτίμηση 7-2024• Απογραφή 2011•Πυκνότητα17.981.933[1](70η)16.655.799[2]432,9 κατ./km2(31η)ΑΕΠ(ΙΑΔ)• Ολικό(2016)• Κατά κεφαλή869,365 δισ. $[3]51.049 $[3]ΑΕΠ(ονομαστικό)• Ολικό(2016)• Κατά κεφαλή771,163 δισ. $[3]45.282 $[3]ΔΑΑ(2021)0,941[4](10η) –πολύ υψηλόςΝόμισμαΕυρώ2(€ EUR)Ζώνη ώρας•Θερινή ώραCET(UTC+1)(UTC+2)ISO 3166-1NLInternet TLD.nlκαι.euως μέλος τηςΕΕΟδηγούν σταδεξιάΚωδικός κλήσης+311Έδρα της κυβέρνησης ηΧάγη.2Πριν το2001:ΦιορίνιήΓκίλντερ.ΗΟλλανδία(ολλανδικά:Nederland‎‎,προφέρεται:[ˈneːdərˌlɑnt]), επίσημαΚάτω Χώρες, είναι το ευρωπαϊκό τμήμα τουΒασιλείου των Κάτω Χωρών(ολλανδικά:Koninkrijk der Nederlanden‎‎). Είναι πυκνοκατοικημένη χώρα που βρίσκεται στηΔυτική Ευρώπη, με τρεις μικρές νησιωτικές περιοχές στηνΚαραϊβική.[σμ 1]Το 2024, είχε συνολικό πληθυσμό 17.981.933 κατοίκους,[1]σύμφωνα με επίσημη εκτίμηση.Η ευρέως διαδεδομένη ονομασία (Ολλανδία) προέκυψε από την περιοχή τηςΟλλανδίας, στην οποία περικλείονται δύο μόνο από τις δώδεκα επαρχίες του κράτους των Κάτω Χωρών. Η χώρα περιβάλλεται από τηΒόρεια Θάλασσα, τοΒέλγιοκαι τηΓερμανία.Η χώρα, που αποκαλείται στα ολλανδικάNederlandκαι κυριολεκτικά σημαίνειΚάτω Χώρες, επηρεάζεται από το γεγονός ότι περίπου το 1/4 της χώρας βρίσκεται κάτω από τη στάθμη της θάλασσας, με μόνο το 50% της γης να υπερβαίνει το ένα μέτρο πάνω από την επιφάνεια της θάλασσας.[5]Οι περισσότερες από τις περιοχές που βρίσκονται κάτω από το επίπεδο της θάλασσας είναι τεχνητές, ενώ 3.000 χιλιόμετρα φραγμάτων προστατεύουν τη χώρα. Από τα τέλη του 16ου αιώνα, μεγάλες περιοχές (πόλντερ) έχουν ανακτηθεί από τη θάλασσα και τις λίμνες, ενώ ανέρχονται σχεδόν στο 17% της τρέχουσας μάζας γης της χώρας. Μεπυκνότητα πληθυσμούπερί τους 510 κατοίκους ανά τετραγωνικό χιλιόμετρο (Ιούλιος 2016), χωρίς να περιλαμβάνονται οι περιοχές με νερό, η Ολλανδία είναι μια πολύ πυκνοκατοικημένη χώρα. Μόνο τοΜπανγκλαντές, ηΝότια Κορέακαι ηΤαϊβάνέχουν μεγαλύτερο πληθυσμό και υψηλότερη πυκνότητα πληθυσμού. Παρ' όλα αυτά, η Ολλανδία είναι ο δεύτερος μεγαλύτερος εξαγωγέας τροφίμων και γεωργικών προϊόντων στον κόσμο, μετά τις Ηνωμένες Πολιτείες.[6][7]Αυτό οφείλεται εν μέρει στη γονιμότητα του εδάφους και στο ήπιο κλίμα.Η Ολλανδία είναι η τρίτη αρχαιότερη χώρα στον κόσμο που έχει εκλεγμένο κοινοβούλιο, ενώ από το 1848 κυβερνάται ωςΒασιλευομένη Κοινοβουλευτική Δημοκρατία, οργανωμένη ωςενιαίο κράτος. Η Ολλανδία έχει μακρά ιστορία όσον αφορά την κοινωνική ανοχή και θεωρείται γενικά ως μια φιλελεύθερη χώρα, αφού νομιμοποίησε την άμβλωση, την πορνεία και την ευθανασία, διατηρώντας παράλληλα μια προοδευτική πολιτική για τα ναρκωτικά. Το 2001, έγινε η πρώτη χώρα στον κόσμο που νομιμοποίησε τον γάμο ατόμων του ίδιου φύλου.Ιστορία[Επεξεργασία|επεξεργασία κώδικα]Αψβουργικές Κάτω Χώρες (1519 - 1581)[Επεξεργασία|επεξεργασία κώδικα]Η καθημερινή ζωή κατά τη «χρυσή εποχή» της ΟλλανδίαςΟι ανεμόμυλοιΚίντερνταϊκΗ ευρύτερη περιοχή της σημερινής Ολλανδίας, μαζί με το σημερινόΒέλγιο, τοΛουξεμβούργοκαι όμορα εδάφη, αναφέρεται ως μέρος τωνΔεκαεπτά Επαρχιών των Κάτω Χωρών, κατά τη βασιλεία τουΚαρόλου του Ε΄,Άγιου Ρωμαίου Αυτοκράτορακαι βασιλιά τηςΙσπανίαςκατά τον 16ο αιώνα. Το1568είναι η αρχή τουογδοηκονταετούς πολέμουμεταξύ των επαρχιών αυτών και της Ισπανίας για τα κυριαρχικά δικαιώματα σε αυτές. Το1579, το βόρειο τμήμα των δεκαεπτά επαρχιών σχημάτισε τηνΈνωση της Ουτρέχτης, η οποία ουσιαστικά αποτέλεσε μία συμφωνία αλληλοϋποστήριξης μεταξύ τους στην άμυνα απέναντι στον ισπανικό στρατό. Η Ένωση τηςΟυτρέχτηςαναφέρεται και ως το πρώτο ιστορικό σημείο εμφάνισης των Κάτω Χωρών ως ξεχωριστή θεσμική οντότητα. Το1581οι βόρειες επαρχίες υιοθέτησαν τηΔήλωση της Άρνησης, με την οποία διακήρυξαν την ανεξαρτησία τους και αποκήρυξαν τονΦίλιππο τον Β΄της Ισπανίας. Ο αγώνας των Ολλανδών ενάντια στους Ισπανούς επηρέασε τη βασίλισσαΕλισάβετ η Α΄τηςΑγγλίας, η οποία το1585υπέγραψε συνθήκη μαζί τους με την υπόσχεση αποστολής στρατού για την υποστήριξή τους στον πόλεμο για την ανεξαρτησία τους. Τον Δεκέμβριο του ίδιου έτους, σχεδόν 7.500 στρατιώτες έφτασαν στην Ολλανδία από την Αγγλία κάτω από τις διαταγές τουΡόμπερτ Ντάντλεϊ, πρώτου κόμη τουΛέστερ. Ο αγγλικός στρατός όμως αναλώθηκε σε ανώφελες εκστρατείες στην ευρύτερη περιοχή, χωρίς να έχει κάποιο ουσιαστικό αντίκτυπο στην ολλανδική εξέγερση. Ο Ντάντλεϊ επέστρεψε το1586στην Ολλανδία με στρατό, αλλά ούτε και τότε συνεισέφερε σε κάποιο σημαντικό αποτέλεσμα. ΟΦίλιππος ο Β΄ της Ισπανίας, γιος του Καρόλου του Ε΄, δεν ήταν διατεθειμένος να παραδώσει τις Κάτω Χώρες και ο πόλεμος συνεχίστηκε μέχρι και το1648, όταν ο βασιλιάςΦίλιππος ο Δ΄τελικά αναγνώρισε την ανεξαρτησία των επτά βορειοδυτικών επαρχιών της περιοχής με τη συνθήκη ειρήνης τουΜίνστερ. Τμήματα των νότιων επαρχιών παρέμειναν στην κατοχή των Ολλανδών και έτσι αποτέλεσαν και αυτά μέρος του νέου ανεξάρτητου κράτους.Ολλανδική Δημοκρατία (1581–1795)[Επεξεργασία|επεξεργασία κώδικα]Μετά την ανακήρυξη της ανεξαρτησίας τους οι επαρχίες Ολλανδία,Ζηλανδία,Χρόνινγκεν,Φρίσλαντ,Ουτρέχτη,ΟφεράισσελκαιΧέλντερλαντσχημάτισαν μία συνομοσπονδία γνωστή ως ηΔημοκρατία των Επτά Ενωμένων Κάτω Χωρών. Όλες οι επαρχίες παρέμειναν αυτόνομες και είχαν τη δική τους κυβέρνηση, την πολιτεία της επαρχίας, όπως έμεινε γνωστή. Η κυβέρνηση της συνομοσπονδίας και οι ύπατοι κυβερνήτες των επαρχιών είχαν έδρα τηΧάγη, ενώ αποτελούνταν από αντιπροσώπους των μελών της συνομοσπονδίας. Η αραιοκατοικημένη περιοχήΝτρέντεήταν μέρος της δημοκρατίας, αν και δεν θεωρούνταν επαρχία. Η Ντρέντε είχε τους δικούς τους αξιωματούχους, αλλά ο κυβερνήτης της διορίζονταν από τους ύπατους κυβερνήτες. Παράλληλα, η δημοκρατία κατείχε και ορισμένες περιοχές εκτός των παραδοσιακών συνόρων των επαρχιών, γνωστές ως Γενικές Εκτάσεις, οι οποίες διοικούταν απευθείας από τους ύπατους κυβερνήτες, χωρίς δικούς τους αντιπροσώπους ή εξουσία. Η πλειοψηφία των περιοχών αυτών είχε καταληφθεί από τους Ολλανδούς κατά τη διάρκεια του ογδοηκονταετούς πολέμου και κατοικούνταν κυρίως από καθολικούς. Οι περιοχές αυτές αποτελούσαν μια ουδέτερη ζώνη ανάμεσα στη δημοκρατία και τις νότιες Κάτω Χώρες.Η ολλανδική αυτοκρατορία αναπτύχθηκε και σταδιακά εξελίχθηκε σε μια από τις μεγαλύτερες ναυτικές και οικονομικές δυνάμεις του 17ου αιώνα. Στην ονομαζόμενη ολλανδική Χρυσή Εποχή ιδρύθηκαν αποικίες και εμπορικοί σταθμοί σε όλο τον κόσμο. Η εγκατάσταση των Ολλανδών στη βόρεια Αμερική ξεκίνησε με την ίδρυση του οικισμούΝέο Άμστερνταμστο νότιο άκρο τουΜανχάταντο1614. Οι Ολλανδοί ίδρυσαν τηνΑποικία του ΑκρωτηρίουστηΝότια Αφρικήτο1652. Μέχρι το1650ο ολλανδικός στόλος αριθμούσε 16.000 εμπορικά πλοία,[8]ενώ παράλληλα ο πληθυσμός αυξήθηκε σε περίπου 2 εκατομμύρια από 1,5 μέσα στον 17ο αιώνα.Πολλοί ιστορικοί και οικονομολόγοι θεωρούν την Ολλανδία ως την πρώτηκαπιταλιστικήχώρα στην παγκόσμια ιστορία. Στην πρώιμη σύγχρονη Ευρώπη, η Ολλανδία είχε την πιο πλούσια εμπορική πόλη, τοΆμστερνταμ, και το πρώτο πλήρως λειτουργικόχρηματιστήριο. Η εφευρετικότητα τωνεμπόρωνοδήγησε στη θεσμοθέτηση κεφαλαίου ασφάλισης και σύνταξης, καθώς και σε λιγότερο ευχάριστα φαινόμενα, όπως στον φαύλο οικονομικό κύκλο, την πρώτη παγκόσμιαπληθωριστικήφούσκα, τη μανία τηςτουλίπαςμεταξύ 1636 και 1637 και στον πρώτο παγκόσμιο τυχοδιώκτη του χρηματιστηρίου, ο οποίος κατέβαζε τις τιμές των μετοχών πουλώντας για να τις αγοράσει ξανά με χαμηλότερη τιμή. Η δημοκρατία έπεσε σε γενική παρακμή στα τέλη του 18ου αιώνα με τον έντονο οικονομικό ανταγωνισμό από τηνΑγγλίακαι συνεχείς εσωτερικές προστριβές ανάμεσα στις δύο κύριες πολιτικές ομάδες της χώρας, τους ρεπουμπλικάνους και τους βασιλικούς.Τον 17ο αιώνα συνεχίστηκαν οι διαμάχες με την Αγγλία για ανταγωνιστικέςαποικίεςκαι εμπορικούς σταθμούς σε όλο τον κόσμο. Οι Ολλανδοί είχαν ιδρύσει αποικίες φυτειών κατά μήκος των ακτών και των ποταμών τηςΓουιάναςστηΝότια Αμερική, παράλληλα με τους Άγγλους. Μετά από συνεχόμενες διαμάχες, οι δύο χώρες κατέληξαν σε συμφωνία αποχώρησης τωνΆγγλωνκαι παραχώρησης των εκτάσεών τους στους Ολλανδούς, με τη συνθήκη τηςΜπρέντα. Η συμφωνία προέβλεπε την ανταλλαγή των εκτάσεων με την αποικία των Ολλανδών στη βόρεια Αμερική, το Νέο Άμστερνταμ, έναν μικρό εμπορικό σταθμό, ο οποίος μετέπειτα εξελίχθηκε στη σημερινήΝέα Υόρκη.Γαλλική κυριαρχία: 1795–1815[Επεξεργασία|επεξεργασία κώδικα]Στις 19 Ιανουαρίου του 1795, μία ημέρα μετά τη διαφυγή του κυβερνήτηΓουλιέλμου Ε΄της Οράγγης στην Αγγλία, ανακηρύχθηκε ηΔημοκρατία της Μπατάβιαμε στόχο την ένωση των Κάτω Χωρών σε ένα ενιαίο κράτος. Από το 1795 έως και το 1806 με το καθεστώς αυτό η Ολλανδία απέκτησε μία κρατική δομή παρόμοια με αυτή της τότε νεοσύστατηςΗ Πρώτη Γαλλική Δημοκρατίακαι η περίοδος τηςΓαλλικής Δημοκρατίας.Με την άνοδο τουΝαπολέονταστην εξουσία τηςΓαλλίας, στις Κάτω Χώρες καθιερώθηκε το Βασίλειο της Ολλανδίας από το 1806 μέχρι το 1810,υποτελέςστη Γαλλία με βασιλιά τον αδελφό του Ναπολέοντα,Λουδοβίκο Βοναπάρτη, με πλήρη έλεγχο των εξουσιών από τους Γάλλους. Για την ονομασία του βασιλείου αυτού χρησιμοποιήθηκε το όνομα της κύριας επαρχίας, της Ολλανδίας, το οποίο και καθιερώθηκε από τότε και στο εξής ως ταυτόσημο των Κάτω Χωρών. Το Βασίλειο της Ολλανδίας κάλυπτε την έκταση της σημερινής χώρας εκτός από την επαρχία του Λίμπουρχ και τμήματα της επαρχίας Ζέελαντ, τα οποία άνηκαν στη Γαλλία. Το 1807 προστέθηκαν στο βασίλειο η ανατολικήΦρισία, πρότερη κτήση τηςΠρωσίας, και η περιοχή του Γιέβερ. Το 1809 όμως, μετά από μία αποτυχημένηΒρετανικήεισβολή, η Ολλανδία υποχρεώθηκε να παραχωρήσει όλα τα εδάφη της νότια τουΡήνουστη Γαλλία.Χάρτης των επτά Ηνωμένων ΕπαρχιώνΟ βασιλιάς Λουδοβίκος δεν ικανοποίησε τις προσδοκίες του Ναπολέοντα, καθώς υποστήριζε τα τοπικά συμφέροντα περισσότερο από τα γαλλικά, και υποχρεώθηκε σε παραίτηση το 1810. Τον διαδέχθηκε ο πεντάχρονος γιος του, Ναπολέοντας Λουδοβίκος Βοναπάρτης, ο οποίος βασίλεψε ως Λουδοβίκος ο Β΄ για δέκα μόλις ημέρες, αφού οΝαπολέονταςδεν αναγνώρισε την εξουσία του στον θρόνο και κατέλαβε άμεσα την Ολλανδία, καταλύοντας το βασίλειο. Έτσι, οι Κάτω Χώρες έγιναν τμήμα τηςΓαλλικής Αυτοκρατορίας, στην οποία και παρέμειναν έως και το 1813, όταν, μετά την ήττα του στημάχη της Λειψίας, ο Ναπολέοντας υποχρεώθηκε να αποσύρει τα στρατεύματά του από τη χώρα.Ηνωμένο Βασίλειο των Κάτω Χωρών[Επεξεργασία|επεξεργασία κώδικα]Χάρτης που απεικονίζει την παλαιά Ολλανδική Αυτοκρατορία, τον 18ο αιώνα.Ο Γουλιέλμος ο Α΄ των Κάτω Χωρών, γιος του τελευταίου κυβερνήτη Γουλιέλμου του Ε΄ της Οράγγης, επέστρεψε στην Ολλανδία το 1813 και ανακηρύχθηκε ισόβιος πρίγκιπας των Κάτω Χωρών, ενώ το 1815 ο τίτλος του εξελίχθηκε σε Βασιλιάς των Κάτω Χωρών.ΤοΣυνέδριο της Βιέννηςτο 1815 εγκαθίδρυσε τοΗνωμένο Βασίλειο των Κάτω Χωρώνμε την επέκταση της επικράτειάς του στο Βέλγιο, ώστε να δημιουργήσει μία ισχυρή κρατική οντότητα στα βόρεια σύνορα της Γαλλίας. Παράλληλα, ο Γουλιέλμος έγινε κληρονόμος του τίτλου του Μεγάλου Δούκα του Λουξεμβούργου. Έτσι, το Λουξεμβούργο παραχωρήθηκε στον Γουλιέλμο ως προσωπική ιδιοκτησία σε ανταλλαγή με τις κτήσεις του στη Γερμανία, δηλαδή στο Νασσάου-Ντίλενμπουργκ, το Ζίγκεν, το Χανταμάρ και το Ντιτς.Το 1830 το Βέλγιο επαναστάτησε και τελικά κέρδισε την ανεξαρτησία του, ενώ η προσωπική ένωση μεταξύ του Λουξεμβούργου και των Κάτω Χωρών καταλύθηκε το 1890, όταν ο βασιλιάς Γουλιέλμος ο Γ΄ των Κάτω Χωρών απεβίωσε χωρίς να αφήσει πίσω του άρρενες κληρονόμους. Οι νόμοι της διαδοχής απαγόρευαν στην κόρη του Βασίλισσα Βιλελμίνα να πάρει τον τίτλο της Μεγάλης Δούκισσας, με συνέπεια ο θρόνος του Λουξεμβούργου να μεταφερθεί από τον οίκο Οράγγης-Νασσάου στον κλάδο Νασσάου-Βάιλμπουργκ, θυγατρικό τουΟίκου του Νασσάου.Η μεγαλύτερη ολλανδική αποικία εκείνη την περίοδο στο εξωτερικό ήταν η Αποικία του Ακρωτηρίου, η οποία είχε ιδρυθεί από τον Γιαν βαν Ρίμπεκ για λογαριασμό της Ολλανδικής Εταιρίας των Ανατολικών Ινδιών το 1652 στην Πόλη του Ακρωτηρίου. Ο Πρίγκηπας του Οράνιε συναίνεσε στην κατάληψη και έλεγχο της αποικίας από τους Βρετανούς το 1788. Η Ολλανδία είχε και άλλες αποικίες, αλλά το Ακρωτήριο ήταν η πολυπληθέστερη, με τις Ολλανδικές Ανατολικές Ινδίες (σημερινή Ινδονησία) και το Σουρινάμ να ακολουθούν. Αυτές οι αποικίες αρχικά διοικούνταν από τηνΟλλανδική Εταιρεία Ανατολικών Ινδιώνκαι αντίστοιχα την Ολλανδική Εταιρία των Δυτικών Ινδιών, οι οποίες ήταν συλλογικές ιδιωτικές επιχειρήσεις. Τρεις αιώνες αργότερα οι εταιρίες αυτές είχαν οικονομικά προβλήματα και οι περιοχές που διοικούσαν πέρασαν στον έλεγχο της Ολλανδικής κυβέρνησης το 1815 και το 1791 αντίστοιχα. Τότε μόνο έγιναν και τυπικά επίσημα αποικίες.Κατά την περίοδο της αποικιοκρατίας, η Ολλανδία εμπλεκόταν ιδιαίτερα στο εμπόριο σκλάβων. Οι Ολλανδοί άποικοι και ιδιοκτήτες φυτειών βασίζονταν στους αφρικανούς σκλάβους για τις καλλιέργειες καφέ, κακάο, ζαχαροκάλαμου και βαμβακιού κατά μήκος των διαφόρων ποταμών. Η μεταχείριση των σκλάβων ήταν ιδιαίτερα άσχημη και αρκετοί δραπέτευαν. Η δουλεία καταργήθηκε από την Ολλανδία στο Σουρινάμ το 1863, αλλά το σύνολο των σκλάβων δεν απελευθερώθηκε παρά μόνο μέχρι το 1873 μετά από μία υποχρεωτική δεκαετή περίοδο μετάβασης, κατά την οποία δούλευαν στις φυτείες για τον ελάχιστο μισθό και χωρίς βασανιστήρια. Με την επίσημη απελευθέρωση οι περισσότεροι έφυγαν από τις φυτείες και προτίμησαν να εγκατασταθούν στην κύρια πόλη του Σουρινάμ, το Παραμαρίμπο.Κατά τον 19ο αιώνα η Ολλανδία εκβιομηχανίστηκε σχετικά αργά σε σύγκριση με τις γειτονικές της χώρες, κυρίως λόγω της μεγάλης πολυπλοκότητας του εκσυγχρονισμού των υποδομών της, οι οποίες κύρια αποτελούνται από υδάτινες οδούς, αλλά και λόγω του σημαντικού ρόλου της αιολικής ενέργειας στη βιομηχανία της χώρας.Αν και η Ολλανδία παρέμεινε ουδέτερη κατά τον Α΄ Παγκόσμιο Πόλεμο, αναμείχθηκε ιδιαίτερα σε αυτόν. Ο κόμης Σλίφεν αρχικά είχε σχεδιάσει να καταλάβει την Ολλανδία κατά την προέλασή του στη Γαλλία. Το σχέδιο αυτό άλλαξε από τον Χέλμουτ φον Μόλτκε τον νεότερο, ώστε να διατηρηθεί η ολλανδική ουδετερότητα. Αργότερα, αυτή η ουδετερότητα αποδείχθηκε κρίσιμη για την επιβίωση της Γερμανίας μέχρι το εμπάργκο που ολοκληρώθηκε με την εισδοχή των ΗΠΑ και της Μεγάλης Βρετανίας το 1916, και την αδυναμία εισαγωγών από την Ολλανδία στα γερμανικά εδάφη. Παρ'όλα αυτά, οι Ολλανδοί παρέμειναν ουδέτεροι χρησιμοποιώντας τη διπλωματία τους και την ικανότητά τους στο εμπόριο.Β' Παγκόσμιος Πόλεμος[Επεξεργασία|επεξεργασία κώδικα]ΤοΡότερνταμμετά τις αεροπορικές επιδρομές τηςΛούφτβαφετο 1940. Η εκκλησία στο κέντρο είναι ο καθεδρικός ναός του Αγίου ΛαυρεντίουΗ Ολλανδία επιθυμούσε να παραμείνει ουδέτερη κατά τονΒ΄ Παγκόσμιο Πόλεμο, όπως και στο παρελθόν, αλλά τα σχέδια των στρατών του Βελγίου, της Γαλλίας και της Μεγάλης Βρετανίας ήταν διαφορετικά. Χωρίς ενδοιασμούς, ηναζιστική Γερμανίαεισέβαλε στην Ολλανδία λόγω της στρατηγικής της θέσης στις10 Μαΐουτου1940, ως μέρος της εκστρατείας κατά των Συμμάχων. Η επίπεδη διαμόρφωση του εδάφους της χώρας διευκόλυνε την ανάπτυξη των γερμανικών στρατευμάτων και ο ολλανδικός στρατός υπέκυψε σε 4 μέρες, παρά την επίμονη αρχική αντίστασή του. Η κυβέρνηση της χώρας και η βασίλισσα εξορίστηκαν στοΛονδίνο.Κατά τη διάρκεια της γερμανικής κατοχής και υπό τη διοίκηση του στυγνούΆρτουρ Ζάις-Ίνκβαρτ100.000 Ολλανδοί Εβραίοι μεταφέρθηκαν σεστρατόπεδα συγκέντρωσης. Αρκετοί ήταν επίσης οι Ολλανδοί - περίπου 50.000, που κατετάγησαν εθελοντικά στηνΕς Ες.[9]Παρά το κόστος της κατοχής σε ζωές και χρήμα, η Ολλανδία είχε πολύ καλύτερη μεταχείριση από το ναζιστικό καθεστώς σε σχέση με χώρες της Ανατολής, καθώς οι Ολλανδοί θεωρούνταν από τους Γερμανούς «τευτονικός» λαός. Επιπλέον μιας και η Γερμανία δεν είχε αρκετά ισχυρό στόλο για να «σιγουρέψει» τις ολλανδικές αποικίες, όφειλε να φερθεί ήπια ώστε να πείσει τους Ολλανδούς να συνεργαστούν.[10]Έτσι καθ'όλη τη διάρκεια της κατοχής ο προπολεμικός κρατικός μηχανισμός παρέμεινε άθικτος και οι Ολλανδοί ανώτεροι κρατικοί υπάλληλοι διεκπεραίωναν το πραγματικό κομμάτι της διοίκησης, με σχετικά μικρό αριθμό Γερμανών να επιβλέπει τη χώρα.[11]Η χώρα απελευθερώθηκε στις 5 Μαΐου 1945 με την παράδοση των τελευταίων γερμανικών στρατευμάτων στους Συμμάχους. Την ίδια περίοδο στηνΙνδονησία, η οποία είχε τελέσει υπόιαπωνικήκατοχή κατά τη διάρκεια του Β΄ Παγκοσμίου Πολέμου, ξεκινούσε ο αγώνας για την αποτίναξη του ολλανδικού αποικιοκρατικού ζυγού.1945 - σήμερα[Επεξεργασία|επεξεργασία κώδικα]Τις επόμενες δεκαετίες η Ολλανδία παράλληλα με την ανάπτυξη της οικονομίας της προώθησε τη σύσφιξη των σχέσεών της με τις γειτονικές χώρες. Υπήρξε ιδρυτικό μέλος της ένωσηςΜπενελούξ, τουΝΑΤΟκαι τηςΕυρωπαϊκής Κοινότητας Άνθρακα και Χάλυβαπου μετεξελίχθηκε στη σημερινήΕΕ. Το 1975 απέκτησε την ανεξαρτησία του από την Ολλανδία και τοΣουρινάμ. Στις 10 Οκτωβρίου 2010 οι Ολλανδικές Αντίλλες εντάχθηκαν στην ολλανδική επικράτεια.[12]Στις 30 Απριλίου 2013 νέος βασιλιάς έγινε ο Γουλιέλμος Αλέξανδρος, μετά την παραίτηση της μητέρας του Βεατρίκης από τον θρόνο[13].Γεωγραφία και κλίμα[Επεξεργασία|επεξεργασία κώδικα]Κύριο λήμμα:Γεωγραφία της ΟλλανδίαςΟι περιοχές της Ολλανδίας που είναι πάνω από το επίπεδο της θάλασσαςΤο φράγμαΆφσλαουτνταϊκ, αριστερά ηΒόρεια Θάλασσα, δεξιά ηΆισελμεερΗ Ολλανδία έχει έκταση 33.491 τ.χλμ. ξηράς και, αν ληφθεί υπ' όψιν και το 20% της θαλάσσιας έκτασης συνολική επιφάνεια: 41.526τ.χλμ.Η μισή χώρα βρίσκεται λιγότερο από ένα μέτρο πάνω από την επιφάνεια της θάλασσας, ενώ το 1/4 κάτω από το επίπεδο της θάλασσας. Το ψηλότερο σημείο της χώρας είναι τοΦάαλσερμπερχ(Vaalserberg) στα νότια της χώρας, στα σύνορα με τοΒέλγιοκαι τηΓερμανίακαι έχει υψόμετρο μόλις 321 μέτρα. Το χαμηλότερο σημείο της χώρας βρίσκεται στον δήμοΝίουερκερκ αν ντεν Άισελ(ολλανδικά:Nieuwerkerk aan den IJssel‎‎) και βρίσκεται 6,76 μέτρακάτωαπό την επιφάνεια της θάλασσας, αποτελώντας έτσι τοχαμηλότερο σημείο της Ευρώπης. Το τοπίο είναι γενικά πιο λοφώδες στα ανατολικά και νότια της χώρας.Πολλά τμήματα της Ολλανδίας, όπως ολόκληρη η επαρχίαΦλέβολαντ(ολλανδικά:Flevoland‎‎) δεν ήταν πάντα στεριά αλλά θάλασσα που οι Ολλανδοί διεκδίκησαν. Τα μέρη που διεκδικήθηκαν από τη θάλασσα ονομάζονταιΠόλντερ. Το 18,4% της συνολικής έκτασης της Ολλανδίας είναι υδάτινες επιφάνειες. Η λίμνη Άισελμεερ (IJsselmeer) χωρίζεται από τη θάλασσα με το φράγμαΆφσλαουτνταϊκμήκους 29 χιλιομέτρων, το οποίο χτίστηκε το1932. Οι σημαντικότεροι ποταμοί της χώρας είναι οΡήνος, οΜάαςκαι οΣχέλντε. Η Ολλανδία είναι, επί της ουσίας, τοδέλταπου δημιουργούν αυτά τα τρία ευρωπαϊκά ποτάμια. Εκτός από τη γεωγραφική τους σημασία, αυτά τα ποτάμια χωρίζουν τη χώρα -σε γενικές γραμμές- πολιτιστικά και θρησκευτικά σε βόρεια και νότια.Το κλίμα είναιωκεάνιομε δυτικούς ανέμους ως επί το πλείστον. Οι βροχές είναι άφθονες όλο τον χρόνο (εκτός του χειμώνα), ενώ οι θερμοκρασίες είναι σχετικά ήπιες τον χειμώνα και δροσερές το καλοκαίρι. Χιονοπτώσεις συμβαίνουν κυρίως από τις αρχές Δεκεμβρίου έως και τα τέλη Φεβρουαρίου. Βροχές έχει όλο τον υπόλοιπο χρόνο και κυρίως τους καλοκαιρινούς μήνες. Οι θερμοκρασίες κυμαίνονται από -1,-2 έως 4-5 βαθμούς τον χειμώνα και από 11-12 έως 20-22 βαθμούς το καλοκαίρι. Οι διαφορές θερμοκρασίας τόσο κατά το καλοκαίρι όσο και κατά και χειμώνα είναι σχετικά μικρές, και αυτό συμβαίνει διότι τον χειμώνα ένα θερμό ρεύμα, το οποίο έρχεται κάθε χρόνο από τον κόλπο του Μεξικού, επηρεάζει τη θερμοκρασία της θάλασσας, με αποτέλεσμα να μην παγώνει σχεδόν ποτέ. Εάν δεν συνέβαινε αυτό, υπολογίζεται πως το Άμστερνταμ τον χειμώνα θα είχε μέση θερμοκρασία γύρω στους -10 βαθμούς Κελσίου.Δημογραφία[Επεξεργασία|επεξεργασία κώδικα]Ο αριθμός κατοίκων στην Ολλανδία σε χιλιάδες (FAOSTAT 2005)Η Ολλανδία με συνολικό πληθυσμό, σύμφωνα με επίσημη εκτίμηση για το 2024, 17.981.933 κατοίκους,[1]κατατάσσεται στην31η θέσητων χωρών ανάπυκνότητα πληθυσμού, με 432,9 κατοίκους ανά τετραγωνικό χιλιόμετρο (ή 510/τ.χλμ. αν δεν ληφθεί υπ' όψιν το 20% της θαλάσσιας έκτασης). Αποτελεί την πιο πυκνοκατοικημένη χώρα τηςΕυρωπαϊκής Ένωσης. Σύμφωνα με τα επίσημα στοιχεία της στατιστικής υπηρεσίας της χώρας, οι εθνικότητες των κατοίκων ποικίλλουν: το 80,8% του πληθυσμού είναι Ολλανδοί, το 5,6% Ευρωπαίοι (με 2,4%Γερμανούς), το 2,4%Ινδονήσιοι, το 2,2%Τούρκοι, το 2,0% από τοΣουρινάμ, το 1,9%Μαροκινοί, το 0,8% από τις πάλαι ποτέΟλλανδικές Αντίλλεςκαι τηνΑρούμπα, ενώ το 4,2% είναι άλλης εθνικότητας. Η χώρα δεν διαθέτει καμία πόλη με πληθυσμό άνω του ενός εκατομμυρίου, ωστόσο οι τέσσερις μεγαλύτερες πόλεις (Άμστερνταμ,Ρότερνταμ,ΧάγηκαιΟυτρέχτη) καθώς και άλλες περιοχές των περιχώρων, θεωρούνται συχνά ως ένα ενιαίο πολεοδομικό σύμπλεγμα, το οποίο ονομάζεταιΡάντσταντ(Randstad) και περιλαμβάνει περίπου 7 εκατομμύρια κατοίκους.Τοπροσδόκιμο ζωήςστο σύνολο του πληθυσμού, σύμφωνα με εκτιμήσεις του 2019 τουΠαγκόσμιου Οργανισμού Υγείαςήταν 81,8 χρόνια (80,4 χρόνια οι άνδρες και 83,1 οι γυναίκες).[14]Γλώσσες[Επεξεργασία|επεξεργασία κώδικα]Ηεπίσημηκαι πλειοψηφική γλώσσα με 16 εκατομμύρια ομιλητές είναι ταΟλλανδικά, που είναιγερμανική γλώσσα της Δύσηςαπό την ομάδα τωνκάτω Γερμανικών. Επίσημα αναγνωρισμένες τοπικές διάλεκτοι είναι ταΛιμβουργιανά, ταΚάτω-σαξονικάκαι ταΦριζικά, που ομιλούνται στην επαρχίαΦρίσλαντ, και συνδέονται έντονα με ταΟλλανδικάαλλά και ταΑγγλικά. Από τις 10 Οκτωβρίου 2010, μετά την διάλυση τωνΟλλανδικών Αντίλλων, επίσημη γλώσσα αποτελούν και ταΠαπιαμέντο.Στην Ολλανδία ομιλούνται επίσης κυρίως από μετανάστες τα τουρκικά και τα αραβικά από περίπου 192.000 και 100.000 κατοίκους αντίστοιχα, ακολουθούμενα από άλλες γλώσσες.Θρησκείες[Επεξεργασία|επεξεργασία κώδικα]Η Ολλανδία, από παλιά χριστιανική χώρα, είναι σήμερα μία από τις πλέοναγνωστικιστικέςχώρες. Περίπου το 40% των κατοίκων της αυτοπροσδιορίζεται ως ακόλουθος καμίας θρησκείας. Υπάρχουν έτσι πολλοίάθεοι. Το υπόλοιπο 60% του πληθυσμού χωρίζεται περίπου ως εξής:στηΡωμαιοκαθολική Εκκλησία(5 εκατομμύρια μέλη, 31%)στηνΠροτεσταντική Εκκλησίατης Ολλανδίας (2,5 εκατομμύρια μέλη, 21%)στις διάφορες μικρέςΑναμορφωμένες εκκλησίες(συνολικά περίπου 700.000 μέλη)στοΙσλάμ(εκτιμ. 900.000 μέλη, 6,1%)στονΙνδουισμό(εκτιμ. 100.000 μέλη, 1,5%)στονΒουδισμό(εκτιμ. 80.000 μέλη)στονΙουδαϊσμό(εκτιμ. 40.000 μέλη).στουςΜορμόνουςτης Εκκλησίας του Ιησού Χριστού των Αγίων των Τελευταίων Ημερών (9.284 μέλη)[15]Οι καθολικοί βρίσκονται κυρίως στο νότιο τμήμα της χώρας, ενώ οι προτεστάντες στο βόρειο.Εκπαιδευτικό σύστημα[Επεξεργασία|επεξεργασία κώδικα]Δευτεροβάθμια εκπαίδευση[Επεξεργασία|επεξεργασία κώδικα]Η Δευτεροβάθμια εκπαίδευση, η οποία ξεκινά από την ηλικία των 12 ετών, είναι υποχρεωτική μέχρι την ηλικία των 16 ετών και προσφέρεται σε διάφορα επίπεδα. Τα δύο προγράμματα γενικής εκπαίδευσης που οδηγούν στην τριτοβάθμια εκπαίδευση είναι ταHAVO(πέντε χρόνια) καιVWO(έξι έτη). Οι μαθητές εγγράφονται ανάλογα με τις ικανότητές τους, και αν και το VWO είναι πιο αυστηρό, τόσο το HAVO όσο και το VWO χαρακτηρίζονται ως επιλεκτικοί τύποι δευτεροβάθμιας εκπαίδευσης. Το πρόγραμμα σπουδών του VWO προετοιμάζει τους μαθητές για το πανεπιστήμιο και μόνο το δίπλωμα VWO παρέχει πρόσβαση σε WO (ερευνητικά πανεπιστήμια). Το δίπλωμα HAVO είναι η ελάχιστη προϋπόθεση για την εισαγωγή στο HBO (πανεπιστήμια επαγγελματικής εκπαίδευσης). Τα δύο τελευταία χρόνια του ΗΑVO και τα τρία τελευταία χρόνια της VWO αναφέρονται ως δεύτερη φάση («tweede fase»), ή ανώτερη δευτεροβάθμια εκπαίδευση. Κατά τη διάρκεια αυτών των ετών, οι μαθητές επικεντρώνονται σε μία από τις τέσσερις θεματικές δέσμες («profielen»), κάθε μια από τις οποίες εστιάζει σε μια συγκεκριμένη περιοχή μελέτης, επιπρόσθετα της ικανοποίησης των γενικών απαιτήσεων εκπαίδευσης. Κάθε δέσμη έχει σχεδιαστεί για να προετοιμάσει τους μαθητές για τα προγράμματα σπουδών στο τριτοβάθμιο επίπεδο. Ένας μαθητής που εγγράφονται στα VWO ή ΗΑVO μπορεί να επιλέξει από τις παρακάτω θεματικές δέσμες:1) Επιστήμη και Τεχνολογίας («Natuur en Techniek»)2) Επιστήμη και Υγεία («Natuur en Gezondheid»)3) Οικονομικά και Κοινωνία («Economie en Maatschappij»)4) Πολιτισμός και Κοινωνία («Cultuur en Maatschappij»)Ανώτερη και Ανώτατη εκπαίδευση[Επεξεργασία|επεξεργασία κώδικα]Η τριτοβάθμια εκπαίδευση στην Ολλανδία προσφέρεται σε δύο τύπους ιδρυμάτων: ερευνητικά πανεπιστήμια («universiteiten» ή «Wetenschappelijk Onderwijs») και τα πανεπιστήμια επαγγελματικής εκπαίδευσης («Hogescholen» ή «Hoger Beroepsonderwijs»). Τα πρώτα περιλαμβάνουν γενικά πανεπιστήμια και πανεπιστήμια που ειδικεύονται στον τομέα της μηχανικής και της γεωργίας. Τα δεύτερα περιλαμβάνουν γενικά ιδρύματα και ιδρύματα που ειδικεύονται σε ένα συγκεκριμένο τομέα, όπως η γεωργία, καλές τέχνες και τέχνες του θεάματος, ή η κατάρτιση των εκπαιδευτικών.Από τον Σεπτέμβριο του 2002, το σύστημα τριτοβάθμιας εκπαίδευσης στην Ολλανδία έχει οργανωθεί γύρω από ένα σύστημα τριών κύκλων σπουδών που αποτελείται από βασικό Πτυχίο, Μεταπτυχιακό και Διδακτορικό. Την ίδια στιγμή, το πιστωτικό σύστημα ECTS υιοθετήθηκε ως ένας τρόπος ποσοτικοποίησης των περιόδων σπουδών. Ωστόσο, το σύστημα τριτοβάθμιας εκπαίδευσης συνεχίζει να είναι ένα δυαδικό σύστημα με μια διάκριση μεταξύ της εκπαίδευσης με προσανατολισμό στην έρευνα και επαγγελματικής τριτοβάθμιας εκπαίδευσης.\nΤο επίπεδο του προγράμματος σπουδών καθορίζει τόσο τον αριθμό των πιστωτικών μονάδων που απαιτούνται για την ολοκλήρωση του προγράμματος και το πτυχίο που απονέμεται. Ένα WO πρόγραμμα βασικού πτυχίου απαιτεί την ολοκλήρωση 180 πιστωτικών μονάδων (3 χρόνια) και οι απόφοιτοι αποκτούν πτυχίο του Bachelor of Arts ή Bachelor of Science (BA / BSc), ανάλογα με τον κλάδο. Ένα πρόγραμμα βασικού πτυχίου HBO απαιτεί την ολοκλήρωση 240 πιστωτικών μονάδων (4 χρόνια), και οι απόφοιτοι αποκτούν πτυχίο που αναφέρει τον τομέα των σπουδών τους, για παράδειγμα Πτυχίο Μηχανικού (Β Eng.) ή Πτυχίο Νοσηλευτικής (B. Nursing).Τα μεταπτυχιακά προγράμματα WO απαιτούν κυρίως την ολοκλήρωση 60 ή 120 μονάδων (1 ή 2 χρόνια). Ορισμένα προγράμματα απαιτούν 90 (1,5 έτη) ή πάνω από 120 μονάδες. Στη μηχανική, τη γεωργία, και τα μαθηματικά και τις φυσικές επιστήμες, οι 120 μονάδες απαιτούνται πάντοτε. Οι απόφοιτοι αποκτούν το πτυχίο Master of Arts ή Μεταπτυχιακό τίτλο ειδίκευσης (MA / MSc). Τα μεταπτυχιακά προγράμματα HBO απαιτούν την ολοκλήρωση 60 έως 120 μονάδες, και οι απόφοιτοι αποκτούν πτυχίο που δείχνει το πεδίο μελέτης, για παράδειγμα Μεταπτυχιακό Κοινωνικής Εργασίας (MSW).Ο τρίτος κύκλος της τριτοβάθμιας εκπαίδευσης προσφέρεται μόνο από τα ερευνητικά πανεπιστήμια, τα οποία έχουν το δικαίωμα να απονείμουν τον υψηλότερο ακαδημαϊκό τίτλο σπουδών της χώρας, το διδακτορικό, το οποίο επιτρέπει σε ένα πρόσωπο να χρησιμοποιεί τον τίτλου δόκτωρ (Δρ.). Η διαδικασία με την οποία επιτυγχάνεται η εκπόνηση διδακτορικής διατριβής αναφέρεται ως promotie. Το διδακτορικό είναι πρωτίστως ένα ερευνητικό πτυχίο, για το οποίο ο υποψήφιος πρέπει να γράψει και αν υπερασπίσει δημοσίως μια διατριβή βασισμένη σε πρωτότυπη έρευνα.Τέχνες και πολιτισμός[Επεξεργασία|επεξεργασία κώδικα]Η Ολλανδία είναι γνωστή παγκοσμίως για τους ζωγράφους της και τους εν γένει εικαστικούς καλλιτέχνες. Ο οικονομικός πλούτος του 17ου αιώνα γέννησε μια πλειάδα αριστουργηματικών καλλιτεχνών, όπως τονΡέμπραντκαι τονΓιοχάνες Βερμέερ, ενώ η νεότερη εποχή συνδέθηκε με τα ηχηρά ονόματα τουΒίνσεντ βαν Γκογκκαι τουΠητ Μοντριάν. Τα έργα του χαράκτηΜαουρίτς Κορνέλις Έσεραφήνουν ακόμη και σήμερα τα αποτυπώματά τους στα έργα άλλων καλλιτεχνών.Από τον κόσμο των γραμμάτων, τα ονόματαΈρασμοςκαιΣπινόζακατέχουν μια θέση στην παγκόσμια ιστορία, αμφότεροι φιλόσοφοι με έδρα την Ολλανδία. Μεγάλης αξίας είναι και το έργο τουΚαρτέσιου, που πραγματοποιήθηκε ως επί το πλείστον στην Ολλανδία, όπως επίσης και η εφεύρεση του εκκρεμούς ρολογιού από τονΚρίστιαν Χόυχενς.Διακυβέρνηση[Επεξεργασία|επεξεργασία κώδικα]Από το τέλος της Γαλλικής Κατοχής το1815, η Ολλανδία αποτελείΒασιλευόμενη Κοινοβουλευτική Δημοκρατίαμε τον βασιλικό οίκο Οράγγης-Νάσσαου στην εξουσία. Την εκτελεστική εξουσία ασκεί ηολλανδική κυβέρνηση.Αρχηγός κράτους[Επεξεργασία|επεξεργασία κώδικα]Αρχηγός κράτους από το1980ήταν η βασίλισσα Βεατρίκη. Από την 30ή Απριλίου 2013, ημέρα της εορτής της Βασίλισσας (Koninginnedag), ο γιος τηςΓουλιέλμος Αλέξανδρος της Ολλανδίας(Willem-Alexander) είναι ο νέος βασιλιάς της χώρας, ο πρώτος άρρην που καταλαμβάνει το ανώτατο αξίωμα μετά από 120 χρόνια. Νέα εθνική εορτή είναι η ημερομηνία γεννήσεως του Γουλιέλμου-Αλεξάνδρου, 27η Απριλίου (1967), η οποία ονομάζεται \"Ημέρα του Βασιλιά\".[16]Κοινοβούλιο[Επεξεργασία|επεξεργασία κώδικα]ΤοΟλλανδικό Κοινοβούλιοαποτελείται από 2 σώματα. Η εκλογή των 150 μελών του δεύτερου σώματος (Tweedekamer) γίνεται κάθε 4 χρόνια. Αυτό το σώμα είναι ουσιαστικά το Κοινοβούλιο, η εκπροσώπηση του λαού στην κυβέρνηση.\nΤο πρώτο σώμα, που ονομάζεταιγερουσία(Eerstekamer), αποτελείται από 75 αντιπροσώπους όλων των κοινοβουλίων των επαρχιών, οι οποίοι εκλέγονται επίσης κάθε 4 χρόνια[17]. Η δουλειά του πρώτου σώματος είναι να παρακολουθεί και να αξιολογεί τους νόμους τους οποίους έχει επεξεργαστεί το δεύτερο σώμα. Οι πιο πρόσφατες εκλογές για το πρώτο σώμα έγιναν στις 15 Μαΐου 2023, και για το δεύτερο σώμα έγιναν στις 22 Νοεμβρίου 2023.Εκλογές[Επεξεργασία|επεξεργασία κώδικα]Κύριο λήμμα:Εκλογές στην ΟλλανδίαΚοινωνική πολιτική[Επεξεργασία|επεξεργασία κώδικα]Η Ολλανδία φημίζεται για την πολύ ελεύθερη κοινωνική πολιτική που διατηρεί. Υπάρχει πολύ χαλαρή νομική ρύθμιση για ταναρκωτικά, τηνπορνεία(οι ιερόδουλες είναι ασφαλισμένες κοινωνικά) και τονγάμο ομοφυλοφίλων, όπου η Ολλανδία ήταν η πρώτη χώρα στον κόσμο όπου έγινε νόμιμος ο γάμος ομοφυλοφίλων, την 1η Απριλίου του 2001.Ωστόσο τα τελευταία χρόνια έχουν ανακύψει ορισμένα προβλήματα στη συμβίωση των μουσουλμάνων με τον υπόλοιπο ολλανδικό πληθυσμό και σημειώθηκαν περιστατικά όπως η δολοφονία το2004, του σκηνοθέτηΤέο Βαν Γκογκ, που ασκούσε κριτική στο Ισλάμ, από έναν νεαρό Μουσουλμάνο.[18]Παγκοσμίως διάσημος για την ισχυρή πολεμική του ενάντια στο Ισλάμ έχει γίνει ο Ολλανδός πολιτικόςΓκερτ Βίλντερς.[19]Επαρχίες[Επεξεργασία|επεξεργασία κώδικα]Κύριο λήμμα:Επαρχίες της ΟλλανδίαςΗ Ολλανδία είναι ένα ενιαίο κράτος με 12 επαρχίες. Σε όλη την ιστορία της χώρας υπήρχαν διοικητικές διαιρέσεις, ως επαρχίες, με τις παλαιότερες να υπάρχουν από το 1579, ενώ η νεότερη είναι τοΦλέβολαντπου αναγνωρίστηκε το 1986 ως επαρχία, η οποία δημιουργήθηκε με επέκταση στη θάλασσα (IJsselmeer) κατά τη διάρκεια του 20ού αιώνα.Οι επαρχίες της ΟλλανδίαςΣημαίαΕπαρχίαΠρωτεύουσαΜεγαλύτερηπόληΈκταση(τ.χλμ.)Πληθυσμός[21](2021)Πυκνότητα(ανά τ.χλμ.)ΝτρέντεΆσσενΆσσεν2.641494.771187,3ΦλέβολαντΛέλυσταντΑλμέρε1.417428.226302,2ΦρίσλαντΛέουβαρντενΛέουβαρντεν3.341651.435195ΧέλντερλαντΆρνεμΝαϊμέχεν4.9712.096.603421,8ΧρόνινχενΧρόνινχενΧρόνινχεν2.333586.937251,6ΛιμβουργίαΜάαστριχτΜάαστριχτ2.1501.115.872519Βόρεια ΒραβάντηΝτεν ΜποςΑϊντχόφεν4.9162.573.949523,6Βόρεια ΟλλανδίαΧάαρλεμΆμστερνταμ2.6712.888.4861.081ΟφεράισσελΖβόλεΕνσχέντε3.3251.166.533350,8ΟυτρέχτηΟυτρέχτηΟυτρέχτη1.3851.361.153982,8ΖηλανδίαΜίντελμπουρχΜίντελμπουρχ1.787385.400215,7Νότια ΟλλανδίαΧάγηΡότερνταμ2.8143.726.0501.324Οικονομία[Επεξεργασία|επεξεργασία κώδικα]Κύριο λήμμα:Οικονομία της ΟλλανδίαςΗ Ολλανδία διαθέτει ένα καλά οργανωμένο οικονομικό σύστημα. Κυρίαρχη είναι ηβιομηχανία τροφίμων, ηχημική βιομηχανίακαι η κατασκευή ηλεκτρικών ειδών.\nΗ σύγχρονη γεωργία είναι επίσης πολύ παραγωγική. Εκτός απόδημητριακά,λαχανικάκαιφρούτα, ηανθοκομίαπαίζει μεγάλο ρόλο στην οικονομία. Ιδιαίτερα η καλλιέργειατουλιπώνείναι ευρέως διαδεδομένη. Ηκτηνοτροφίακαι κυρίως ηγαλακτοκομίαχαρίζουν στη χώρα το καλό όνομα για τα περίφημα ολλανδικά τυριά. Παρόλο που η ολλανδική γεωργία απασχολεί μόνο το 4% του συνολικού πληθυσμού, παίζει μεγάλο ρόλο στις εξαγωγές. Η Ολλανδία είναι μετά τιςΗΠΑκαι τηΓαλλίαο τρίτος μεγαλύτερος παγκοσμίως εξαγωγέας γεωργικών προϊόντων.Φυσικές πηγές[Επεξεργασία|επεξεργασία κώδικα]Η Ολλανδία διαθέτει πηγές μεφυσικό αέριο, ιδιαίτερα στη Βόρεια Θάλασσα, οι οποίες επαρκούν για να καλύψουν ένα μέρος από τις ενεργειακές ανάγκες της χώρας. Στην παγκόσμια κλίμακα, η Ολλανδία βρίσκεται 5η στην παραγωγή φυσικού αερίου. Επιπλέον, στα σύνορα με τηΓερμανίαβρίσκονται μικρές πετρελαιοπηγές. Εκτός από την κοπριά, η Ολλανδία δεν διαθέτει άλλες φυσικές πηγές ή ορυκτά.Σημειώσεις[Επεξεργασία|επεξεργασία κώδικα]↑ΟISOορίζει τιςΜποναίρ,Άγιο ΕυστάθιοκαιΣάμπαως δήμουςISO 3166-1.Παραπομπές[Επεξεργασία|επεξεργασία κώδικα]↑1,01,11,2«Population dynamics; month and year». StatLine. 30 Ιουλίου 2024. Ανακτήθηκε στις 31 Ιουλίου 2024.↑Στατιστικά στοιχεία του ΟΗΕ↑3,03,13,23,3«Ολλανδία».ΔΝΤ. Απρίλιος 2017. Ανακτήθηκε στις 9 Μαΐου 2017.↑Human Development Report 2021-22: Uncertain Times, Unsettled Lives: Shaping our Future in a Transforming World(PDF).hdr.undp.org. United Nations Development Programme. 8 Σεπτεμβρίου 2022. σελίδες 272–276.ISBN978-9-211-26451-7.Αρχειοθετήθηκε(PDF)από το πρωτότυπο στις 8 Σεπτεμβρίου 2022. Ανακτήθηκε στις 8 Σεπτεμβρίου 2022.↑«Netherlands Guide – Interesting facts about the Netherlands». Eupedia. 19 Απριλίου 1994. Ανακτήθηκε στις 29 Απριλίου 2010.↑«Netherlands: Agricultural exports top 80 billion Euros». Αρχειοθετήθηκεαπό το πρωτότυποστις 22 Ιανουαρίου 2015. Ανακτήθηκε στις 15 Οκτωβρίου 2016.↑(RVO), Netherlands Enterprise Agency.«Agriculture and food».hollandtrade.com. Αρχειοθετήθηκεαπό το πρωτότυποστις 1 Ιανουαρίου 2016. Ανακτήθηκε στις 26 Αυγούστου 2016.↑\"The Middle Colonies: New York\". Digital History.↑Georg Tessin, Verbände und Truppen der deutschen Wehrmacht und Waffen SS 1939-1945, Biblio Verlag, vol. 2 for Nederland, vol. 14 for Landstorm Nederland↑Mark Mazower, Η Αυτοκρατορία του Χίτλερ: Ναζιστική Εξουσία στην Κατοχική Ευρώπη, εκδόσεις Αλεξάνδρια,ISBN 978-960-221-466-4, σελ.105↑W. Warmbrunn, The Dutch under German occupation, 1940-1945 (Στάνφορντ, 1963), 27-8↑Antillen opgeheven op 10-10-2010Αρχειοθετήθηκε2009-12-24 στοWayback Machine. ΝΟS news↑Het Koninklijk Huis (28 Ιανουαρίου 2013).«Koningin kondigt aftreden aan - Nieuwsbericht - Het Koninklijk Huis».www.koninklijkhuis.nl(στα Ολλανδικά). Ανακτήθηκε στις 23 Σεπτεμβρίου 2024.↑Παγκόσμιος Οργανισμός Υγείας, Προσδόκιμο ζωής και υγιές προσδόκιμο ζωής, Δεδομένα ανά χώρα↑\"Facts and Statistics\",mormonnewsroom.org↑Public Holidays, Επίσημη ιστοσελίδα της Ολλανδίας(Αγγλικά)↑Eerstekamer der Staten- General.«[[:Πρότυπο:Taalaan(\"en\")]]English[[:Πρότυπο:Taaluit]]».www.eerstekamer.nl(στα Ολλανδικά). Αρχειοθετήθηκεαπό το πρωτότυποστις 23 Σεπτεμβρίου 2024. Ανακτήθηκε στις 23 Σεπτεμβρίου 2024.URL–wikilink conflict (βοήθεια)↑The Murder of Theo Van Gogh. Mohammed Bouyeri sentenced, TRUtv Crime Library↑(Αγγλικά) «Dutch Politician Plans on Global Spread of Anti-Islam Party[νεκρός σύνδεσμος]» απόpattayadailynews.comΑρχειοθετήθηκε2009-12-30 στοWayback Machine.. Δημοσιεύθηκε 17 Ιουλ. 2010.Αρχειοθετήθηκε12 Ιαν. 2013. Ανακτήθηκε 6 Φεβρ. 2018↑«Regionale Kerncijfers Nederland»(στα Ολλανδικά). Statistics Netherlands. 2007. Ανακτήθηκε στις 13 Οκτωβρίου 2007.↑«Bevolking per regio naar leeftijd, geslacht en burgerlijke staat»(στα Ολλανδικά). Statistics Netherlands. 2007. Ανακτήθηκε στις 13 Οκτωβρίου 2007.Εξωτερικοί σύνδεσμοι[Επεξεργασία|επεξεργασία κώδικα]Commons logoΤαWikimedia Commonsέχουν πολυμέσα σχετικά με το θέμαΟλλανδίαCommons logoΤαWikimedia Commonsέχουν πολυμέσα σχετικά με το θέμαAtlas of the Netherlands(Άτλας της Ολλανδίας)WikiVoyage logoΣτοWikivoyageυπάρχει ταξιδιωτικός οδηγός σχετικός με το λήμμα:Ολλανδίαwiktionary logoΤοΒικιλεξικόέχει σχετικό λήμμα:ΟλλανδίαOverheid.nl, επίσημος κόμβος της ολλανδικής κυβέρνησης(Ολλανδικά)Government.nl, επίσημο site της ολλανδικής κυβέρνησης(Αγγλικά)Πληροφορίες για τη διοικητική διαίρεση της χώρας(Αγγλικά)Γενικές πληροφορίες από την ιστοσελίδα της ΕΕΠληροφορίες χώραςΑρχειοθετήθηκε2020-05-21 στοWayback Machine. (The World Factbook)(Αγγλικά)CBS- Στοιχεία της ολλανδικής διεύθυνσης στατιστικών(Αγγλικά)ΟλλανδίαστοCurlieπσεΧώρες-μέλη τουΝΑΤΟΚράτη Μέλη του NATO, που είναι επίσης και κράτη μέλη και τηςΕΕΒέλγιοΒουλγαρίαΓαλλίαΓερμανίαΔανίαΕλλάδαΕσθονίαΙσπανίαΙταλίαΚροατίαΛετονίαΛιθουανίαΛουξεμβούργοΟλλανδίαΟυγγαρίαΠολωνίαΠορτογαλίαΡουμανίαΣλοβακίαΣλοβενίαΣουηδίαΤσεχίαΦινλανδίαΚράτη Μέλη του ΝΑΤΟ, που είναι επίσης και κράτη μέλη και τηςΕΖΕΣΙσλανδίαΝορβηγίαΕυρωπαϊκά Κράτη Μέλη μόνο του ΝΑΤΟΗνωμένο ΒασίλειοΚράτη Μέλη του ΝΑΤΟ εκτός ΕυρώπηςΗνωμένες ΠολιτείεςΚαναδάςΕυρωπαϊκά Κράτη Μέλη μόνο του ΝΑΤΟ, που είναιυποψήφια εδώ και πολλά χρόνια και για ένταξη στην ΕΕΑλβανίαΒόρεια ΜακεδονίαΜαυροβούνιοΤουρκίαΥπερπόντια Εδάφη υπό την προστασία άλλων χωρώνΓαλλική ΓουιάναΓροιλανδίαΝήσοι ΦερόεςΣε εκκρεμότηταΒοσνία και ΕρζεγοβίνηΓεωργίαΟυκρανίαπσεΧώρεςτηςΕυρώπηςΚυρίαρχα κράτηΆγιος ΜαρίνοςΑζερμπαϊτζάν1ΑλβανίαΑνδόρραΑρμενία2ΑυστρίαΒατικανόΒέλγιοΒόρεια ΜακεδονίαΒοσνία και ΕρζεγοβίνηΒουλγαρίαΓαλλία3ΓερμανίαΓεωργία1ΔανίαΕλβετίαΕλλάδαΕσθονίαΗνωμένο Βασίλειο3ΙρλανδίαΙσλανδίαΙσπανία3ΙταλίαΚαζακστάν1ΚροατίαΚύπρος2ΛετονίαΛευκορωσίαΛιθουανίαΛίχτενσταϊνΛουξεμβούργοΜάλταΜαυροβούνιοΜολδαβίαΜονακόΝορβηγία3Ολλανδία3ΟυγγαρίαΟυκρανίαΠολωνίαΠορτογαλίαΡουμανίαΡωσία1ΣερβίαΣλοβακίαΣλοβενίαΣουηδίαΤουρκία1ΤσεχίαΦινλανδίαΕξαρτημένα εδάφηΔανίαΝήσοι ΦερόεςΗνωμένο ΒασίλειοΑκρωτήρι και ΔεκέλειαΓιβραλτάρΓκέρνσεϊΝήσος του ΜανΤζέρσεϊΝορβηγίαΣβάλμπαρντΓιαν ΜάγενΦινλανδίαΏλαντΑμφισβητούμενα εδάφηΚριμαίαΡόκαλΜη αναγνωρισμένα κράτηΑμπχαζίαΚόσοβοΝότια ΟσσετίαΤ.Δ.Β.Κ.2Υπερδνειστερία1. Διηπειρωτικές χώρες με επικράτεια στην Ευρώπη και στην Ασία. 2. Γεωγραφικά ανήκει στην Ασία, αλλά θεωρείται ευρωπαϊκό κράτος για ιστορικούς και πολιτισμικούς λόγους. 3. Κράτη που περιλαμβάνουν υπερπόντια εδάφη και σε άλλες ηπείρους με τη μητροπολιτική περιοχή να βρίσκεται στην Ευρώπη.πσεΧώρες τηςΕυρωπαϊκής ΈνωσηςΜέλη τηςΕυρωζώνηςΑυστρίαΒέλγιοΓαλλίαΓερμανίαΕλλάδαΕσθονίαΙρλανδίαΙσπανίαΙταλίαΚροατίαΚύπροςΛετονίαΛιθουανίαΛουξεμβούργοΜάλταΟλλανδίαΠορτογαλίαΣλοβακίαΣλοβενίαΦινλανδίαΕκτός ΕυρωζώνηςΒουλγαρίαΔανίαΟυγγαρίαΠολωνίαΡουμανίαΣουηδίαΤσεχίαΠρώην Μέλη της ΕΕΗνωμένο ΒασίλειοΥπερπόντια Εδάφη μέλη της ΕΕΆγιος ΜαρτίνοςΓαλλική ΓουιάναΓουαδελούπηΜαρτινίκαΚαθιερωμένοι όροιWorldCat:E39PCjGctfqf4FkcyYvj7tDQFXVIAF:156652814LCCN:n78085423ISNI:0000 0001 2369 754XGND:4042203-3SELIBR:155069SUDOC:026357240BNF:cb11862083x(data)BIBSYS:90546878HDS:003364NDL:00568908NKC:ge128525ICCU:CFIV048226BNE:XX451224CiNii:DA03480434KulturNav:idΠύλη:ΓεωγραφίαΠύλη:ΕυρώπηΠύλη:Ευρωπαϊκή Ένωση"
    },
    {
        "url": "https://el.wikipedia.org/wiki/%CE%93%CE%BA%CE%AF%CE%BD%CF%84%CE%BF_%CE%B2%CE%B1%CE%BD_%CE%A1%CF%8C%CF%83%CF%83%CE%BF%CF%85%CE%BC",
        "title": "Γκίντο βαν Ρόσσουμ",
        "content": "Γκίντο βαν ΡόσσουμΓενικές πληροφορίεςΌνομα στημητρική γλώσσαGuido van Rossum(Ολλανδικά)Γέννηση31  Ιανουαρίου 1956ΧάαρλεμΚατοικίαBelmontΗνωμένες Πολιτείες Αμερικής[1]Χώρα πολιτογράφησηςΒασίλειο των Κάτω ΧωρώνΕκπαίδευση και γλώσσεςΜητρική γλώσσαΟλλανδικάΟμιλούμενες γλώσσεςΟλλανδικάΣπουδέςΠανεπιστήμιο του Άμστερνταμ(έως 1981)Stedelijk Gymnasium HaarlemΠληροφορίες ασχολίαςΙδιότηταεπιστήμονας υπολογιστώνμηχανικόςσυγγραφέαςπρογραμματιστήςΕργοδότηςMicrosoft(από 2020)[2]Αξιοσημείωτο έργοPythonABCΑξιώματα και βραβεύσειςΑξίωμαBenevolent Dictator for Life(έως 2018,Python)ΒραβεύσειςFSF Award for the Advancement of Free Software(16  Φεβρουαρίου 2002)[3]ACM Distinguished Member(2006)[4]Ιστότοποςgvanrossum.github.ioΣχετικά πολυμέσαδεδομέναΟΓκίντο βαν Ρόσσουμ(ολλανδικά:Guido van Rossum, 31 Ιανουαρίου 1956) είναιΟλλανδόςπρογραμματιστής κυρίως γνωστός ως ο δημιουργός τηςγλώσσας προγραμματισμούPython.[5]Πρωτοστατούσε στην κοινότητα της Python μέχρι τον Ιούλιο του 2018, οπότε και αποσύρθηκε από την ενεργό δράση.[6][7]Σήμερα είναι μέλος του Διοικητικού Συμβουλίου της Python.[5]Παραπομπές[Επεξεργασία|επεξεργασία κώδικα]↑gayanvoice / top-github-users.↑gvanrossum.github.io/Resume.html.↑www.gnu.org/award/2001/.↑awards.acm.org/distinguished-members/award-winners. Ανακτήθηκε στις 29  Μαΐου 2020.↑5,05,1(Αγγλικά) Guido van Rossum, «Guido van Rossum - Brief Bio».Αρχειοθετήθηκε2019-05-24. Ανακτήθηκε 2019-09-10.↑(Αγγλικά) Carlie Fairchild. «Guido van Rossum Stepping Down from Role as Python's Benevolent Dictator For Life» στο www.linuxjournal.com. Δημοσιεύθηκε 12/07/2018.Αρχειοθετήθηκε27/03/2019. Ανακτήθηκε 15/04/2019.↑(Αγγλικά) «Python boss Guido van Rossum steps down after 30 years» στο www.theinquirer.net.Αρχειοθετήθηκε19/02//2019. Ανακτήθηκε 15/04/2019.Εξωτερικοί σύνδεσμοι[Επεξεργασία|επεξεργασία κώδικα]Προσωπικός ιστοχώρος του Guido van RossumΚαθιερωμένοι όροιWorldCat:E39PBJqqBkFt4C9YrJyDcJQcydVIAF:28799390LCCN:n96080557ISNI:0000 0000 3539 3853GND:1067604243NDL:01103013CiNii:DA10288481"
    },
    {
        "url": "https://el.wikipedia.org/wiki/%CE%A0%CF%81%CE%BF%CE%B3%CF%81%CE%B1%CE%BC%CE%BC%CE%B1%CF%84%CE%B9%CF%83%CF%84%CE%AE%CF%82",
        "title": "Προγραμματιστής",
        "content": "Δύο προγραμματιστές που εργάζονται σε ένα IBM 704 στην NACA, 1954Οπρογραμματιστήςυπολογιστών, ο οποίος μερικές φορές καλείται τελευταία ωςπαραγωγός κώδικα(ειδικά σε πιο άτυπα κείμενα), είναι άτομο που δημιουργείλογισμικό ηλεκτρονικών υπολογιστών. Ο όροςπρογραμματιστής ηλεκτρονικών υπολογιστώνμπορεί να αναφέρεται σε άτομο ειδικό σε μια κατηγορίαυπολογιστώνή σε κάποιον που γράφει γενικά κώδικα για πολλά είδη λογισμικού.Η πιο συνηθισμένηγλώσσα προγραμματισμούτων προγραμματιστών (π.χ.Assembly,COBOL,C,C ++,C #,JavaScript,Lisp,Python) μπορεί να προηγείται στον τίτλο τουπρογραμματιστή. Μερικοί που εργάζονται με γλώσσες προγραμματισμούιστούπροηγείται η ονομασία αυτή π.χ. web developer.Μια σειρά από επαγγέλματα που απαιτούν προγραμματισμό συχνά απαιτούν επίσης μια σειρά άλλων, παρόμοιων δεξιοτήτων, για παράδειγμα: προγραμματιστής λογισμικού, προγραμματιστής ιστοσελίδων, προγραμματιστής εφαρμογών για κινητά, προγραμματιστής ενσωματωμένουυλικολογισμικού,μηχανικός λογισμικού, επιστήμονας υπολογιστών, προγραμματιστής παιχνιδιών, προγραμματιστής παιχνιδιών και αναλυτής λογισμικού  . Η χρήση του όρουπρογραμματιστής,όπως εφαρμόζεται σε αυτές τις θέσεις, θεωρείται μερικές φορές ως προσβλητική απλούστευση ή ακόμη και υποτιμητική.[1][2][3][4][5]Ιστορία[Επεξεργασία|επεξεργασία κώδικα]Η Άντα Λάβλεϊςθεωρείται από πολλούς ως η πρώτη προγραμματίστρια υπολογιστών.[6]Η βρετανίδακόμισσακαι μαθηματικόςΆντα Λάβλεϊςθεωρείται συχνά ως η πρώτη προγραμματίστρια υπολογιστών, καθώς ήταν η πρώτη που δημοσίευσε μέρος ενός προγράμματος (συγκεκριμένα ενόςαλγορίθμου) που προοριζόταν για εφαρμογή στηναναλυτική μηχανή τουΤσαρλς Μπάμπατζ, τον Οκτώβριο του 1842. Ο αλγόριθμος χρησιμοποιήθηκε για τον υπολογισμό των αριθμών Bernoulli .[7]Επειδή η μηχανή του Μπάμπατζ δεν ολοκληρώθηκε ποτέ ως λειτουργικό πρότυπο στην εποχή της Λάβλεϊς, δυστυχώς δεν είχε ποτέ την ευκαιρία να δει τον αλγόριθμο σε δράση.Ο πρώτος που εκτέλεσε ένα πρόγραμμα σε λειτουργικό, σύγχρονο, ηλεκτρονικό υπολογιστή ήταν ο γνωστός επιστήμονας πληροφορικήςΚόνραντ Τσούζε, το 1941.Betty Jennings και Fran Bilas, μέρος της πρώτης ομάδας προγραμματισμούENIACΗ ομάδα προγραμματισμούENIAC, αποτελούμενη από τους Kay McNulty, τη Betty Jennings, τη Betty Snyder, τον Marlyn Wescoff, τον Fran Bilas και τον Ruth Lichterman, ήταν οι πρώτοι προγραμματιστές που εργάζονταν τακτικά.[8][9]Η Διεθνής Ημέρα Προγραμματιστών γιορτάζεται ετησίως στις 7 Ιανουαρίου.[10]Το 2009, ηκυβέρνηση της Ρωσίαςαποφάσισε μια επαγγελματική ετήσια γιορτή, γνωστή ως Ημέρα Προγραμματιστών, που θα γιορτάσει στις 13 Σεπτεμβρίου (12 Σεπτεμβρίου τα δίσεκτα χρόνια). Ήταν ήδη μιαανεπίσημηγιορτή πριν από αυτό σε πολλές χώρες.Λογισμικό[Επεξεργασία|επεξεργασία κώδικα]Η λέξηλογισμικόχρησιμοποιήθηκε ήδη από το 1953, αλλά δεν εμφανίστηκε τακτικά στις εκδόσεις μέχρι τη δεκαετία του 1960.[11]Πριν από τότε, οι υπολογιστές προγραμματίζονταν είτε από πελάτες είτε από τους λίγους εμπορικούς κατασκευαστές ηλεκτρονικών υπολογιστών της εποχής, όπως η UNIVAC και ηIBM. Η πρώτη εταιρεία που ιδρύθηκε με σκοπό την παροχή ειδικών προϊόντων και υπηρεσιών λογισμικού ήταν ηComputer Usage Company, το 1955.[12]Η βιομηχανία λογισμικού επεκτάθηκε στις αρχές της δεκαετίας του 1960, σχεδόν αμέσως μετά την πρώτη πώληση των υπολογιστών σε μαζικές παραγόμενες ποσότητες. Τα πανεπιστήμια, οι κυβερνήσεις και οι επιχειρήσεις δημιούργησαν ζήτηση για λογισμικό. Πολλά από αυτά τα προγράμματα γράφτηκαν από τους προγραμματιστές προσωπικού πλήρους απασχόλησης. ορισμένα διανεμήθηκαν ελεύθερα μεταξύ των χρηστών μιας συγκεκριμένης μηχανής χωρίς χρέωση. Και άλλα αναπτύχθηκαν σε εμπορική βάση. Άλλες επιχειρήσεις, όπως η Computer Sciences Corporation (που ιδρύθηκε το 1959), άρχισαν επίσης να αναπτύσσονται. Οι κατασκευαστές υπολογιστών /υλικούσύντομα άρχισαν να συνδυάζουνλειτουργικά συστήματα,λογισμικό συστήματοςκαι περιβάλλοντα προγραμματισμού με τα μηχανήματά τους.Η βιομηχανία επεκτάθηκε σε μεγάλο βαθμό με την άνοδο τουπροσωπικού υπολογιστή(\"PC\") στα μέσα της δεκαετίας του 1970, η οποία έφερε υπολογιστές στον μέσο εργαζόμενο γραφείου. Στα επόμενα χρόνια, ο υπολογιστής βοήθησε επίσης στη δημιουργία μιας συνεχώς αναπτυσσόμενης αγοράς παιχνιδιών, εφαρμογών και λογισμικού κοινής ωφέλειας. CP / M, αντικαταστάθηκε αργότερα από τοDOS, το δημοφιλές λειτουργικό σύστημα τωνWindows τηςMicrosoftτην εποχή εκείνη.[13]Στα πρώτα χρόνια του 21ου αιώνα, δημιουργήθηκε ένα άλλο επιτυχημένοεπιχειρηματικό μοντέλογια φιλοξενούμενο λογισμικό, το οποίο ονομάζεται λογισμικό-ως-υπηρεσία, ή SaaS. αυτό ήταν τουλάχιστον για τρίτη φορά το μοντέλο που είχε επιχειρηθεί. Από την άποψη των παραγωγών κάποιου ιδιόκτητου λογισμικού, το SaaS μειώνει τις ανησυχίες για μη εξουσιοδοτημένη αντιγραφή, δεδομένου ότι είναι προσβάσιμο μόνο μέσω του Διαδικτύου και εξ ορισμού δεν φορτώνεται λογισμικό πελάτη στον υπολογιστή του τελικού χρήστη.     Μέχρι το 2014, ο ρόλος του προγραμματιστή σεσύννεφοείχε καθοριστεί σε αυτό το πλαίσιο, ένας ορισμός ενός «προγραμματιστή» γενικά δημοσιεύθηκε:[14]Παραπομπές[Επεξεργασία|επεξεργασία κώδικα]↑«No Programmers».http://www.ericsink.com/No_Programmers.html.↑«Developer versus programmer». Αρχειοθετήθηκε απότο πρωτότυποστις 2010-11-25.https://web.archive.org/web/20101125071809/http://codebetter.com/blogs/raymond.lewallen/archive/2005/02/22/55812.aspx. Ανακτήθηκε στις 2020-02-11.↑«Developers AND Programmers».http://weblogs.asp.net/miked/archive/2006/10/13/_2200_Developers_2200_-and-_2200_Programmers_2200_.aspx.↑«Programmer vs. Developer vs. Software Engineer». Αρχειοθετήθηκε απότο πρωτότυποστις 10 July 2018.https://web.archive.org/web/20180710101939/http://discuss.joelonsoftware.com/default.asp?joel.3.112837.37#. Ανακτήθηκε στις 21 April 2008.↑«Programmer vs. Developer vs. Software Engineer».http://www.xtremevbtalk.com/archive/index.php/t-233780.html.↑Fuegi, J.; Francis, J. (2003). «Lovelace & Babbage and the creation of the 1843 'notes'».Annals of the History of Computing25(4):  18–26.doi:10.1109/MAHC.2003.1253887.↑Fuegi, J.; Francis, J. (October–December 2003). «Lovelace & babbage and the creation of the 1843 'notes'».IEEE Annals of the History of Computing25(4):  16–26.doi:10.1109/MAHC.2003.1253887.↑«Memorials». Eniacprogrammers.org. Ανακτήθηκε στις 11 Οκτωβρίου 2018.↑«ABC News: First Computer Programmers Inspire Documentary». Abcnews.go.com. 4 Δεκεμβρίου 2007. Ανακτήθηκε στις 3 Οκτωβρίου 2010.↑«International Programmers' Day». Αρχειοθετήθηκεαπό το πρωτότυποστις 3 Ιανουαρίου 2018. Ανακτήθηκε στις 19 Σεπτεμβρίου 2018.↑Paul Niquette (1995).«Softword: Provenance for the Word 'Software'».adapted fromSophisticated: The Magazine(ISBN1-58922-233-4)↑Elmer C. Kubie (Summer 1994). «Recollections of the first software company».Annals of the History of Computing16(2):  65–71.doi:10.1109/85.279238.↑Rebello, Kathy· Schwartz, Evan I.· Verity, John W.· Lewyn, Mark· Levine, Jonathan (28 Φεβρουαρίου 1993).«Is Microsoft Too Powerful?».Businessweek Archives. Bloomberg Businessweek. Ανακτήθηκε στις 26 Σεπτεμβρίου 2014.↑Hardiman, Nick (24 July 2014).«A portrait of the modern cloud developer».TechRepublic.http://www.techrepublic.com/article/a-portrait-of-the-modern-cloud-developer/."
    },
    {
        "url": "https://el.wikipedia.org/wiki/C%2B%2B",
        "title": "C++",
        "content": "ΟΜπιάρνε Στρούστρουπ, δημιουργός της γλώσσας C++.ΗC++(διαβάζεται: σι πλας πλας[1][siː plʌs plʌs]) είναι μία γενικού σκοπούγλώσσα προγραμματισμούΗ/Υ. Θεωρείται μέσου επιπέδου γλώσσα, καθώς περιλαμβάνει έναν συνδυασμό χαρακτηριστικών από γλώσσες υψηλού και χαμηλού επιπέδου. Είναι μιαμεταγλωττιζόμενηγλώσσα πολλαπλών παραδειγμάτων, μετύπους. Υποστηρίζειδομημένο,αντικειμενοστρεφήκαι γενικό προγραμματισμό.Η γλώσσα αναπτύχθηκε από τονΜπιάρνε Στρούστρουπτο1979σταεργαστήρια BellτηςAT&T, ως βελτίωση της ήδη υπάρχουσαςγλώσσας προγραμματισμού C. Ουσιαστικά ήταν η γλώσσα C εφοδιασμένη με κλάσεις όπως αυτές τηςSimulaκαι γι' αυτό αρχικά ονομάστηκε \"C with Classes\".[1]Ο Rick Mascitti πρότεινε το όνομα «C++» στα μέσα του1983και έκτοτε επικράτησε.[1]Οι βελτιώσεις ξεκίνησαν με την προσθήκη κλάσεων, και ακολούθησαν, μεταξύ άλλων, εικονικές συναρτήσεις, υπερφόρτωση τελεστών, πολλαπλή κληρονομικότητα, πρότυπα κ.α.Η γλώσσα ορίστηκε παγκοσμίως, το1998, με το πρότυποISO/IEC 14882:1998. Η τρέχουσα έκδοση αυτού του προτύπου είναι αυτή του2020, η ISO/IEC 14882:2020. Μια καινούρια έκδοση είναι υπό ανάπτυξη, γνωστή ανεπίσημα με την ονομασία C++2b.Φιλοσοφία[Επεξεργασία|επεξεργασία κώδικα]Στο βιβλίοThe Design and Evolution of C++(1994),ο Μπιάρνε Στρούστρουπ περιγράφει τα κριτήρια που χρησιμοποιεί για το σχεδιασμό της C++, εξηγώντας πως η C++ είναι σχεδιασμένη:ως μία γενικής χρήσης γλώσσα μεστατικούς τύπους, που είναι όσο αποτελεσματική και φορητή, όσο η Cώστε να υποστηρίζει άμεσα και σφαιρικά πολλά είδη προγραμματισμού (δομημένος προγραμματισμός,αντικειμενοστρεφής προγραμματισμός,γενικός προγραμματισμός)ώστε να δίνει επιλογές στον προγραμματιστή, ακόμα κι αν του επιτρέπει να επιλέξει λανθασμέναμε σκοπό να είναι όσο το δυνατόν συμβατή με τη C, διευκολύνοντας έτσι τη μετάβαση από τη C στη C++με σκοπό να αποφεύγει χαρακτηριστικά που αναφέρονται σε συγκεκριμένες πλατφόρμες ή δεν είναι γενικής χρήσηςώστε να μην δημιουργείται επιπλέον επεξεργαστικό κόστος για χαρακτηριστικά της γλώσσας που δεν χρησιμοποιούνταιώστε να λειτουργεί χωρίς κάποιο εξελιγμένο προγραμματιστικό περιβάλλονΤο βιβλίοInside the C++ Object Model(Lippman, 1996) περιγράφει πως οι μεταγλωττιστές μπορούν να μετατρέψουν εντολές ενός προγράμματος C++ σε μια διάταξη στη μνήμη. Παρόλα αυτά, οι συγγραφείς μεταγλωττιστών είναι γενικά ελεύθεροι να υλοποιήσουν το πρότυπο με δικό τους τρόπο.Χαρακτηριστικά[Επεξεργασία|επεξεργασία κώδικα]Η C++ κληρονόμησε το μεγαλύτερο μέρος τηςσύνταξηςτης C και τονπροεπεξεργαστήτης C. Το παρακάτω είναι έναπρόγραμμα hello worldπου χρησιμοποιεί την λειτουργία stream τηςπρότυπης βιβλιοθήκης της C++για να γράψει ένα μήνυμα στηνκύρια έξοδο. Το παρακάτω πρόγραμμα χρησιμοποιεί την βιβλιοθήκη εισόδου/εξόδουiostream#include<iostream>// αρχείο επικεφαλίδας για την βιβλιοθήκη εισόδου/εξόδου iostream (για cout)// std: standard namespace// cout: \"see-output\"intmain(){std::cout<<\"Hello, world!\\n\";}Τελεστές και υπερφόρτωση τελεστών[Επεξεργασία|επεξεργασία κώδικα]Η C++ παρέχει περισσότερους από30 τελεστές, που καλύπτουν τη βασική αριθμητική, το χειρισμό bit, αναφορά δεικτών, συγκρίσεις, λογικές πράξεις κ.ά. Σχεδόν όλοι οι τελεστές μπορούν ναυπερφορτωθούνγια τύπους ορισμένους από το χρήστη, με λίγες εξαιρέσεις όπως πρόσβαση μέλους (.και.*). Το πλούσιο σύνολο από τελεστές που μπορούν να υπερφορτωθούν είναι βασικό για τη χρήση της C++ ωςγλώσσα ειδικού πεδίου(domain specific language). Οι υπερφορτώσιμοι τελεστές είναι ακόμα βασικό μέρος πολλών προχωρημένων τεχνικών προγραμματισμού της C++, όπως οιέξυπνοι δείκτες. Η υπερφόρτωση ενός τελεστή δεν αλλάζει την προτεραιότητα των υπολογισμών όπου χρησιμοποιείται, ούτε τον αριθμό των τελεστέων που χρησιμοποιεί ο τελεστής (αν και οποιοσδήποτε τελεστέος μπορεί απλά να αγνοείται).Παραπομπές[Επεξεργασία|επεξεργασία κώδικα]↑1,01,11,2Bjarne Stroustrup, «Η γλώσσα προγραμματισμού C++»,σελ. 39, Εκδότης: Κλειδάριθμος, 1999,(ISBN9603321427και9789603321422).Αρχειοθετήθηκε04/09/2019. Ανακτήθηκε 04/09/2019.Πηγές[Επεξεργασία|επεξεργασία κώδικα]«Η Προέλευση της C++»Αρχειοθετήθηκε2007-01-08 στοWayback Machine., Ζαφείρης Φιλίτσας. Ανακτήθηκε στις 2006-08-25.Εξωτερικοί σύνδεσμοι[Επεξεργασία|επεξεργασία κώδικα]Commons logoΤαWikimedia Commonsέχουν πολυμέσα σχετικά με το θέμαC++The invention of C++Αρχειοθετήθηκε2006-08-24 στοWayback Machine. — Συνέντευξη του Μπιάρνε Στρούστρουπ για τη δημιουργία της γλώσσας.(Αγγλικά)C++στοCurlieΤαΒικιβιβλίαέχουν\n      ένα βιβλίο σχετικά, με τίτλοΕισαγωγή στην C και C++ σε Ολοκληρωμένο Περιβάλλον Δημιουργίας ΛογισμικούΒιβλία:Η γλώσσα C++ σε βάθος[1](Ν. Χατζηγιαννάκης - Εκδόσεις ΚΛΕΙΔΑΡΙΘΜΟΣ)πσεΓλώσσες προγραμματισμούAdaALGOLAPLApplescriptAssemblyBASICCC++C#COBOLErlangForthFortranGoHaskellJavaJavaScriptKotlinLispLogoLuaMLObjective-CPascalPerlPHPPrologPythonRRubyRustSQLShellSimulaSmalltalkSwiftVisual BasicΚαθιερωμένοι όροιLCCN:sh87007505GND:4193909-8SUDOC:029859778BNF:cb12139768z(data)NKC:ph116956BNE:XX540250Πύλη:Προγραμματισμός↑[cpp.bytes.gr «Η γλώσσα C++ σε βάθος»]Check|url=value (βοήθεια)."
    },
    {
        "url": "https://el.wikipedia.org/wiki/Java",
        "title": "Java",
        "content": "Το λογότυπο της γλώσσας Java.ΗJavaείναιαντικειμενοστρεφήςγλώσσα προγραμματισμούπου σχεδιάστηκε από την εταιρείαπληροφορικήςSun Microsystems.Ιστορία[Επεξεργασία|επεξεργασία κώδικα]Στις αρχές του1991, ηSunαναζητούσε το κατάλληλο εργαλείο για να αποτελέσει την πλατφόρμα ανάπτυξηςλογισμικούσε μικρο-συσκευές (έξυπνες οικιακές συσκευές έως πολύπλοκα συστήματα παραγωγής γραφικών). Τα εργαλεία της εποχής ήταν γλώσσες όπως ηC++και ηC. Μετά από διάφορους πειραματισμούς προέκυψε το συμπέρασμα ότι οι υπάρχουσες γλώσσες δεν μπορούσαν να καλύψουν τις ανάγκες τους. Ο \"πατέρας\" της Java,James Gosling, που εργαζόταν εκείνη την εποχή για την Sun, έκανε ήδη πειραματισμούς πάνω στη C++ και είχε παρουσιάσει κατά καιρούς κάποιες πειραματικές γλώσσες (C++ ++, που μετέπειτα ονομάστηκε C# ) ως πρότυπα για το νέο εργαλείο που αναζητούσαν στηνSun. Τελικά μετά από λίγο καιρό κατέληξαν με μια πρόταση για το επιτελείο της εταιρίας, η οποία ήταν η γλώσσαOak. Το όνομά της το πήρε από το ομώνυμο δένδρο (βελανιδιά) το οποίο ο Gosling είχε έξω από το γραφείο του και έβλεπε κάθε μέρα.Από την Oak στη Java[Επεξεργασία|επεξεργασία κώδικα]ΗOakήταν μία γλώσσα που διατηρούσε μεγάλη συγγένεια με την C++. Παρόλα αυτά είχε πολύ πιο έντονο αντικειμενοστρεφή (object oriented) χαρακτήρα σε σχέση με την C++ και χαρακτηριζόταν για την απλότητα της. Σύντομα η υπεύθυνοι ανάπτυξης της νέας γλώσσας ανακάλυψαν ότι το όνομαOakήταν ήδη κατοχυρωμένο οπότε κατά την διάρκεια μιας εκ των πολλών συναντήσεων σε κάποιο τοπικό καφέ αποφάσισαν να μετονομάσουν το νέο τους δημιούργημα σε Java που εκτός των άλλων ήταν το όνομα της αγαπημένης ποικιλίας καφέ για τους δημιουργούς της. Η επίσημη εμφάνιση τηςJavaαλλά και τουHotJava(πλοηγός με υποστήριξηJava) στη βιομηχανία της πληροφορικής έγινε το Μάρτιο του1995όταν ηSunτην ανακοίνωσε στο συνέδριοSun World1995. Ο πρώτοςμεταγλωττιστής(compiler) της ήταν γραμμένος στη γλώσσα C από τον James Gosling. Το1994, ο A.Van Hoff ξαναγράφει τον μεταγλωττιστή της γλώσσας σεJava, ενώ το Δεκέμβριο του1995πρώτες οιIBM,Borland,Mitsubishi Electronics,SybaseκαιSymantecανακοινώνουν σχέδια να χρησιμοοιήσουν τηJavaγια την δημιουργία λογισμικού. Από εκεί και πέρα η Java ακολουθεί μία ανοδική πορεία και είναι πλέον μία από τις πιο δημοφιλείς γλώσσες στον χώρο της πληροφορικής. Στις 13 Νοεμβρίου του 2006 η Java έγινε πλέον μια γλώσσαανοιχτού κώδικα(GPL) όσον αφορά το μεταγλωττιστή (javac) και το πακέτο ανάπτυξης (JDK, Java Development Kit).Η εξαγορά από την Oracle και το μέλλον της Java[Επεξεργασία|επεξεργασία κώδικα]Στις 27 Απριλίου 2010 η εταιρία λογισμικούOracle Corporationανακοίνωσε ότι μετά από πολύμηνες συζητήσεις ήρθε σε συμφωνία για την εξαγορά της Sun Microsystems και των τεχνολογιών (πνευματικά δικαιώματα/ πατέντες) που η δεύτερη είχε στην κατοχή της ή δημιουργήσει. Η συγκεκριμένη συμφωνία θεωρείται σημαντική για το μέλλον της Java και του γενικότερου οικοσυστήματος τεχνολογιών γύρω από αυτή μιας και ο έμμεσος έλεγχος της τεχνολογίας και η εξέλιξη της περνάει σε άλλα χέρια.Εκδόσεις[Επεξεργασία|επεξεργασία κώδικα]Σήμερα οι υποστηριζόμενες εκδόσεις είναι οι Java 8 και 9. Οι σημαντικότερες που έχουν κυκλοφορήσει, με τις αντίστοιχες ημερομηνίες κυκλοφορίας, είναι οι εξής :JDK 1.0 (23 Ιανουαρίου 1996)[1]JDK 1.1 (19 Φεβρουαρίου 1997)J2SE 1.2 (8 Δεκεμβρίου 1998)J2SE 1.3 (8 Μαΐου 2000)J2SE 1.4 (6 Φεβρουαρίου 2002)J2SE 5.0 (30 Σεπτεμβρίου 2004)Java SE 6 (11 Δεκεμβρίου 2006)Java SE 7 (28 Ιουλίου 2011)Java SE 8 (18 Μαρτίου 2014)Java SE 9 (21 Σεπτεμβρίου 2017)Java SE 10 (20 Μαρτίου 2018)Java SE 11 (LTS*) (25 Σεπτεμβρίου 2018)Java SE 12 (Μάρτιος 2019)Java SE 13 (Σεπτέμβριος 2019)Java SE 14 (Μάρτιος 2020)Java SE 15 (Σεπτέμβριος 2020)Java SE 16 (Μάρτιος 2021)Java SE 17 (LTS*) (Σεπτέμβριος 2021)LTS = Long-Term Support. Είναι η έκδοση η οποία προορίζεται να παραμείνει στάνταρντ για τα επόμενα χρόνια.Τα χαρακτηριστικά της Java[Επεξεργασία|επεξεργασία κώδικα]Ένα από τα βασικά πλεονεκτήματα της Java έναντι των περισσότερων άλλων γλωσσών είναι η ανεξαρτησία τουλειτουργικού συστήματοςκαι πλατφόρμας. Τα προγράμματα που είναι γραμμένα σεJavaεκτελούνται ακριβώς το ίδιο σεWindows,Linux,UnixκαιMacintosh(σύντομα θα τρέχουν και σεPlaystationκαθώς και σε άλλες κονσόλες παιχνιδιών) χωρίς να χρειαστεί να ξαναγίνει μεταγλώττιση (compiling) ή να αλλάξει οπηγαίος κώδικαςγια κάθε διαφορετικό λειτουργικό σύστημα. Για να επιτευχθεί όμως αυτό χρειαζόταν κάποιος τρόπος έτσι ώστε τα προγράμματα γραμμένα σε Java να μπορούν να είναι «κατανοητά» από κάθε υπολογιστή ανεξάρτητα του είδους επεξεργαστή (Intel x86, IBM,Sun SPARC, Motorola) αλλά και λειτουργικού συστήματος (Windows, Unix, Linux,BSD, Mac OS). Ο λόγος είναι ότι κάθεκεντρική μονάδα επεξεργασίαςκατανοεί διαφορετικό κώδικα μηχανής. Οσυμβολικός κώδικας(assembly) που μεταφράζεται και εκτελείται σε Windows είναι διαφορετικός από αυτόν που μεταφράζεται και εκτελείται σε έναν υπολογιστή Macintosh. Η λύση δόθηκε με την ανάπτυξη τηςΕικονικής Μηχανής(Virtual Machineή VM ή ΕΜ στα ελληνικά)[2].Η εικονική μηχανή της Java[Επεξεργασία|επεξεργασία κώδικα]Αφού γραφεί κάποιο πρόγραμμα σε Java, στη συνέχεια μεταγλωττίζεται μέσω τουμεταγλωττιστήjavac, ο οποίος παράγει έναν αριθμό από αρχεία .class (κώδικας byte ή bytecode). Ο κώδικας byte είναι η μορφή που παίρνει ο πηγαίος κώδικας της Java όταν μεταγλωττιστεί. Όταν πρόκειται να εκτελεστεί η εφαρμογή σε ένα μηχάνημα, το Java Virtual Machine που πρέπει να είναι εγκατεστημένο σε αυτό θα αναλάβει να διαβάσει τα αρχεία .class. Στη συνέχεια τα μεταφράζει σεγλώσσα μηχανήςπου να υποστηρίζεται από το λειτουργικό σύστημα και τον επεξεργαστή, έτσι ώστε να εκτελεστεί. Αυτό συμβαίνει με την παραδοσιακή Εικονική Μηχανή (Virtual Machine).[3]Πιο σύγχρονες εφαρμογές της εικονικής Μηχανής μπορούν και μεταγλωττίζουν εκ των προτέρων τμήματα bytecode απευθείας σε κώδικα μηχανής (εγγενή κώδικα ή native code) με αποτέλεσμα να βελτιώνεται η ταχύτητα. Χωρίς αυτό δε θα ήταν δυνατή η εκτέλεση λογισμικού γραμμένου σε Java. Η JVM είναι λογισμικό που εξαρτάται από την πλατφόρμα, δηλαδή για κάθε είδος λειτουργικού συστήματος και αρχιτεκτονικής επεξεργαστή υπάρχει διαφορετική έκδοση του. Έτσι υπάρχουν διαφορετικές JVM γιαWindows,Linux,Unix,Macintosh, κινητά τηλέφωνα, παιχνιδομηχανές κλπ.Οτιδήποτε θέλει να κάνει ο προγραμματιστής (ή ο χρήστης) γίνεται μέσω της εικονικής μηχανής. Αυτό βοηθάει στο να υπάρχει μεγαλύτερη ασφάλεια στο σύστημα γιατί η εικονική μηχανή είναι υπεύθυνη για την επικοινωνία χρήστη - υπολογιστή. Ο προγραμματιστής δεν μπορεί να γράψει κώδικα ο οποίος θα έχει καταστροφικά αποτελέσματα για τον υπολογιστή γιατί η εικονική μηχανή θα τον ανιχνεύσει και δε θα επιτρέψει να εκτελεστεί. Από την άλλη μεριά ούτε ο χρήστης μπορεί να κατεβάσει «κακό» κώδικα από το δίκτυο και να τον εκτελέσει. Αυτό είναι ιδιαίτερα χρήσιμο για μεγάλακατανεμημένα συστήματαόπου πολλοί χρήστες χρησιμοποιούν το ίδιο πρόγραμμα συγχρόνως.Ο συλλέκτης απορριμμάτων (Garbage Collector)[Επεξεργασία|επεξεργασία κώδικα]Ακόμα μία ιδέα που βρίσκεται πίσω από τηJavaείναι η ύπαρξη τουσυλλέκτη απορριμμάτων(Garbage Collector). Συλλογή απορριμμάτων είναι μία κοινή ονομασία που χρησιμοποιείται στον τομέα της πληροφορικής για να δηλώσει την ελευθέρωση τμημάτων μνήμης από δεδομένα που δε χρειάζονται και δε χρησιμοποιούνται άλλο. Αυτή η απελευθέρωση μνήμης στη Java είναι αυτόματη και γίνεται μέσω τουσυλλέκτη απορριμμάτων. Υπεύθυνη για αυτό είναι και πάλι η εικονική μηχανή η οποία μόλις «καταλάβει» ότι ο σωρός (heap) της μνήμης (στη Java η συντριπτική πλειοψηφία των αντικειμένων αποθηκεύονται στο σωρό σε αντίθεση με τηC++όπου αποθηκεύονται κυρίως στηστοίβα) κοντεύει να γεμίσει ενεργοποιεί το συλλέκτη απορριμμάτων. Έτσι ο προγραμματιστής δε χρειάζεται να ανησυχεί για το πότε και αν θα ελευθερώσει ένα συγκεκριμένο τμήμα της μνήμης, ούτε και για σφάλματαδεικτών. Αυτό είναι ιδιαίτερα σημαντικό γιατί είναι κοινά τα σφάλματα προγραμμάτων που οφείλονται σε λανθασμένο χειρισμό της μνήμης.Η προεπιλεγμένη μέθοδος για συλλογή απορριμμάτων μοιράζει το σωρό σε δύο κομμάτια. Το πρώτο, χρησιμοποιείται για νέα αντικείμενα και λέγεται μαιευτήριο. Αφού επιβιώσουν ένα προεπιλεγμένο αριθμό εκκαθαρίσεων στο μαιευτήριο, ώριμα αντικείμενα μεταφέρονται στο δεύτερο κομμάτι του σωρού. Το μαιευτήριο είναι μοιρασμένο σε δύο κομμάτια, τον από-χωρο και τον προς-χωρο. Νέα αντικείμενα τοποθετούνται αρχικά στον από-χωρο. Όταν αυτός γεμίσει, ζωντανά αντικείμενα αντιγράφονται στον προς-χωρο και οι δύο χώροι ανταλλάσσουν ρόλο.Επιδόσεις[Επεξεργασία|επεξεργασία κώδικα]Παρόλο που η εικονική μηχανή προσφέρει όλα αυτά (και όχι μόνο) τα πλεονεκτήματα, ηJavaαρχικά ήταν πιο αργή σε σχέση με άλλες προγραμματιστικές γλώσσες υψηλού επιπέδου (high-level) όπως ηC++. Εμπειρικές μετρήσεις στο παρελθόν είχαν δείξει ότι η C++ μπορούσε να είναι αρκετές φορές γρηγορότερη από την Java. Ωστόσο γίνονται προσπάθειες από τη Oracle για τη βελτιστοποίηση της εικονικής μηχανής, ενώ υπάρχουν και άλλες υλοποιήσεις της εικονικής μηχανής από διάφορες εταιρίες (όπως της IBM), οι οποίες μπορεί σε κάποια σημεία να προσφέρουν καλύτερα και σε κάποια άλλα χειρότερα αποτελέσματα. Επιπλέον με την καθιέρωση των μεταγλωττιστών JIT (Just In Time), οι οποίοι μετατρέπουν τον κώδικα byte απευθείας σε γλώσσα μηχανής, η διαφορά ταχύτητας από τη C++ έχει μικρύνει κατά πολύ.[4]Οι τελευταίες εκδόσεις του javac με τη χρήση της τεχνολογίας Hot Spot έχουν καταφέρει αξιόλογες επιδόσεις που πλησιάζουν ή και ξεπερνούν σε μερικές περιπτώσεις τον εγγενή κώδικα.[4]Κώδικας[Επεξεργασία|επεξεργασία κώδικα]Ως αντικειμενοστρεφής γλώσσα, η Java βασίζεται σε κλάσεις και αντικείμενα. Μια κλάση (class) είναι μια φόρμα για τη δημιουργία αντικειμένων (objects ή instances). Αφού πρώτα δημιουργηθεί μια κλάση, στη συνέχεια  μπορεί να χρησιμοποιηθεί για την παραγωγή αντικειμένων. Παρομοιάζοντας, θα μπορούσαμε να πούμε ότι η κλάση αποτελεί μια \"συνταγή\" για τη δημιουργία αντικειμένων. Μια κλάση περιγράφει μια οντότητα, για παράδειγμα η κλάση Student μπορεί να περιγράψει ένα φοιτητή, η κλάση Employee έναν εργαζόμενο, η κλάση Car ένα αυτοκίνητο κ.λπ. Μια κλάση περιλαμβάνει α) πεδία (fields) και β) μεθόδους (methods). Τα πεδία αντιστοιχούν σε ιδιότητες των αντικειμένων της κλάσης ενώ οι μέθοδοι επιτελούν λειτουργίες στα αντικείμενα της κλάσης. Κάθε μέλος μίας κλάσης, είτε πεδίο είτε μέθοδος, πρoσδιορίζεται από έναν προσδιοριστή προσπέλασης (access modifier). Υπάρχουν τέσσερεις προσδιοριστές προσπέλασης: private, package-private (με κενό μετρατροπέα), protect και public. Τα private μέλη είναι ορατά μόνο από την ίδια κλάση, τα package-private είναι ορατά από κλάσεις του ίδιου πακέτου, τα protected από κλάσεις του ίδιου πακέτου και από κλάσεις εκτός πακέτου που επεκτείνουν (extends) αυτήν την κλάση, είναι δηλαδή υποκλάσεις της. Τα public μέλη είναι ορατά από όλες τις κλάσεις της εφαρμογής.Έστω, για παράδειγμα, ότι θέλουμε να δημιουργήσουμε μια  κλάση η οποία να παριστά  την οντότητα  \"φοιτητής\" (Student) . Κάθε φοιτητής θα προσδιορίζεται από  δύο πεδία, το πεδίο code (κωδικός) και το πεδίο name (όνομα). Επιπλέον, η κλάση θα περιέχει μεθόδους  για ανάγνωση και τροποποίηση των πεδίων code και name  καθώς και μεθόδους για κατασκευή νέου αντικειμένου Student (κατασκευαστές). Ο κώδικας που ακολουθεί δημιουργεί την κλάση Student και περιέχει: α) Δύο πεδία, το αριθμητικό (int) πεδίο code και το αλφαριθμητικό (String). name β) Δύο κατασκευαστές, έναν χωρίς παραμέτρους και έναν με παραμέτρους τις code και name. γ) Δύο μεθόδους λήψης της τιμής των πεδίων (getters), τις getCode() και getName. δ) Δύο μεθόδους εκχώρησης τιμής (setters) στα πεδία code και name, τις setCode() και setName().publicclassStudent{privateintcode;privateStringname;//Kατασκευαστής της κλάσης χωρίς παραμέτρουςpublicStudent(){code=0;name=\"\";}//Kατασκευαστής της κλάσης με παραμέτρουςpublicStudent(intcode,Stringname){this.code=code;this.name=name;}//Η μέθοδος επιστρέφει τον κωδικόpublicintgetCode(){returncode;}//Η μέθοδος επιστρέφει το όνομαpublicStringgetName(){returnname;}//Η μέθοδος θέτει κωδικό σε ένα αντικείμενοpublicvoidsetCode(intcode){this.code=code;}//Η μέθοδος θέτει όνομα σε ένα αντικείμενοpublicvoidsetName(Stringname){this.name=name;}}Εργαλεία ανάπτυξης[Επεξεργασία|επεξεργασία κώδικα]Όλα τα εργαλεία που χρειάζεται κάποιος για να γράψει Java προγράμματα έρχονται δωρεάν, από το περιβάλλον ανάπτυξης μέχρι εργαλείαbuildόπως τοApache Antκαι βιβλιοθήκες, ενώ υπάρχουν πολλές διαφορετικές υλοποιήσεις τηςΕικονικής Μηχανήςκαι τουμεταγλωττιστή(π.χ.the GNU Compiler for Java) τηςJava.Πολλά εργαλεία και τεχνολογίες σε Java μπορούν να βρεθούν στοApache Software Foundationαλλά και στοJakarta Project.Ολοκληρωμένο περιβάλλον ανάπτυξης (IDE)[Επεξεργασία|επεξεργασία κώδικα]Για να να γράψει κάποιος κώδικα Java δε χρειάζεται τίποτα άλλο παρά έναν επεξεργαστή κειμένου, όπως το Σημειωματάριο (Notepad) των Windows ή οvi(γνωστός στο χώρο τουUnix). Παρόλ' αυτά, έναολοκληρωμένο περιβάλλον ανάπτυξης(IDE) βοηθάει πολύ, ιδιαίτερα στονεντοπισμό σφαλμάτων(debugging). Υπάρχουν αρκετά διαθέσιμα IDEs, ενώ πολλά από αυτά παρέχονται δωρεάν. Τα πιο γνωστά Ολοκληρωμένα Περιβάλλοντα Ανάπτυξης είναι το NetBeans της Apache, το Eclipse και το IntelliJ Idea της JetBrains.Δείτε επίσης[Επεξεργασία|επεξεργασία κώδικα]JARJava Platform, Enterprise EditionΠαραπομπές[Επεξεργασία|επεξεργασία κώδικα]↑(Αγγλικά) «JAVASOFT SHIPS JAVA 1.0». Ιστορική ανακοίνωση, που δημοσιεύθηκε στις 23/1/1996.↑Deitel, Paul· Deitel, Harvey (2015).Java Προγραμματισμός (Ελληνική Μετάφραση)(10η έκδοση). Αθήνα: Μ. Γκιούρδας. σελ. 19.ISBN978-960-512-681-0.↑(Αγγλικά) «The Java® Virtual Machine Specification, SE 7 Edition» από docs.oracle.com. Ανακτήθηκε 27/1/2018.↑4,04,1Horstmann C. 2015, βλ. πηγές σελ. 5-6, 7Πηγές[Επεξεργασία|επεξεργασία κώδικα]Cay S. Horstmann «Core Java, Volume I - Fundamentals» Tenth Edition, December 2015.Daniel Y. Liang \"Introduction to JAVA programming and data structures\" Twelfth Edition, 2020Εξωτερικοί σύνδεσμοι[Επεξεργασία|επεξεργασία κώδικα]Wikibooks logoΤα αγγλικά Βικιβιβλίαέχουν βιβλία που έχουν σχέση με τη:JavaCommons logoΤαWikimedia Commonsέχουν πολυμέσα σχετικά με το θέμαJavaJava Tutorial((Linux)),((Windows))Community((Linux)),((Windows))JavaστοCurlieIDE[Επεξεργασία|επεξεργασία κώδικα]NetBeans((Linux)),((Windows))Eclipse((Linux)),((Windows))jΕdit((Linux)),((Windows))JCreatorΑρχειοθετήθηκε2009-02-28 στοWayback Machine.((Windows))JΒuilderIntelliJ IDEAΟμάδες χρηστών Java (User Groups)[Επεξεργασία|επεξεργασία κώδικα]jugs κοινότηταjhug(ελληνική ομάδα χρηστών Java)bejug(βελγική ομάδα χρηστών Java)jugmilano(μιλανέζικη ομάδα χρηστών Java)egjug(αιγυπτιακή ομάδα χρηστών Java)πσεΓλώσσες προγραμματισμούAdaALGOLAPLApplescriptAssemblyBASICCC++C#COBOLErlangForthFortranGoHaskellJavaJavaScriptKotlinLispLogoLuaMLObjective-CPascalPerlPHPPrologPythonRRubyRustSQLShellSimulaSmalltalkSwiftVisual BasicπσεΕλεύθερο λογισμικόκαιλογισμικό ανοικτού κώδικαΓενικάCopyleft·Γεγονότα και βραβεία·Ελεύθερο λογισμικό·Ορισμός του Ελεύθερου Λογισμικού·Δωρεάν και ελεύθερο·Κατάλογος ελεύθερου λογισμικού και λογισμικού ανοιχτού κώδικα·Λογισμικό ανοικτού κώδικαΛειτουργικά συστήματαAROS·BSD·Darwin·eCos·FreeDOS·GNU·Haiku·Inferno·Linux·Mach·MINIX·OpenSolaris·Plan 9·ReactOS·SymbianΑνάπτυξη λογισμικούEclipse·Free Pascal·GCC·Gambas·Java·LLVM·Lua·NetBeans·Open64·Perl·PHP·Python·ROSE·Ruby·TclΙστορίαGNU·Haiku·Linux·Mozilla(Application Suite·Firefox·Thunderbird)ΟργανισμοίApache Software Foundation·Ίδρυμα Blender·Eclipse Foundation·freedesktop.org·Ίδρυμα Ελεύθερου Λογισμικού(Ευρώπη·India·Latin America) ·FSMI·GNOME Foundation·GNU Project·Google Code·KDE e.V.·Linux Foundation·Mozilla Foundation·Open Source Geospatial Foundation·Open Source Initiative·Python Software Foundation-Software Freedom Conservancy·SourceForge·Symbian Foundation·The Document Foundation·Xiph.Org Foundation·XMPP Standards Foundation·X.Org FoundationΆδειες ελεύθερου λογισμικούApache·Artistic·BSD·GNU GPL·GNU LGPL·ISC·MIT·MPL·Ms-PL/RL·zlib·FSF approved licensesΠρότυπα αδειών λογισμικούΟρισμός του Λογισμικού Ανοιχτού Κώδικα·Ορισμός του Ελεύθερου Λογισμικού·Debian Free Software GuidelinesΣημαντικά θέματαBinary blob·Canonical's contributor agreement·Digital rights management·Συμβατότητα καρτών γραφικών·License proliferation·Mozilla software rebranding·Proprietary software·Διαμάχη SCO-Linux·Ασφάλεια·Πατέντες λογισμικού·Περιορισμοί υλικού·Trusted Computing·Viral licenseΆλλα θέματαΕναλλακτικοί όροι·Κοινότητα·Διανομή Linux·Forking·Κίνημα·Microsoft Open Specification Promise·Revolution OS·Σύγκριση με λογισμικό κλειστού κώδικαΚαθιερωμένοι όροιLCCN:sh95008574GND:4401313-9BNF:cb12533207m(data)NKC:ph117027BNE:XX540033Πύλη:Προγραμματισμός"
    },
    {
        "url": "https://el.wikipedia.org/wiki/C_(%CE%B3%CE%BB%CF%8E%CF%83%CF%83%CE%B1_%CF%80%CF%81%CE%BF%CE%B3%CF%81%CE%B1%CE%BC%CE%BC%CE%B1%CF%84%CE%B9%CF%83%CE%BC%CE%BF%CF%8D)",
        "title": "C (γλώσσα προγραμματισμού)",
        "content": "ΗCείναιδιαδικαστικήγλώσσα προγραμματισμούγενικής χρήσης, η οποία αναπτύχθηκε αρχικά, μεταξύ του 1969 και του 1973, από τονΝτένις Ρίτσιστα εργαστήρια AT&T Bell Labs για να χρησιμοποιηθεί για την ανάπτυξη του λειτουργικού συστήματοςUNIX. Όπως οι περισσότερες διαδικαστικές γλώσσες προγραμματισμού που ακολουθούν την παράδοση τηςALGOL, η C έχει δυνατότητες δομημένου προγραμματισμού και επιτρέπει τη χρήση αναδρομής (αλλά όχι καιεμφωλευμένων συναρτήσεων), ενώ, ο στατικός ορισμός του τύπου των μεταβλητών που επιβάλλει, προλαμβάνει πολλά σφάλματα κατά την χρήση τους. Ο σχεδιασμός της περιλαμβάνει δομές που μεταφράζονται αποδοτικά σε τυπικές εντολές μηχανής (machine instructions) και εξ αιτίας αυτού χρησιμοποιείται συχνά σε εφαρμογές που παλιότερα γράφονταν σεσυμβολική γλώσσα(assembly language). Αυτό ακριβώς το χαρακτηριστικό της, που έχει σαν συνέπεια και την αυξημένη ταχύτητα εκτέλεσης των εφαρμογών που γράφονται σε αυτή, καθώς και το γεγονός ότι είναι διαθέσιμη στα περισσότερα σημερινάλειτουργικά συστήματα, συνέβαλε κατά πολύ στην καθιέρωση της και την χρήση της για ανάπτυξηλειτουργικών συστημάτωνκαι λοιπών προγραμμάτων συστήματος (system software), αλλά και απλών εφαρμογών.Η C συγκαταλέγεται πλέον στις πιο ευρέως χρησιμοποιούμενες γλώσσες προγραμματισμού όλων των εποχών και πολλές νεώτερες γλώσσες έχουν επηρεαστεί άμεσα ή έμμεσα από αυτήν, συμπεριλαμβανομένων τωνC++,C#, D, Go,Java,JavaScript, Limbo, LPC,Perl,PHP,Python, καθώς και τουκελύφους C(C shell) του Unix. Κάποιες από αυτές τις γλώσσες έχουν επηρεαστεί κυρίως στη σύνταξη τους, με το σύστημα τύπων, τα μοντέλα δεδομένων και το νόημα των εκφράσεων τους να διαφέρουν σημαντικά από την C. Η C++, ειδικά, ξεκίνησε σανπροεπεξεργαστήςτης C, αλλά έχει εξελιχθεί πλέον σε μια αντικειμενοστραφή γλώσσα, που αποτελεί υπερσύνολο της C.Φιλοσοφία[Επεξεργασία|επεξεργασία κώδικα]Η C είναι μια σχετικά μινιμαλιστικήγλώσσα προγραμματισμού. Ανάμεσα στους σχεδιαστικούς στόχους που έπρεπε να καλύψει η γλώσσα περιλαμβανόταν το ότι θα μπορούσε ναμεταγλωττιστείάμεσα με τη χρήση μεταγλωττιστή ενός περάσματος (single-pass compiler) — με άλλα λόγια, ότι θα απαιτούνταν μόνο ένας μικρός αριθμός από εντολές σεγλώσσα μηχανήςγια κάθε βασικό στοιχείο της, χωρίς εκτεταμένη υποστήριξη στον χρόνο εκτέλεσης. Ως αποτέλεσμα, είναι δυνατό να γραφτεί κώδικας σε C σε χαμηλό επίπεδο προγραμματισμού με ακρίβεια ανάλογη τηςσυμβολικής γλώσσας, στην πραγματικότητα η C ορισμένες φορές αποκαλείται (και χωρίς να υπάρχει πάντα αντιπαράθεση) «συμβολική γλώσσα υψηλού επιπέδου» («high-level assembly») ή «φορητή συμβολική γλώσσα» («portable assembly»). Επίσης, γίνονται αναφορές στη C ωςγλώσσα προγραμματισμού μεσαίου επιπέδου.Χαρακτηριστικά[Επεξεργασία|επεξεργασία κώδικα]Στη C δεν επιβάλλεται κάποια συγκεκριμένη μορφή στον πηγαίο κώδικα (όπως, για παράδειγμα, συνέβαινε στις αρχικές εκδόσεις τηςFortran). Ο προγραμματιστής, χωρίς να αγνοεί φυσικά το συντακτικό της γλώσσας, είναι ελεύθερος να δώσει όποια μορφή θέλει στον κώδικα που γράφει (free-format source). Το ελληνικό ερωτηματικό (;) (σύμβολο U+003B, όχι U+037E) χρησιμοποιείται ως τερματιστής εντολών (και όχι ως διαχωριστής, όπως στηνPascal, παραδείγματος χάριν) και τα άγκιστρα ({}) χρησιμοποιούνται για την ομαδοποίηση εντολών (όπως τα begin/end στην Pascal).Ακόμα, στη C όλος ο εκτελέσιμος κώδικας περιέχεται σευπορουτίνεςοι οποίες ονομάζονται «συναρτήσεις» (όχι με την αυστηρή έννοια του συναρτησιακού προγραμματισμού). Οιπαράμετροιπερνιούνται στις συναρτήσεις πάντα με τιμή (pass-by-value). Το πέρασμα με αναφορά (pass-by-reference) γίνεται έμμεσα στην ουσία, περνώντας, ως παραμέτρους των συναρτήσεων, δείκτες στις μεταβλητές των οποίων θέλουμε να αλλάζουμε τις τιμές μέσα από τις συναρτήσεις.Η C έχει ακόμα τα εξής χαρακτηριστικά:Έχει ένα πολύ μικρό σταθερό πλήθος λέξεων-κλειδιών (keywords), το οποίο περιλαμβάνει ένα πλήρες σύνολο δομών/εντολών ελέγχου ροής: for, if/else, while, switch, και do/while, goto.Υπάρχει μόνο ένας χώρος ονομάτων (namespace) και τα ονόματα (μεταβλητών, συναρτήσεων, κ.τ.λ.) που ορίζονται από το χρήστη δεν διακρίνονται με κάποιο τρόπο από τις λέξεις-κλειδιά της γλώσσας.Υπάρχει ένα μεγάλο πλήθος αριθμητικών, σχεσιακών και λογικών τελεστών, όπως οι: +, +=, ++, -, -=, --, *, *=, /, /=, ==, >,>=, <, <=, !=, &, &&, |, ||, ~, κ.ά.Σε μία εντολή μπορεί να γίνουν παραπάνω από μια εκχωρήσεις τιμών.Η τιμή που επιστρέφει μια συνάρτηση, μπορεί να αγνοηθεί εάν δεν χρειάζεται.Ο ορισμός των τύπων των μεταβλητών είναι στατικός και απαραίτητος, αλλά γίνονται έμμεσες μετατροπές από τη γλώσσα. Για παράδειγμα, παραστάσεις με τύπο χαρακτήρα μπορούν να χρησιμοποιηθούν σε σημεία που απαιτείται ακέραιος.Η σύνταξη των δηλώσεων ονομάτων προσομοιάζει την χρήση αυτών μέσα στον εκτελέσιμο κώδικα. Η C δεν έχει ειδική λέξη-κλειδί για τον ορισμό ονομάτων (όπως είναι η \"var\" στην Pascal, για παράδειγμα) ή συναρτήσεων (όπως η \"function\", πάλι στην Pascal). Μια γραμμή που ξεκινάει με το όνομα ενός τύπου, εκλαμβάνεται σαν ορισμός μεταβλητής ή συνάρτησης, ανάλογα με τον αν υπάρχουν, ή όχι, παρενθέσεις που περικλείουν (τυπικές) παραμέτρους συνάρτησης.Ο χρήστης μπορεί να ορίσει δικούς του τύπους (και σύνθετους), εάν το επιθυμεί. Μπορεί επίσης να ορίσει και τύπουςεγγραφών(structs στη C, records σε άλλες γλώσσες).Μπορούν να οριστούνπίνακες, αν και δεν υπάρχει ειδική λέξη-κλειδί για τον ορισμό τους (όπως το \"array\" στην Pascal). Η δεικτοδότηση τους γίνεται με χρήση αγκυλών ([]), αν και πολύ συχνά γίνεται χρήση αριθμητικής δεικτών. Το πρώτο στοιχείο κάθε πίνακα δεικτοδοτείται πάντα από το μηδέν (0). Π.χ.: Το στοιχείο month[0] είναι το πρώτο στοιχείο του πίνακα month. Τέλος, δεν υπάρχουν τελεστές για την σύγκριση ή εκχώρηση πινάκων.Είναι δυνατή η δημιουργία απαριθμήσιμων τύπων με τη χρήση της λέξης-κλειδί \"enum\", οι οποίοι μπορούν να χρησιμοποιηθούν όπου οι ακέραιοι και αντίστροφα.Δεν υπάρχει ιδιαίτερος τύπος γιααλφαριθμητικά, τα οποία παραδοσιακά υλοποιούνται και αντιμετωπίζονται σαν πίνακες από χαρακτήρες, και έχουν έναν μηδενικό χαρακτήρα να σημαδεύει το τέλος τους (null-terminated arrays of characters).Είναι δυνατή η άμεση προσπέλαση χαμηλού επιπέδου στη μνήμη του υπολογιστή με τη χρήσηδεικτών.Οι υπορουτίνες που δεν επιστρέφουν τιμή (\"procedures\" σε άλλες γλώσσες) είναι συναρτήσεις που ορίζονται να είναι τύπου \"void\" (ψευδοτύπος που δείχνει την απουσία επιστρεφόμενης τιμής, αλλά χρησιμοποιείται και για δείκτες που δεν δείχνουν σε αντικείμενο συγκεκριμένου τύπου).Δεν μπορούν να οριστούν συναρτήσεις μέσα σε άλλες συναρτήσεις (εμφωλιασμένες).Οι δείκτες σε συναρτήσεις και δεδομένα επιτρέπουν την υλοποίησηπολυμορφισμούστην πράξη.Ο προεπεξεργαστής της γλώσσας επιτρέπει τον ορισμό μακροεντολών, την συγχώνευση αρχείων πηγαίου κώδικα, καθώς και την μεταγλώττιση υπό συνθήκες.Αρχεία πηγαίου κώδικα μπορούν να μεταγλωττιστούν χωριστά και να συνδεθούν μαζί, ενώ υπάρχει η δυνατότητα ελέγχου της ορατότητας συναρτήσεων και μεταβλητών στα αλλα αρχεία (πέρα από αυτό στο οποίο ορίζονται) με το χαρακτηρισμό τους ως \"static\" ή \"extern\".Οι πολύπλοκες λειτουργίες, όπως οι λειτουργίες εισόδου/εξόδου, ο χειρισμός των αλφαριθμητικών, καθώς και οι μαθηματικές συναρτήσεις, έχουν ανατεθεί, με συνεπή τρόπο, στις αντίστοιχεςβιβλιοθήκες.Η C δεν διαθέτει κάποιες από τις δυνατότητες νεώτερων γλωσσών, όπως τον προσανατολισμό στα αντικείμενα και την συλλογή απορριμάτων (garbage collection).Ιστορία[Επεξεργασία|επεξεργασία κώδικα]Πρώιμη ανάπτυξη[Επεξεργασία|επεξεργασία κώδικα]Σε πρώτη φάση,η C αναπτύχθηκε σταAT&T Bell Labsανάμεσα στο 1969 και το 1973, σύμφωνα με τον D. Ritchie, η πιο δημιουργική περίοδος υπήρξε το 1972. Η νέα γλώσσα ονομάστηκε \"C\" λόγω του ότι πολλά από τα χαρακτηριστικά της προήλθαν από μια παλαιότερη γλώσσα, η οποία ονομαζόταν \"B\". Οι πηγές δεν επιτρέπουν την πλήρη εξακρίβωση για την προέλευση του ονόματος \"B\" : οKen Thompsonτο παρουσιάζει ως απλούστευση μιας έκδοσης της γλώσσας προγραμματισμού BCPL, αλλά είχε επίσης δημιουργήσει μία γλώσσα που ονομαζόταν Bon προς τιμήν της συζύγου του Bonnie.Μέχρι το 1973, η C είχε γίνει αρκετά ισχυρή και αποτελεσματική, ώστε το μεγαλύτερο μέρος του πυρήνα του UNIX (UNIX kernel), γραμμένο αρχικά σε PDP-11/20 assembly, επανεγγράφηκε σε C. Ήταν ένας από τους πρώτους πυρήνες που υλοποιήθηκε σε μια γλώσσα διαφορετική της assembly. (Προηγούμενα παραδείγματα περιλαμβάνουν το Multics system (γραμμένο σε PL/I), και το MCP (Master Control Program) για το Burroughs B5000 γραμμένο σεALGOLτο 1961.)K&R C[Επεξεργασία|επεξεργασία κώδικα]Το 1978, οDennis Ritchieκαι οBrian Kernighanδημοσίευσαν την πρώτη έκδοση του βιβλίου\"The C Programming Language\". Το συγκεκριμένο βιβλίο, γνωστό στους προγραμματιστές της C ως \"K&R\", χρησίμευσε πολλά χρόνια σαν ανεπίσημος ορισμός της γλώσσας. Η έκδοση της C που περιγράφει αναφέρεται συνήθως ως \"K&R C.\" ή \"Common C\". (Η δεύτερη έκδοση του βιβλίου καλύπτει το μεταγενέστερο πρότυπο ANSI για τη C (ANSI C standard), βλ. συνέχεια.)Το K&R εισήγαγε τα παρακάτω χαρακτηριστικά στη γλώσσα:Τύποι δεδομένων: ενώσεις (union), τύποι ακεραίων (long int,unsigned int)Ο τελεστής (operator)=+αλλάχθηκε σε+=για να αποφευχθούν σημασιολογικά διφορούμενες εκφράσεις όπως ηi=+10, που μπορούσε να ερμηνευθεί είτε σανi =+ 10είτε σανi = +10.Η K&R C συχνά λογίζεται ως το βασικό μέρος της γλώσσας που πρέπει να υποστηρίζει έναςμεταγλωττιστήςτης C. Για αρκετά χρόνια, ακόμη και μετά την εισαγωγή της ANSI C, θεωρούνταν ο \"ελάχιστος συνήθης παρονομαστής\" στον οποίο έπρεπε να προσαρμοστούν οι προγραμματιστές της C σε περιπτώσεις κατά τις οποίες ήταν επιθυμητή η μέγιστη μεταφερσιμότητα (portability), καθώς δεν είχαν ενημερωθεί όλοι οι μεταγλωττιστές για πλήρη υποστήριξη της ANSI C. Επίσης, με προσοχή, ο κώδικας σε K&R C μπορούσε να γραφεί ώστε να είναι σύμφωνος και με το πρότυπο ANSI.ANSI C[Επεξεργασία|επεξεργασία κώδικα]Το 1983, τοAmerican National Standards Institute(ANSI) όρισε επιτροπή, τη X3J11, για να δώσει ένα σύγχρονο, πλήρη ορισμό της C. Μετά από μακρά και επίπονη επεξεργασία, το πρότυπο (standard) ολοκληρώθηκε το 1989 και επικυρώθηκε ως ANSI X3.159-1989 \"Programming Language C\". Η συγκεκριμένη έκδοση της γλώσσας ονομάζεται συχνά ANSI C ή, ορισμένες φορές, C89 (για να διαχωρίζεται από τη C99).Το 1990, το πρότυπο ANSI για τη C (με ορισμένες μικρές τροποποιήσεις) υιοθετήθηκε από τον Οργανισμό Διεθνών Προτύπων (International Organization for Standardization (ISO)) ως ISO/IEC 9899:1990. Αυτή η έκδοση καλείται C90. Επομένως, οι όροι \"C89\" και \"C90\" αναφέρονται ουσιαστικά στην ίδια γλώσσα.Ένας από τους στόχους της διαδικασίας δημιουργίας του προτύπου ANSI για τη C ήταν να δημιουργήσει ένα υπερσύνολο της K&R C, το οποίο θα απορροφούσε πολλά χαρακτηριστικά που είχαν εισαχθεί στην πορεία. Παρόλα αυτά, η επιτροπή συμπεριέλαβε και ορισμένα νέα χαρακτηριστικά, όπως function prototypes (δανεισμένα από τη C++), και ένα πιο ικανόπροεπεξεργαστή (preprocessor). Ησύνταξηγια τους ορισμούς παραμέτρων άλλαξε επίσης, ώστε να αντικατοπτρίζει το στυλ της C++.C99[Επεξεργασία|επεξεργασία κώδικα]Μετά τη διαδικασία καθορισμού του προτύπου ANSI, ο ορισμός της γλώσσας C παρέμενε σχετικά σταθερός για ορισμένο καιρό, ενώ ηC++συνέχιζε να αναπτύσσεται. (Normative Amendment 1 δημιούργησε μία νέα έκδοση της γλώσσας C το 1995, αλλά σπάνια είναι γνωστή.) Ωστόσο, το πρότυπο επανεξετάστηκε προς το τέλος της δεκαετίας του '90, γεγονός που οδήγησε στην έκδοση του ISO 9899:1999 το 1999.\nΤο πρότυπο αυτό συχνά αναφέρεται ως \"C99\". Υιοθετήθηκε ως πρότυπο ANSI το Μάρτιο του 2000.ΟGCCκαι μερικοί άλλοι C compilers υποστηρίζουν πλέον τα περισσότερα χαρακτηριστικά του C99. Ωστόσο, υπάρχει μικρότερη υποστήριξη από εταιρίες όπως ηMicrosoftκαι ηBorlandπου εστίασαν περισσότερο στη C++, καθώς η C++ παρέχει παρόμοια λειτουργικότητα και συχνά ασύμβατους τρόπους (π.χ., ηcomplextemplate class). Ο Brandon Bray από τη Microsoft είπε \"Σε γενικές γραμμές, έχουμε δει μικρές απαιτήσεις για πολλά χαρακτηριστικά του C99. Μερικά χαρακτηριστικά έχουν μεγαλύτερη ζήτηση από άλλα, και θα τη λάβουμε υπόψιν μας σε μελλοντικές εκδόσεις εφόσον είναι συμβατά με τη C++.\"[1]Ακόμη και ο GCC με την εκτεταμένη υποστήριξη του C99 ακόμη δεν προσεγγίζει μια πλήρως συμβατή υλοποίηση, ορισμένα χαρακτηριστικά-κλειδιά λείπουν ή δεν λειτουργούν σωστά.[2]C11[Επεξεργασία|επεξεργασία κώδικα]Το 2007 άρχισαν οι εργασίες για μια ακόμα αναθεώρηση του προτύπου της C, ανεπίσημα αποκαλούμενο \"C1X\" ως και την επίσημη δημοσίευση του στις 8/12/2011. Η επιτροπή προτύπων της C έθεσε ως κατευθυντήριες γραμμές τον περιορισμό υιοθεσίας νέων χαρακτηριστικών τα οποία δεν έχουν δοκιμαστεί απο υπάρχουσες υλοποιήσεις.Το πρότυπο C11 προσθέτει πολυάριθμα χαρακτηριστικά στην C και στην βιβλιοθήκη συμπεριλαμβομένων type generic macros, anonymoys structures, βελτιωμένη υποστήριξη Unicode, atomic operations, multi-threading και συναρτήσεις bounds-checked. Επίσης κάνεις κάποιες προαιρετικές αναθεωρήσεις στην βιβλιοθήκη του C99 και βελτιώνει την συμβατότητα με την C++. Η πρότυπη μάκρο __STDC_VERSION__ προσδιορίζεται ως 201112L για να δηλώσει οτί η υποστήριξη για το C11 είναι διαθέσιμη.C18[Επεξεργασία|επεξεργασία κώδικα]Δημοσιευμένο το Ιούνιο του 2018, το C18 είναι το τρέχον πρότυπο για τη γλώσσα προγραμματισμού C. Δεν εισάγει νέα χαρακτηριστικά στη γλώσσα αλλά μόνο τεχνικές διορθώσεις και διευκρινίσεις σε ατέλειες του προτύπου C11. Η πρότυπη μάκρο __STDC_VERSION__ προσδιορίζεται ως 201710L.C23[Επεξεργασία|επεξεργασία κώδικα]C23 είναι το ανεπίσημο όνομα του επόμενου προτύπου που θα διαδεχθεί το C17. Αναμένεται να εκδοθεί μέσα στο 2024.[3]Παράδειγμα \"Hello world\"[Επεξεργασία|επεξεργασία κώδικα]Πρόγραμμα σε C που εκτυπώνει στο τερματικό \"Hello world!\":#include<stdio.h>intmain(){printf(\"Hello world!\");return0;}Αναφορές[Επεξεργασία|επεξεργασία κώδικα]↑[1]↑http://gcc.gnu.org/c99status.html↑https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3132.pdfΔείτε επίσης[Επεξεργασία|επεξεργασία κώδικα]C πρότυπη βιβλιοθήκηC++C είσοδος/έξοδος αρχείωνΒιβλία[Επεξεργασία|επεξεργασία κώδικα]Brian W. Kernighan, Dennis M. Ritchie. \"Η Γλώσσα Προγραμματισμού C\", Prentice-Hall (Ελληνική μετάφραση, εκδόσεις Κλειδάριθμος), 1988.Νίκος Μ. Χατζηγιαννάκης. \"Η γλώσσα C σε βάθος\", Εκδόσεις Κλειδάριθμος (Ελληνικά)http://c.bytes.grΚωνσταντίνος Φ. Γραίκας. \"Γραμματική και Συντακτικό της ANSI C\". Εκδόσεις Κλειδάριθμος 2007, σελ. 296.Δημήτριος Καρολίδης. \"Μαθαίνετε εύκολα C\",Εκδόσεις Άβακας, 2013.Γεώργιος Σ. Τσελίκης, Νικόλαος Δ. Τσελίκας \"C: Από τη Θεωρία στην Εφαρμογή\"], Δ' Έκδοση, 2023, σελ. 888,ISBN 978-618-86762-0-6.www.c4all.gr/Θεόδωρος Αλεβίζος. \"Προγραμματισμός με τη γλώσσα C++\", 2015 (Διαθέσιμο δωρεάν)Πάρις Μαστοροκώστας. \"Διαδικαστικός προγραμματισμός – Η γλώσσα C\", 2015. (Διαθέσιμο δωρεάν)Εξωτερικοί σύνδεσμοι[Επεξεργασία|επεξεργασία κώδικα]Commons logoΤαWikimedia Commonsέχουν πολυμέσα σχετικά με το θέμαC (γλώσσα προγραμματισμού)Wikiversity logoΣτoΒικιεπιστήμιουπάρχει ή αναπτύσσεται εκπαιδευτικό υλικό για αυτό το θέμα:C (γλώσσα προγραμματισμού)ΤαΒικιβιβλίαέχουν\n      ένα βιβλίο σχετικά, με τίτλοΕισαγωγή στην C και C++ σε Ολοκληρωμένο Περιβάλλον Δημιουργίας ΛογισμικούC programming— Εγχειρίδιο της C για αρχάριους(Αγγλικά)Programming in C : A tutorial— Εγχειρίδιο της C από τον Brian Kernighan (σε pdf)(Αγγλικά)Από τη B στη C(Αγγλικά)[2]- Το άρθρο της αγγλικής Wikipedia για τη C.(Αγγλικά)C (γλώσσα προγραμματισμού)στοCurlieπσεΓλώσσες προγραμματισμούAdaALGOLAPLApplescriptAssemblyBASICCC++C#COBOLErlangForthFortranGoHaskellJavaJavaScriptKotlinLispLogoLuaMLObjective-CPascalPerlPHPPrologPythonRRubyRustSQLShellSimulaSmalltalkSwiftVisual BasicΚαθιερωμένοι όροιLCCN:sh85018532GND:4113195-2SUDOC:027672441BNF:cb119665180(data)NKC:ph116955Πύλη:ΠρογραμματισμόςΑυτό το  λήμμα σχετικά με τηνΠληροφορικήχρειάζεταιεπέκταση. Μπορείτε να βοηθήσετε την Βικιπαίδειαεπεκτείνοντάς το.''"
    },
    {
        "url": "https://el.wikipedia.org/wiki/%CE%9B%CE%B5%CE%B9%CF%84%CE%BF%CF%85%CF%81%CE%B3%CE%B9%CE%BA%CF%8C_%CF%83%CF%8D%CF%83%CF%84%CE%B7%CE%BC%CE%B1",
        "title": "Λειτουργικό σύστημα",
        "content": "Τυπική θέση του λειτουργικού συστήματος σε ένα υπολογιστικό σύστημαΛειτουργικό σύστημα(αγγλικά: Operating System ή OS) ονομάζεται στην επιστήμη τηςπληροφορικήςτολογισμικότουυπολογιστήπου είναι υπεύθυνο για τη διαχείριση και τον συντονισμό των εργασιών, καθώς και την κατανομή των διαθέσιμων πόρων  .[1]Το λειτουργικό σύστημα παρέχει ένα θεμέλιο, ένα μεσολαβητικό επίπεδο λογικής διασύνδεσης μεταξύ λογισμικού καιυλικού, διαμέσου του οποίου οιεφαρμογέςαντιλαμβάνονται εμμέσως τον υπολογιστή.[2]Μια από τις κεντρικές αρμοδιότητες του λειτουργικού συστήματος είναι η διαχείριση του υλικού, απαλλάσσοντας έτσι το λογισμικό του χρήστη από τον άμεσο και επίπονο χειρισμό του υπολογιστή και καθιστώντας ευκολότερο τον προγραμματισμό τους. Σχεδόν όλοι οι υπολογιστές (παλάμης,επιτραπέζιοι,υπερυπολογιστές, ακόμη καιπαιχνιδομηχανές) χρησιμοποιούν έναν τύπο λειτουργικού συστήματος. Ορισμένα παλαιότερα μοντέλα ωστόσο βασίζονται σε ένα ενσωματωμένο λειτουργικό σύστημα, το οποίο περιέχεται σε ένανοπτικό δίσκοή άλλες συσκευές αποθήκευσης δεδομένων.Ως λειτουργικό σύστημα (ΛΣ) χαρακτηρίζεται μία συλλογή βασικώνπρογραμμάτων[3], η οποία ελέγχει τη λειτουργία του υπολογιστή συνολικά και χρησιμοποιείται ως υπόβαθρο για την εκτέλεση όλων των υπόλοιπων προγραμμάτων, τη διαχείριση τωνπεριφερειακών συσκευώνκαι την εξασφάλιση της επικοινωνίας μεταξύ χρήστη και υπολογιστή. Στην πράξη πρόκειται για ένα επίπεδο λογισμικού που μεσολαβεί μεταξύ του υλικού και των εκτελούμενων προγραμμάτων σε έναν ηλεκτρονικό υπολογιστή. Αποτελείται από ένα σύνολο μηχανισμών μέσω των οποίων επιτυγχάνεται αυτόματη διαχείριση των πόρων ενός υπολογιστή και ελεγχόμενη κατανομή τους στις εκτελούμενες εφαρμογές, έτσι ώστε οι τελευταίες να είναι σε θέση να προσπελάσουν εύκολα τους πόρους και τις συσκευές του συστήματος χωρίς να χρειάζεται να γνωρίζουν με ακρίβεια τη δομή του υποκείμενου υλικού, αλλά και ώστε πολλαπλές εφαρμογές να μπορούν να εκτελούνταιταυτόχροναχωρίς να έρχονται σε διένεξη μεταξύ τους ή με τον υπολογιστή.Οι πρώιμοι υπολογιστές στερούνταν λειτουργικού συστήματος. Ένας άνθρωπος 'χειριστής'(operator) φόρτωνε τα προγράμματα στη μνήμη του υπολογιστή και φρόντιζε για την εκτέλεσή τους, εξ ου και το όνομα του λογισμικού συστήματος το οποίο αντικατέστησε τις ανθρώπινες αυτές ενέργειες (Operating System). Με το μεσολαβητικό επίπεδο διασύνδεσης που προσφέρει το ΛΣ, οι εφαρμογές μπορούν να αξιοποιούν εύκολα τημνήμη, τονεπεξεργαστή, τοσύστημα αρχείωνκαι τις περιφερειακές συσκευές. Δηλαδή το ΛΣ δημιουργεί ένα απλουστευμένο εικονικό περιβάλλον μέσα στο οποίο εκτελούνται οι εφαρμογές. Οι τελευταίες, μέσα από κάποια συγκεκριμένη και τυποποιημένηπρογραμματιστική διασύνδεσηπου τους προσφέρει το ΛΣ, τιςκλήσεις συστήματος, διαμορφώνουν αυστηρά συμμορφούμενα με αυτήν τη διασύνδεση αιτήματα για να αποκτήσουν πόρους, προκειμένου να φέρουν εις πέρας τις εργασίες που ζητά ο χρήστης[3].ΣταPCτο ΛΣ είναι το πρώτο λογισμικό που «φορτώνεται» στη μνήμη του υπολογιστή μετά την εκτέλεση τουBIOS. Οποιοδήποτε λογισμικό φορτωθεί στη συνέχεια βασίζεται στο ΛΣ για την παροχή όλων των υπηρεσιών οι οποίες απαιτούν πρόσβαση στο υλικό.Υπηρεσίες[Επεξεργασία|επεξεργασία κώδικα]Το λειτουργικό σύστημα περιέχει κώδικα χαμηλού επιπέδου, αποκλειστικά για την αρχιτεκτονική του επεξεργαστή στην οποία εκτελείται (γραμμένο είτε σε κάποια κατάλληλη γλώσσα προγραμματισμού υψηλού επιπέδου, όπως ηC, είτε απευθείας σεσυμβολική γλώσσα), ο οποίος αναλαμβάνει την υλοποίηση όλων αυτών των μηχανισμών. Ο εν λόγω κώδικας, ο οποίος κατά την κανονική λειτουργία του υπολογιστή είναι αποθηκευμένος στη μνήμη, ονομάζεται «πυρήνας» και ο κώδικας των εκτελούμενων εφαρμογών («κώδικας χρήστη») δεν έχει άμεση πρόσβαση σε αυτόν. Ο πυρήνας όμως παρέχει μία προγραμματιστική διασύνδεση, τις κλήσεις συστήματος που προαναφέρθηκαν, με την οποία τα προγράμματα χρήστη μπορούν να καλούν με ελεγχόμενο τρόποδιαδικασίεςπου εξάγει ο πυρήνας και παρέχουν υπηρεσίες στον καλούντα. Η σύνταξη, η σημασιολογία και η ονοματολογία των κλήσεων συστήματος διαφέρει από ΛΣ σε ΛΣ, με αποτέλεσμα ένα εκτελέσιμο πρόγραμμα συνήθως να μπορεί να τρέξει μόνο σε  Ο κώδικας χρήστη δεν μπορεί να προσπελάσει μόνος του τους πόρους του υπολογιστή (π.χ. δίσκους, μνήμη συστήματος, περιφερειακά, δίκτυο κλπ) αλλά μπορεί να ζητήσει ό,τι χρειάζεται (π.χ. άνοιγμα ενός αρχείου στον δίσκο) από τον πυρήνα μέσω των κλήσεων συστήματος.Οι βασικοί μηχανισμοί ενός λειτουργικού συστήματος αφορούν τη διαχείριση της εκτέλεσης των προγραμμάτων χρήστη (μέσω του μηχανισμού τωνδιεργασιώνκαι - στα συστήματα τα οποία υποστηρίζουν ταυτοχρονισμό / πολυδιεργασία / πολυπρογραμματισμό - του κατάλληλουχρονοπρογραμματισμούτους), της επικοινωνίας μεταξύ τους (μέσω των μηχανισμώνεικονικής μνήμηςκαιδιαδιεργασιακής επικοινωνίας) και των δεδομένων που αυτές χρησιμοποιούν (μέσω τουσυστήματος αρχείων). Με τον τρόπο που είναι υλοποιημένοι οι εν λόγω μηχανισμοί διασφαλίζουν συνήθως τόσο την ασφάλεια του πυρήνα απέναντι στον κώδικα χρήστη, όσο και την ασφάλεια μεταξύ των προγραμμάτων χρήστη, ώστε κανένα να μην παρεμποδίζει ή να επηρεάζει αρνητικά την πρόσβαση των άλλων στους πόρους του συστήματος.Διαχείριση διεργασιών[Επεξεργασία|επεξεργασία κώδικα]Ένα πρόγραμμα που εκτελείται στον υπολογιστή συνιστά μία ή περισσότερεςδιεργασίες. Πρόκειται για το βασικό μέσο εκτέλεσης προγραμμάτων σε ένα συνηθισμένο ΛΣ. Ο ίδιος κώδικας / πρόγραμμα μπορεί να εκτελείται ταυτόχρονα μέσα από πολλές διαφορετικές διεργασίες οι οποίες μπορεί να ανήκουν σε διαφορετικούς χρήστες. Στα πλαίσια της σειριακήςαρχιτεκτονικής φον Νόιμανκαι των υπολογιστών που έχουν οικοδομηθεί με βάση αυτήν, μόνο μια διεργασία μπορεί να εκτελείται στην ΚΜΕ (Κεντρική Μονάδα Επεξεργασίας) οποιαδήποτε χρονική στιγμή[3]· επομένως οι ποικίλες διεργασίες οι οποίες είναι ταυτόχρονα ενεργές εκτελούνται ψευδοπαράλληλα, με διαδοχική εναλλαγή του επεξεργαστή μεταξύ τους κάθε λίγη ώρα. Σε έναπαράλληλο σύστημα, όπου υπάρχουν πολλαπλοί επεξεργαστές, ο ταυτοχρονισμός / πολυδιεργασία μπορούν να υλοποιηθούν πραγματικά παράλληλα. Σε κάθε περίπτωση, το τμήμα του πυρήνα το οποίο λαμβάνει διάφορες αποφάσεις σχετικά με την ανάθεση των ΚΜΕ στις διάφορες διεργασίες ονομάζεταιχρονοπρογραμματιστής.Διαχείριση μνήμης[Επεξεργασία|επεξεργασία κώδικα]Στις σύγχρονες αρχιτεκτονικές υπολογιστών η μνήμη είναι οργανωμένηιεραρχικά.\nΑρχίζοντας από την ταχύτερη:καταχωρητές,κρυφή μνήμη,κύρια μνήμηκαιδευτερεύουσα μνήμη(π. χ.σκληροί δίσκοι). Το τμήμα εκείνο του ΛΣ που καλείταιδιαχειριστής μνήμηςσυντονίζει τη χρήση των διαφόρων τύπων μνήμης, καταγράφοντας ποια τμήματά τους είναι διαθέσιμα, ποια είναι δεσμευμένα και, αναλόγως με τις απαιτήσεις τωνδιεργασιών, εκχωρεί ή απελευθερώνει τμήματα για να τα χρησιμοποιήσουν οι τελευταίες. Αυτή η δραστηριότητα λέγεται διαχείρισηεικονικής μνήμης,[1]αφού η συνολική μνήμη που είναι σε θέση να αξιοποιήσουν οι διεργασίες κατά την εκτέλεσή τους μπορεί να υπερβαίνει το μέγεθος της κύριας μνήμης (της φυσικής μνήμηςRAM), μέσω της δέσμευσης ενός τμήματος του σκληρού δίσκου από τον πυρήνα το οποίο χρησιμοποιείται από τον τελευταίο σαν επέκταση της κύριας μνήμης. Τα προηγμένα Λ.Σ. αποφεύγουν, όπου και όταν είναι δυνατό, τη χρήση αυτής της τεχνικής, επειδή η χρήση δευτερεύουσας μνήμης ως κύριας μειώνει την ταχύτητα του συστήματος.Συστήματα αρχείων[Επεξεργασία|επεξεργασία κώδικα]Το τμήμα του ΛΣ που ονομάζεται διαχειριστής συστήματοςαρχείωνδημιουργεί τηναφαιρετική έννοιατων αρχείων και των δένδρωνκαταλόγων. Έτσι ο χρήστης και οι εφαρμογές του έχουν τη δυνατότητα να βλέπουν τη δευτερεύουσα μνήμη σαν ένα σύνολο από αρχεία, τα οποία μπορούν να δημιουργούν, να τροποποιούν, να διαγράφουν, να μετακινούν και να αντιγράφουν.Δικτύωση[Επεξεργασία|επεξεργασία κώδικα]Τα περισσότερα σύγχρονα λειτουργικά συστήματα επιτρέπουν τη σύνδεση ενός\nυπολογιστή τόσο σετοπικά δίκτυαόσο και στοΔιαδίκτυο, ενσωματώνοντας στον κωδικά τους την υλοποίηση των απαιτούμενων αντίστοιχωνπρωτοκόλλων.Εσωτερική ασφάλεια[Επεξεργασία|επεξεργασία κώδικα]Με τον όρο αυτό, γνωστό και ωςπροστασία μνήμης, εννοούνται οι ενέργειες στις οποίες προβαίνει το ΛΣ προκειμένου να προφυλάξει τους πόρους μιας διεργασίας από τις παρεμβάσεις άλλων διεργασιών\nπου τυχαίνει να εκτελούνται (ψευδο)παράλληλα. Το σκεπτικό είναι πως, δεν πρέπει μια διεργασία ενός χρήστη (σε περίπτωση πολυχρηστικούδιακομιστήπου εξυπηρετεί πολλαπλούςπελάτες) ταυτόχρονα μέσω δικτύου, να έχει αποκλειστική πρόσβαση σε ολόκληρο το σύστημα αρχείων, ούτε μια διεργασία να εγγράφει δεδομένα στο τμήμα εκείνο της μνήμης που έχει εκχωρηθεί σε άλλη διεργασία.Εξωτερική ασφάλεια[Επεξεργασία|επεξεργασία κώδικα]Σαν κόμβος ενός δικτύου ένας υπολογιστής μπορεί να δεχτεί επιθέσεις απόκακόβουλο λογισμικό. Τα σύγχρονα ΛΣ περιλαμβάνουν και τμήματα που είναι υπεύθυνα να αναγνωρίσουν τέτοιες απειλές.Το λειτουργικό σύστημα ενός υπολογιστικού συστήματος, το οποίο υποστηρίζει πολλούς διαφορετικούς χρήστες, εκτελεί ένα ευρύ φάσμα εφαρμογών και είναι συνδεδεμένο στο δίκτυο. Το γεγονός αυτό αυξάνει τις απαιτήσεις ασφάλειας των αντικειμένων του, επειδή συντρέχει κίνδυνος απώλειας, καταστροφής, διαγραφής, τροποποίησης ή διάδοσης τους, χωρίς την απαιτούμενη δικαιοδοσία. Ενδεικτικές ευπάθειες και απειλές αποτελούν η απώλεια συνθηματικών, η μη εξουσιοδοτημένη εκτέλεση λογισμικού με στόχο την σπατάλη των διαθέσιμων πόρων, καθώς και κακόβουλο λογισμικό ή ενέργειες.Οι συνηθέστεροι μηχανισμοί οι οποίοι εν μέρει προσφέρουν ασφάλεια σε ένα λειτουργικό σύστημα είναι, οιβιομετρικοί μέθοδοι,αγνωστικά πρωτόκολλα, μηχανισμοί δημοσίου κλειδιού και σύνθετα συνθηματικά. Ενώ, οι συνηθέστερες τεχνικές οι οποίες υιοθετούνται για την προστασία και την ακεραιότητα των λειτουργικών συστημάτων είναι, οι μέθοδοι φραγμών, μέθοδοι καταχωρητών, σύνολα ελέγχου και συνόψεις αρχείων, μηχανισμοί ανοχής σφαλμάτων,αναχώματα ασφαλείας(Firewalls) καισύστημα ανίχνευσης εισβολών(Intrusion Detection System).Από την άλλη πλευρά, το «content spoofing» ή διαφορετικά η αλλοίωση περιεχομένου, χαρακτηρίζει την τεχνική της επίθεσης η οποία επιτρέπει σε έναν εισβολέα να εισφέρει κακόβουλο ωφέλιμο φορτίο το οποίο παραποιείται αργότερα, ως νόμιμο περιεχόμενο ενός ιστού (Web). Το γεγονός αυτό ενδέχεται να εκδηλωθεί σε πολλές διαφορετικές μορφές και συμπεριλαμβάνεται στη λίστα των πιο συχνών επιθέσεων. Παράλληλα, σε πολλές περιπτώσεις ο εισβολέας αποκτά πρόσβαση σε μία υπάρχουσα ιστοσελίδα (website), παραποιώντας τον πηγαίο κώδικα των προγραμμάτων αλλοιώνοντας το περιεχόμενο του ιστού.Γραφική διασύνδεση χρήστη[Επεξεργασία|επεξεργασία κώδικα]Η εξωτερική απεικόνιση (συνήθως στην οθόνη) του λειτουργικού συστήματος, ώστε ο χρήστης να μπορεί να αλληλεπιδράσει με αυτό και να διαχειριστεί τα προγράμματα και τις εργασίες του, δεν ταυτίζεται με το ίδιο το ΛΣ. Στην πραγματικότητα τοκέλυφος(αγγλ: shell, εναλλακτικά στα ελληνικά είναι γνωστό και ωςφλοιός), όπως λέγεται το εν λόγω τμήμα του ΛΣ το οποίο παρέχει μία οπτική και αλληλεπιδραστική διασύνδεση προς τους χρήστες, είναι απολύτως δευτερεύον σε σχέση με τον πυρήνα και τους μηχανισμούς του, παρόλο που πρόκειται για το μόνο συστατικό ενός λειτουργικού συστήματος το οποίο είναι άμεσα ορατό από έναν απλό χρήστη.Υπάρχουν δύο βασικοί τύποι κελύφους: οιγραμμές εντολών, όπου οι χρήστες απλώς πληκτρολογούν εντολές για να διαχειριστούν τα αρχεία και τα προγράμματά τους, και οιγραφικές διασυνδέσεις χρήστη(GUI), όπου οι χρήστες χειρίζονται ένα γραφικό περιβάλλον στηριζόμενο στο ποντίκι και σε οπτικές μεταφορές (εικονίδια, παράθυρα κλπ). Τα σύγχρονα ΛΣ παρέχουν τη δυνατότητα στον χρήστη να επικοινωνεί γραφικά με τονΗ/Υμέσωποντικιού, παραθύρων, εικονιδίων, δείκτη ποντικιού, γραμμές εργασιών κλπ.Οδηγοί συσκευών[Επεξεργασία|επεξεργασία κώδικα]Ένα λειτουργικό σύστημα περιλαμβάνει και πολλούςοδηγούς συσκευών(drivers). Συνοπτικά, ένας οδηγός συσκευής είναι το λογισμικό συστήματος που χρησιμοποιεί το ΛΣ και οι διεργασίες των χρηστών κάθε φορά που πρέπει να ανταλλάξουν δεδομένα με τη συγκεκριμένη συσκευή. Συνήθως οι οδηγοί συσκευών περιλαμβάνονται στο λογισμικό που συνοδεύει την περιφερειακή συσκευή κατά την αγορά της. Ωστόσο τα περισσότερα ΛΣ διατίθενται και με ορισμένους προκατασκευασμένους, γενικής χρήσης οδηγούς συσκευών, συνήθως όχι τόσο βελτιστοποιημένους από άποψη ταχύτητας.Πυρήνας[Επεξεργασία|επεξεργασία κώδικα]Όπως αναφέρθηκε, ο όροςπυρήναςαφορά τα πιο βασικά μέρη ενός ΛΣ τα οποία αλληλεπιδρούν στενά με το υλικό. Αντιθέτως, τμήματα του ΛΣ που δεν ανήκουν στον πυρήνα μπορούν να θεωρηθούν π.χ. η διασύνδεση με τον χρήστη, τα πρωτόκολλα επικοινωνίας ανάμεσα στις εφαρμογές, τα πρωτόκολλα διαχείρισης περιόδων εργασιών χρηστών, τα πρωτόκολλα δικτύου κτλ. Μια ενδιαφέρουσα ανάλυση σχετικά με την διαφορά ΛΣ και πυρήνα μπορεί να βρεθείεδώ (Linux και GNU). Πάντως δεν επικρατεί κάποια γενική συναίνεση σχετικά με το θέμα αυτό στην κοινότητα της πληροφορικής.Σύγχρονα λειτουργικά συστήματα[Επεξεργασία|επεξεργασία κώδικα]Στις μέρες μας (2012), τα δημοφιλέστερα λειτουργικά συστήματα στουςμικροϋπολογιστές, (συμπεριλαμβανομένων τωνπροσωπικών υπολογιστών), έχουν διαμορφωθεί σε δύο μεγάλες οικογένειες: αυτή τωνUnix-συμβατώνκαι την οικογένεια τωνMicrosoft Windows. Οικεντρικοί υπολογιστέςκαι ταενσωματωμένα συστήματαχρησιμοποιούν μια ποικιλία άλλων λειτουργικών συστημάτων, τα περισσότερα από τα οποία δεν έχουν άμεση συγγένεια με τα Windows ή με τοUnix.ΤαUnix-συμβατάΛειτουργικά Συστήματα αποτελούν μια πολυποίκιλη ομάδα, με πολλές κύριες υποκατηγορίες συμπεριλαμβανομένων τωνSystem V,BSD, καιGNU/Linux. Το εμπορικό σήμα Unix χρησιμοποιείται από πολλά ΛΣ που έχουν πολλά κοινά με το αρχικό Unix. Τα Unix Λ.Σ. τρέχουν σε μια μεγάλη γκάμα από αρχιτεκτονικές υπολογιστών. Χρησιμοποιούνται πολύ σαν συστήματαεξυπηρετητέςστις επιχειρήσεις και σε σταθμούς εργασίας σε ακαδημαϊκούς και μηχανολογικούς χώρους εργασίας.Παραλλαγές του Unix που διακινούνται ωςΕλεύθερο λογισμικό, όπως τοGNU/LinuxκαιBSDαυξάνουν σε δημοτικότητα στο χώρο των σταθμών εργασίας και των προσωπικών υπολογιστών. Παραλλαγές που διακινούνται με κλειστές άδειες χρήσης όπως τοHP-UXτηςHewlett-Packard, τοIrixτηςSilicon Graphicsκαι τοAIXτηςIBMέχουν σχεδιαστεί να τρέχουν μόνο στο υλικό των συγκεκριμένων εταιρειών ενώ άλλες παραλλαγές μπορούν να τρέξουν και σε προσωπικούς υπολογιστές. ΤοSolarisτηςSun(που άλλαξε άδεια χρήσης σε λογισμικό ανοιχτού κώδικα υπό την CDDL άδεια) είναι ένα τέτοιο πολύμορφο αλλά αληθινόUnixκαι μπορεί να τρέχει στους σταθμούς εργασίας της Sun αλλά και στον μικρότερο υπολογιστή αρχιτεκτονικήςx86. Το ΛΣMac OS XτηςAppleείναι μια παραλλαγή του BSD, και έχει αντικαταστήσει τα προηγούμενα (μη-unix) MacOS ΛΣ τηςAppleσε μια σχετικά μικρή αλλά αφοσιωμένη αγορά, έχοντας γίνει ένα πολύ δημοφιλέςUnix.Η οικογένεια τωνMicrosoft WindowsΛΣ ξεκίνησε σαν ένα επίπεδο γραφικής διασύνδεσης πάνω από το παλιότεροMS-DOSπεριβάλλον για τουςIBM PC. Οι σύγχρονες εκδόσεις των Windows βασίζονται στον καινούργιο πυρήνα τωνWindows NTπου πρωτοδιαμορφώθηκε στοOS/2, με πιο πρόσφατη έκδοση εν έτει 2010 ταWindows 7. Τα Windows τρέχουν πάνω σε 32- και 64-bitIntelκαιAMDυπολογιστές, αν και προηγούμενες εκδόσεις έτρεχαν και σεDEC Alpha,MIPSκαιPowerPCαρχιτεκτονικές (και υπήρξε και προσπάθεια να μεταφερθεί και σε αρχιτεκτονικήSPARC).Σήμερα, τα Windows είναι το δημοφιλέστερο ΛΣ προσωπικών υπολογιστών απολαμβάνοντας ένα σχεδόνμονοπώλιοτου 90% του παγκόσμιουμεριδίου αγοράςτων προσωπικών υπολογιστών[4]. Επίσης χρησιμοποιείται ευρέως και στους εξυπηρετητές υποστηρίζοντας εφαρμογές όπωςWeb εξυπηρετητές(Web Servers) καιεξυπηρετητές βάσεων δεδομένων(DBMS Servers).Τα ΛΣ μεγάλων υπολογιστών, όπως τηςIBMz/OSκαιενσωματωμένωνΛΣ όπωςQNX,eCos,SymbianκαιPalm OS, είναι συνήθως άσχετα με τοUnixκαι ταWindows. Τα ΛΣWindows CE,Windows NT Embedded 4.0καιWindows XP Embeddedσχετίζονται με ταWindows.Παλιότερα ΛΣ που ακόμα χρησιμοποιούνται σε κλειστές αγορές περιλαμβάνουν το παρόμοιο με τα WindowsOS/2τηςIBM, τοVMSτηςHewlett-Packard(πρώηνDEC), τοMac OS, το όχι-Unix προηγούμενο τουMac OSτης Apple X και τοAmigaOS, το πρώτο μεγραφική διασύνδεση χρήστηΛΣ με αναπτυγμένες δυνατότητες πολυμέσων που έγινε διαθέσιμο στο κοινό. Παλαιότερο, επίσης, ΛΣ που χρησιμοποιείται ακόμη σε πολύ περιορισμένες εφαρμογές, είναι ο πρόγονος τωνWindowsστους Προσωπικούς υπολογιστές, τοMS-DOS. Η έρευνα και η ανάπτυξη νέων τύπων ΛΣ συνεχίζεται και αποτελεί ένα ενεργό πεδίο της πληροφορικής.Παραδείγματα λειτουργικών συστημάτων[Επεξεργασία|επεξεργασία κώδικα]UNIX- που περιλαμβάνει όλα τα UNIXBSD(FreeBSD,OpenBSD,NetBSD), τοSolaris(και τοOpenSolaris), τοGNU/Linuxκαι τοMac OS XMac OS(μέχρι την έκδοση 9)Microsoft WindowsMS-DOSCP/MAmigaOSΕρευνητικά λειτουργικά συστήματα[Επεξεργασία|επεξεργασία κώδικα]Πολλά λειτουργικά συστήματα αναπτύσσονται από πανεπιστήμια, επιχειρήσεις, χομπίστες ή άλλους φορείς για καθαρά επιστημονικούς λόγους ώστε να διερευνηθούν νέες τεχνικές ή να χρησιμοποιηθούν ως βάση για μελλοντική εμπορική ή παραγωγική χρήση. Μερικά παραδείγματα ερευνητικών λειτουργικών συστημάτων είναι τα εξής:MulticsSprite (λειτουργικό σύστημα)MenuetOSPlan 9SortixToaruOSEMPIX[5]τουΕΜΠΓια μια πιο πλήρη λίστα δείτε εδώ:http://wiki.osdev.org/ProjectsΠαραπομπές[Επεξεργασία|επεξεργασία κώδικα]↑1,01,1«Εισαγωγή στα λειτουργικά συστήματα»(PDF). Αρχειοθετήθηκεαπό το πρωτότυπο(PDF)στις 21 Ιουλίου 2011. Ανακτήθηκε στις 21 Ιουλίου 2011.↑Λειτουργικά Συστήματα - Διεργασίες↑3,03,13,2Daniel Pierre Bovet, Marco Cesati,Understanding the Linux Kernel: [from I/Ο Ports to Process Management]., O'Reilly 2005, σελ. 8,ISBN 978-0-596-00565-8↑«Έρευνα της AT Internet». Αρχειοθετήθηκεαπό το πρωτότυποστις 9 Μαρτίου 2011. Ανακτήθηκε στις 16 Μαρτίου 2011.↑«The Hitchhiker's Guide to EMPIX». Αρχειοθετήθηκεαπό το πρωτότυποστις 21 Ιουλίου 2011. Ανακτήθηκε στις 16 Μαρτίου 2011.Πηγές[Επεξεργασία|επεξεργασία κώδικα]Αρχιτεκτονική Υπολογιστών: Μια Δομημένη Προσέγγιση,Tanenbaum Andrew S., Εκδ. ΚλειδάριθμοςΣύγχρονα Λειτουργικά Συστήματα, Tanenbaum Andrew S., Εκδ. ΚλειδάριθμοςPrinciples of Information Security,[Whitman M., Mattord Η (2011), 4th Edition]Βιβλιογραφία[Επεξεργασία|επεξεργασία κώδικα]\"ΛΕΙΤΟΥΡΓΙΚΑ ΣΥΣΤΗΜΑΤΑ\",Γ.Κ.ΠΑΠΑΚΩΝΣΤΑΝΤΙΝΟΥ, Ν.Α.ΜΠΙΛΑΛΗΣ, Π.Α.ΤΣΑΝΑΚΑΣ, Εκδ.Συμμετρία 1986.\"Fundamentals of Operating Systems\",A.M.Lister,5th ed. with R.D.Eager, Springer 1993.Εξωτερικοί σύνδεσμοι[Επεξεργασία|επεξεργασία κώδικα]Wikiversity logoΣτoΒικιεπιστήμιουπάρχει ή αναπτύσσεται εκπαιδευτικό υλικό για αυτό το θέμα:Λειτουργικό σύστημαCommons logoΤαWikimedia Commonsέχουν πολυμέσα σχετικά με το θέμαΛειτουργικό σύστημαΙστορική αναδρομή λειτουργικών συστημάτωνΑρχειοθετήθηκε2011-05-19 στοWayback Machine.Εισαγωγή στα λειτουργικά συστήματαΑρχειοθετήθηκε2011-07-21 στοWayback Machine.ΕΑΠ - Λειτουργικά ΣυστήματαΑρχειοθετήθηκε2011-05-19 στοWayback Machine.Καθιερωμένοι όροιLCCN:sh85094982GND:4006216-8BNF:cb119333481(data)NDL:00865121NKC:ph115593"
    },
    {
        "url": "https://el.wikipedia.org/wiki/%CE%91%CE%BD%CE%BF%CE%B9%CF%87%CF%84%CF%8C_%CE%BB%CE%BF%CE%B3%CE%B9%CF%83%CE%BC%CE%B9%CE%BA%CF%8C",
        "title": "Λογισμικό ανοικτού κώδικα",
        "content": "Το λήμμα παραθέτει τις πηγές του αόριστα, χωρίςπαραπομπές.Βοηθήστε συνδέοντας το κείμενο με τις πηγέςχρησιμοποιώντας παραπομπές, ώστε να είναιεπαληθεύσιμο.Το πρότυπο τοποθετήθηκε χωρίς ημερομηνία. Για τη σημερινή ημερομηνία χρησιμοποιήστε:{{χωρίς παραπομπές|10|01|2025}}Το λογότυπο του ανοιχτού λογισμικούΣτον χώρο τηςπληροφορικήςκαι τωνηλεκτρονικών υπολογιστών, με τον όρολογισμικό ανοικτού κώδικα(αγγλ.:Open Source Software, OSS) εννοείταιλογισμικότου οποίου οπηγαίος κώδικαςδιατίθεται σε τρίτον για να τον εξετάσει.\nΚατά καιρούς έχουν εμφανιστεί αρκετές διαφορετικέςάδειες χρήσηςσχεδιασμένες να συνοδεύουν λογισμικό ανοικτού κώδικα. Μερικές από αυτές επιτρέπουν στους χρήστες και να τροποποιήσουν τον κώδικα ή και να τον αξιοποιήσουν σε άλλες εφαρμογές.Το λογισμικό ανοικτού κώδικα δεν σημαίνει απαραιτήτωςδωρεάν λογισμικό, ούτεΕλεύθερο Λογισμικόσύμφωνα με τον ορισμό που δίνει στο Ελεύθερο Λογισμικό τοΊδρυμα Ελεύθερου Λογισμικού, αλλά αναφέρεται μόνο στο γεγονός πως επιτρέπεται σε κάθε χρήστη να εξετάσει και να χρησιμοποιήσει τη γνώση και τις δυνατότητες που προσφέρει ο παρεχόμενος πηγαίος κώδικας. Στην πράξη, τα περισσότερα προγράμματα ανοιχτού κώδικα παρέχονται δωρεάν και μπορούν να χαρακτηριστούν ελεύθερα.Δείτε επίσης[Επεξεργασία|επεξεργασία κώδικα]Ελεύθερο λογισμικόΕΕΛ/ΛΑΚΕξωτερικοί σύνδεσμοι[Επεξεργασία|επεξεργασία κώδικα]SourceForge.net- Αποθετήριο και σελίδες ανάπτυξης για λογισμικό ανοιχτού κώδικαΑυτό το  λήμμα σχετικά με τηνΠληροφορικήχρειάζεταιεπέκταση. Μπορείτε να βοηθήσετε την Βικιπαίδειαεπεκτείνοντάς το.πσεΕλεύθερο λογισμικόκαιλογισμικό ανοικτού κώδικαΓενικάCopyleft·Γεγονότα και βραβεία·Ελεύθερο λογισμικό·Ορισμός του Ελεύθερου Λογισμικού·Δωρεάν και ελεύθερο·Κατάλογος ελεύθερου λογισμικού και λογισμικού ανοιχτού κώδικα·Λογισμικό ανοικτού κώδικαΛειτουργικά συστήματαAROS·BSD·Darwin·eCos·FreeDOS·GNU·Haiku·Inferno·Linux·Mach·MINIX·OpenSolaris·Plan 9·ReactOS·SymbianΑνάπτυξη λογισμικούEclipse·Free Pascal·GCC·Gambas·Java·LLVM·Lua·NetBeans·Open64·Perl·PHP·Python·ROSE·Ruby·TclΙστορίαGNU·Haiku·Linux·Mozilla(Application Suite·Firefox·Thunderbird)ΟργανισμοίApache Software Foundation·Ίδρυμα Blender·Eclipse Foundation·freedesktop.org·Ίδρυμα Ελεύθερου Λογισμικού(Ευρώπη·India·Latin America) ·FSMI·GNOME Foundation·GNU Project·Google Code·KDE e.V.·Linux Foundation·Mozilla Foundation·Open Source Geospatial Foundation·Open Source Initiative·Python Software Foundation-Software Freedom Conservancy·SourceForge·Symbian Foundation·The Document Foundation·Xiph.Org Foundation·XMPP Standards Foundation·X.Org FoundationΆδειες ελεύθερου λογισμικούApache·Artistic·BSD·GNU GPL·GNU LGPL·ISC·MIT·MPL·Ms-PL/RL·zlib·FSF approved licensesΠρότυπα αδειών λογισμικούΟρισμός του Λογισμικού Ανοιχτού Κώδικα·Ορισμός του Ελεύθερου Λογισμικού·Debian Free Software GuidelinesΣημαντικά θέματαBinary blob·Canonical's contributor agreement·Digital rights management·Συμβατότητα καρτών γραφικών·License proliferation·Mozilla software rebranding·Proprietary software·Διαμάχη SCO-Linux·Ασφάλεια·Πατέντες λογισμικού·Περιορισμοί υλικού·Trusted Computing·Viral licenseΆλλα θέματαΕναλλακτικοί όροι·Κοινότητα·Διανομή Linux·Forking·Κίνημα·Microsoft Open Specification Promise·Revolution OS·Σύγκριση με λογισμικό κλειστού κώδικα"
    },
    {
        "url": "https://el.wikipedia.org/wiki/Python_Software_Foundation",
        "title": "Python Software Foundation",
        "content": "Python Software FoundationΣυντομογραφίαPSFΊδρυση6 Μαρτίου 2001Τύποςμη κερδοσκοπικός οργανισμόςΣκοπόςΝα προωθήσει, προστατεύσει και εξελίξει τη γλώσσα προγραμματισμούPython, όπως και να υποστηρίξει και να βοηθήσει στην ανάπτυξη της διαφορετικότητας στη χρήση από την διεθνή κοινότητα προγραμματιστώνΈδραΝτέλαγουερ,Ηνωμένες Πολιτείες ΑμερικήςΥπηρεσίεςσε όλο τον κόσμοΠρόεδροςΓκίντο βαν Ρόσσουμ(Guido van Rossum)Ιστότοποςwww.python.org/psf-landing/δεδομένα(π•σ•ε)ΤοPython Software Foundation(συντομογραφία:PSF) είναι έναςμη κερδοσκοπικός οργανισμός, ο οποίος ξεκίνησε να λειτουργεί στις 6 Μαρτίου του 2001, με σκοπό την υποστήριξη τηςγλώσσας προγραμματισμούPython. Aποστολή του είναι να προωθεί την ανάπτυξη της κοινότητας Python, να αναλαμβάνει την οργάνωση και την ευθύνη σε διάφορες διαδικασίες της κοινότητας, συμπεριλαμβανομένης της ανάπτυξης της βασικής διανομής της Python, τη διαχείριση πνευματικών δικαιωμάτων, τα συνέδρια των προγραμματιστών συμπεριλαμβανομένων τωνPyConsκαι τη συγκέντρωσης κεφαλαίων για την δική του συντήρησή.[1][2][3]Το 2005, το Python Software Foundation έλαβε το βραβείο Computerworld Horizon στις τεχνολογίες αιχμής.[4][5]Ιστορία[Επεξεργασία|επεξεργασία κώδικα]Το πρώτο συνέδριο της κοινότητας Python έγινε τον Νοέμβριο του 1994, πολύ πριν την ίδρυση τουPSF.[6]Python Software Activity[Επεξεργασία|επεξεργασία κώδικα]Πριν την ίδρυση τηςPSF(2001), λειτουργούσε ο επίσης μη κερδοσκοπικός οργανισμόςPython Software Activity(συντομογραφία:PSA), που όμως είχε διαφορετικό, πιο περιορισμένο σκοπό και λιγότερα μέλη.[7][8]Τα μέλη, τα οποία ήταν από σπουδαστές έως εταιρείες και οργανισμοί, ήταν συνδρομητικά (στο πλαίσιο των οικονομικών προσδοκιών τους) και είχαν πλεονεκτήματα (π.χ. νεότερες εκδόσεις, υποστήριξη, κλπ) έναντι των υπόλοιπον χρηστών.[9]Παραπομπές[Επεξεργασία|επεξεργασία κώδικα]↑«Mission statement».Python Software Foundation(στα Αγγλικά). Αρχειοθετήθηκεαπό το πρωτότυποστις 17 Ιουνίου 2019. Ανακτήθηκε στις 10 Σεπτεμβρίου 2019.↑«About the Python Software Foundation».Python.org(στα Αγγλικά). Αρχειοθετήθηκεαπό το πρωτότυποστις 10 Σεπτεμβρίου 2019. Ανακτήθηκε στις 10 Σεπτεμβρίου 2019.↑«Python Software Foundation».Python.org(στα Αγγλικά). Αρχειοθετήθηκεαπό το πρωτότυποστις 23 Αυγούστου 2019. Ανακτήθηκε στις 10 Σεπτεμβρίου 2019.↑«Python Software Foundation Wins Computerworld Horizon Award for Popular Python Programming Language».Elemental Security(στα Αγγλικά). 15 Σεπτεμβρίου 2005. Αρχειοθετήθηκεαπό το πρωτότυποστις 1 Μαΐου 2015. Ανακτήθηκε στις 5 Οκτωβρίου 2016.↑«Computerworld Horizon Awards 2005 Honorees»(στα Αγγλικά).Computerworld. 12 Σεπτεμβρίου 2005. Αρχειοθετήθηκεαπό το πρωτότυποστις 31 Ιουλίου 2019. Ανακτήθηκε στις 5 Οκτωβρίου 2016.↑«Python Conferences».ftp.ntua.gr(στα Αγγλικά). Αρχειοθετήθηκεαπό το πρωτότυποστις 14 Φεβρουαρίου 2019. Ανακτήθηκε στις 10 Σεπτεμβρίου 2019.↑«Python Community Resources».ftp.ntua.gr(στα Αγγλικά). Αρχειοθετήθηκεαπό το πρωτότυποστις 10 Σεπτεμβρίου 2019. Ανακτήθηκε στις 10 Σεπτεμβρίου 2019.↑Lutz, Mark (23 Αυγούστου 2006).Programming Python. \"O'Reilly Media, Inc.\". σελ. 8.ISBN9780596554613.↑Hammond, Mark· Robinson, Andy (2000).Python Programming On Win32: Help for Windows Programmers(στα Αγγλικά). \"O'Reilly Media, Inc.\". σελ. 13.ISBN9781565926219.Εξωτερικοί σύνδεσμοι[Επεξεργασία|επεξεργασία κώδικα](Αγγλικά)Python Software Foundation, ο επίσημος ιστότοποςπσεΕλεύθερο λογισμικόκαιλογισμικό ανοικτού κώδικαΓενικάCopyleft·Γεγονότα και βραβεία·Ελεύθερο λογισμικό·Ορισμός του Ελεύθερου Λογισμικού·Δωρεάν και ελεύθερο·Κατάλογος ελεύθερου λογισμικού και λογισμικού ανοιχτού κώδικα·Λογισμικό ανοικτού κώδικαΛειτουργικά συστήματαAROS·BSD·Darwin·eCos·FreeDOS·GNU·Haiku·Inferno·Linux·Mach·MINIX·OpenSolaris·Plan 9·ReactOS·SymbianΑνάπτυξη λογισμικούEclipse·Free Pascal·GCC·Gambas·Java·LLVM·Lua·NetBeans·Open64·Perl·PHP·Python·ROSE·Ruby·TclΙστορίαGNU·Haiku·Linux·Mozilla(Application Suite·Firefox·Thunderbird)ΟργανισμοίApache Software Foundation·Ίδρυμα Blender·Eclipse Foundation·freedesktop.org·Ίδρυμα Ελεύθερου Λογισμικού(Ευρώπη·India·Latin America) ·FSMI·GNOME Foundation·GNU Project·Google Code·KDE e.V.·Linux Foundation·Mozilla Foundation·Open Source Geospatial Foundation·Open Source Initiative·Python Software Foundation-Software Freedom Conservancy·SourceForge·Symbian Foundation·The Document Foundation·Xiph.Org Foundation·XMPP Standards Foundation·X.Org FoundationΆδειες ελεύθερου λογισμικούApache·Artistic·BSD·GNU GPL·GNU LGPL·ISC·MIT·MPL·Ms-PL/RL·zlib·FSF approved licensesΠρότυπα αδειών λογισμικούΟρισμός του Λογισμικού Ανοιχτού Κώδικα·Ορισμός του Ελεύθερου Λογισμικού·Debian Free Software GuidelinesΣημαντικά θέματαBinary blob·Canonical's contributor agreement·Digital rights management·Συμβατότητα καρτών γραφικών·License proliferation·Mozilla software rebranding·Proprietary software·Διαμάχη SCO-Linux·Ασφάλεια·Πατέντες λογισμικού·Περιορισμοί υλικού·Trusted Computing·Viral licenseΆλλα θέματαΕναλλακτικοί όροι·Κοινότητα·Διανομή Linux·Forking·Κίνημα·Microsoft Open Specification Promise·Revolution OS·Σύγκριση με λογισμικό κλειστού κώδικα"
    },
    {
        "url": "https://el.wikipedia.org/wiki/GNU_General_Public_License",
        "title": "Γενική Άδεια Δημόσιας Χρήσης GNU",
        "content": "Λογότυπος του Επεξεργασία: Γενική Άδεια Δημόσιας Χρήσης GNUΛογότυπος τουGNUΗΓενική Άδεια Δημόσιας Χρήσης GNU(GNU General Public License, ήGNU GPLή απλάGPL) είναι πιθανόν η περισσότερο δημοφιλήςάδεια χρήσηςελεύθερου λογισμικού, και είναι η άδεια που προστατεύει το μεγαλύτερο ποσοστό του ελεύθερου λογισμικού που υπάρχει μέχρι σήμερα.Παρουσίαση[Επεξεργασία|επεξεργασία κώδικα]Η άδεια γράφτηκε αρχικά από τονΡίτσαρντ Στόλλμανγια το εγχείρημαGNU. Η πιο πρόσφατη έκδοση της άδειας, η έκδοση 3, κυκλοφόρησε στις 29 Ιουνίου 2007. Η GPLv3 έχει διχάσει την κοινότητα του ανοιχτού λογισμικού, καθώς μέρος των προγραμματιστών[1][2]τουLinuxδηλώνουν πωςδεν είναι ευχαριστημένοιμε την καινούργια έκδοση.Η άδεια GPL, που δημιουργήθηκε για τα προγράμματα που έγραφε το Gnu Project, δίνει στους κατόχους ενός προγράμματος τα ακόλουθα τέσσερα δικαιώματα, που στην κοινότητα του ελεύθερου λογισμικού είναι γνωστά και ωςΤέσσερις Ελευθερίες:να τρέξουν ένα πρόγραμμα για οποιοδήποτε λόγο.να μελετήσουν τη λειτουργία ενός προγράμματος και να το τροποποιήσουννα διανείμουν αντίγραφα του προγράμματος έτσι ώστε να βοηθήσουν τον πλησίοννα βελτιώσουν το πρόγραμμα και να προσφέρουν τις βελτιώσεις στο κοινό, έτσι ώστε να ωφεληθεί ολόκληρη η κοινότηταΠροϋποθέσεις για τα παραπάνω είναι οανοιχτός κώδικας, δηλαδή οκώδικαςτου προγράμματος να είναι γνωστός και προσβάσιμος στον χρήστη. Η διαφορά της GPL από τηνBSDείναι ότι κάθε αντίγραφο, παράγωγο και προϊόν ενός GPL προγράμματος, υποχρεούται να κυκλοφορεί κι αυτό υπό την ίδια άδεια. Αντίθετα στην άλλη περίπτωση, τα παράγωγα προγράμματα μπορεί να είναι και ιδιόκτητα (κλειστού κώδικα).Η μεγαλύτερη απόσταση όμως είναι μεταξύ GNU καιιδιόκτητου λογισμικού. Το τελευταίο δεν δίνει κανένα δικαίωμα στο χρήστη, πέραν από το δικαίωμα χρήσης και αυτό κατόπιν συμφωνίας με τον ιδιοκτήτη του προγράμματος (με τη μορφή μιαςEnd User License Agreement). Κριτικοί του ιδιόκτητου λογισμικού υποστηρίζουν ότι δεν πρέπει να χρειάζεται άδεια για χρήση και υποστηρίζουν ότι οι περιορισμοί αυτοί και η διάθεση από τους ιδιοκτήτες του λογισμικού μόνο των δυαδικών πακέτων και όχι του πηγαίου κώδικα του προγράμματος απαγορεύουν νόμιμες διαδικασίες όπως ηανάστροφη μηχανική.Δημοφιλία και στατιστικές[Επεξεργασία|επεξεργασία κώδικα]Σύμφωνα με κάποιες μελέτες και μετρήσεις, η GPL είναι η δημοφιλέστερη άδεια ελεύθερου και ανοιχτού λογισμικού. Σε μέτρηση που έγινε τον Απρίλιο του 2005, 75% από τα 23,479 ελεύθερα προγράμματα τουFreshmeat, και 68% από τα προγράμματα στοSourceForge, ανήκουν στην GPL. Αξίζει να αναφερθεί ότι οι δύο αυτοίδικτυακοί τόποι, ανήκουν στην εταιρεία Geeknet, η οποία υποστηρίζει τόσο την άδεια όσο και κατ' επέκτασιν τοΛίνουξ.Μια παλαιότερη έρευνα που έκανε τοRed HatLinux 7.1 το 2001, βρήκε πως το 50% του πηγαίου κώδικα ήταν άδειας GPL, και η έρευνα του 1997 που έκανε το Metalab, το μεγαλύτερο αρχείο ελεύθερου λογισμικού της εποχής, έδειξε το ίδιο.Τα πιο γνωστά/σημαντικά προγράμματα που ανήκουν στην άδεια αποτελούν τονπυρήνα Λίνουξκαι τονμεταγγλωτιστήGNU Compiler Collection. Άλλα προγράμματα ελεύθερου λογισμικού κυκλοφορούν σε πολλαπλές άδειες, μεταξύ των οποίων και GPL, όπως είναι ηPerl.Η GPL στην δοκιμασία[Επεξεργασία|επεξεργασία κώδικα]Το ανοιχτό λογισμικό εκ φύσεως είναι πιο ευάλωτο στην καταπάτηση των δικαιωμάτων των προγραμματιστών από χρήστες ή εταιρείες που χρησιμοποιούν κώδικα χωρίς να σέβονται τις άδειες υπό τις οποίες αυτός δημοσιεύεται. Η GPL αναγκάζει το οποιοδήποτε λογισμικό χρησιμοποιεί ή βασίζεται σε κώδικα που κυκλοφορεί υπό την GPL, να δώσει την δυνατότητα στους χρήστες που το επιθυμούν να δουν τον κώδικα. Παρόλα ταύτα, μερικές υποθέσεις έφτασαν ως τα δικαστήρια[3][4][5]όπου και αποδείχτηκε η ασφάλεια και σιγουριά της άδειας αυτής και η πρόθεση τουFree Software Foundationνα προασπίσει τις τέσσερις ελευθερίες που εγγυάται η άδεια..Κείμενα[Επεξεργασία|επεξεργασία κώδικα]Το κείμενο της GNU General Public LicenseΑνεπίσημη μετάφραση της GPL στα ελληνικάΤο προσχέδιο της έκδοσης 3.Παραπομπές[Επεξεργασία|επεξεργασία κώδικα]↑(Αγγλικά)Ψήφοιμέρος των προγραμματιστών του Linux, δίνοντας την γνώμη τους στην GPLv3 (2ο προσχέδιο)↑(Αγγλικά)ΆποψηΑρχειοθετήθηκε2006-10-01 στοWayback Machine. τουΛίνους Τόρβαλντς↑(Αγγλικά) Η εταιρείαSitecom Germanyχρησιμοποιεί κώδικα του προγράμματοςnetfilter/iptablesκαιχάνει την υπόθεση στα γερμανικά δικαστήρια↑(Αγγλικά)ΕπίθεσηΑρχειοθετήθηκε2006-09-25 στοWayback Machine. κατά της GPL στιςΗΠΑ↑(Αγγλικά) ΗD-Link Germany GmbHχρησιμοποίησε μέρος του κώδικα τουLinuxκαιχάνει την υπόθεσηΑρχειοθετήθηκε2014-10-07 στοWayback Machine. στα γερμανικά δικαστήριαΕξωτερικοί σύνδεσμοι[Επεξεργασία|επεξεργασία κώδικα]http://www.gnu.org/home.el.htmlΑρχειοθετήθηκε2006-01-28 στοWayback Machine.Κείμενο του Richard Stallman για την GPLv3 που παρουσιάστηκε στις Βρυξέλλες, 1 Απριλίου 2007πσεΕλεύθερο λογισμικόκαιλογισμικό ανοικτού κώδικαΓενικάCopyleft·Γεγονότα και βραβεία·Ελεύθερο λογισμικό·Ορισμός του Ελεύθερου Λογισμικού·Δωρεάν και ελεύθερο·Κατάλογος ελεύθερου λογισμικού και λογισμικού ανοιχτού κώδικα·Λογισμικό ανοικτού κώδικαΛειτουργικά συστήματαAROS·BSD·Darwin·eCos·FreeDOS·GNU·Haiku·Inferno·Linux·Mach·MINIX·OpenSolaris·Plan 9·ReactOS·SymbianΑνάπτυξη λογισμικούEclipse·Free Pascal·GCC·Gambas·Java·LLVM·Lua·NetBeans·Open64·Perl·PHP·Python·ROSE·Ruby·TclΙστορίαGNU·Haiku·Linux·Mozilla(Application Suite·Firefox·Thunderbird)ΟργανισμοίApache Software Foundation·Ίδρυμα Blender·Eclipse Foundation·freedesktop.org·Ίδρυμα Ελεύθερου Λογισμικού(Ευρώπη·India·Latin America) ·FSMI·GNOME Foundation·GNU Project·Google Code·KDE e.V.·Linux Foundation·Mozilla Foundation·Open Source Geospatial Foundation·Open Source Initiative·Python Software Foundation-Software Freedom Conservancy·SourceForge·Symbian Foundation·The Document Foundation·Xiph.Org Foundation·XMPP Standards Foundation·X.Org FoundationΆδειες ελεύθερου λογισμικούApache·Artistic·BSD·GNU GPL·GNU LGPL·ISC·MIT·MPL·Ms-PL/RL·zlib·FSF approved licensesΠρότυπα αδειών λογισμικούΟρισμός του Λογισμικού Ανοιχτού Κώδικα·Ορισμός του Ελεύθερου Λογισμικού·Debian Free Software GuidelinesΣημαντικά θέματαBinary blob·Canonical's contributor agreement·Digital rights management·Συμβατότητα καρτών γραφικών·License proliferation·Mozilla software rebranding·Proprietary software·Διαμάχη SCO-Linux·Ασφάλεια·Πατέντες λογισμικού·Περιορισμοί υλικού·Trusted Computing·Viral licenseΆλλα θέματαΕναλλακτικοί όροι·Κοινότητα·Διανομή Linux·Forking·Κίνημα·Microsoft Open Specification Promise·Revolution OS·Σύγκριση με λογισμικό κλειστού κώδικα"
    },
    {
        "url": "https://el.wikipedia.org/wiki/%CE%9C%CF%8C%CE%BD%CF%84%CF%85_%CE%A0%CE%AC%CE%B9%CE%B8%CE%BF%CE%BD",
        "title": "Monty Python",
        "content": "Μόντυ ΠάιθονΧώρα πολιτογράφησηςΗνωμένο ΒασίλειοΚίνημαυπερρεαλισμόςΕίδος τέχνηςσάτιρα,σουρεαλιστικό χιούμορ,μαύρη κωμωδίακαιπαρωδίαΚαλλιτεχνικά ρεύματαυπερρεαλισμόςΣημαντικά έργαThe Ministry of Silly Walks,Dead Parrot Sketch,The Funniest Joke in the World,The Lumberjack Song,Spam,The Fish-Slapping Dance,Four Yorkshiremen sketch,Ένας Προφήτης... Μα τι Προφήτης!,Johann Gambolputty,Monty Python's The Meaning of Life,Οι Ιππότες της Ελεεινής Τραπέζης,Monty Python's Flying Circus,And Now for Something Completely Different[1]καιMonty Python Live at the Hollywood Bowl[1]Βραβεύσειςβραβείο Ευρωπαϊκής Ακαδημίας Κινηματογράφου Συνολικής προσφοράς(2001)[2]ΙστοσελίδαΕπίσημος ιστότοποςΣχετικά πολυμέσαδεδομένα(π•σ•ε)ΟιMonty Python(ήΜόντι Πάιθον,[3][4][5][6]γνωστοί και ωςThe Pythons[7][8]) είναι το όνομα της ομάδας παραγωγής της τηλεοπτικής σειράςΤο ιπτάμενο τσίρκο των Μόντι Πάιθον(Monty Python's Flying Circus), μιας κωμωδίας που άρχισε να εκπέμπεται στηΜεγάλη Βρετανίατο 1969, αλλά και μιας σειράς εκπομπών, κινηματογραφικών έργων, ηχογραφήσεων και θεατρικών παραγωγών από το 1969 μέχρι το 1989.Τα μέλη της ομάδας των Μόντι Πάιθον[Επεξεργασία|επεξεργασία κώδικα]Τα μέλη της ομάδας των Μόντι Πάιθον είναι οιΓκράχαμ Τσάπμαν(Graham Chapman),Έρικ Άιντλ(Eric Idle),Τέρι Γκίλιαμ(Terry Gilliam),Τέρι Τζόουνς(Terry Jones),Τζον Κλιζ(John Cleese) καιΜάικλ Πέιλιν(Michael Palin).Έργα των Μόντι Πάιθον[Επεξεργασία|επεξεργασία κώδικα]Τα κωμικά και σατιρικά έργα τους είχαν μεγάλη επιρροή στη λαϊκή κουλτούρα στη Βρετανία, αλλά και σε παγκόσμιο επίπεδο, επηρεάζοντας μετέπειτα Βρετανούς δημιουργούς.Από τα πιο σημαντικά έργα τους είναι:Το ιπτάμενο τσίρκο των Μόντι Πάιθονκωμωδία σε τηλεοπτική σειρά η οποία παράχθηκε και παρουσιάστηκε στοBBCτης Μεγάλης Βρετανίας από το 1969 με 45 επεισόδια μέχρι το 1974.And Now for Something Completely Different(1971), κινηματογραφική ταινία με σκετς από την τηλεοπτική σειρά.Οι ιππότες της Ελεεινής Τραπέζης(Monty Python and the Holy Grail) (1975) σατιρική κινηματογραφική ταινία για τον μύθο τουΒασιλιά Αρθούρου.Ένας προφήτης... Μα τι προφήτης!(Monty Python's Life of Brian) (1979), μια κινηματογραφική σάτιρα με την ιστορία ενός νεαρούΕβραίουπου θεωρήθηκεμεσσίας.Monty Python Live at the Hollywood Bowl(1982), η ταινία από μια ζωντανή παρουσίασή τους, στην οποία έπαιξαν μερικά από τα πιο ωραία κωμικά τους σκετς.Μόντι Πάιθον, το νόημα της ζωής(1983), μια κινηματογραφική συλλογή από σκετς για το νόημα της ζωής, με αρκετόμαύρο χιούμορ.Φωτογραφίες μελών της ομάδας των Μόντι Πάιθον[Επεξεργασία|επεξεργασία κώδικα]Michael PalinEric IdleTerry GilliamJohn CleeseΔείτε επίσης[Επεξεργασία|επεξεργασία κώδικα]Ιππότες που λένε Νι!Παραπομπές[Επεξεργασία|επεξεργασία κώδικα]↑1,01,1Ανακτήθηκε στις 12  Αυγούστου 2022.↑www.europeanfilmacademy.org/European-Film-Awards-Winners-2001.72.0.html. Ανακτήθηκε στις 15  Δεκεμβρίου 2019.↑«10 πράγματα που αξίζει να ξέρεις για τους Μόντι Πάιθον».Athens Voice. 2 Νοεμβρίου 2019. Ανακτήθηκε στις 27 Ιανουαρίου 2024.↑«Ο Κάρολος, οι Μόντι Πάιθον και ο Νικ Κέιβ - Τελικά ποιος νοιάζεται για τον νέο βασιλιά;».Η Ναυτεμπορική. 6 Μαΐου 2023. Ανακτήθηκε στις 27 Ιανουαρίου 2024.↑«Κακώς χειροκροτούσαν οι επίσημοι τα κορίτσια με το ανόητο βάδισμα των Μόντι Πάιθον».Έθνος. 1 Ιανουαρίου 1980. Ανακτήθηκε στις 27 Ιανουαρίου 2024.↑«Μόντι Πάιθον: Τα 50α γενέθλια, οι εκπλήξεις και το ρεκόρ Γκίνες».HuffPost Greece. 27 Ιουνίου 2019. Ανακτήθηκε στις 27 Ιανουαρίου 2024.↑Wilmut (1980), p. 250.↑Chapman, Graham· Gilliam, Terry· Cleese, John· Idle, Eric· Jones, Terry· Palin, Michael (2003).The Pythons. Orion.ISBN9780752852935.Εξωτερικοί σύνδεσμοι[Επεξεργασία|επεξεργασία κώδικα]Commons logoΤαWikimedia Commonsέχουν πολυμέσα σχετικά με το θέμαMonty Pythonhttps://web.archive.org/web/20060314132918/http://www.pythonline.com/Ιστότοπος του Έρικ Άιντλ για τους Μόντι Πάιθον(Αγγλικά)Καθιερωμένοι όροιVIAF:154754514Europeana:agent/base/146886LCCN:n79022378ISNI:0000 0001 2298 4731GND:811153-4SELIBR:331784SUDOC:031805949BNF:cb13773092f(data)MusicBrainz:4a5c8526-f8ec-43f1-97af-49722ad88394NLA:36024358NDL:00954548NKC:ko2002149886"
    },
    {
        "url": "https://el.wikipedia.org/wiki/%CE%A0%CF%8D%CE%B8%CF%89%CE%BD%CE%B1%CF%82",
        "title": "Πύθωνας",
        "content": "ΠύθωναςΙνδικός πύθωνας (Πύθων ο μόλουρος-Python molurus)Συστηματική ταξινόμησηΒασίλειο:Ζώα(Animalia)Συνομοταξία:Χορδωτά(Chordata)Υποσυνομοταξία:Σπονδυλωτά(Vertebrata)Ομοταξία:Ερπετά(Reptilia)Τάξη:Φολιδωτά(Squamata)Υποτάξη:Φίδια(Serpentes)Οικογένεια:Πυθωνίδες(Pythonidae)Γένος:Πύθων(Python)Daudin, 1803ΣυνώνυμαPython- Daudin, 1803Συσφιγκτήρ- Wagler, 1830Enygrus- Wagler, 1830Engyrus- Gary, 1831Enygris- Gray, 1842Heleionomus- Gray, 1842Hortulia- Gray, 1842Αστερόφις- Fitzinger, 1843Ασπιδοβόας- Sauvage, 1884[1]Πύθωναςείναιγένοςανιοβόλωνφιδιώνπου ανήκουν στην οικογένεια τωνπυθωνιδώνκαι στην τάξη τωνφολιδωτώνερπετών. Απαντώνται στηνΑφρικήκαι στηνΑσία. Σήμερα αναγνωρίζονται επτά συνολικά είδη. Η κοινή του ονομασία είναι πύθωνας[2]. Το μήκος του κυμαίνεται, ανάλογα με το είδος, από μερικά εκατοστά μέχρι 10 μ.. Το κύριο χαρακτηριστικό τους είναι ότι δεν έχουν αδένες μεδηλητήριοκαι σκοτώνουν τη λεία τους σφίγγοντάς την με τις δυνατές σπείρες τους. Από τα επτά είδη επικίνδυνο για τον άνθρωπο είναι ο «πύθων ο δικτυωτός», ο οποίος ζει στις ζούγκλες τηςΜαλαισίαςκαι τηςΜιανμάρ. Το βάρος αυτού του πύθωνα μπορεί να φθάσει τα 120 κιλά.Είδη[Επεξεργασία|επεξεργασία κώδικα]ΕίδοςΑρχήΥποείδοςΚοινή ονομασίαΓεωγραφική κατανομήPython anchietae(Πύθων του Αντσιέτα)[3]Bocage, 18870Πύθωνας της ΑγκόλαςΑφρικήστη νότιαΑγκόλακαι στη νότιαΝαμίμπιαPython curtus(Πύθων ο κοντός)Schlegel, 18722Κοντός πύθωναςΝοτιοανατολική Ασίαστη νότιαΤαϊλάνδη, στηΜαλαισίακαι στοΣαράουακκα σε Ινδονησία (Σουμάτρα, Καλιμαντάν και αλλού)Python molurus(Πύθων ο μόλουρος)T(Linnaeus, 1758)1Ινδικός πύθωναςΠακιστάν,Ινδία,Σρι Λάνκα,Νεπάλ,Μπανγκλαντές,Μιανμάρ, νότιαΚίνα,Χονγκ Κονγκ,Λάος,Βιετνάμ,Καμπότζη,Μαλαισία,ΙνδονησίαPython regius(Πύθων ο βασιλικός)(Shaw, 1802)0Βασιλικός πύθωνας[4]Κεντρική, Δυτική και Ανατολική ΑφρικήPython reticulatus(Πύθων ο δικτυωτός)(Schneider, 1801)0Πύθωνας δικτυωτόςνοτιοανατολικήΑσία,Ινδονησία,ΦιλιππίνεςPython sebae(Πύθων ο σέβειος)(Gmelin, 1788)1Αφρικανικός πύθωνας των βράχων[5]Υποσαχάρια ΑφρικήPython timoriensis(Πύθων του Τιμόρ)(Peters, 1876)0Πύθωνας του ΤιμόρΙνδονησία, νησιά Τιμόρ*) Χωρίς το τυπικό υποείδος.Τροφή[Επεξεργασία|επεξεργασία κώδικα]Η κύρια τροφή στα μεγάλα φίδια του γένους είναι τα διάφοραθηλαστικάζώα. Αυτά τα καταπίνουν ολόκληρα και για τον λόγο αυτό η στοματική και φαρυγγική τους κοιλότητα διαστέλλεται.Αναπαραγωγή[Επεξεργασία|επεξεργασία κώδικα]Ο πύθωνας γεννάαυγάκαι ο αριθμός τους σε μερικά είδη υπερβαίνει τα 100 ανά γέννα. Η διάρκεια της επώασης είναι 9-11 εβδομάδες. Κατά την περίοδο αυτή το θηλυκό δεν προσλαμβάνει τροφή.Παραπομπές[Επεξεργασία|επεξεργασία κώδικα]↑McDiarmid RW, Campbell JA, Touré T. 1999. Snake Species of the World: A Taxonomic and Geographic Reference, vol. 1. Herpetologists' League. 511 pp.ISBN 1-893777-00-6(series).ISBN 1-893777-01-4(volume).↑ITIS, ID =202186, taxon=Python, 11 Σεπτεμβρίου 2007↑Named for José Alberto de Oliveira Anchieta (Portuguese explorer and naturalist)↑Ο βασιλικός πύθωνας έχει μικρές διαστάσεις και χρωματιστά σχέδια.↑Το είδος αυτό είναι αδηφάγο και πολύ επιθετικό. Κρύβεται σε πυκνές φυλλωσιές την ημέρα και βγαίνει προς αναζήτηση τροφής τη νύχτα. Το μήκος του μπορεί να φθάσει και τα 8 μέτρα.Βιβλιογραφία[Επεξεργασία|επεξεργασία κώδικα]wiktionary logoΤοΒικιλεξικόέχει σχετικό λήμμα:πύθωναςCommons logoΤαWikimedia Commonsέχουν πολυμέσα σχετικά με το θέμαΠύθωναςWikispecies logoΤαΒικιείδηέχουν πληροφορίες για το θέμα:ΠύθωναςΕγκυκλοπαίδεια 2002, τόμ.  17, σελ. 105, εκδ. 1984Καθιερωμένοι όροιNKC:ph317220"
    },
    {
        "url": "https://el.wikipedia.org/wiki/%CE%93%CE%BB%CF%8E%CF%83%CF%83%CE%B1_%CF%83%CE%B5%CE%BD%CE%B1%CF%81%CE%AF%CF%89%CE%BD",
        "title": "Γλώσσα προγραμματισμού σεναρίων",
        "content": "Μιαγλώσσα σεναρίων(scripting language,script language) ήγλώσσα επέκτασης(extension language) είναι μιαγλώσσα προγραμματισμούπου επιτρέπει τον έλεγχο μιας ή περισσότερων εφαρμογών. Τα \"σενάρια\" (\"scripts\") είναι διακριτά από τον βασικό κώδικα της εφαρμογής, καθώς γράφονται συνήθως σε διαφορετική γλώσσα και συχνά δημιουργούνται ή τροποποιούνται από τον τελικό χρήστη.[1]Τα σενάρια συνήθωςδιερμηνεύονταιαπό τονπηγαίο κώδικαή τον κώδικα byte (bytecode), ενώ η εφαρμογή συνήθως έχει ήδη πρώταμεταγλωττιστείσεκώδικα μηχανής.[2]Οι πρώτες γλώσσες σεναρίων συχνά αποκαλούντανγλώσσες δέσμης(batch languages) ήγλώσσες ελέγχου εργασιών(job control languages). Αυτές οι πρώτες γλώσσες σεναρίων δημιουργήθηκαν για να συντομεύσουν την παραδοσιακή διαδικασίαδιόρθωση-μεταγλώττιση-σύνδεση-εκτέλεση.Ιστορία[Επεξεργασία|επεξεργασία κώδικα]Οι πρώτοικεντρικοί υπολογιστές(τη δεκαετία του 1950) δεν είχαν δυνατότητες αλληλεπίδρασης αλλά λειτουργούσαν με επεξεργασία δεσμών. ΗJob Control Language(JCL) της IBM είναι κλασική γλώσσα που χρησιμοποιήθηκε για τον έλεγχο της επεξεργασίας δεσμών.Τα πρώτα αλληλεπιδραστικάκελύφηαναπτύχθηκαν κατά τη δεκαετία του 1960 για να γίνει δυνατός ο απομακρυσμένος χειρισμός των πρώτων συστημάτων χρονικού διαμερισμού (time-sharing), τα οποία χρησιμοποιούσαν σενάρια κελύφους για τον έλεγχο της εκτέλεσης των προγραμμάτων, σε ένα πρόγραμμα, το κέλυφος.Γλώσσες όπως ηTclκαι ηLuaσχεδιάστηκαν ειδικά σαν γλώσσες σεναρίων γενικού σκοπού, οι οποίες να μπορούν να ενσωματωθούν σε οποιαδήποτε εφαρμογή. Άλλες γλώσσες όπως ηVisual Basic for Applications(VBA) παρείχαν σημαντική ολοκλήρωση με τις δυνατότητες αυτοματοποίησης του συστήματος στο οποίο εκτελούνταν. Η ενσωμάτωση αυτών των γλωσσών σεναρίων γενικού σκοπού αντί της ανάπτυξης μιας νέας γλώσσας ανά εφαρμογή είχε προφανή πλεονεκτήματα, γλιτώνοντας τον προγραμματιστή της εφαρμογής από την ανάγκη να δημιουργεί από το μηδέν έναν νέο μεταφραστή για τη γλώσσα, ενώ ο χρήστης μπορούσε να χρησιμοποιήσει γνώσεις που είχε αποκτήσει σε άλλα περιβάλλοντα.Υπάρχει λογισμικό που ενσωματώνει πολλές διαφορετικές γλώσσες προγραμματισμού. Οι σύγχρονοιπεριηγητές Ιστού(web browsers) συνήθως περιλαμβάνουν μια γλώσσα για τη συγγραφή επεκτάσεων του ίδιου του περιηγητή και αρκετές πρότυπες γλώσσες για τον έλεγχό του, όπως ηJavaScript(διάλεκτος τηςECMAScript) ή ηXUL.Τύποι γλωσσών σεναρίων[Επεξεργασία|επεξεργασία κώδικα]Γλώσσες ελέγχου εργασιών και κελύφη[Επεξεργασία|επεξεργασία κώδικα]Κύριο λήμμα:Σενάριο κελύφουςΟ έλεγχος εργασιών (job control) δημιουργησε μια μεγάλη κλάση γλωσσών σεναρίων, για την εκκίνηση και τον έλεγχο της συμπεριφοράς προγραμμάτων του συστήματος. (Σύμφωνα με αυτήν την έννοια, τα κελύφη γραμμής εντολών μπορούν να θεωρηθούν απόγονοι της γλώσσας προγραμματισμού JCL, ήJob Control Language, της IBM, που χρησιμοποιήθηκε ακριβώς για αυτόν τον σκοπό.) Πολλοί από τους διερμηνείς αυτών των γλωσσών παίζουν δεύτερο ρόλο και σανδιερμηνείς γραμμής εντολώνόπως τοκέλυφος Unixή τοCOMMAND.COMτουMS-DOS. Άλλες, όπως ηAppleScript, προσφέρουν σύνταξη και εντολές που να μοιάζουν μεΑγγλικά, για την κατασκευή σεναρίων. Σε συνδυασμό με τα πλαίσια τουCocoaτουMac OS X, ο χρήστης μπορεί να φτιάξει ολόκληρες εφαρμογές χρησιμοποιώντας μονο αντικείμεναAppleScriptκαιCocoa.Σενάρια GUI[Επεξεργασία|επεξεργασία κώδικα]Με την εμφάνιση τωνγραφικών διασυνδέσεων χρήστη(graphical user interfaces) αναπτύχθηκε ένα εξειδικευμένο είδος γλώσσας σεναρίων για τον έλεγχο του υπολογιστή. Γλώσσες αυτού του είδους αλληλεπιδρούν με τα ίδια γραφικά παράθυρα, μενού, ποντίκια και άλλα γραφικά αντικείμενα και τεχνολογίες που ελέγχει το σύστημα. Αυτό το επιτυγχάνουν προσομοιώνοντας τις ενέργειες ενός ανθρώπου-χρήστη και συνήθως χρησιμοποιούνται για τον αυτοματισμό ενεργειών του χρήστη ή για να ρυθμίσουν μια γνωστή κατάσταση. Όταν ο έλεγχος γίνεται μέσα από προσομοιωμένα πατήματα πλήκτρων ή κλικ του ποντικιού αυτές οι γλώσσες ονομάζονται \"μακροεντολές\" (\"macros\").Αυτές οι γλώσσες θα μπορούσαν θεωρητικά να χρησιμοποιηθούν για να ελέγξουν οποιαδήποτε εφαρμογή τρέχει σε έναν υπολογιστή που βασίζεται σε γραφική διασύνδεση χρήστη, στην πραγματικότητα όμως η υποστήριξη για τέτοιες γλώσσες συνήθως εξαρτάται από την εφαρμογή και τολειτουργικό σύστημα. Υπάρχουν κάποιες εξαιρέσεις σε αυτόν τον περιορισμό. Υπάρχουν γλώσσες αυτού του είδους που βασίζονται στην αναγνώριση γραφικών αντικειμένων από ταπίξελπου φαίνονται στην οθόνη και δεν εξαρτώνται από την υποστήριξη του λειτουργικού συστήματος ή της εφαρμογής.Εξειδικευμένες γλώσσες εφαρμογών[Επεξεργασία|επεξεργασία κώδικα]Πολλές μεγάλες εφαρμογές περιέχουν μια δική τους γλώσσα σεναρίων, προσαρμοσμένη στις ανάγκες του χρήστη. Επίσης, πολλά συστήματαβιντεοπαιχνιδιώνχρησιμοποιούν μια ειδική γλώσσα σεναρίων για την περιγραφή των προγραμματισμένων ενεργειών των χαρακτήρων που ελέγχονται από τον υπολογιστή (non-player characters, NPCs) και του περιβάλλοντος του παιχνιδιού. Οι γλώσσες αυτού του τύπου σχεδιάζονται για μια μόνο εφαρμογή και, αν και μπορεί να μοιάζουν με κάποια γλώσσα γενικού σκοπού (όπως η QuakeC τουQuake, που σχεδιάστηκε με βάση τηνC), έχουν ειδικά χαρακτηριστικά που τις ξεχωρίζουν. ΗEmacs Lisp, αν και πλήρης διάλεκτος τηςLisp, περιέχει κάποια ειδικά χαρακτηριστικά για την επέκταση των λειτουργιών του διορθωτήEmacs. Μια ειδική γλώσσα σεναρίων μιας εφαρμογής μπορεί να θεωρηθεί ότι είναι μιαγλώσσα προγραμματισμού ειδικού πεδίου(domain-specific programming language), η οποία εξειδικεύεται σε μια εφαρμογή.Φυλλομετρητές Ιστού[Επεξεργασία|επεξεργασία κώδικα]Οιφυλλομετρητές Ιστού(Web browsers) είναι εφαρμογές που εμφανίζουνιστοσελίδεςκαι μπορούν να εκτελέσουν σενάρια για να αλλάξουν την εμφάνιση ή την συμπεριφορά των ιστοσελίδων αυτών (για παράδειγμα, να αλλάξουν το περιεχόμενο ανάλογα με τον χρήστη που το βλέπει). Έχουν αναπτυχθεί αρκετές ειδικές γλώσσες ελέγχου φυλλομετρητών, όπως ηJavaScript, ηVBScriptτηςMicrosoft(που λειτουργεί μόνο στονInternet Explorer), ηXULτου εγχειρήματοςMozilla(που λειτουργεί μόνο στονFirefox) και ηXSLT, μια γλώσσα παρουσίασης που μετατρέπει περιεχόμενο XML σε κάποια νέα μορφή. Όταν χρησιμοποιούνται τεχνικές που συνδυάζουν τηνXMLκαι τα σενάρια JavaScript για να βελτιωθεί η εμπειρία του χρήστη και η απόκριση μιας ιστοσελίδας, η πρακτική ονομάζεταιAJAX. Τα σενάρια στην πλευρά του πελάτη (client-side scripts) στέλνονται από τονδιακομιστήστον υπολογιστή του πελάτη. Παράδειγμα σεναρίου στην πλευρά του πελάτη είναι μια ιστοσελίδα που περιέχει ένα κουμπί, το οποίο, όταν πατηθεί από τον χρήστη, εμφανίζει ένα παράθυρο με κάποιο μήνυμα μέσω JavaScript.Γλώσσες επεξεργασίας κειμένου[Επεξεργασία|επεξεργασία κώδικα]Η επεξεργασία εγγραφών κειμένου είναι από τις παλαιότερες χρήσεις των γλωσσών σεναρίων. Τα σενάρια που γράφονται για τα εργαλεία τουUnixAWK,sedκαιgrepαυτοματοποιούν εργασίες που έχουν να κάνουν με ρυθμίσεις με μορφήκειμένουκαι με αρχεία καταγραφών (log files). Σημαντικό ρόλο παίζουν οικανονικές εκφράσεις, που είναι μιατυπική γλώσσαπου περιγράφει τη λεξιλογική δομή του κειμένου, και η οποία χρησιμοποιείται από όλα αυτά τα εργαλεία.ΗPerlσχεδιάστηκε αρχικά για να αντιμετωπιστούν περιορισμοί σε αυτά τα εργαλεία και έχει καταλήξει να είναι μια από τις πιο ευρέως χρησιμοποιούμενες γλώσσες κοινού σκοπού.Δυναμικές γλώσσες γενικού σκοπού[Επεξεργασία|επεξεργασία κώδικα]Δείτε επίσης:Δυναμική γλώσσα προγραμματισμούΚάποιες γλώσσες, όπως ηPerl, άρχισαν σαν γλώσσες σεναρίων αλλά στη συνέχεια αναπτύχθηκαν σε γλώσσες προγραμματισμούς για ευρύτερους σκοπούς. Άλλες παρόμοιες γλώσσες – συχνά διερμηνευμένες, με αυτόματη διαχείριση μνήμης ή μεδυναμικά χαρακτηριστικά– έχουν περιγραφεί σαν \"γλώσσες σεναρίων\", λόγω των ομοιοτήτων τους, ακόμα και αν χρησιμοποιούνται συχνότερα για την ανάπτυξη εφαρμογών. Συνήθως αυτές οι γλώσσεςδεναποκαλούνται \"γλώσσες σεναρίων\" από τους ίδιους τους χρήστες τους.Γλώσσες επέκτασης και ενσωματωμένες γλώσσες[Επεξεργασία|επεξεργασία κώδικα]Αρκετές γλώσσες έχουν σχεδιαστεί έτσι ώστε να μπορούν να αντικαταστήσουν τις γλώσσες σεναρίων που είναι εξειδικευμένες για κάποια εφαρμογή, προσφέροντας ενσωμάτωση στο πρόγραμμα της εφαρμογής. Ο προγραμματιστής της εφαρμογής (που χρησιμοποιεί C ή κάποια άλλη γλώσσα χαμηλού επιπέδου ή προγραμματισμού συστημάτων) προσθέτει \"σημεία αγκίστρωσης\" (\"hooks\"), όπου η γλώσσα σεναρίων μπορεί να ελέγξει την εφαρμογή. Οι γλώσσες αυτές έχουν τον ίδιο σκοπό με τις εξειδικευμένες γλώσσες επέκτασης εφαρμογών αλλά ο χρήστης έχει το πλεονέκτημα να μπορεί να μεταφέρει κάποιες από τις γνώσεις του ανάμεσα στις εφαρμογές.Η JavaScript ξεκίνησε, και σε μεγάλο βαθμό εξακολουθεί, να είναι γλώσσα συγγραφής σεναρίων μέσα σε φυλλομετρητές αλλά η δημιουργία προτύπου της γλώσσας (ECMAScript) την έκανε δημοφιλή σαν γλώσσα γενικού σκοπού που μπορεί να ενσωματωθεί. Ειδικότερα η υλοποίηση του εγχειρήματοςMozilla(SpiderMonkey) ενσωματώνεται σε πολλά περιβάλλοντα, όπως τοYahoo! Widget Engine. Άλλες εφαρμογές που ενσωματώνουν υλοποιήσεις της ECMAScript είναι τα προϊόντα τηςAdobe,Adobe Flash(ActionScript) καιAdobe Acrobat(για σενάρια σε αρχείαPDF).ΗTclδημιουργήθηκε σαν γλώσσα επέκτασης αλλά χρησιμοποιείται πια πιο συχνά όπως ηPython, ηPerlκαι ηRuby.Υπάρχουν πολύπλοκες εφαρμογές, που βασίζονται στις εργασίες (tasks), οι οποίες μπορεί να ενσωματώνουν και να δίνουν στον χρήστη μια γλώσσα προγραμματισμού για περισσότερες δυνατότητες ελέγχου και λειτουργίες μέσω μιας διεπαφής χρήστη (η οποία μπορεί να είναι και αυτή πολύπλοκη). Για παράδειγμα, τα εργαλεία δημιουργίας3DτουAutodesk Mayaενσωματώνουν τη γλώσσα σεναρίωνMEL, ενώ τοBlenderχρησιμοποιεί για τον ίδιο σκοπό τηνPython.Άλλοι τύποι εφαρμογών που χρειάζονται έναν τρόπο να προστίθενται γρήγορα νέα χαρακτηριστικά ή να είναι γρηγορότερος ο κύκλος τροποποίηση-εκτέλεση του κώδικα (όπως οιμηχανές παιχνιδιών) χρησιμοποιούν επίσης κάποια ενσωματωμένη γλώσσα. Κατά τη διάρκεια της ανάπτυξης, αυτό διευκολύνει τη γρήγορη δημιουργία και τροποποίηση χαρακτηριστικών, χωρίς ο χρήστης να πρέπει να γνωρίζει τις εσωτερικές λειτουργίες της εφαρμογής ή να πρέπει να την μεταγλωττίζει πάλι μετά από κάθε αλλαγή (κάτι που μπορεί να είναι χρονοβόρο). Για αυτόν τον σκοπό, χρησιμοποιούνται πολλές γλώσσες σεναρίων, από τις πιο γνωστέςLuaκαιPython, σε λιγότερο γνωστές όπως ηAngelScriptκαι ηSquirrel.Ανάλυση αγοράς[Επεξεργασία|επεξεργασία κώδικα]Σύμφωνα με μια έρευνα σε παγκόσμιο επίπεδο της Evans Data το 2008[1]Αρχειοθετήθηκε2011-11-23 στοWayback Machine., η πιο διαδεδομένη γλώσσα σεναρίων είναι ηJavaScriptκαι ακολουθεί ηPHP. ΗPerlείναι η τρίτη πιο διαδεδομένη γλώσσα σεναρίων, αλλά είναι πολύ πιο διαδεδομένη στηΒόρεια Αμερική.[3]Δείτε επίσης[Επεξεργασία|επεξεργασία κώδικα]Διερμηνευμένη γλώσσαShebang (Unix)Κέλυφος (υπολογιστές)Προγραμματισμός συστημάτωνWeb template languagesΠαραπομπές[Επεξεργασία|επεξεργασία κώδικα]↑IEEE Computer, 2008,In praise of scripting,Ronald Loui↑Brown, Vicki.«\"Scripting Languages\"». Ανακτήθηκε στις 22 Ιουλίου 2009.↑«PHP, JavaScript, Ruby, Perl, Python, and Tcl Today: The State of the Scripting Universe - CIO.com». Αρχειοθετήθηκεαπό το πρωτότυποστις 23 Νοεμβρίου 2011. Ανακτήθηκε στις 28 Σεπτεμβρίου 2011.Εξωτερικοί σύνδεσμοι[Επεξεργασία|επεξεργασία κώδικα]Patterns for Scripted Applications(Αγγλικά)Are Scripting Languages Any Good? A Validation of Perl, Python, Rexx, and Tcl against C, C++, and Java (PDF)— μελέτη του 2003(Αγγλικά)Scripting on the Java platform— JavaWorld(Αγγλικά)\"Programming is Hard - Let's Go Scripting\" by Larry Wall- μεταγραφή του λόγου State of the Onion στην ιστοσελίδα Perl.com."
    },
    {
        "url": "https://el.wikipedia.org/wiki/%CE%9A%CE%BB%CE%AE%CF%83%CE%B5%CE%B9%CF%82_%CF%83%CF%85%CF%83%CF%84%CE%AE%CE%BC%CE%B1%CF%84%CE%BF%CF%82",
        "title": "Κλήση συστήματος",
        "content": "Το λήμμα παραθέτει τις πηγές του αόριστα, χωρίςπαραπομπές.Βοηθήστε συνδέοντας το κείμενο με τις πηγέςχρησιμοποιώντας παραπομπές, ώστε να είναιεπαληθεύσιμο.Το πρότυπο τοποθετήθηκε χωρίς ημερομηνία. Για τη σημερινή ημερομηνία χρησιμοποιήστε:{{χωρίς παραπομπές|10|01|2025}}Στηνπληροφορικήκλήσεις συστήματοςονομάζεται ένα σύνολο υπηρεσιών που παρέχει οπυρήναςτουλειτουργικού συστήματοςμέσω μίας προτυποποιημένηςπρογραμματιστικής διασύνδεσης. Κανονικά ο κώδικας των εκτελούμενωνπρογραμμάτων(«κώδικας χρήστη») δεν έχει άμεση πρόσβαση στον πυρήνα, αλλά χάρη στις κλήσεις συστήματος που αυτός εξάγει, τα προγράμματα χρήστη μπορούν να καλούν με ελεγχόμενο τρόποδιαδικασίεςπου παρέχουν υπηρεσίες στον καλούντα. Η σύνταξη, η σημασιολογία και η ονοματολογία των κλήσεων συστήματος διαφέρει από ΛΣ σε ΛΣ, με αποτέλεσμα έναεκτελέσιμοπρόγραμμα συνήθως να μπορεί να τρέξει μόνο σε ένα ΛΣ. Ο κώδικας χρήστη δεν μπορεί να προσπελάσει μόνος του τους πόρους τουυπολογιστή(π.χ.δίσκους,μνήμησυστήματος,περιφερειακές συσκευές,δίκτυοκλπ), αλλά μπορεί να ζητήσει ό,τι χρειάζεται (π.χ. άνοιγμα ενόςαρχείουστον δίσκο) από τον πυρήνα μέσω των κλήσεων συστήματος.Συνήθως οιγλώσσες προγραμματισμούπαρέχουν προτυποποιημένεςβιβλιοθήκεςπου αποκρύπτουν αυτήν τη διαδικασία από τον προγραμματιστή και παρέχουν φορητότηταπηγαίου κώδικααπό ΛΣ σε ΛΣ. Π.χ. η απλή συνάρτησηfopen()της πρότυπης βιβλιοθήκης τηςγλώσσας C, με κοινή σύνταξη για όλες τιςαρχιτεκτονικέςκαι λειτουργικά συστήματα αλλά με διαφορετική υλοποίηση για το καθένα, όταν κληθεί καλεί με τη σειρά της την αντίστοιχη κλήση συστήματος - κατά κανόνα πιο πολύπλοκη - που παρέχει το υποκείμενο ΛΣ. Ο κώδικας που υλοποιεί τις κλήσεις συστήματος είναι ουσιαστικά τμήμα του πυρήνα, οπότε ηfopen()του συγκεκριμένου παραδείγματος ζητά μετάβαση του επεξεργαστή σε «κατάσταση πυρήνα», κατά την οποία μπορούν να εκτελεστούν εντολές με άμεση επίδραση στο υλικό και στους πόρους του υπολογιστή, και μεταφέρει τον έλεγχο στον κώδικα της κλήσης συστήματος. Όταν ο τελευταίος τερματίσει ο επεξεργαστής μεταβαίνει πάλι σε «κατάσταση χρήστη» και ηfopen()συνεχίζει την εκτέλεσή της από την εντολή που ακολουθεί την κλήση συστήματος. Φυσικά τα προγράμματα χρήστη μπορούν να παρακάμψουν τηνfopen()και να καλέσουν κατευθείαν τον πυρήνα, κάτι που γίνεται αναγκαστικά όταν η βιβλιοθήκη της γλώσσας προγραμματισμού δεν παρέχει υψηλού επιπέδου διασύνδεση (όπως τηνfopen()) για κάποια λειτουργία. Ακόμα και σε αυτή την περίπτωση όμως οι κλήσεις συστήματος είναι προσπελάσιμες από τα προγράμματα χρήστη μόνο μέσω της μεσολάβησης των βιβλιοθηκών συστήματος (π.χ. τηςglibc), αφού για παράδειγμα η κλήση συστήματος OPEN των ΛΣ τύπουUnixκαθίσταται προσβάσιμη μέσω της συνάρτησης συστήματοςopen(), η οποία είναι αυτή που καλείται εσωτερικά από την υψηλότερου επιπέδουfopen()στις υλοποιήσεις τηςπρότυπης βιβλιοθήκης της Cγια Unix.Κάθε φορά που μίαδιεργασίακαλεί μία κλήση συστήματος το ΛΣ εκτελεί έναν έλεγχο ώστε να επιβεβαιώσει ότι πράγματι η διεργασία αυτή έχει δικαίωμα να εκτελέσει τη συγκεκριμένη πράξη στον συγκεκριμένο πόρο (π.χ. ανάγνωση αρχείου). Τα δικαιώματα πρόσβασης των διαφορετικών χρηστών του συστήματος (άρα και των διεργασιών που αυτοί δημιουργούν μέσω των προγραμμάτων που εκτελούν), διατηρούνται από το ΛΣ σε κατάλληλεςδομές δεδομένων. Οι κλήσεις συστήματος διαχειρίζονται τους ίδιους πόρους για λογαριασμό διαφορετικών διεργασιών, με αποτέλεσμα να προσπελαύνουν και να τροποποιούν κατά τη λειτουργία τους τις ίδιες εσωτερικές δομές δεδομένων του πυρήνα. Το λειτουργικό σύστημα αναλαμβάνει νασυντονίσειτις κλήσεις συστήματος που εκτελούνται από κάθε διεργασία ώστε να μην προξενούνται προβλήματα. Ακόμη, οχρονοπρογραμματιστήςτου πυρήνα επιβλέπει κάθε κλήση συστήματος, αφού πολλές από αυτές οδηγούν σε αναστολή της καλούσας διεργασίας μέχρι να απελευθερωθεί κάποιος πόρος ή να ικανοποιηθεί κάποια άλλη συνθήκη.Unix[Επεξεργασία|επεξεργασία κώδικα]Κύριο λήμμα:POSIXΣτα συστήματα Unix οι κλήσεις συστήματος, οι οποίες χαρακτηρίζονται από ένα αναγνωριστικό όνομα και έναν αριθμόπαραμέτρων, εκτελούνται μέσα από κατάλληλες συναρτήσεις της γλώσσας προγραμματισμού C, ομαδοποιημένες σεβιβλιοθήκεςτου συστήματος. Οι βιβλιοθήκες αυτές συνήθως διατηρούν εσωτερική «κατάσταση» (καθολικέςμεταβλητέςκαι δομές δεδομένων), οπότεσυνδέονταιστατικά κατά τημεταγλώττισηενός προγράμματος με αυτό· έτσι κάθε εφαρμογή έχει ενσωματωμένο το δικό της στιγμιότυπο των βιβλιοθηκών συστήματος που χρησιμοποιεί.Κάθε κλήση συστήματος επιστρέφει έναν ακέραιο αριθμό στη συνάρτηση που την κάλεσε· αρνητική τιμή επιστροφής σημαίνει αποτυχία ενώ θετική σημαίνει επιτυχία. Σε περίπτωση αποτυχίας ο κωδικός λάθους αποθηκεύεται στηνerrno, μία εσωτερική καθολική μεταβλητή που διατηρεί αυτομάτως το λειτουργικό σύστημα για κάθε διεργασία ξεχωριστά. Η τιμή της errno διατηρείται μέχρι την επόμενη κλήση συστήματος, ασχέτως αν αυτή θα είναι επιτυχής ή αποτυχημένη. Το μήνυμα που αντιστοιχεί στον τρέχοντα κωδικό λάθους της errno επιστρέφεται από τη συνάρτησηstrerror()που παρέχει η γλώσσα C σε περιβάλλοντα Unix, ενώ εκτύπωση αυτού του μηνύματος γίνεται με την αντίστοιχη συνάρτησηperror().Η προγραμματιστική διασύνδεση των κλήσεων συστήματος των διαφόρων εκδοχών του Unix οριστικοποιήθηκε με τη σειρά προτύπωνPOSIX(IEEE1003), τα οποία επίσης καθόριζαν και άλλες λεπτομέρειες του ΛΣ όπως τοκέλυφοςγραμμής εντολών. Έτσι οπηγαίος κώδικαςενός προγράμματος μπορεί να μεταγλωττιστεί επιτυχώς σε οποιοδήποτε λειτουργικό σύστημα ακολουθεί το πρότυπο POSIX χωρίς να χρειαστεί αλλαγές, ενώ η συμμόρφωση με το POSIX αποτελεί προϋπόθεση για να μπορεί ένα λειτουργικό σύστημα να αποκαλείται Unix.Windows[Επεξεργασία|επεξεργασία κώδικα]Κύριο λήμμα:Διασύνδεση Προγραμματισμού Εφαρμογών WindowsΠηγές[Επεξεργασία|επεξεργασία κώδικα]Αρχιτεκτονική Υπολογιστών: Μια Δομημένη Προσέγγιση,Tanenbaum Andrew S., Εκδ. ΚλειδάριθμοςΣύγχρονα Λειτουργικά Συστήματα, Tanenbaum Andrew S., Εκδ. Κλειδάριθμος"
    },
    {
        "url": "https://el.wikipedia.org/wiki/Microsoft_Windows",
        "title": "Microsoft Windows",
        "content": "Το λήμμα δεν περιέχειπηγέςή αυτές που περιέχει δεν επαρκούν.Μπορείτε να βοηθήσετεπροσθέτοντας την κατάλληλη τεκμηρίωση. Υλικό που είναι ατεκμηρίωτο μπορεί να αμφισβητηθεί και να αφαιρεθεί.Η σήμανση τοποθετήθηκε στις 13/10/2016.Microsoft WindowsΓενικάΔημιουργοίMicrosoftΗμερ. Δημιουργίας20 Νοέμβριος 1985ΕίδοςMS-DOS/9x-based, Windows CE, Windows NTΔιανομήΈκδοση10.0.22000.556 (8 Μάρτιος 2022)[1]Δοκιμαστική έκδοση10.0.22567.200 (7 Μάρτιος 2022)ΛειτουργικάΑρχιτεκτονικήΑρχιτεκτονική ARM,x86[2][3]Διαχείριση πακέτωνMicrosoft StoreΔιαθέσιμο σε137 γλώσσεςΠροκάτοχοςMS-DOSΑνάπτυξηΤύποςΛειτουργικό ΣύστημαΓραφικό περιβάλλονΔιεπαφή Προγραμματισμού Εφαρμογών Windows, NET FrameworkΓραμμένο σεC,C++,AssemblyΚατάστασηΕνεργήΆδεια χρήσηςMS-EULAΣύνδεσμοιΕπίσημος ιστότοποςMicrosoft WindowsΤαMicrosoft Windows(ή απλάWindows) είναι μια σειρά απόλειτουργικά συστήματαγιαπροσωπικούςυπολογιστέςκαιδιακομιστές. Η σειρά εμφανίστηκε πρώτα από τηMicrosoftτο1985για να ανταγωνιστεί το καινούριο σύστημα τηςApple, τονApple Macintosh, το οποίο χρησιμοποιούσεγραφικό περιβάλλον. Τα Microsoft Windows τελικά επικράτησαν στην παγκόσμια αγορά προσωπικών υπολογιστών με ένα μερίδιο αγοράς που υπολογίζεται περίπου στο 90%. Τα Microsoft Windows είναι λογισμικό κλειστού κώδικα.Tα Windows αναπτύχθηκαν για τουςIBMσυμβατούς μικροϋπολογιστές, οι οποίοι ήταν βασισμένοι στην αρχιτεκτονικήx86τηςIntelκαι σήμερα σχεδόν όλες οι εκδόσεις των Windows είναι κατασκευασμένες για αυτή την πλατφόρμα.Από τον Σεπτέμβριο του 2022, η πιο πρόσφατη έκδοση των Windows γιαυπολογιστές,tabletκαι ενσωματωμένες συσκευές είναι ταWindows 11. Οι πιο πρόσφατες εκδόσεις για υπολογιστές διακομιστή είναι ο Windows Server 2022. Μια εξειδικευμένη έκδοση των Windows εκτελείται στηνκονσόλα παιχνιδιώνXbox One.Εκδόσεις των Windows[Επεξεργασία|επεξεργασία κώδικα]Εκδόσεις DOS[Επεξεργασία|επεξεργασία κώδικα]Windows 1.0Κύριο λήμμα:Windows 1.0ΤαWindows 1.0ήταν έναγραφικό περιβάλλονλειτουργίας 16-bit, που κυκλοφόρησε στις 20 Νοεμβρίου 1985, από τηναμερικανικήεταιρείαMicrosoft. Ήταν η πρώτη προσπάθεια της Microsoft να εφαρμόσει μίαmultitaskingγραφική διεπαφή χρήστη-λειτουργικού περιβάλλοντος που βασίζονται στην πλατφόρμα του υπολογιστή.Windows 2.0Κύριο λήμμα:Windows 2.0ΤαWindows 2.0ήταν ένα 16-bitλειτουργικό περιβάλλοντης σειράς προϊόντων Micrososft Windows . Χρησιμοποιούσε ως βάση το λειτουργικό σύστημαMS-DOS. Ήταν το επόμενο προϊόν μετά ταWindows 1.0Τα Windows 2.0 συμπληρώθηκαν με ταWindows/286καιWindows/386το 1988.Windows 2.1xΚύριο λήμμαWindows 2.1xΤαWindows 2.1x(μεκωδικό όνομαBlaze) είναι μια σειρά λειτουργικών συστημάτων λειτουργικών περιβαλλόντων βασισμένα σεγραφικά περιβάλλοντακαι δημιουργήθηκε από την Microsoft. Αποτελείται από ταWindows/286καιWindows/386, τα οποία κυκλοφόρησαν 27 Μαΐου του 1988, λιγότερο από έξι μήνες μετά ταWindows 2.0.Windows 3.0Κύριο λήμμα:Windows 3.0ΤαWindows 3.0είναι η τρίτη μεγάλη έκδοση των Microsoft Windows, και κυκλοφόρησαν στις 22 Μαΐου1990. Έγινε η πρώτη πολύ επιτυχημένη έκδοση των Windows και έγινε ισχυρός αντίπαλος για τα υπόλοιπαλειτουργικά συστήματα. ΤαWindows 3.1ακολούθησαν την έκδοση των Windows 3.0.Windows 3.1xΚύριο λήμμα:Windows 3.1xΤαWindows 3.1x(μεκωδικό όνομαJanus) είναι μια σειρά λειτουργικών συστημάτων16-bitπου δημιουργήθηκε από την Microsoft για χρήση σε προσωπικούς υπολογιστές. Η σειρά ξεκίνησε με τα Windows 3.1 τον Απρίλιο του 1992 ως ο διάδοχος τωνWindows 3.0.Windows 9x[Επεξεργασία|επεξεργασία κώδικα]Windows 95Κύριο λήμμα:Windows 95ΤαWindows 95(με κωδικό όνομα Chicago) είναι μια προσανατολισμένη προς τον καταναλωτή γραφική διεπαφή χρήστη με βάση τολειτουργικό σύστημα. Κυκλοφόρησαν στις 24 Αυγούστου 1995 από τηMicrosoft, και ήταν μια σημαντική εξέλιξη από τις προηγούμενες εκδόσεις των Windows.Windows 98Κύριο λήμμα:Windows 98ΤαWindows 98(μεκωδικό όνομαMemphis) είναι ένα γραφικόλειτουργικό σύστηματηςMicrosoft. Παρουσιάστηκε στους κατασκευαστές στις 15 Μαΐου 1998 και στα καταστήματα στις 25 Ιουνίου 1998. Τα Windows 98 αντικατέστησαν ταWindows 95Windows MeΚύριο λήμμα:Windows MeΤαWindows Me(Millennium Edition) ήταν σχεδιασμένα για χρήση σε οικιακούς υπολογιστές και παρείχαν αρκετές βελτιώσεις στις λειτουργίες μουσικής, βίντεο και οικιακής δικτύωσης, καθώς επίσης και στην αξιοπιστία, σε σύγκριση με τις προηγούμενες εκδόσεις. Τα Windows Me κυκλοφόρησαν στις 14 Σεπτεμβρίου του 2000.Windows NT[Επεξεργασία|επεξεργασία κώδικα]Πρώτες εκδόσειςWindows NT 3.1Κύριο λήμμα:Windows NT 3.1ΤαWindows NT 3.1ήταν η πέμπτη έκδοση των Micrososft Windows και ανήκει στην οικογένεια της Microsoft. Κυκλοφόρησαν στις 27 Ιουλίου του 1993 και ήταν η πρώτη έκδοση τωνWindows NT(New Technology-ελλ. Νέα Τεχνολογία-). Τα Windows NT 3.1 τα διαδέχτηκαν ταWindows NT 3.5.Windows NT 3.5Κύριο λήμμα:Windows NT 3.5ΤαWindows NT 3.5(με κωδικό όνομα Daytona) είναι ένα λειτουργικό σύστημα που δημιουργήθηκε από τη Microsoft και κυκλοφόρησε στις 21 Σεπτεμβρίου 1994. Είναι η δεύτερη έκδοση τωνWindows NTκαι ο διάδοχος τωνWindows NT 3.1.Windows NT 3.51Κύριο λήμμα:Windows NT 3.51ΤαWindows NT 3.51είναι ένα λειτουργικό σύστημα που δημιουργήθηκε από τηMicrosoftκαι κυκλοφόρησε στις 30 Μαΐου του 1995. Είναι η τρίτη έκδοση τωνWindows NTκαι ο διάδοχος τωνWindows NT 3.5. Τα Windows NT 3.51 διαδέχτηκαν ταWindows NT 4.0. Η υποστήριξη των Windows NT 3.51 έληξε στις 31 Δεκεμβρίου του 2001.Windows NT 4.0Κύριο λήμμα:Windows NT 4.0ΤαWindows NT 4.0είναι ένα προληπτικό πολλαπλών εργασιών γραφικό λειτουργικό σύστημα 32-bit που δημιουργήθηκε από τη Microsoft και κυκλοφόρησε στις 31 Ιουλίου 1996. Σχεδιάστηκε για υπολογιστέςuniprocessorήσυμμετρικής πολυεπεξεργασίαςκαι είναι μέρος της σειράς λειτουργικών συστημάτων με όνομαWindows NT.Windows 2000Κύριο λήμμα:Windows 2000Εκδόσεις πελατώνΤαWindows 2000είναι ένα λειτουργικό σύστημα που κυκλοφόρησαν για βιομηχανοποίηση στις 15 Δεκεμβρίου του 1999 και διαθέσιμα στις 17 Φεβρουαρίου του 2000 και είναι ο διάδοχος τωνWindows NT 4.0.Windows XPΚύριο λήμμα:Windows XPΤαWindows XP(κωδικός Whistler, επίσης γνωστά ως Windows NT 5.1) είναι έναλειτουργικό σύστηματωνWindowsτηςMicrosoftγια προσωπικούς υπολογιστές. Κυκλοφόρησε στις 25 Οκτωβρίου 2001.Windows VistaΚύριο λήμμα:Windows VistaΤαWindows Vista(με κωδική ονομασίαLonghorn) είναι μία έκδοση του λειτουργικού συστήματος Microsoft Windows τηςMicrosoft. Κυκλοφόρησαν στις 30 Ιανουαρίου 2007.Windows 7Κύριο λήμμα:Windows 7ΤαWindows 7(προηγουμένως γνωστά με τιςκωδικές ονομασίεςBlackcomb και Vienna) είναι ο διάδοχος τωνWindows Vistaκαι κυκλοφόρησαν στις22 Οκτωβρίου2009σε32-bitκαι σε64-bitεκδόσεις.Windows 8 και 8.1Κύριο λήμμα:Windows 8καιWindows 8.1ΤαWindows 8είναι έκδοση τουλειτουργικού συστήματοςWindowsτηςMicrosoft. Κυκλοφορήσαν στην αγορά στις 26 Οκτωβρίου 2012[4], όπως ανακοίνωσε ηMicrosoft. Προορίζονται για χρήση σεεπιτραπέζιουςκαιφορητούς υπολογιστές, καθώς και σεtablet.ΤαWindows 8.1(κωδική ονομασία Blue) είναι μια αναβάθμιση για ταWindows 8, μια έκδοση τωνWindows NT, έναλειτουργικό σύστημαυπολογιστή που κυκλοφόρησε από τηMicrosoft. Κυκλοφόρησε επίσημα στις 17 Οκτωβρίου του 2013, σχεδόν ένα χρόνο μετά την επίσημη έκδοση του προκατόχου του.Windows 10Κύριο λήμμα:Windows 10ΤαWindows 10είναι ένα λειτουργικό σύστημα τηςMicrosoftγια υπολογιστές, τα οποία κυκλοφόρησαν επισήμως στις 29 Ιουλίου του 2015 και αποτέλεσαν το νεότερο λειτουργικό σύστημα της εταιρίας μέχρι τις 5 Οκτωβρίου 2021, όπου και κυκλοφόρησε η επόμενη έκδοση τωνWindows, ταWindows 11.Windows 11Κύριο λήμμα:Windows 11ΤαWindows 11είναι μια σημαντική έκδοση τουλειτουργικού συστήματοςWindows NTπου αναπτύχθηκε από τηMicrosoftκαι ανακοινώθηκε στις 24 Ιουνίου 2021 και είναι ο διάδοχος τωνWindows 10, που κυκλοφόρησαν το 2015. Τα Windows 11 κυκλοφόρησαν στις 5 Οκτωβρίου 2021, ως δωρεάν αναβάθμιση μέσω τουWindows Updateγια κατάλληλες συσκευές με Windows 10.Windows ServerWindows Server 2003Κύριο λήμμα:Windows Server 2003ΤαWindows Server 2003είναι λειτουργικό σύστημα τηςMicrosoftκαι κυκλοφόρησε στις 24 Απριλίου του 2003. Βασίζονται σταWindows XPκαι είναι μια ενισχυμένη έκδοση. Δύο χρόνια αργότερα, το 2005, μια καινούρια έκδοση των Windows Server 2003 κυκλοφόρησε με όνομαWindows Server 2003 R2Windows Server 2008Windows Server 2012Windows Server 2016Windows Server 2019Windows Server 2022Εξειδικευμένες εκδόσειςWindows Preinstallation EnvironmentWindows Embedded[Επεξεργασία|επεξεργασία κώδικα]Embedded CompactΚύριο λήμμα:Windows CEΤαWindows CEείναιλειτουργικό σύστηματηςMicrosoftγια μικρούς υπολογιστές,προσωπικούς βοηθούςκαιενσωματωμένα συστήματα. Η τελευταία έκδοσή του (6.0) αναφέρεται επίσημα ωςWindows Embedded CE. Είναι λειτουργικό διαφορετικό από ταWindowsγια προσωπικούς υπολογιστές και βασίζεται σε πυρήνα που αναπτύχθηκε ανεξάρτητα.CE 5.0Embedded CE 6.0Embedded Compact 7Embedded AutomotiveEmbedded IndustryEmbedded 8Windows Mobile[Επεξεργασία|επεξεργασία κώδικα]Pocket PC 2000Κύριο λήμμα:Pocket PC 2000ΤαPocket PC 2000 (με κωδικό όνομα Rapier) είναι η πρώτη έκδοση τουWindows Mobile. Κυκλοφόρησαν στις 19 Απριλίου του 2000, ήταν βασισμένα σταWindows CE 3.0και ήταν ο διάδοχος τωνPalm-size PCs, μεσυμβατότητανα ήταν διαθέσιμη για εφαρμογές των Palm-size PCs.Pocket PC 2002Mobile 2003Mobile 5.0Mobile 6.0Mobile 6.1Mobile 6.5Windows Phone[Επεξεργασία|επεξεργασία κώδικα]Phone 7Κύριο λήμμα:Phone 7Τα WindowsPhone 7ανακοινώθηκαν στις 15 Φεβρουαρίου του 2010 και κυκλοφόρησαν στις 8 Νοεμβρίου του 2010 στις ΗΠΑ.Το2011, ηMicrosoftκυκλοφόρησε τα Windows Phone 7.5 “Mango”. Η αναβάθμιση περιλάμβανε τονφυλλομετρητήInternet Explorer 9. Μια μικρή αναβάθμιση κυκλοφόρησε το2012γνωστή ως “Tango”, περιλάμβανε επιδιορθώσεις σφαλμάτων και το λειτουργικό σύστημα χρειαζόταν λιγότερες απαιτήσεις υλισμικού, για να λειτουργήσει σε έξυπνα τηλέφωνα μεεπεξεργαστική ισχή800 MHz και 256GBRAM.Phone 8Phone 8.110 (mobile)Ακυρωθείσες εκδόσεις[Επεξεργασία|επεξεργασία κώδικα]CairoΚύριο λήμμα:CairoΤαWindows Cairoήταν το κωδικό όνομα ενός έργου στηMicrosoftαπό το 1991 έως το 1996.ΤαWindows Cairoδεν κυκλοφόρησαν ποτέ, παρόλο που τμήματα των τεχνολογιών του έχουν έκτοτε εμφανιστεί σε άλλα προϊόνταNashvilleΚύριο λήμμα:NashvilleΤαWindows Nashville(πρώην Cleveland) ήταν μια ακυρωθείσα έκδοση των Windows. Κυκλοφόρησαν το 1996, ανάμεσα σε Chicago (Windows 95) και Memphis (Windows 98), και αναφερόταν δημόσια ως και Windows 96.NeptureΚύριο λήμμαNeptuneΤαWindows Neptuneήταν μια ακυρωθείσα έκδοση τωνWindows. Κυκλοφόρησαν στις 27 Δεκεμβρίου του 1999 και βασιζόταν σταWindows 2000. Ήταν η πρώτη έκδοση των Windows που ήταν σχεδιασμένη στον κώδικα τωνWindows NTκαι αντικατέστησε τις εκδόσειςWindows 9x.OdysseyΚύριο λήμμα:OdysseyΤοWindows Odysseyείναι η κωδική ονομασία μιας έκδοσης του λειτουργικού συστήματος Micrososft Windows, η οποία ακυρώθηκε και προοριζόταν να ακολουθήσει την έκδοση Windows 2000. Αργότερα συνδυάστηκε με ταWindows Neptuneγια τη δημιουργία τωνWindows XP.Λογότυπο[Επεξεργασία|επεξεργασία κώδικα]1985-19921992-19951995-20012001-20072007-20092009-20122012-20212021-ΣήμεραΔείτε επίσης[Επεξεργασία|επεξεργασία κώδικα]Windows CEWindows MobileWindows PhoneΠαραπομπές[Επεξεργασία|επεξεργασία κώδικα]↑Error: Unable to display the reference properly. Seethe documentationfor details.↑Error: Unable to display the reference properly. Seethe documentationfor details.↑Error: Unable to display the reference properly. Seethe documentationfor details.↑http://www.zdnet.com/windows-8s-delivery-date-october-26-7000001158/Εξωτερικοί σύνδεσμοι[Επεξεργασία|επεξεργασία κώδικα]Commons logoΤαWikimedia Commonsέχουν πολυμέσα σχετικά με το θέμαMicrosoft WindowsΕπίσημος ιστότοποςBlogMicrosoft Developer NetworkInformIT- Ιστορία των Microsoft WindowsπσεΕκδόσεις τωνMicrosoft WindowsΕκδόσειςDOSWindows 1.0Windows 2.0Windows 2.1xWindows 3.0Windows 3.1xWindows 9xWindows 95(Ανάπτυξη)Windows 98Windows MeWindows NTΠρώτες εκδόσειςWindows NT 3.1Windows NT 3.5Windows NT 3.51Windows NT 4.0Windows 2000Εκδόσεις πελατώνWindows XPεκδόσειςx64Media CenterFundamentalsWindows VistaεκδόσειςWindows 7εκδόσειςWindows 8εκδόσεις8.1RTWindows 10εκδόσειςWindows 11Windows ServerServer 2003Home ServerServer 2008EBS 2008HPC Server 2008Server 2008 R2Home Server 2011Server 2012Server 2016Server 2019MultiPoint ServerServer EssentialsΕξειδικευμένες εκδόσειςWindows Preinstallation EnvironmentWindows EmbeddedEmbedded CompactCE 5.0Embedded CE 6.0Embedded Compact 7Embedded AutomotiveEmbedded IndustryEmbedded 8Windows MobilePocket PC 2000Pocket PC 2002Mobile 2003Mobile 5.0Mobile 6.0Mobile 6.1Mobile 6.5Windows PhonePhone 7Phone 8Phone 8.110 (mobile)Ακυρωθείσες εκδόσειςCairoNashvilleNeptuneOdysseyπσεΣτοιχεία τωνWindowsΕργαλεία διαχείρισηςΓραμμή εντολώνΠίνακας ΕλέγχουΕκκαθάριση ΔίσκουΑνασυγκρότηση ΔίσκουΡυθμίσειςΕπαναφορά ΣυστήματοςΔιαχείριση ΕργασιώνWindows Error ReportingWindows InkWindows InstallerPowerShellWindows UpdateΕφαρμογές3D BuilderAlarms & ClockΑριθμομηχανήΗμερολόγιοΚάμεραΠίνακας χαρακτήρωνCortanaEdgeFax and ScanFeedback HubGet HelpGrooveΜεγεθυντικός φακόςMailMapsMedia PlayerMovies & TVMobility CenterΑφηγητήςΣημειωματάριοOneDriveOneNoteΖωγραφικήPaint 3DPeoplePhone CompanionΦωτογραφίεςQuick AssistΕργαλείο αποκομμάτωνSpeech RecognitionSkypeSticky NotesView 3DStoreTipsΗχογράφησηWalletWindows To GoWordPadXboxΑσφάλειαWindows DefenderWindows FirewallΠου έχουν αποσυρθείΠαιχνίδιαSolitaireHearts3D PinballFreeCellChess TitansPurble PlaceInkballHold 'EmSpider SolitaireTinkerΕφαρμογέςActiveMovieAnytime UpgradeAddress BookBackup and RestoreCardfileCardSpaceContactsDesktop GadgetsDiagnosticsDriveSpaceΔημιουργία DVDEasy TransferFaxFile ManagerHelp and Support CenterHyperTerminalInternet ExplorerJournalMedia CenterMeeting SpaceMessagingMessengerMobile Device CenterMovie MakerNetMeetingNTBackupOutlook ExpressΣυλλογή φωτογραφιώνProgram ManagerSteps RecorderWinHelpWriteΛοιπάScandiskΠροστασία αρχείωνVideo for WindowsWindows SideShowWindows Services for UNIXWindows System Assessment ToolΜετακινήθηκαν στοWindows StoreDVD PlayerHover!MahjongMinesweeperΚαθιερωμένοι όροιVIAF:230666902LCCN:n88027331GND:4192183-5BNF:cb14400232k(data)BIBSYS:7006728NKC:ph117055"
    },
    {
        "url": "https://el.wikipedia.org/wiki/IDLE_(Python)",
        "title": "IDLE (Python)",
        "content": "IDLE (Python)IDLE σε περιβάλλον Ubuntu: Το παράθυρο ρύθμισης της επισήμανσης σύνταξης και πίσω το κέλυφος της PythonΓενικάΗμερ. Δημιουργίας22 Δεκέμβριος 1998Είδοςολοκληρωμένο περιβάλλον ανάπτυξης,βιβλιοθήκη,ελεύθερο λογισμικόΔιανομήΈκδοση3.11.0 (24 Οκτώβριος 2022)[1]ΛειτουργικάΑνεξάρτητο πλατφόρμαςΑνάπτυξηΥπευθ. ανάπτυξηςΓκίντο βαν ΡόσσουμΓραμμένο σεPythonΣύνδεσμοιΕπίσημος ιστότοποςhttps://python.org/idleΑποθετήριο κώδικαhttps://github.com/python/cpython/tree/master/Lib/idlelibΤοIDLE(συντομογραφία τουIntegrated DeveLopment Environment[2][3]ήIntegrated Development and Learning Environment[4]) είναι έναολοκληρωμένο περιβάλλον ανάπτυξης(IDE) για την γλώσσα προγραμματισμούPythonκαι παρέχεται δωρεάν μαζί με την εγκατάσταση από την έκδοση 1.5.2beta.[2][5]Είναι εξολοκλήρου γραμμένο σε Python και επειδή ωςγραφικό περιβάλλον χρήστη(GUI)  χρησιμοποιεί το Tkinter toolkit, μπορεί να εκτελεσθεί σε περιβάλλονLinux,Microsoft WindowsκαιMac OS X. Πιθανολογείται ότι το όνομα προήλθε από ένα μέλος της κωμικής σειράς «Monty Python's Flying Circus», τονEric Idle.[5]Ιστορία[Επεξεργασία|επεξεργασία κώδικα]ΟΓκίντο βαν Ρόσσουμ(Guido van Rossum), όταν ξεκίνησε να δημιουργεί το IDLE δεν είχε πολύ χρόνο να το τελειοποιήσει, οπότε αποφάσισε κάθε βελτίωση να την κυκλοφορεί όσο πιο σύντομα μπορούσε και με συχνότερες εκδόσεις.[6]IDLE 0.1, είναι πρώτη πρόχειρη έκδοση, η οποία κυκλοφόρησε στις 16 Οκτωβρίου του 1998 και απευθυνόταν στα συνδρομητικά μέλη της Python,[Σημ 1]που είχαν την έκδοση 1.5.2alpha.[6]IDLE 0.2, κυκλοφορεί στις 8 Ιανουαρίου του 1999, που λειτουργεί σε Unix ή Windows (NT ή 9x), Tcl/Tk 8.0 και Python έκδοση 1.5.2beta.[2]Χαρακτηριστικά[Επεξεργασία|επεξεργασία κώδικα]Το IDLE να είναι ένα απλόIDE, κατάλληλο για αρχάριους, ιδιαιτέρως σε εκπαιδευτικό περιβάλλον.Σύμφωνα με τοIDLE Helpτης εφαρμογής τα κύρια χαρακτηριστικά είναι:Κειμενογράφος που υποστηρίζει πολλαπλά παράθυρα με χρωματική επισήμανση σύνταξης (syntax highlighting), αυτόματη συμπλήρωση εντολών (autocompletion), κατάλληλη στοίχιση των εντολών με την έξυπνη χρήση των εσοχών και άλλα.[5]Τοκέλυφος(shell) της διαδραστικής χρήσης της Python με χρωματική επισήμανση σύνταξης.[5]Ενσωματωμένοεργαλείο αποσφαλμάτωσης(debugger) για την παρακολούθηση της εκτέλεσης του κώδικα με σκοπό την εύρεση σφαλμάτων.[5]Σημειώσεις[Επεξεργασία|επεξεργασία κώδικα]↑Μέλη της τότεPython Software Activity(PSA), η οποία αργότερα αντικαταστάθηκε από την Python Software Foundation (PSF).Παραπομπές[Επεξεργασία|επεξεργασία κώδικα]↑«Python 3.11.0 is now available». 24 Οκτώβριος 2022.↑2,02,12,2Guido van Rossum (8 Ιανουαρίου 1999).«Subject: IDLE 0.2 -- Integrated DeveLopment Environment for Python». Ανακτήθηκε στις 10 Σεπτεμβρίου 2019.↑Από την επιλογή: Help > About, του ίδιου του λογισμικού (του IDLE)↑«24.6. IDLE».Python 2.7.16 documentation(στα Αγγλικά). Python Software Foundation. Αρχειοθετήθηκεαπό το πρωτότυποστις 6 Μαΐου 2019. Ανακτήθηκε στις 10 Σεπτεμβρίου 2019.↑5,05,15,25,35,4Αγγελιδάκης, Ν., βλ. πηγές σελ. 13 (σελ. 22 του pdf)↑6,06,1Guido van Rossum (16 Οκτωβρίου 1998).«IDLE 0.1 -- a Python IDE».Linux Weekly News(στα Αγγλικά). Αρχειοθετήθηκεαπό το πρωτότυποστις 25 Σεπτεμβρίου 2018. Ανακτήθηκε στις 10 Σεπτεμβρίου 2019.Πηγές[Επεξεργασία|επεξεργασία κώδικα]Αγγελιδάκης, Νικόλαος Α., Εκπαιδευτικός Πληροφορικής, Μ.Δ.Ε. (M.Sc.) στην Επιστήμη Υπολογιστών (Ηράκλειο, Αύγουστος 2015). \"Εισαγωγή στον προγραμματισμό με την Python\".Αρχειοθετήθηκε12/06/2018 Ανακτήθηκε 07/04/2019.(ISBN978-960-93-7364-7). Ηλεκτρονικό βιβλίο 150 σελίδων, για αρχάριους και με άδεια: CC BY-SA 4.0.Εξωτερικοί σύνδεσμοι[Επεξεργασία|επεξεργασία κώδικα]IDLE home page in the Python documentationIDLE page in the Python wikiA guide to using IDLE"
    },
    {
        "url": "https://el.wikipedia.org/wiki/%CE%9F%CE%BB%CE%BF%CE%BA%CE%BB%CE%B7%CF%81%CF%89%CE%BC%CE%AD%CE%BD%CE%BF_%CF%80%CE%B5%CF%81%CE%B9%CE%B2%CE%AC%CE%BB%CE%BB%CE%BF%CE%BD_%CE%B1%CE%BD%CE%AC%CF%80%CF%84%CF%85%CE%BE%CE%B7%CF%82",
        "title": "Ολοκληρωμένο περιβάλλον ανάπτυξης",
        "content": "Το λήμμα παραθέτει τις πηγές του αόριστα, χωρίςπαραπομπές.Βοηθήστε συνδέοντας το κείμενο με τις πηγέςχρησιμοποιώντας παραπομπές, ώστε να είναιεπαληθεύσιμο.Το πρότυπο τοποθετήθηκε χωρίς ημερομηνία. Για τη σημερινή ημερομηνία χρησιμοποιήστε:{{χωρίς παραπομπές|10|01|2025}}Έναολοκληρωμένο περιβάλλον ανάπτυξης(integrated development environment, IDE) είναι μία σουίταλογισμικούπου \nβοηθάει στην ανάπτυξηπρογραμμάτων υπολογιστή. Συνήθως ένα IDE περιλαμβάνει κάποιον επεξεργαστήπηγαίου κώδικα, ένανμεταγλωττιστή, εργαλεία αυτόματης παραγωγής κώδικα,αποσφαλματωτή,συνδέτη,σύστημα ελέγχου εκδόσεωνκαι εργαλεία κατασκευήςγραφικών διασυνδέσεων χρήστηγια τις υπό ανάπτυξη εφαρμογές.Αυτό το  λήμμα σχετικά με τηνΠληροφορικήχρειάζεταιεπέκταση. Μπορείτε να βοηθήσετε την Βικιπαίδειαεπεκτείνοντάς το."
    },
    {
        "url": "https://el.wikipedia.org/wiki/%CE%94%CE%B9%CE%B5%CF%81%CE%BC%CE%B7%CE%BD%CE%AD%CE%B1%CF%82_(%CF%85%CF%80%CE%BF%CE%BB%CE%BF%CE%B3%CE%B9%CF%83%CF%84%CE%AD%CF%82)",
        "title": "Διερμηνέας (υπολογιστές)",
        "content": "Το λήμμα παραθέτει τις πηγές του αόριστα, χωρίςπαραπομπές.Βοηθήστε συνδέοντας το κείμενο με τις πηγέςχρησιμοποιώντας παραπομπές, ώστε να είναιεπαληθεύσιμο.Η σήμανση τοποθετήθηκε στις 06/02/2020.Στηνπληροφορικήδιερμηνέαςήδιερμηνευτής(interpreter) συνήθως σημαίνει έναπρόγραμμαπουεκτελείήερμηνεύειεντολές σε κάποιαγλώσσα προγραμματισμού. Η διερμήνευση και ημεταγλώττισηείναι τα δύο βασικά μέσα με τα οποία υλοποιούνται οι γλώσσες προγραμματισμού, αν και δεν αποτελούν εντελώς διακριτές κατηγορίες, καθώς οι λειτουργίες τους επικαλύπτονται σε κάποιον βαθμό.Διερμηνέαςείναι ένα πρόγραμμα που είτε:εκτελεί τονπηγαίο κώδικααπευθείαςμεταφράζει τον πηγαίο κώδικα σε μια περισσότερο αποδοτική μορφή (κώδικα) που αμέσως εκτελείσαφώς εκτελεί προ-μεταγλωττισμένο κώδικα που έχει δημιουργήσει κάποιος μεταγλωττιστής που είναι μέρος του συστήματος διερμήνευσης.Με την τελευταία έννοια, οεπεξεργαστήςείναι μιας μορφής διερμηνέας εντολών κώδικα μηχανής σε συνδυασμό με τον μεταγλωττιστή που τις παράγει.ΗPerl, ηPython, ηMATLAB, και ηRubyείναι παραδείγματα γλωσσών που μεταφράζουν τον κώδικα σε αποδοτική μορφή, στο νούμερο 2 παραπάνω, ενώ ηUCSD Pascalκαι η εικονική μηχανή τηςJavaανήκουν στο νούμερο 3 παραπάνω: τα προγράμματα Java μεταγλωττίζονται και αποθηκεύονται ως κώδικας bytecode, που στη συνέχειασυνδέεταικατά την ώρα της εκτέλεσης και εκτελείται από ένα διερμηνέα (εικονική μηχανή). Μερικά συστήματα όπως ηSmalltalkσυνδυάζουν τη δεύτερη και τρίτη κατηγορία.Ο όροςδιερμηνευμένη γλώσσασημαίνει  ότι η κανονική υλοποίηση της γλώσσας είναι διερμηνέας ή μεταγλωττιστής. Μια γλώσσα υψηλού επιπέδου είναι βασικά μια αφαίρεση, που (ιδανικά) δεν εξαρτάται από κάποια συγκεκριμένη υλοποίηση.Θεωρητικά, οποιαδήποτε γλώσσα μπορεί να είναι είτεμεταγλωττισμένηείτε διερμηνευμένη, έτσι ο διαχωρισμός αυτός εφαρμόζεται μόνο με βάση την συνήθη πρακτική υλοποίησης, και όχι κάποια συγκεκριμένη ιδιότητα μιας γλώσσας.Πολλές γλώσσες έχουν υλοποιηθεί τόσο με χρήση μεταγλωττιστών όσο και με διερμηνείς, όπως ηLisp, ηPascal, ηC, ηBASICκαι ηPython.  Η γλώσσαJavaμεταφράζεται σε μια μορφή που προορίζεται συνήθως για διερμήνευση, αν και συχνά χρησιμοποιείται ημεταγλώττιση ακριβώς-στην-ώρα(just-in-time compilation) για να παράγει κώδικα μηχανής πριν την εκτέλεση.  Οι γλώσσες .Net τηςMicrosoftμεταγλωττίζονται στηνCILαπό την οποία συνήθως μεταγλωττίζονται στη συνέχεια σε κώδικα μηχανής, αν και υπάρχειεικονική μηχανήπου μπορεί να διερμηνεύσει τη CIL.Αυτό το  λήμμα σχετικά με τηνΠληροφορικήχρειάζεταιεπέκταση. Μπορείτε να βοηθήσετε την Βικιπαίδειαεπεκτείνοντάς το."
    },
    {
        "url": "https://el.wikipedia.org/wiki/%CE%94%CE%B5%CF%83%CE%BC%CE%B5%CF%85%CE%BC%CE%AD%CE%BD%CE%B7_%CE%BB%CE%AD%CE%BE%CE%B7_(%CF%85%CF%80%CE%BF%CE%BB%CE%BF%CE%B3%CE%B9%CF%83%CF%84%CE%AD%CF%82)",
        "title": "Δεσμευμένη λέξη (υπολογιστές)",
        "content": "Το λήμμα δεν περιέχειπηγέςή αυτές που περιέχει δεν επαρκούν.Μπορείτε να βοηθήσετεπροσθέτοντας την κατάλληλη τεκμηρίωση. Υλικό που είναι ατεκμηρίωτο μπορεί να αμφισβητηθεί και να αφαιρεθεί.Η σήμανση τοποθετήθηκε στις 19/03/2015.Ο όροςδεσμευμένη λέξηήλέξη-κλειδί(αγγλικά: reserved word ή reserved identifier ή keyword) στονπρογραμματισμό, δηλώνει λέξη (ακολουθία χαρακτήρων) την οποία ομεταγλωττιστήςαντιλαμβάνεται σαν τελεστή κάποιας λειτουργίας. Για παράδειγμα η λέξη if συχνά θεωρείται δεσμευμένη και δηλώνει την έναρξη επιλογής. Οι δεσμευμένες λέξεις δεν μπορούν να χρησιμοποιηθούν σαν ονόματα μεταβλητών ή σταθερών.wiktionary logoΤοΒικιλεξικόέχει σχετικό λήμμα:δεσμευμένη λέξηΑυτό το  λήμμα σχετικά με τηνΠληροφορικήχρειάζεταιεπέκταση. Μπορείτε να βοηθήσετε την Βικιπαίδειαεπεκτείνοντάς το."
    },
    {
        "url": "https://el.wikipedia.org/wiki/%CE%A4%CF%8D%CF%80%CE%BF%CF%82_%CE%B4%CE%B5%CE%B4%CE%BF%CE%BC%CE%AD%CE%BD%CF%89%CE%BD",
        "title": "Τύπος δεδομένων",
        "content": "Στονπρογραμματισμό υπολογιστών, έναςτύπος δεδομένων(data type) είναι μία κατηγοριοποίηση που προσδιορίζει διαφορετικούς τύπους από δεδομένα, όπωςκινητής υποδιαστολής(floating-point),ακεραίους(integer), ήτύπους δεδομένων αλήθειας(Boolean), η οποία καθορίζει τις πιθανές τιμές για αυτόν τον τύπο, τις λειτουργίες που μπορούν να επιτελεστούν σε τιμές αυτού του τύπου, την σημασία των δεδομένων και τον τρόπο που οι τιμές αυτού του τύπου μπορούν να αποθηκευτούν.[1][2]Οι τύποι δεδομένων χρησιμοποιούνται μέσα σεσυστήματα τύπων(type systems), τα οποία προσφέρουν διάφορους τρόπους για τον ορισμό, την υλοποίηση και την χρήση τους. Διαφορετικά συστήματα τύπων εξασφαλίζουν διαφορετικούς βαθμούςασφάλειας τύπων(type safety). Τυπικά, ένας τύπος μπορεί να οριστεί ως \"οποιαδήποτε ιδιότητα ενός προγράμματος την οποία μπορούμε να προσδιορίσουμε πριν την εκτέλεση του προγράμματος\".[3]Επισκόπηση[Επεξεργασία|επεξεργασία κώδικα]Σχεδόν όλες οι γλώσσες προγραμματισμού περιλαμβάνουν ρητά την έννοια του τύπου δεδομένων, παρόλο που διαφορετικές γλώσσες μπορεί να χρησιμοποιούν διαφορετική ορολογία.\nΟι συνήθεις τύποι δεδομένων είναι:ακέραιοι(integers),τύποι δεδομένων αληθείας(booleans),χαρακτήρες(characters),κινητής υποδιαστολής(floating-point numbers),αλφαριθμητικέςσυμβολοσειρές(strings).Για παράδειγμα, στηνγλώσσα προγραμματισμού Java, ο τύπος \"int\" αναπαριστά το σύνολο των32-bitακεραίωντου οποίου οι τιμές ανήκουν στο διάστημα από -2,147,483,648 έως 2,147,483,647, όπως και τις λειτουργίες που μπορούν να εφαρμοστούν πάνω σε ακέραιους, όπως η πρόσθεση, η αφαίρεση και ο πολλαπλασιασμός. Τα χρώματα αφετέρου αναπαρίστανται από τρίαbytesπου υποδηλώνουν την ποσότητα από κόκκινο, πράσινο και μπλε, και μία συμβολοσειρά που αναπαριστά το όνομα του χρώματος. Οι επιτρεπτές λειτουργίες περιλαμβάνουν πρόσθεση και αφαίρεση, αλλά όχι πολλαπλασιασμό.Οι περισσότερες γλώσσες προγραμματισμού επιτρέπουν επίσης στον προγραμματιστή να ορίσει επιπλέον τύπους δεδομένων, συνήθως συνδυάζοντας πολλαπλά στοιχεία από άλλους τύπους και ορίζοντας τις έγκυρες λειτουργίες του νέου τύπου δεδομένων. Για παράδειγμα, ένας προγραμματιστής μπορεί να δημιουργήσει έναν καινούργιο τύπο δεδομένων που θα ονομάζεται \"μιγαδικός αριθμός\", ο οποίος θα περιλάμβανε πραγματικά και φανταστικά μέρη.Ένας τύπος δεδομένων αναπαριστά επίσης έναν περιορισμό στην ερμηνεία των δεδομένων σε ένασύστημα τύπων, περιγράφοντας την αναπαράσταση, την ερμηνεία και την δομή τωντιμώνήαντικειμένωνπου αποθηκεύονται στην μνήμη του υπολογιστή. Το σύστημα τύπων χρησιμοποιεί την πληροφορία του τύπου δεδομένων για να ελέγξει τηνορθότητα των προγραμμάτωντα οποία έχουν πρόσβαση ή χειρίζονται τα δεδομένα.Κλάσεις τύπων δεδομένων[Επεξεργασία|επεξεργασία κώδικα]Τύποι δεδομένων μηχανής[Επεξεργασία|επεξεργασία κώδικα]Όλα τα δεδομένα στους υπολογιστές που βασίζονται σε ψηφιακά ηλεκτρονικά κυκλώματα αναπαρίστανται ωςbit(εναλλακτικές 0 και 1) στο πιο χαμηλό επίπεδο. Η μικρότερη μονάδα δεδομένων που μπορεί να διευθυνσιοδοτηθεί είναι συνήθως μια ομάδα από bit που αποκαλούνταιbyte(συνήθως μίαοκτάδα(octet), που είναι 8 bit). Η μονάδα που μπορεί να επεξεργαστεί από εντολέςγλώσσας μηχανήςονομάζεταιλέξη(word) (η οποία από το 2011 είναι τυπικά 32 ή 64 bit). Οι περισσότερες εντολές ερμηνεύουν την λέξη ως ένανδυαδικό αριθμό, έτσι ώστε ένας 32 bit αριθμός να μπορεί να αναπαραστήσει μη προσημασμένες ακέραιες τιμές από 0 έως232−1{\\displaystyle 2^{32}-1}ή προσημασμένες ακέραιες τιμές από−231{\\displaystyle -2^{31}}έως231−1{\\displaystyle 2^{31}-1}. Λόγω τουσυμπληρώματος ως προς 2, η μηχανή και η γλώσσα μηχανής ως επί το πλείστον δεν χρειάζεται να διακρίνουν τους μη προσημασμένους από τους προσημασμένους τύπους δεδομένων.Υπάρχει ένα συγκεκριμένο σύνολο εντολών αριθμητικών πράξεων, οι οποίες χρησιμοποιούν διαφορετική ερμηνεία των bit μίας λέξης σαν έναν αριθμόκινητής υποδιαστολής.Οι τύποι δεδομένων μηχανής είναι αναγκαίο ναεκτίθενταιή είναι διαθέσιμοι σεσυστήματαήχαμηλού επιπέδου γλώσσες προγραμματισμούώστε να επιτρέπουν τον ευέλικτο έλεγχο τουυλικού(hardware). Ηγλώσσα προγραμματισμού Cγια παράδειγμα είναι εφοδιασμένη με τύπους δεδομένων διαφόρων μεγεθών, όπως οshortκαι οlong. Αν ένας αντίστοιχος εγγενής (native) τύπος δεν υπάρχει στην πλατφόρμα στόχο, ο μεταγλωττιστής θα τον \"σπάσει\" σε κώδικα που χρησιμοποιεί τύπους που υπάρχουν. Για παράδειγμα, αν ζητείται ένας ακέραιος των 32 bit σε μία πλατφόρμα των 16 bit, ο μεταγλωττιστής θα τον αντιμετωπίσει σιωπηρά ως έναν πίνακα από δύο ακεραίους των 16 bit.Πολλές γλώσσες επιτρέπουνδυαδικάκαιδεκαεξαδικάλεκτικά (literals), για τον εύκολο χειρισμό δεδομένων μηχανής.Σε υψηλότερου επιπέδου προγραμματισμό, οι τύποι δεδομένων μηχανής είναι συνήθως κρυμμένοι ήαφηρημένοι(abstracted) ως μία λεπτομέρεια της υλοποίησης που θα καθιστούσε τον κώδικα λιγότερο μεταφέρσιμο αν ήταν φανερή στον χρήστη. Για παράδειγμα, μπορεί να παρέχεται ένας γενικευμένος αριθμητικός τύπος αντί ενός τύπου συγκεκριμένου μεγέθους.Ο τύπος δεδομένων αληθείας[Επεξεργασία|επεξεργασία κώδικα]Κύριο:Τύπος δεδομένων αλήθειαςΟτύπος δεδομένων αληθείαςαναπαριστά τις τιμές:αληθέςκαιψευδές. Παρότι μόνο δύο τιμές είναι πιθανές, σπάνια αναπαρίστανται στους υπολογιστές με ένα μόνο δυαδικό ψηφίο για λόγους αποδοτικότητας. Πολλές γλώσσες προγραμματισμού δεν είναι εφοδιασμένες με ρητό τύπο αληθείας. Αντί αυτού ερμηνεύουν το 0 (για παράδειγμα) ως ψευδές και τις υπόλοιπες τιμές ως αληθείς.Αριθμητικοί τύποι δεδομένων[Επεξεργασία|επεξεργασία κώδικα]Κάποια παραδείγματα αριθμητικών τύπων δεδομένων είναι:Οακέραιος(integer) τύπος δεδομένων, ήολόκληρος αριθμός. Μπορεί να έχει υποτύπους ανάλογα με την ικανότητά τους να συμπεριλαμβάνουν αρνητικές τιμές (για παράδειγμαunsignedστην γλώσσα C και C++). Μπορεί επίσης να έχει έναν μικρό αριθμό από προκαθορισμένους υποτύπους (όπως οshortκαι οlongστην C/C++) ή να επιτρέπουν στους χρήστες να ορίσουν ελεύθερα υποτμήματα όπως το 1..12 (για παράδειγμα οιPascal/Ada).Οτύπος δεδομένων κινητής υποδιαστολής(floating point), ο οποίος αποκαλείται κάποιες φορές παραπλανητικάπραγματικός, περιέχει κλασματικές τιμές. Συνήθως έχουν προκαθορισμένα όρια στην μέγιστη τιμή τους και την ακρίβειά τους.Οτύπος δεδομένων σταθερής υποδιαστολής(fixed point), που προσφέρεται για την αναπαράσταση νομισματικών τιμών. Συνήθως αναπαρίσταται εσωτερικά ως ακέραιος, γεγονός που οδηγεί σε προκαθορισμένες τιμές.Ο αριθμητικός τύπος μεγάλων αριθμών (Bignum) ή αριθμών μεταβλητής ακρίβειας (arbitrary precision) που δεν έχουν προκαθορισμένη ακρίβεια. Δεν είναι πρωταρχικοί τύποι και χρησιμοποιούνται με φειδώ για λόγους αποδοτικότητας.Συμβολοσειρές και τύποι δεδομένων κειμένου[Επεξεργασία|επεξεργασία κώδικα]Όπως:Αλφαριθμητικόςχαρακτήρας(alphanumeric character). Ένα γράμμα τηςαλφαβήτου, ένα ψηφίο, ένα κενό, ένα σημείο στίξης κτλ.Αλφαριθμητικήσυμβολοσειρά(string), δηλαδή μία ακολουθία χαρακτήρων. Χρησιμοποιούνται συνήθως για να αναπαραστήσουν λέξεις ή κείμενο.Οι χαρακτήρες και οι συμβολοσειρές αποθηκεύουν ακολουθίες από ένα σύνολο χαρακτήρων (character sets) όπως ο κώδικαςASCII. Επειδή τα περισσότερα σύνολα χαρακτήρων περιλαμβάνουν και τα ψηφία, είναι δυνατό να έχουμε μία αριθμητική συμβολοσειρά, όπως η\"1234\". Ωστόσο πολλές γλώσσες θεωρούν ότι ανήκει σε διαφορετικό τύπο από τον αυτόν της αριθμητικής τιμής1234.Οι τύποι των χαρακτήρων και των συμβολοσειρών μπορεί να έχουν διαφορετικούς υποτύπους σύμφωνα με το απαιτούμενο \"μέγεθος\" του χαρακτήρα. Ο αρχικός κώδικας ASCII μεγέθους 7-bit αποδείχθηκε ανεπαρκής και αντικαταστάθηκε από 8 και 16-bit σύνολα χαρακτήρων, τα οποία μπορούν να κωδικοποιήσουν ένα ευρύ φάσμα από μη λατινικά αλφάβητα (Εβραϊκά,Κινέζικα) και άλλα σύμβολα.Οι συμβολοσειρές μπορεί να είναι σταθερού είτε επεκτατού μεγέθους, ακόμα και μέσα στην ίδια γλώσσα. Μπορεί να έχουν υποτύπους ανάλογα με το μέγιστο μέγεθός τους.Σημείωση:οι συμβολοσειρές δεν είναι πρωταρχικοί τύποι σε όλες τις γλώσσες. Για παράδειγμα στην C αποτελούνται από πίνακες (arrays) χαρακτήρων.Απαριθμήσεις[Επεξεργασία|επεξεργασία κώδικα]Οιαπαριθμήσεις. Αυτές έχουν τιμές που διαφέρουν μεταξύ τους, οι οποίες μπορούν να συγκριθούν και να ανατεθούν, αλλά δεν έχουν απαραίτητα κάποια συγκεκριμένη αναπαράσταση στην μνήμη του υπολογιστή. Οι μεταγλωττιστές και οι διερμηνευτές τις αναπαριστούν αυθαίρετα. Για παράδειγμα, τα τέσσερα χαρτιά σε μία τράπουλα θα μπορούσαν να είναι τέσσερις απαριθμητές με ονόματαΣΠΑΘΙ,ΚΑΡΩ,ΜΠΑΣΤΟΥΝΙ,ΚΟΥΠΑ, που θα ανήκουν σε μία απαρίθμηση με όνοματράπουλα. Αν η μεταβλητήVδηλωθεί να έχειτράπουλαγια τύπο, μπορούμε να αναθέσουμε οποιαδήποτε από αυτές τις τιμές σε αυτή την μεταβλητή. Κάποιες υλοποιήσεις επιτρέπουν στον προγραμματιστή να αναθέσει ακέραιες τιμές στις τιμές απαρίθμησης, ή ακόμα και να τις αντιμετωπίζει ως τυπικά ισοδύναμες (type-equivalent) με τους ακεραίους.Επαγόμενοι Τύποι[Επεξεργασία|επεξεργασία κώδικα]Οι επαγόμενοι τύποι μπορούν να βασίζονται, ή να προέρχονται από τους βασικούς τύπους που εξηγήθηκαν παραπάνω.Σε κάποια γλώσσα σαν την C, οισυναρτήσεις(functions) έχουν τύπο που προέρχεται από τον τύπο τηςτιμής επιστροφής(return value) τους.Δείκτες και Αναφορές[Επεξεργασία|επεξεργασία κώδικα]Δείτε επίσης:Δείκτης (πληροφορική),Αναφορά (επιστήμη υπολογιστών)Ο βασικότερος μη σύνθετος επαγόμενος τύπος είναι οδείκτης, ένας τύπος δεδομένων του οποίου η τιμή αναφέρεται ευθέως σε (ή \"δείχνει σε\") μία άλλη τιμή η οποία είναι αποθηκευμένη κάπου αλλού στηνμνήμη του υπολογιστήχρησιμοποιώντας τηνδιεύθυνση μνήμηςτης. Είναι μία πρωταρχική μορφήαναφοράς. (Σε καθημερινή ορολογία, ένας αριθμός σελίδας σε ένα βιβλίο θα μπορούσε να θεωρηθεί ένα κομμάτι δεδομένων που αναφέρεται σε ένα άλλο). Οι δείκτες αποθηκεύονται συχνά σε μία μορφή παρόμοια με έναν ακέραιο. Ωστόσο, στην προσπάθειά μας να δούμε τα περιεχόμενα που δείχνει ένας δείκτης (dereference) του οποίου η τιμή δεν είναι κάποια έγκυρη διεύθυνση μνήμης το πρόγραμμα θα μπορούσε να τερματιστεί βίαια (crash). Για την βελτίωση αυτού του πιθανού προβλήματος, οι δείκτες θεωρούνται διαφορετικού τύπου από τον τύπο των δεδομένων που δείχνουν, ακόμα και αν η υποκείμενη αναπαράσταση είναι η ίδια.Σύνθετοι τύποι[Επεξεργασία|επεξεργασία κώδικα]Οι σύνθετοι τύποι παράγονται από περισσότερους από έναν πρωταρχικούς τύπους. Αυτό μπορεί να γίνει με πολλούς τρόπους. Οι διαφορετικοί τρόποι με τους οποίους μπορούμε να τους συνδυάσουμε ονομάζονταιδομές δεδομένων. Η κατασκευή ενός σύνθετου τύπου από πρωταρχικούς τύπους οδηγεί στη δημιουργία ενός νέου τύπου, για παράδειγμα ο τύποςπίνακας-ακεραίωνείναι διαφορετικός τύπος από τον τύποακέραιος.Έναςπίνακας(array) αποθηκεύει έναν αριθμό από στοιχεία ιδίου τύπου σε μία συγκεκριμένη σειρά. Προσπελαύνονται χρησιμοποιώντας έναν ακέραιο για να δείξουμε ποιο στοιχείο απαιτείται (παρόλο που τα στοιχεία μπορεί να είναι οποιουδήποτε σχεδόν τύπου). Οι πίνακες μπορεί να είναι σταθερού μεγέθους ή επεκτάσιμοι.Εγγραφή(επίσης γνωστή ως δυάδα (tuple) ή δομή (struct)). Οι εγγραφές είναι από τις απλούστερεςδομές δεδομένων. Μία εγγραφή είναι μία τιμή που περιέχει άλλες τιμές, συνήθως με σταθερό πλήθος και σειρά και δεικτοδοτημένες με ονόματα. Τα στοιχεία μίας εγγραφής αποκαλούνται συνήθωςπεδίαήμέλη.Ένωση. Μία δήλωση τύπου ένωσης καθορίζει ποιοι από ένα πλήθος πρωταρχικών τύπων θα αποθηκευτούν στα στιγμιότυπά του, για παράδειγμα \"float ή long integer\". Σε σύγκριση με μία εγγραφή, η οποία θα μπορούσε να περιέχει μία τιμή κινητής υποδιαστολήςκαιέναν ακέραιο, η ένωση περιέχει μόνο μία από τις δύο τιμές κάθε φορά.Ηένωση με ετικέτα(γνωστή και ως παραλλαγή (variant), παραλλαγμένη εγγραφή (variant record), διακεκριμένη ένωση (discriminated union), ή διαχωρισμένη ένωση (disjoint union)) περιέχει ένα επιπλέον πεδίο το οποίο υποδεικνύει τον τρέχοντα τύπο, για περισσότερη ασφάλεια τύπων.Τοσύνολοείναι έναςαφηρημένος τύπος δεδομένωνπου μπορεί να αποθηκεύει συγκεκριμένες τιμές, χωρίς κάποια συγκεκριμένηδιάταξηκαι χωρίς επαναλαμβανόμενες τιμές. Οι τιμές δεν ανακτώνται από το σύνολο, αλλά ο προγραμματιστής μπορεί να ρωτήσει το κατά πόσο μία τιμή περιέχεται στο σύνολο, παίρνοντας ως απάντηση ένα λογικό \"ναι\" ή \"όχι\".Ένααντικείμενοπεριέχει έναν αριθμό από πεδία δεδομένων, όπως οι εγγραφές, και έναν αριθμό από κομμάτια κώδικα για να την προσπέλασή τους και την τροποποίησή τους. Οι δομές δεδομένων που δεν περιέχουν κώδικα, όπως οι παραπάνω, ονομάζονταιαπλές δομές δεδομένων(plain old data structures).Πολλοί άλλοι σύνθετοι τύποι είναι δυνατοί, αλλά τείνουν να είναι περαιτέρω παραλλαγές και συνθέσεις των παραπάνω.Αφηρημένοι τύποι[Επεξεργασία|επεξεργασία κώδικα]Κύριο:Αφηρημένος τύπος δεδομένωνΚάθε τύπος που δεν περιλαμβάνει κάποια υλοποίηση είναι έναςαφηρημένος τύπος δεδομένων. Για παράδειγμα, μίαστοίβα(η οποία είναι ένας αφηρημένος τύπος δεδομένων) μπορεί να υλοποιηθεί με έναν πίνακα (ένα συνεχές κομμάτι μνήμης που περιέχει πολλαπλές τιμές), ή με μίασυνδεδεμένη λίστα(ένα σύνολο από μη συνεχόμενα κομμάτια μνήμης που συνδέονται μεδείκτες).Οι αφηρημένοι τύποι δεδομένων μπορούν να χειριστούν από κώδικα που δεν γνωρίζει ή \"ενδιαφέρεται\" για τους τύπους που περιέχονται σε αυτούς. Ο προγραμματισμός που δεν γνωρίζει τους υποκείμενους συγκεκριμένους τύπους που θα χρησιμοποιηθούν ονομάζεταιγενικευμένος προγραμματισμός. Οι πίνακες και οι εγγραφές μπορεί να περιέχουν επίσης υποκείμενους τύπους, αλλά θεωρούνται συγκεκριμένοι επειδή προσδιορίζουν το πως τα περιεχόμενα ή τα στοιχεία τους αποθηκεύονται στην μνήμη.Παραδείγματα:Έναςέξυπνος δείκτης(smart pointer) είναι το αφηρημένο αντίστοιχο του δείκτη. Και οι δύο είναι ήδηαναφορών.Έναςπίνακας κατακερματισμού(hash table) ήλεξικό(dictionary) ήχάρτης/συσχετιστικός πίνακας(map/associative array) είναι μία πιο ευέλικτη παραλλαγή της εγγραφής, στην οποία ζευγάρια κλειδιού-τιμής μπορούν να εισαχθούν και να διαγραφούν ελεύθερα.Σε μίαουρά(queue) όποιος εισέλθει πρώτος εξέρχεται πρώτος. Παραλλαγές είναι ηδύο-άκρων ουρά(deque) και ηουρά προτεραιότητας(priority queue).Ένασύνολο(set) μπορεί να αποθηκεύει συγκεκριμένες τιμές, χωρίς κάποια συγκεκριμένη διάταξη και χωρίς επαναλαμβανόμενες τιμές.Σε μίαστοίβα(stack) όποιος εισέλθει τελευταίος εξέρχεται πρώτος.Έναδέντρο(tree) είναι μίαιεραρχικήδενδρικήδομή.Γράφος(graph).Βοηθητικοί τύποι[Επεξεργασία|επεξεργασία κώδικα]Για ευκολία, πολλές γλώσσες προγραμματισμού υψηλού επιπέδου είναι εφοδιασμένες με χρήσιμους στην πράξη τύπους, όπως για παράδειγμαχρονικές,ημερολογιακέςκαινομισματικές τιμές, ακόμα και στις περιπτώσεις που η γλώσσα επιτρέπει την κατασκευή τους από πρωταρχικούς τύπους.Συστήματα τύπων[Επεξεργασία|επεξεργασία κώδικα]Κύριο λήμμα:Σύστημα τύπωνΈνα σύστημα τύπων συσχετίζει τύπους με κάθε υπολογισμένη τιμή. Εξετάζοντας την ροή αυτών των τιμών, ένα σύστημα τύπων προσπαθεί να αποδείξει ότι δεν μπορούν να συμβούνσφάλματα τύπων. Το εν λόγω σύστημα τύπων καθορίζει τι αποτελεί ένα σφάλμα τύπου, αλλά τα συστήματα τύπων προσπαθούν γενικά να εγγυηθούν ότι λειτουργίες που αναμένουν ένα συγκεκριμένο είδος τιμών δεν χρησιμοποιούνται σε τιμές για τις οποίες αυτές δεν έχουν νόημα.Έναςμεταγλωττιστήςενδέχεται να χρησιμοποιήσει τον στατικό τύπο μιας τιμής για να βελτιστοποιήσει την αποθήκευση που χρειάζεται και την επιλογή των αλγορίθμων για λειτουργίες πάνω στην τιμή. Σε πολλούς μεταγλωττιστές της γλώσσας προγραμματισμούCο τύπος δεδομένων float, για παράδειγμα, αναπαρίσταται με 32bit, σύμφωνα με τοπρότυπο της IEEE για αριθμούς κινητής υποδιαστολής απλής ακρίβειας. Έτσι θα χρησιμοποιήσουνεντολές του μικροεπεξεργαστήειδικές για αριθμούς κινητής υποδιαστολής πάνω σε αυτές τις τιμές (πρόσθεση κινητής υποδιαστολής, πολλαπλασιασμό, κτλ).Το βάθος των περιορισμών των τύπων και ο τρόπος αποτίμησής τους επηρεάζουν τηντυποποίηση(typing) της γλώσσας. Μίαγλώσσα προγραμματισμούμπορεί να συσχετίσει περαιτέρω μία λειτουργία με διαφορετικούς συγκεκριμένους αλγορίθμους για κάθε τύπο στην περίπτωση τουπολυμορφισμού υποτύπων.Θεωρία τύπωνείναι η μελέτη των συστημάτων τύπων, μολονότι τα συγκεκριμένα (concrete) συστήματα τύπων γλωσσών προγραμματισμού προέρχονται από πρακτικά θέματα αρχιτεκτονικής υπολογιστών, υλοποίησης μεταγλωττιστών και σχεδιασμού γλωσσών.Τα συστήματα τύπων μπορεί να είναιστατικάήδυναμικά,αυστηράήασθενήκτλ.Δείτε επίσης[Επεξεργασία|επεξεργασία κώδικα]Λεξικό δεδομένωνΣυναρτησιακός προγραμματισμόςΕίδοςΘεωρία τύπωνγια μαθηματικά μοντέλα τύπωνΣύστημα τύπωνγια διαφορετικές επιλογές στο σύστημα τύπων γλωσσών προγραμματισμούΑναφορές[Επεξεργασία|επεξεργασία κώδικα]↑http://multimedia.dictionary.reference.com/browse/data+type[νεκρός σύνδεσμος]↑Shaffer, C.A.Data Structures and Algorthms, 1.2↑Programming Languages: Application and Interpretation, Shriram Krishnamurthi, Brown UniversityΠεραιτέρω διάβασμα[Επεξεργασία|επεξεργασία κώδικα]Luca Cardelli, Peter Wegner.On Understanding Types, Data Abstraction, and Polymorphism,[1]Αρχειοθετήθηκε2006-06-19 στοWayback Machine. from Computing Surveys, (December, 1985)Various Data Types in CπσεΤύποι δεδομένωνΧωρίς ερμηνείαBit·Byte·Trit·Tryte·ΛέξηΑριθμητικοίΑκέραιος·Σταθερής υποδιαστολής·Κινητής υποδιαστολής·Πραγματικός·Μιγαδικός·Bignum·ΔιάστημαΚείμενοΧαρακτήρας·ΣυμβολοσειράΔείκτεςΔιεύθυνση·Αναφορά·Δείκτης συνάρτησηςΣύνθετοιΑλγεβρικός τύπος δεδομένων(γενικευμένος)·Πίνακας·Πίνακας αντιστοίχισης·Κλάση·Λίστα·Αντικείμενο·Τύπος επιλογής·Γινόμενο·Εγγραφή·Σύνολο·Ένωση(με ετικέτες)ΆλλοιΑλήθειας·Bottom type·Συλλογή·Τύπος απαρίθμησης·Εξαίρεση·Τύπος συνάρτησης·Αδιαφανής τύπος δεδομένων·Αναδρομικός τύπος δεδομένων·Σημαφόρος·Stream·Top type·Κλάση τύπου·Unit type·VoidΣχετικά θέματαΑφηρημένος τύπος δεδομένων·Δομή δεδομένων·Interface·Kind·Πρωτογενής τύπος δεδομένων·Υποτύποι·Template·Κατασκευαστής τύπων·Παραμετρικός πολυμορφισμός·Πολυμορφισμός υποτύπων"
    }
]